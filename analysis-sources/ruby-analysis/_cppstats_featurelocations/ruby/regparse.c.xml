<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\regparse.c">





























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WARN_BUFSIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS</name></cpp:macro></cpp:define>


<decl_stmt><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name></type> <name>OnigSyntaxRuby</name> <init>= <expr><block>{
<expr><operator>(</operator><operator>(</operator> <name>SYN_GNU_REGEX_OP</name> <operator>|</operator> <name>ONIG_SYN_OP_QMARK_NON_GREEDY</name> <operator>|</operator>
<name>ONIG_SYN_OP_ESC_OCTAL3</name> <operator>|</operator> <name>ONIG_SYN_OP_ESC_X_HEX2</name> <operator>|</operator>
<name>ONIG_SYN_OP_ESC_X_BRACE_HEX8</name> <operator>|</operator> <name>ONIG_SYN_OP_ESC_CONTROL_CHARS</name> <operator>|</operator>
<name>ONIG_SYN_OP_ESC_C_CONTROL</name> <operator>)</operator>
<operator>&amp;</operator> <operator>~</operator><name>ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END</name> <operator>)</operator></expr>
, <expr><operator>(</operator> <name>ONIG_SYN_OP2_QMARK_GROUP_EFFECT</name> <operator>|</operator>
<name>ONIG_SYN_OP2_OPTION_RUBY</name> <operator>|</operator>
<name>ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP</name> <operator>|</operator> <name>ONIG_SYN_OP2_ESC_K_NAMED_BACKREF</name> <operator>|</operator>
<name>ONIG_SYN_OP2_ESC_G_SUBEXP_CALL</name> <operator>|</operator>
<name>ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY</name> <operator>|</operator>
<name>ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT</name> <operator>|</operator>
<name>ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT</name> <operator>|</operator>
<name>ONIG_SYN_OP2_CCLASS_SET_OP</name> <operator>|</operator> <name>ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL</name> <operator>|</operator>
<name>ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META</name> <operator>|</operator> <name>ONIG_SYN_OP2_ESC_V_VTAB</name> <operator>|</operator>
<name>ONIG_SYN_OP2_ESC_H_XDIGIT</name> <operator>|</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>ONIG_SYN_OP2_ESC_U_HEX4</name> <operator>|</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER</name> <operator>|</operator>
<name>ONIG_SYN_OP2_QMARK_LPAREN_CONDITION</name> <operator>|</operator>
<name>ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK</name> <operator>|</operator>
<name>ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP</name> <operator>|</operator>
<name>ONIG_SYN_OP2_QMARK_TILDE_ABSENT</name> <operator>)</operator></expr>
, <expr><operator>(</operator> <name>SYN_GNU_REGEX_BV</name> <operator>|</operator>
<name>ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV</name> <operator>|</operator>
<name>ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND</name> <operator>|</operator>
<name>ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP</name> <operator>|</operator>
<name>ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME</name> <operator>|</operator>
<name>ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY</name> <operator>|</operator>
<name>ONIG_SYN_WARN_CC_OP_NOT_ESCAPED</name> <operator>|</operator>
<name>ONIG_SYN_WARN_CC_DUP</name> <operator>|</operator>
<name>ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT</name> <operator>)</operator></expr>
, <expr><operator>(</operator> <name>ONIG_OPTION_ASCII_RANGE</name> <operator>|</operator> <name>ONIG_OPTION_POSIX_BRACKET_ALL_RANGE</name> <operator>|</operator>
<name>ONIG_OPTION_WORD_BOUND_ALL_RANGE</name> <operator>)</operator></expr>
,
<expr><block>{
<expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'\\'</literal></expr> 
, <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>ONIG_INEFFECTIVE_META_CHAR</name></expr> 
, <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>ONIG_INEFFECTIVE_META_CHAR</name></expr> 
, <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>ONIG_INEFFECTIVE_META_CHAR</name></expr> 
, <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>ONIG_INEFFECTIVE_META_CHAR</name></expr> 
, <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>ONIG_INEFFECTIVE_META_CHAR</name></expr> 
}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>OnigDefaultSyntax</name> <init>= <expr><name>ONIG_SYNTAX_RUBY</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>extern</specifier> <name>void</name></type> <name>onig_null_warn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <name>s</name></type> <name>ARG_UNUSED</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEFAULT_WARN_FUNCTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>OnigWarnFunc</name></type> <name>onig_warn</name> <init>= <expr><operator>(</operator><name>OnigWarnFunc</name> <operator>)</operator><name>DEFAULT_WARN_FUNCTION</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>OnigWarnFunc</name></type> <name>onig_warn</name> <init>= <expr><name>onig_null_warn</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEFAULT_VERB_WARN_FUNCTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>OnigWarnFunc</name></type> <name>onig_verb_warn</name> <init>= <expr><operator>(</operator><name>OnigWarnFunc</name> <operator>)</operator><name>DEFAULT_VERB_WARN_FUNCTION</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>OnigWarnFunc</name></type> <name>onig_verb_warn</name> <init>= <expr><name>onig_null_warn</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>extern</specifier> <name>void</name></type> <name>onig_set_warn_func</name><parameter_list>(<parameter><decl><type><name>OnigWarnFunc</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>onig_warn</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>void</name></type> <name>onig_set_verb_warn_func</name><parameter_list>(<parameter><decl><type><name>OnigWarnFunc</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>onig_verb_warn</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CC_DUP_WARN</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>to</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>ParseDepthLimit</name> <init>= <expr><name>DEFAULT_PARSE_DEPTH_LIMIT</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>extern</specifier> <name>unsigned</name> <name>int</name></type>
<name>onig_get_parse_depth_limit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ParseDepthLimit</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_set_parse_depth_limit</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ParseDepthLimit</name> <operator>=</operator> <name>DEFAULT_PARSE_DEPTH_LIMIT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ParseDepthLimit</name> <operator>=</operator> <name>depth</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>bbuf_free</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bbuf_clone</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>rto</name></decl></parameter>, <parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BBuf</name> <modifier>*</modifier></type><name>to</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>rto</name> <operator>=</operator> <name>to</name> <operator>=</operator> <operator>(</operator><name>BBuf</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>BBUF_INIT</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xmemcpy</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKREF_REL_TO_ABS</name><parameter_list>(<parameter><type><name>rel_no</name></type></parameter>, <parameter><type><name>env</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((env)-&gt;num_mem + 1 + (rel_no))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONOFF</name><parameter_list>(<parameter><type><name>v</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>negative</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(negative) ? ((v) &amp;= ~(f)) : ((v) |= (f))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MBCODE_START_POS</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(OnigCodePoint )(ONIGENC_MBC_MINLEN(enc) &gt; 1 ? 0 : 0x80)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_ALL_MULTI_BYTE_RANGE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>pbuf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>add_code_range_to_buf(pbuf, env, MBCODE_START_POS(enc), ONIG_LAST_CODE_POINT)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_ALL_MULTI_BYTE_RANGE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>mbuf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (! ONIGENC_IS_SINGLEBYTE(enc)) {r = SET_ALL_MULTI_BYTE_RANGE(enc, &amp;(mbuf));if (r) return r;}} while (0)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITSET_SET_BIT_CHKDUP</name><parameter_list>(<parameter><type><name>bs</name></type></parameter>, <parameter><type><name>pos</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (BITSET_AT(bs, pos)) CC_DUP_WARN(env, pos, pos); BS_ROOM(bs, pos) |= BS_BIT(pos); } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITSET_IS_EMPTY</name><parameter_list>(<parameter><type><name>bs</name></type></parameter>,<parameter><type><name>empty</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {int i;empty = 1;for (i = 0; i &lt; BITSET_SIZE; i++) {if ((bs)[i] != 0) {empty = 0; break;}}} while (0)</cpp:value></cpp:define>









<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitset_set_range</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>BitSetRef</name></type> <name>bs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>to</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name>bs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void
bitset_set_all(BitSetRef bs)
{
int i;
for (i = 0; i &lt; BITSET_SIZE; i++) { bs[i] = ~((Bits )0); }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitset_invert</name><parameter_list>(<parameter><decl><type><name>BitSetRef</name></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BITSET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <expr_stmt><expr><name><name>bs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>~</operator><operator>(</operator><name><name>bs</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitset_invert_to</name><parameter_list>(<parameter><decl><type><name>BitSetRef</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>BitSetRef</name></type> <name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BITSET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <expr_stmt><expr><name><name>to</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>~</operator><operator>(</operator><name><name>from</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitset_and</name><parameter_list>(<parameter><decl><type><name>BitSetRef</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>BitSetRef</name></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BITSET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>bs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt> </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitset_or</name><parameter_list>(<parameter><decl><type><name>BitSetRef</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>BitSetRef</name></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BITSET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>bs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt> </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitset_copy</name><parameter_list>(<parameter><decl><type><name>BitSetRef</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>BitSetRef</name></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BITSET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>bs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt> </block_content>}</block></for>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_ST_LIBRARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_strncmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>*</operator><name>s2</name><operator>++</operator> <operator>-</operator> <operator>*</operator><name>s1</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>onig_strcpy</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>len</name> <init>= <expr><name>end</name> <operator>-</operator> <name>src</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xmemcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>UChar</name><modifier>*</modifier></type>
<name>strdup_with_null</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>slen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>term_len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>term_len</name> <operator>=</operator> <call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name>slen</name> <operator>+</operator> <name>term_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xmemcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>term_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>r</name><index>[<expr><name>slen</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEND_VALUE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFETCH_READY</name></cpp:macro> <cpp:value>UChar* pfetch_prev = NULL; (void)pfetch_prev</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFETCH_READY</name></cpp:macro> <cpp:value>UChar* pfetch_prev</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEND</name></cpp:macro> <cpp:value>(p &lt; end ? 0 : 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUNFETCH</name></cpp:macro> <cpp:value>p = pfetch_prev</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PINC</name></cpp:macro> <cpp:value>do { pfetch_prev = p; p += enclen(enc, p, end); } while (0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFETCH</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { c = ((enc-&gt;max_enc_len == 1) ? *p : ONIGENC_MBC_TO_CODE(enc, p, end)); pfetch_prev = p; p += enclen(enc, p, end); } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PINC_S</name></cpp:macro> <cpp:value>do { p += enclen(enc, p, end); } while (0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFETCH_S</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { c = ((enc-&gt;max_enc_len == 1) ? *p : ONIGENC_MBC_TO_CODE(enc, p, end)); p += enclen(enc, p, end); } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PPEEK</name></cpp:macro> <cpp:value>(p &lt; end ? ONIGENC_MBC_TO_CODE(enc, p, end) : PEND_VALUE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PPEEK_IS</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(PPEEK == (OnigCodePoint )c)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>UChar</name><modifier>*</modifier></type>
<name>strcat_capa</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>dest_end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>src_end</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>capa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dest</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>xrealloc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>capa</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name>capa</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_strcpy</name><argument_list>(<argument><expr><name>r</name> <operator>+</operator> <operator>(</operator><name>dest_end</name> <operator>-</operator> <name>dest</name><operator>)</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>src_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>UChar</name><modifier>*</modifier></type>
<name>strcat_capa_from_static</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>dest_end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>src_end</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>capa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name>capa</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_strcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dest_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_strcpy</name><argument_list>(<argument><expr><name>r</name> <operator>+</operator> <operator>(</operator><name>dest_end</name> <operator>-</operator> <name>dest</name><operator>)</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>src_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ST_LIBRARY</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"st.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl>;</decl_stmt>
}</block></struct></type> <name>st_str_end_key</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>str_end_cmp</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>xp</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>yp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>st_str_end_key</name> <modifier>*</modifier></type><name>x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>st_str_end_key</name> <operator>*</operator><operator>)</operator><name>xp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>st_str_end_key</name> <operator>*</operator><operator>)</operator><name>yp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>x</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>y</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>y</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name><name>y</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name><name>x</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>p</name> <operator>-</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>q</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>str_end_hash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>xp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>st_str_end_key</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>st_str_end_key</name> <operator>*</operator><operator>)</operator><name>xp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name><name>x</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>val</name> <operator>*</operator> <literal type="number">997</literal> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>val</name> <operator>+</operator> <operator>(</operator><name>val</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>hash_table_type</name><modifier>*</modifier></type>
<name>onig_st_init_strend_table_with_size</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>hashType</name> <init>= <expr><block>{
<expr><name>str_end_cmp</name></expr>,
<expr><name>str_end_hash</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>hash_table_type</name><operator>*</operator> <operator>)</operator>
<call><name>onig_st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashType</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_st_lookup_strend</name><parameter_list>(<parameter><decl><type><name>hash_table_type</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>str_key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end_key</name></decl></parameter>, <parameter><decl><type><name>hash_data_type</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_str_end_key</name></type> <name>key</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>key</name><operator>.</operator><name>s</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>str_key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>.</operator><name>end</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>end_key</name></expr>;</expr_stmt>

<return>return <expr><call><name>onig_st_lookup</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name> <operator>)</operator><operator>(</operator><operator>&amp;</operator><name>key</name><operator>)</operator></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_st_insert_strend</name><parameter_list>(<parameter><decl><type><name>hash_table_type</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>str_key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end_key</name></decl></parameter>, <parameter><decl><type><name>hash_data_type</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_str_end_key</name><modifier>*</modifier></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>st_str_end_key</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>st_str_end_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>str_key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>end_key</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>onig_st_insert</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name> <operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_NAME_BACKREFS_ALLOC_NUM</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>name_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>back_num</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>back_alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>back_ref1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>back_refs</name></decl>;</decl_stmt>
}</block></struct></type> <name>NameEntry</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ST_LIBRARY</name></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type><name>st_table</name></type> <name>NameTable</name>;</typedef>
<typedef>typedef <type><name>st_data_t</name></type> <name>HashDataType</name>;</typedef> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>i_print_name_entry</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name> <init>= <expr><operator>(</operator><name>FILE</name><operator>*</operator> <operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>e</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_print_names</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"name table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_st_foreach</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>st_foreach_callback_func</name> <operator>*</operator><operator>)</operator><name>i_print_name_entry</name></expr></argument>, <argument><expr><operator>(</operator><name>HashDataType</name> <operator>)</operator><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>int</name></type>
<name>i_free_name_entry</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier> <name>arg</name></type> <name>ARG_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_DELETE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>names_clear</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_st_foreach</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>st_foreach_callback_func</name> <operator>*</operator><operator>)</operator><name>i_free_name_entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_names_free</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>names_clear</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>onig_st_free_table</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameEntry</name><modifier>*</modifier></type>
<name>name_find</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>NameEntry</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_st_lookup_strend</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>, <argument><expr><operator>(</operator><name>HashDataType</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator> <operator>)</operator><operator>(</operator><operator>&amp;</operator><name>e</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl>;</decl_stmt>
}</block></struct></type> <name>INamesArg</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>i_names</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier> <name>key</name></type> <name>ARG_UNUSED</name></decl></parameter>, <parameter><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>INamesArg</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name><name>arg</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator><operator>)</operator><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>name</name></name>,
<name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>name_len</name></name>,
<name><name>e</name><operator>-&gt;</operator><name>back_num</name></name>,
<operator>(</operator><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr> </then><else>: <expr><operator>&amp;</operator><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name><operator>)</operator></expr></else></ternary><operator>)</operator>,
<name><name>arg</name><operator>-&gt;</operator><name>reg</name></name>, <name><name>arg</name><operator>-&gt;</operator><name>arg</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>ret</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_foreach_name</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>INamesArg</name></type> <name>narg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>narg</name><operator>.</operator><name>ret</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>narg</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>narg</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>narg</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>narg</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>onig_st_foreach</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>st_foreach_callback_func</name> <operator>*</operator><operator>)</operator><name>i_names</name></expr></argument>, <argument><expr><operator>(</operator><name>HashDataType</name> <operator>)</operator><operator>&amp;</operator><name>narg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>narg</name><operator>.</operator><name>ret</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>i_renumber_name</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier> <name>key</name></type> <name>ARG_UNUSED</name></decl></parameter>, <parameter><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>GroupNumRemap</name><modifier>*</modifier></type> <name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>e</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>map</name><index>[<expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>new_val</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name> <operator>=</operator> <name><name>map</name><index>[<expr><name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name></expr>]</index></name><operator>.</operator><name>new_val</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_renumber_name_table</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>GroupNumRemap</name><modifier>*</modifier></type> <name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_st_foreach</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>st_foreach_callback_func</name> <operator>*</operator><operator>)</operator><name>i_renumber_name</name></expr></argument>, <argument><expr><operator>(</operator><name>HashDataType</name> <operator>)</operator><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_number_of_names</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>int</name> <operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>num_entries</name></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_NAMES_ALLOC_NUM</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>alloc</name></decl>;</decl_stmt>
}</block></struct></type> <name>NameTable</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_print_names</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>num</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"name table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>e</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>names_clear</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>name_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_alloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_names_free</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>names_clear</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameEntry</name><modifier>*</modifier></type>
<name>name_find</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>name_end</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name><name>e</name><operator>-&gt;</operator><name>name_len</name></name> <operator>&amp;&amp;</operator> <call><name>onig_strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>e</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>NameEntry</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_foreach_name</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>name_len</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr> </then><else>: <expr><operator>&amp;</operator><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_number_of_names</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>num</name></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>int</name></type>
<name>name_add</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>backref</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameTable</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name_end</name> <operator>-</operator> <name>name</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_EMPTY_GROUP_NAME</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>name_find</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ST_LIBRARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>onig_st_init_strend_table_with_size</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator> <operator>)</operator><name>t</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>NameEntry</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup_with_null</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>onig_st_insert_strend</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <operator>(</operator><name>name_end</name> <operator>-</operator> <name>name</name><operator>)</operator><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>HashDataType</name> <operator>)</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>name_len</name></name> <operator>=</operator> <name>name_end</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_alloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>alloc</name> <operator>=</operator> <name>INIT_NAMES_ALLOC_NUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>NameTable</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <operator>(</operator><name>NameEntry</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>alloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>name_table</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<goto>goto <name>clear</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>num</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>alloc</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>alloc</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>alloc</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>NameEntry</name><operator>*</operator> <operator>)</operator><call><name>xrealloc</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>alloc</name></expr>;</expr_stmt>

<label><name>clear</name>:</label>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>num</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>alloc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>back_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>back_alloc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>back_refs</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>e</name><index>[<expr><name><name>t</name><operator>-&gt;</operator><name>num</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>num</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup_with_null</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>name_len</name></name> <operator>=</operator> <name>name_end</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>!</operator> <call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>ONIGERR_MULTIPLEX_DEFINED_NAME</name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MULTIPLEX_DEFINED_NAME</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name> <operator>=</operator> <name>backref</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>alloc</name> <operator>=</operator> <name>INIT_NAME_BACKREFS_ALLOC_NUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_alloc</name></name> <operator>=</operator> <name>alloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>backref</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>&gt;</operator> <name><name>e</name><operator>-&gt;</operator><name>back_alloc</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>alloc</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>back_alloc</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><call><name>xrealloc</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_alloc</name></name> <operator>=</operator> <name>alloc</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>back_refs</name><index>[<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>backref</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_name_to_group_numbers</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier><modifier>*</modifier></type> <name>nums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NameEntry</name><modifier>*</modifier></type> <name>e</name> <init>= <expr><call><name>name_find</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_UNDEFINED_NAME_REFERENCE</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nums</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nums</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>back_ref1</name></name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nums</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>back_refs</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_name_to_backref_number</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigRegion</name> <modifier>*</modifier></type><name>region</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nums</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>onig_name_to_group_numbers</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>n</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>nums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>region</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>region</name><operator>-&gt;</operator><name>beg</name><index>[<expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>!=</operator> <name>ONIG_REGION_NOTPOS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>nums</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_name_to_group_numbers</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier><modifier>*</modifier></type> <name>nums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ONIG_NO_SUPPORT_CONFIG</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_name_to_backref_number</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigRegion</name><modifier>*</modifier></type> <name>region</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ONIG_NO_SUPPORT_CONFIG</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_foreach_name</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ONIG_NO_SUPPORT_CONFIG</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_number_of_names</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_noname_group_capture_is_active</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIG_IS_OPTION_ON</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>ONIG_OPTION_DONT_CAPTURE_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>onig_number_of_names</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ONIG_IS_OPTION_ON</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>ONIG_OPTION_CAPTURE_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_SCANENV_MEMNODES_ALLOC_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scan_env_clear</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BIT_STATUS_CLEAR</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>capture_history</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIT_STATUS_CLEAR</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>bt_mem_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIT_STATUS_CLEAR</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIT_STATUS_CLEAR</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>backrefed_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>error_end</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_call</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_named</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>mem_alloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>mem_nodes_dynamic</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SCANENV_MEMNODES_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>mem_nodes_static</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt></block_content></block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_comb_exp_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>comb_exp_max_regnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>curr_max_regnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>has_recursion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>parse_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>warnings_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>scan_env_add_mem_entry</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>need</name></decl>, <decl><type ref="prev"/><name>alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>need</name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>need</name> <operator>&gt;</operator> <name>ONIG_MAX_CAPTURE_GROUP_NUM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TOO_MANY_CAPTURE_GROUPS</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>need</name> <operator>&gt;=</operator> <name>SCANENV_MEMNODES_SIZE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>mem_alloc</name></name> <operator>&lt;=</operator> <name>need</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>mem_nodes_dynamic</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>alloc</name> <operator>=</operator> <name>INIT_SCANENV_MEMNODES_ALLOC_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xmemcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>mem_nodes_static</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>SCANENV_MEMNODES_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>alloc</name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>mem_alloc</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>*</operator> <operator>)</operator><call><name>xrealloc</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>mem_nodes_dynamic</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>alloc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>mem_nodes_dynamic</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>mem_alloc</name></name> <operator>=</operator> <name>alloc</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>scan_env_set_mem_node</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>&gt;=</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><index>[<expr><name>num</name></expr>]</index> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>extern</specifier> <name>void</name></type>
<name>onig_node_free</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<label><name>start</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_STR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>capa</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>!=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>next_node</name> <init>= <expr><call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name>next_node</name></expr>;</expr_stmt>
<goto>goto <name>start</name>;</goto>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name> <init>= <expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>back_dynamic</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>back_dynamic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl>;</decl_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_cclass</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BITSET_CLEAR</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_cclass</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_CCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>initialize_cclass</name><argument_list>(<argument><expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_ctype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>not</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ascii_range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_CTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name> <operator>=</operator> <name>not</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name> <operator>=</operator> <name>ascii_range</name></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_anychar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_CANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_list</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type>
<name>onig_node_new_list</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>node_new_list</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type>
<name>onig_node_list_add</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>onig_node_new_list</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL_NODE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type>
<name>onig_node_new_alt</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type>
<name>onig_node_new_anchor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_ANCHOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>char_len</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_backref</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>back_num</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>backrefs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>by_name</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<parameter><decl><type><name>int</name></type> <name>exist_level</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nest_level</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_BREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>back_num</name> <operator>=</operator> <name>back_num</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>back_dynamic</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>by_name</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>|=</operator> <name>NST_NAME_REF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>exist_level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>|=</operator> <name>NST_NEST_LEVEL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nest_level</name> <operator>=</operator> <name>nest_level</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>back_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>backrefs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>&amp;&amp;</operator>
<call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><index>[<expr><name><name>backrefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>|=</operator> <name>NST_RECURSION</name></expr>;</expr_stmt> 
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>back_num</name> <operator>&lt;=</operator> <name>NODE_BACKREFS_SIZE</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>back_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>back_static</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>backrefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>back_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>back_dynamic</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>back_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>backrefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_call</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>gnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>name</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>name_end</name> <operator>=</operator> <name>name_end</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>group_num</name> <operator>=</operator> <name>gnum</name></expr>;</expr_stmt> 
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_quantifier</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>upper</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>by_number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_QTFR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lower</name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>upper</name> <operator>=</operator> <name>upper</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>greedy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target_empty_info</name> <operator>=</operator> <name>NQ_TARGET_ISNOT_EMPTY</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head_exact</name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next_head_exact</name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>is_referred</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>by_number</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>|=</operator> <name>NST_BY_NUMBER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>comb_exp_check_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_enclose</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_ENCLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>call_addr</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opt_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type>
<name>onig_node_new_enclose</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>node_new_enclose</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_enclose_memory</name><parameter_list>(<parameter><decl><type><name>OnigOptionType</name></type> <name>option</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_named</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_MEMORY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_named</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_option</name><parameter_list>(<parameter><decl><type><name>OnigOptionType</name></type> <name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_OPTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_node_str_cat</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>addlen</name> <init>= <expr><name>end</name> <operator>-</operator> <name>s</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>len</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end</name> <operator>-</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>capa</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>len</name> <operator>+</operator> <name>addlen</name> <operator>&gt;</operator> <name>NODE_STR_BUF_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>capa</name> <init>= <expr><name>len</name> <operator>+</operator> <name>addlen</name> <operator>+</operator> <name>NODE_STR_MARGIN</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>&lt;=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>capa</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_strcpy</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>==</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strcat_capa_from_static</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end</name></expr></argument>,
<argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strcat_capa</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>capa</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>capa</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>onig_strcpy</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end</name> <operator>=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>+</operator> <name>len</name> <operator>+</operator> <name>addlen</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_node_str_set</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>onig_node_str_clear</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>onig_node_str_cat</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>node_str_cat_char</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>UChar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<return>return <expr><call><name>onig_node_str_cat</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>node_str_cat_codepoint</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>num</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>onig_node_str_cat</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
extern void
onig_node_conv_to_str_node(Node* node, int flag)
{
SET_NTYPE(node, NT_STR);
NSTR(node)-&gt;flag = flag;
NSTR(node)-&gt;capa = 0;
NSTR(node)-&gt;s = NSTR(node)-&gt;buf;
NSTR(node)-&gt;end = NSTR(node)-&gt;buf;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>onig_node_str_clear</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>capa</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>!=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>capa</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end</name> <operator>=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NT_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>capa</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name> <operator>=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end</name> <operator>=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>onig_node_str_cat</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type>
<name>onig_node_new_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>node_new_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_str_raw</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>node_new_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NSTRING_SET_RAW</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>node_new_str</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>node_new_str_raw_char</name><parameter_list>(<parameter><decl><type><name>UChar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<return>return <expr><call><name>node_new_str_raw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>str_node_split_last_char</name><parameter_list>(<parameter><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>n</name> <init>= <expr><name>NULL_NODE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>onigenc_get_prev_char_head</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>node_new_str</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sn</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;</operator> <name>NSTR_RAW</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NSTRING_SET_RAW</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>str_node_can_be_split</name><parameter_list>(<parameter><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PAD_TO_SHORT_BYTE_CHAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>node_str_head_pad</name><parameter_list>(<parameter><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>UChar</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>NODE_STR_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sn</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>num</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>+=</operator> <name>num</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_scan_unsigned_number</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name> <operator>)</operator><call><name>DIGITVAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>INT_MAX_LIMIT</name> <operator>-</operator> <name>val</name><operator>)</operator> <operator>/</operator> <literal type="number">10UL</literal> <operator>&lt;</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>num</name> <operator>=</operator> <name>num</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>scan_unsigned_hexadecimal_number</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>restlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><name>restlen</name> <operator>=</operator> <name>maxlen</name> <operator>-</operator> <name>minlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <name>maxlen</name><operator>--</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_XDIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name> <operator>)</operator><call><name>XDIGITVAL</name><argument_list>(<argument><expr><name>enc</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>INT_MAX_LIMIT</name> <operator>-</operator> <name>val</name><operator>)</operator> <operator>/</operator> <literal type="number">16UL</literal> <operator>&lt;</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>num</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>XDIGITVAL</name><argument_list>(<argument><expr><name>enc</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>maxlen</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&gt;</operator> <name>restlen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>scan_unsigned_octal_number</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>,
<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <name>maxlen</name><operator>--</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="char">'8'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>ODIGITVAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>INT_MAX_LIMIT</name> <operator>-</operator> <name>val</name><operator>)</operator> <operator>/</operator> <literal type="number">8UL</literal> <operator>&lt;</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>num</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BBUF_WRITE_CODE_POINT</name><parameter_list>(<parameter><type><name>bbuf</name></type></parameter>,<parameter><type><name>pos</name></type></parameter>,<parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BBUF_WRITE(bbuf, pos, &amp;(code), SIZE_CODE_POINT)</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>new_code_range</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_MULTI_BYTE_RANGE_SIZE</name></cpp:macro> <cpp:value>(SIZE_CODE_POINT * 5)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bbuf</name> <operator>=</operator> <operator>*</operator><name>pbuf</name> <operator>=</operator> <operator>(</operator><name>BBuf</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>BBUF_INIT</name><argument_list>(<argument><expr><operator>*</operator><name>pbuf</name></expr></argument>, <argument><expr><name>INIT_MULTI_BYTE_RANGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BBUF_WRITE_CODE_POINT</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_code_range_to_buf0</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>to</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>checkdup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>inc_n</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>, <decl><type ref="prev"/><name>bound</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt> <expr_stmt><expr><name>from</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt> <expr_stmt><expr><name>to</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>new_code_range</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bbuf</name> <operator>=</operator> <operator>*</operator><name>pbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bbuf</name> <operator>=</operator> <operator>*</operator><name>pbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><operator>(</operator><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>bound</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>from</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>low</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>low</name> <operator>+</operator> <name>bound</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>data</name><index>[<expr><name>x</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>low</name> <operator>=</operator> <name>x</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bound</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>high</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>to</name> <operator>==</operator> <name>ONIG_LAST_CODE_POINT</name><operator>)</operator></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>low</name></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>bound</name> <operator>=</operator> <name>n</name></expr>;</init> <condition><expr><name>high</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>high</name> <operator>+</operator> <name>bound</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>data</name><index>[<expr><name>x</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name>x</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bound</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>




<expr_stmt><expr><name>inc_n</name> <operator>=</operator> <name>low</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>high</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>+</operator> <name>inc_n</name> <operator>&gt;</operator> <name>ONIG_MAX_MULTI_BYTE_RANGES_NUM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TOO_MANY_MULTI_BYTE_RANGES</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>inc_n</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>checkdup</name> <operator>&amp;&amp;</operator> <name>from</name> <operator>&lt;=</operator> <name><name>data</name><index>[<expr><name>low</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>low</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>&lt;=</operator> <name>from</name> <operator>||</operator> <name><name>data</name><index>[<expr><name>low</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <name>to</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CC_DUP_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;</operator> <name><name>data</name><index>[<expr><name>low</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>low</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>&lt;</operator> <name><name>data</name><index>[<expr><operator>(</operator><name>high</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>data</name><index>[<expr><operator>(</operator><name>high</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>inc_n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>from_pos</name> <init>= <expr><name>SIZE_CODE_POINT</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>high</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>to_pos</name> <init>= <expr><name>SIZE_CODE_POINT</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>low</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>inc_n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>high</name> <operator>&lt;</operator> <name>n</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><operator>(</operator><name>n</name> <operator>-</operator> <name>high</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name>SIZE_CODE_POINT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>BBUF_MOVE_RIGHT</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>, <argument><expr><name>from_pos</name></expr></argument>, <argument><expr><name>to_pos</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>BBUF_MOVE_LEFT_REDUCE</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>, <argument><expr><name>from_pos</name></expr></argument>, <argument><expr><name>to_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>SIZE_CODE_POINT</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>low</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BBUF_ENSURE_SIZE</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <name>SIZE_CODE_POINT</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BBUF_WRITE_CODE_POINT</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BBUF_WRITE_CODE_POINT</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <name>SIZE_CODE_POINT</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <name>inc_n</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BBUF_WRITE_CODE_POINT</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_code_range_to_buf</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>add_code_range_to_buf0</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_code_range0</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>checkdup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>add_code_range_to_buf0</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>checkdup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_code_range</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>add_code_range0</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>not_code_range_buf</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf</name></decl></parameter>, <parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>pre</name></decl>, <decl><type ref="prev"/><name>from</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>, <decl><type ref="prev"/><name>to</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>pbuf</name> <operator>=</operator> <operator>(</operator><name>BBuf</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<label><name>set_all</name>:</label>
<return>return <expr><call><name>SET_ALL_MULTI_BYTE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><operator>(</operator><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>set_all</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pre</name> <operator>=</operator> <call><name>MBCODE_START_POS</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pre</name> <operator>&lt;=</operator> <name>from</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name>from</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>==</operator> <name>ONIG_LAST_CODE_POINT</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pre</name> <operator>=</operator> <name>to</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>&lt;</operator> <name>ONIG_LAST_CODE_POINT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>to</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ONIG_LAST_CODE_POINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_BBUF_NOT</name><parameter_list>(<parameter><type><name>bbuf1</name></type></parameter>, <parameter><type><name>not1</name></type></parameter>, <parameter><type><name>bbuf2</name></type></parameter>, <parameter><type><name>not2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {BBuf *tbuf; int tnot; tnot = not1; not1 = not2; not2 = tnot; tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; } while (0)</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>or_code_range_buf</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>not1</name></decl></parameter>,
<parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>not2</name></decl></parameter>, <parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>from</name></decl>, <decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>pbuf</name> <operator>=</operator> <operator>(</operator><name>BBuf</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>bbuf1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_NULL</name><argument_list>(<argument><expr><name>bbuf2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>not2</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SET_ALL_MULTI_BYTE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>bbuf2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SWAP_BBUF_NOT</name><argument_list>(<argument><expr><name>bbuf1</name></expr></argument>, <argument><expr><name>not1</name></expr></argument>, <argument><expr><name>bbuf2</name></expr></argument>, <argument><expr><name>not2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>bbuf1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>SET_ALL_MULTI_BYTE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>not2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>bbuf_clone</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>bbuf2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>not_code_range_buf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>bbuf2</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SWAP_BBUF_NOT</name><argument_list>(<argument><expr><name>bbuf1</name></expr></argument>, <argument><expr><name>not1</name></expr></argument>, <argument><expr><name>bbuf2</name></expr></argument>, <argument><expr><name>not2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data1</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><operator>(</operator><name><name>bbuf1</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>data1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data1</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>not2</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>not1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>bbuf_clone</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>bbuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>not1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>not_code_range_buf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>bbuf2</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>data1</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>data1</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>and_code_range1</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>from1</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>to1</name></decl></parameter>,
<parameter><decl><type><name>OnigCodePoint</name><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>from2</name></decl>, <decl><type ref="prev"/><name>to2</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>from2</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to2</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>from2</name> <operator>&lt;</operator> <name>from1</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>to2</name> <operator>&lt;</operator> <name>from1</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>from1</name> <operator>=</operator> <name>to2</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>from2</name> <operator>&lt;=</operator> <name>to1</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>to2</name> <operator>&lt;</operator> <name>to1</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>from1</name> <operator>&lt;=</operator> <name>from2</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>from1</name></expr></argument>, <argument><expr><name>from2</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>from1</name> <operator>=</operator> <name>to2</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>to1</name> <operator>=</operator> <name>from2</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>from1</name> <operator>=</operator> <name>from2</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>from1</name> <operator>&gt;</operator> <name>to1</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>from1</name> <operator>&lt;=</operator> <name>to1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>from1</name></expr></argument>, <argument><expr><name>to1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>and_code_range_buf</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>not1</name></decl></parameter>, <parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>not2</name></decl></parameter>, <parameter><decl><type><name>BBuf</name><modifier>*</modifier><modifier>*</modifier></type> <name>pbuf</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>from</name></decl>, <decl><type ref="prev"/><name>to</name></decl>, <decl><type ref="prev"/><name>from1</name></decl>, <decl><type ref="prev"/><name>to1</name></decl>, <decl><type ref="prev"/><name>from2</name></decl>, <decl><type ref="prev"/><name>to2</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>pbuf</name> <operator>=</operator> <operator>(</operator><name>BBuf</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>bbuf1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>bbuf2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><call><name>bbuf_clone</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>bbuf2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>bbuf2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>not2</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>bbuf_clone</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>bbuf1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SWAP_BBUF_NOT</name><argument_list>(<argument><expr><name>bbuf1</name></expr></argument>, <argument><expr><name>not1</name></expr></argument>, <argument><expr><name>bbuf2</name></expr></argument>, <argument><expr><name>not2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data1</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><operator>(</operator><name><name>bbuf1</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>data2</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><operator>(</operator><name><name>bbuf2</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>data1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>n2</name></expr></argument>, <argument><expr><name>data2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data1</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>data2</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>not2</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>not1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>from1</name> <operator>=</operator> <name><name>data1</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to1</name> <operator>=</operator> <name><name>data1</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n2</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>from2</name> <operator>=</operator> <name><name>data2</name><index>[<expr><name>j</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to2</name> <operator>=</operator> <name><name>data2</name><index>[<expr><name>j</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>from2</name> <operator>&gt;</operator> <name>to1</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>to2</name> <operator>&lt;</operator> <name>from1</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>from1</name></expr></argument>, <argument><expr><name>from2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>to1</name></expr></argument>, <argument><expr><name>to2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>not1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>from1</name> <operator>=</operator> <name><name>data1</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to1</name> <operator>=</operator> <name><name>data1</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>and_code_range1</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>from1</name></expr></argument>, <argument><expr><name>to1</name></expr></argument>, <argument><expr><name>data2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>and_cclass</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>not1</name></decl>, <decl><type ref="prev"/><name>not2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BBuf</name> <modifier>*</modifier></type><name>buf1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pbuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitSetRef</name></type> <name>bsr1</name></decl>, <decl><type ref="prev"/><name>bsr2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitSet</name></type> <name>bs1</name></decl>, <decl><type ref="prev"/><name>bs2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>not1</name> <operator>=</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr1</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf1</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>mbuf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>not2</name> <operator>=</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr2</name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf2</name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_invert_to</name><argument_list>(<argument><expr><name>bsr1</name></expr></argument>, <argument><expr><name>bs1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr1</name> <operator>=</operator> <name>bs1</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>not2</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_invert_to</name><argument_list>(<argument><expr><name>bsr2</name></expr></argument>, <argument><expr><name>bs2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr2</name> <operator>=</operator> <name>bs2</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bitset_and</name><argument_list>(<argument><expr><name>bsr1</name></expr></argument>, <argument><expr><name>bsr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bsr1</name> <operator>!=</operator> <name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_copy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>bsr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr1</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_invert</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_SINGLEBYTE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>not2</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>or_code_range_buf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>and_code_range_buf</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>not1</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>not2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BBuf</name> <modifier>*</modifier></type><name>tbuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>not_code_range_buf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pbuf</name> <operator>=</operator> <name>tbuf</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>mbuf</name></name> <operator>=</operator> <name>pbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>or_cclass</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>not1</name></decl>, <decl><type ref="prev"/><name>not2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BBuf</name> <modifier>*</modifier></type><name>buf1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pbuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitSetRef</name></type> <name>bsr1</name></decl>, <decl><type ref="prev"/><name>bsr2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitSet</name></type> <name>bs1</name></decl>, <decl><type ref="prev"/><name>bs2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>not1</name> <operator>=</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr1</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf1</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>mbuf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>not2</name> <operator>=</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr2</name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf2</name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_invert_to</name><argument_list>(<argument><expr><name>bsr1</name></expr></argument>, <argument><expr><name>bs1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr1</name> <operator>=</operator> <name>bs1</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>not2</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_invert_to</name><argument_list>(<argument><expr><name>bsr2</name></expr></argument>, <argument><expr><name>bs2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr2</name> <operator>=</operator> <name>bs2</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bitset_or</name><argument_list>(<argument><expr><name>bsr1</name></expr></argument>, <argument><expr><name>bsr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bsr1</name> <operator>!=</operator> <name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_copy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>bsr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsr1</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_invert</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_SINGLEBYTE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>not1</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>not2</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>and_code_range_buf</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>or_code_range_buf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>not1</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>not2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>not1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BBuf</name> <modifier>*</modifier></type><name>tbuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>not_code_range_buf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tbuf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pbuf</name> <operator>=</operator> <name>tbuf</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>mbuf</name></name> <operator>=</operator> <name>pbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UNKNOWN_ESC_WARN</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>OnigCodePoint</name></type>
<name>conv_backslash_value</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_CONTROL_CHARS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'n'</literal></expr>:</case> <return>return <expr><literal type="char">'\n'</literal></expr>;</return>
<case>case <expr><literal type="char">'t'</literal></expr>:</case> <return>return <expr><literal type="char">'\t'</literal></expr>;</return>
<case>case <expr><literal type="char">'r'</literal></expr>:</case> <return>return <expr><literal type="char">'\r'</literal></expr>;</return>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> <return>return <expr><literal type="char">'\f'</literal></expr>;</return>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> <return>return <expr><literal type="char">'\007'</literal></expr>;</return>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> <return>return <expr><literal type="char">'\010'</literal></expr>;</return>
<case>case <expr><literal type="char">'e'</literal></expr>:</case> <return>return <expr><literal type="char">'\033'</literal></expr>;</return>
<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_V_VTAB</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="char">'\v'</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="char">'a'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>UNKNOWN_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NO_INVALID_QUANTIFIER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_invalid_quantifier_target</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_invalid_quantifier_target</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>


<break>break;</break>

<case>case <expr><name>NT_LIST</name></expr>:</case>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>is_invalid_quantifier_target</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_invalid_quantifier_target</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>popular_quantifier_num</name><parameter_list>(<parameter><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">4</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<enum>enum <name>ReduceType</name> <block>{
<decl><name>RQ_ASIS</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>RQ_DEL</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, 
<decl><name>RQ_A</name></decl>, 
<decl><name>RQ_AQ</name></decl>, 
<decl><name>RQ_QQ</name></decl>, 
<decl><name>RQ_P_QQ</name></decl>, 
<decl><name>RQ_PQ_Q</name></decl> 
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>enum</name> <name>ReduceType</name></name> <specifier>const</specifier></type> <name><name>ReduceTypeTable</name><index>[<expr><literal type="number">6</literal></expr>]</index><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{

<expr><block>{<expr><name>RQ_DEL</name></expr>, <expr><name>RQ_A</name></expr>, <expr><name>RQ_A</name></expr>, <expr><name>RQ_QQ</name></expr>, <expr><name>RQ_AQ</name></expr>, <expr><name>RQ_ASIS</name></expr>}</block></expr>, 
<expr><block>{<expr><name>RQ_DEL</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_P_QQ</name></expr>, <expr><name>RQ_P_QQ</name></expr>, <expr><name>RQ_DEL</name></expr>}</block></expr>, 
<expr><block>{<expr><name>RQ_A</name></expr>, <expr><name>RQ_A</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_ASIS</name></expr>, <expr><name>RQ_P_QQ</name></expr>, <expr><name>RQ_DEL</name></expr>}</block></expr>, 
<expr><block>{<expr><name>RQ_DEL</name></expr>, <expr><name>RQ_AQ</name></expr>, <expr><name>RQ_AQ</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_AQ</name></expr>, <expr><name>RQ_AQ</name></expr>}</block></expr>, 
<expr><block>{<expr><name>RQ_DEL</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_DEL</name></expr>}</block></expr>, 
<expr><block>{<expr><name>RQ_ASIS</name></expr>, <expr><name>RQ_PQ_Q</name></expr>, <expr><name>RQ_DEL</name></expr>, <expr><name>RQ_AQ</name></expr>, <expr><name>RQ_AQ</name></expr>, <expr><name>RQ_DEL</name></expr>}</block></expr> 
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>onig_reduce_nested_quantifier</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>cnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pnum</name></decl>, <decl><type ref="prev"/><name>cnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QtfrNode</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>NQTFR</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>NQTFR</name><argument_list>(<argument><expr><name>cnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pnum</name> <operator>=</operator> <call><name>popular_quantifier_num</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cnum</name> <operator>=</operator> <call><name>popular_quantifier_num</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pnum</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>cnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>ReduceTypeTable</name><index>[<expr><name>cnum</name></expr>]</index><index>[<expr><name>pnum</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RQ_DEL</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>pnode</name> <operator>=</operator> <operator>*</operator><name>cnode</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RQ_A</name></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RQ_AQ</name></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RQ_QQ</name></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RQ_P_QQ</name></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>cnode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return ;</return>
<break>break;</break>
<case>case <expr><name>RQ_PQ_Q</name></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>cnode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return ;</return>
<break>break;</break>
<case>case <expr><name>RQ_ASIS</name></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>cnode</name></expr>;</expr_stmt>
<return>return ;</return>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>cnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<enum>enum <name>TokenSyms</name> <block>{
<decl><name>TK_EOT</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>TK_RAW_BYTE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>TK_CHAR</name></decl>,
<decl><name>TK_STRING</name></decl>,
<decl><name>TK_CODE_POINT</name></decl>,
<decl><name>TK_ANYCHAR</name></decl>,
<decl><name>TK_CHAR_TYPE</name></decl>,
<decl><name>TK_BACKREF</name></decl>,
<decl><name>TK_CALL</name></decl>,
<decl><name>TK_ANCHOR</name></decl>,
<decl><name>TK_OP_REPEAT</name></decl>,
<decl><name>TK_INTERVAL</name></decl>,
<decl><name>TK_ANYCHAR_ANYTIME</name></decl>, 
<decl><name>TK_ALT</name></decl>,
<decl><name>TK_SUBEXP_OPEN</name></decl>,
<decl><name>TK_SUBEXP_CLOSE</name></decl>,
<decl><name>TK_CC_OPEN</name></decl>,
<decl><name>TK_QUOTE_OPEN</name></decl>,
<decl><name>TK_CHAR_PROPERTY</name></decl>, 
<decl><name>TK_LINEBREAK</name></decl>,
<decl><name>TK_EXTENDED_GRAPHEME_CLUSTER</name></decl>,
<decl><name>TK_KEEP</name></decl>,

<decl><name>TK_CC_CLOSE</name></decl>,
<decl><name>TK_CC_RANGE</name></decl>,
<decl><name>TK_POSIX_BRACKET_OPEN</name></decl>,
<decl><name>TK_CC_AND</name></decl>, 
<decl><name>TK_CC_CC_OPEN</name></decl> 
}</block>;</enum>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name><name>enum</name> <name>TokenSyms</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>escaped</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>backp</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>subtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ascii_range</name></decl>;</decl_stmt>
}</block> <decl><name>anchor</name></decl>;</struct>
<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>lower</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>upper</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>greedy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>possessive</name></decl>;</decl_stmt>
}</block> <decl><name>repeat</name></decl>;</struct>
<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ref1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>by_name</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>exist_level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block> <decl><name>backref</name></decl>;</struct>
<struct>struct <block>{
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rel</name></decl>;</decl_stmt>
}</block> <decl><name>call</name></decl>;</struct>
<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ctype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>not</name></decl>;</decl_stmt>
}</block> <decl><name>prop</name></decl>;</struct>
}</block> <decl><name>u</name></decl>;</union>
}</block></struct></type> <name>OnigToken</name>;</typedef>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_range_quantifier</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>low</name></decl>, <decl><type ref="prev"/><name>up</name></decl>, <decl><type ref="prev"/><name>syn_allow</name></decl>, <decl><type ref="prev"/><name>non_low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><name>syn_allow</name> <operator>=</operator> <call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_INVALID_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>syn_allow</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_END_PATTERN_AT_LEFT_BRACE</name></expr>;</return></block_content></block></else></if_stmt> 
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>syn_allow</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>PPEEK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ONIGERR_END_PATTERN_AT_LEFT_BRACE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>low</name> <operator>=</operator> <call><name>onig_scan_unsigned_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>low</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>low</name> <operator>&gt;</operator> <name>ONIG_MAX_REPEAT_NUM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <operator>*</operator><name>src</name></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>non_low</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<goto>goto <name>invalid</name>;</goto></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>prev</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>up</name> <operator>=</operator> <call><name>onig_scan_unsigned_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>up</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>up</name> <operator>&gt;</operator> <name>ONIG_MAX_REPEAT_NUM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>prev</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>non_low</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>up</name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>non_low</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>up</name> <operator>=</operator> <name>low</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_BRACE_INTERVAL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <call><name>MC_ESC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name>up</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>low</name> <operator>&gt;</operator> <name>up</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_INTERVAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>low</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>upper</name></name> <operator>=</operator> <name>up</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return> 

<label><name>invalid</name>:</label>
<if_stmt><if>if <condition>(<expr><name>syn_allow</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_REPEAT_RANGE_PATTERN</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_escaped_value</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name><modifier>*</modifier></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_AT_ESCAPE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'M'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_AT_META</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_META_CODE_SYNTAX</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_AT_META</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ESC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>fetch_escaped_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<goto>goto <name>backslash</name>;</goto></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_AT_CONTROL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_CONTROL_CODE_SYNTAX</name></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>control</name>;</goto>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<goto>goto <name>backslash</name>;</goto></block_content></block></else></if_stmt>

<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_C_CONTROL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<label><name>control</name>:</label>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_AT_CONTROL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0177</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ESC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>fetch_escaped_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>&amp;=</operator> <literal type="number">0x9f</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<default>default:</default>
<block>{<block_content>
<label><name>backslash</name>:</label>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>conv_backslash_value</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fetch_token</name><parameter_list>(<parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>OnigCodePoint</name></type>
<name>get_name_end_code_point</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>start</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> <return>return <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'&gt;'</literal></expr>;</return> <break>break;</break>
<case>case <expr><literal type="char">'\''</literal></expr>:</case> <return>return <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'\''</literal></expr>;</return> <break>break;</break>
<case>case <expr><literal type="char">'('</literal></expr>:</case> <return>return <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">')'</literal></expr>;</return> <break>break;</break>
<case>case <expr><literal type="char">'{'</literal></expr>:</case> <return>return <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'}'</literal></expr>;</return> <break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONIGENC_IS_CODE_NAME</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TRUE</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONIGENC_IS_CODE_NAME</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ONIGENC_IS_CODE_WORD(enc, c)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_name_with_level</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name>start_code</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>rname_end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>,
<parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>rback_num</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>rlevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>sign</name></decl>, <decl><type ref="prev"/><name>is_num</name></decl>, <decl><type ref="prev"/><name>exist_level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>end_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>pnum_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <name>exist_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pnum_head</name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end_code</name> <operator>=</operator> <call><name>get_name_end_code_point</name><argument_list>(<argument><expr><name>start_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ONIGERR_EMPTY_GROUP_NAME</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>end_code</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_EMPTY_GROUP_NAME</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pnum_head</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ONIGENC_IS_CODE_NAME</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_IN_GROUP_NAME</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>end_code</name> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_num</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ONIGENC_IS_CODE_NAME</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_IN_GROUP_NAME</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>end_code</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_IN_GROUP_NAME</name></expr>;</expr_stmt>
<goto>goto <name>end</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>onig_scan_unsigned_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>rlevel</name> <operator>=</operator> <operator>(</operator><name>level</name> <operator>*</operator> <name>flag</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>exist_level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>end_code</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>=</operator> <call><name>onig_scan_unsigned_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pnum_head</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rback_num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>rback_num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>*=</operator> <name>sign</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>rname_end</name> <operator>=</operator> <name>name_end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>exist_level</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 





<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_name</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name>start_code</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>rname_end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>rback_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>is_num</name></decl>, <decl><type ref="prev"/><name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>end_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>pnum_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>end_code</name> <operator>=</operator> <call><name>get_name_end_code_point</name><argument_list>(<argument><expr><name>start_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pnum_head</name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ONIGERR_EMPTY_GROUP_NAME</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>end_code</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_EMPTY_GROUP_NAME</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pnum_head</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ONIGENC_IS_CODE_NAME</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_IN_GROUP_NAME</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>end_code</name> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_num</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<goto>goto <name>teardown</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ONIGENC_IS_CODE_WORD</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_IN_GROUP_NAME</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>teardown</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ONIGENC_IS_CODE_NAME</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_IN_GROUP_NAME</name></expr>;</expr_stmt>
<goto>goto <name>teardown</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>end_code</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>=</operator> <call><name>onig_scan_unsigned_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pnum_head</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rback_num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>rback_num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>*=</operator> <name>sign</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>rname_end</name> <operator>=</operator> <name>name_end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<label><name>teardown</name>:</label>
<while>while <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>end_code</name> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_name</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name>start_code</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>rname_end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>rback_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>is_num</name></decl>, <decl><type ref="prev"/><name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>end_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>pnum_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>end_code</name> <operator>=</operator> <call><name>get_name_end_code_point</name><argument_list>(<argument><expr><name>start_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>rname_end</name> <operator>=</operator> <name>name_end</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pnum_head</name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ONIGERR_EMPTY_GROUP_NAME</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>end_code</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_EMPTY_GROUP_NAME</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_num</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pnum_head</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_IN_GROUP_NAME</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>end_code</name> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_IN_GROUP_NAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>end_code</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>=</operator> <call><name>onig_scan_unsigned_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pnum_head</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rback_num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>rback_num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>rback_num</name> <operator>*=</operator> <name>sign</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>rname_end</name> <operator>=</operator> <name>name_end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 


<function><type><specifier>static</specifier> <name>void</name></type>
<name>onig_syntax_warn</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>WARN_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_vsnprintf_with_pattern</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>WARN_BUFSIZE</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>,
<argument><expr><name><name>env</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>pattern_end</name></name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>UChar</name> <operator>*</operator><operator>)</operator><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_compile_warn</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>sourcefile</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call>(<modifier>*</modifier><name>onig_warn</name>)<argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator> <operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CC_ESC_WARN</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>UChar</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>onig_warn</name> <operator>==</operator> <name>onig_null_warn</name></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_WARN_CC_OP_NOT_ESCAPED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_BACKSLASH_ESCAPE_IN_CC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"character class has '%s' without escape"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CLOSE_BRACKET_WITHOUT_ESC_WARN</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>onig_warn</name> <operator>==</operator> <name>onig_null_warn</name></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_WARN_CC_OP_NOT_ESCAPED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"regular expression has '%s' without escape"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTEST</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CC_DUP_WARN</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name> <name>from</name></type> <name>ARG_UNUSED</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name> <name>to</name></type> <name>ARG_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>onig_warn</name> <operator>==</operator> <name>onig_null_warn</name> <operator>||</operator> <operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_WARN_CC_DUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>env</name><operator>-&gt;</operator><name>warnings_flag</name></name> <operator>&amp;</operator> <name>ONIG_SYN_WARN_CC_DUP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WARN_ALL_CC_DUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"character class has duplicated range: %04x-%04x"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>warnings_flag</name></name> <operator>|=</operator> <name>ONIG_SYN_WARN_CC_DUP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"character class has duplicated range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>UNKNOWN_ESC_WARN</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>onig_warn</name> <operator>==</operator> <name>onig_null_warn</name> <operator>||</operator> <operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Unknown escape \\%c is ignored"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UChar</name><modifier>*</modifier></type>
<name>find_str_position</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name><name>s</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>to</name></decl></parameter>,
<parameter><decl><type><name>UChar</name> <modifier>*</modifier><modifier>*</modifier></type><name>next</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>ONIGENC_MBC_TO_CODE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator> <name>q</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>ONIGENC_MBC_TO_CODE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>+=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>n</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL_UCHARP</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>str_exist_check_with_esc</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name><name>s</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>to</name></decl></parameter>,
<parameter><decl><type><name>OnigCodePoint</name></type> <name>bad</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>in_esc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>in_esc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>in_esc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in_esc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>ONIGENC_MBC_TO_CODE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator> <name>q</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>ONIGENC_MBC_TO_CODE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>+=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>ONIGENC_MBC_TO_CODE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>bad</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>x</name> <operator>==</operator> <call><name>MC_ESC</name><argument_list>(<argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>in_esc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_token_in_cc</name><parameter_list>(<parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syn</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_EOT</name></expr>;</expr_stmt>
<return>return <expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>escaped</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CC_CLOSE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CC_RANGE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ESC</name><argument_list>(<argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_BACKSLASH_ESCAPE_IN_CC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_AT_ESCAPE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>escaped</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_WORD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'W'</literal></expr>:</case>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_WORD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_DIGIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_DIGIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_SPACE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_SPACE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_H_XDIGIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_XDIGIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'H'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_H_XDIGIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_XDIGIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<case>case <expr><literal type="char">'P'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>PPEEK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_PROPERTY</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="char">'P'</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode Property \\%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_X_BRACE_HEX8</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_hexadecimal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_WIDE_CHAR_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>PPEEK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_XDIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TOO_LONG_WIDE_CHAR_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>prev</name> <operator>+</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CODE_POINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>num</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_X_HEX2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_hexadecimal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>prev</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_RAW_BYTE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_U_HEX4</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_hexadecimal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_SHORT_DIGITS</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>prev</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CODE_POINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_O_BRACE_OCTAL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_octal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_WIDE_CHAR_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>PPEEK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c2</name> <operator>&lt;</operator> <literal type="char">'8'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TOO_LONG_WIDE_CHAR_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>prev</name> <operator>+</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CODE_POINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>num</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'0'</literal></expr>:</case>
<case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_OCTAL3</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_octal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <literal type="number">0xff</literal> <operator>&lt;</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>prev</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_RAW_BYTE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>fetch_escaped_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>num</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>!=</operator> <name>c2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>c2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CODE_POINT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_POSIX_BRACKET</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name><name>send</name><index>[]</index></name> <init>= <expr><block>{ <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">':'</literal></expr>, <expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">']'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>backp</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>str_exist_check_with_esc</name><argument_list>(<argument><expr><name>send</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">']'</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_POSIX_BRACKET_OPEN</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<goto>goto <name>cc_in_cc</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<label><name>cc_in_cc</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_CCLASS_SET_OP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CC_CC_OPEN</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>CC_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_CCLASS_SET_OP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CC_AND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_named_backref_token</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syn</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>backs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>back_num</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>NULL_UCHARP</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_name_with_level</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_end</name></expr></argument>,
<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>back_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>exist_level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>exist_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>back_num</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>back_num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>back_num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>back_num</name> <operator>=</operator> <call><name>BACKREF_REL_TO_ABS</name><argument_list>(<argument><expr><name>back_num</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>back_num</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_STRICT_CHECK_BACKREF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>back_num</name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>||</operator>
<call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><index>[<expr><name>back_num</name></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_BACKREF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>by_name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>num</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>ref1</name></name> <operator>=</operator> <name>back_num</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>onig_name_to_group_numbers</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>,
<argument><expr><name>ONIGERR_UNDEFINED_NAME_REFERENCE</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_UNDEFINED_NAME_REFERENCE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_STRICT_CHECK_BACKREF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>||</operator>
<call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><index>[<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_BACKREF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>by_name</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_USE_LEFT_MOST_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>num</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>ref1</name></name> <operator>=</operator> <name><name>backs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>refs</name></name> <operator>=</operator> <name>backs</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_token</name><parameter_list>(<parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syn</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<label><name>start</name>:</label>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_EOT</name></expr>;</expr_stmt>
<return>return <expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_STRING</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>backp</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_MC_ESC_CODE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_AT_ESCAPE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>backp</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>escaped</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_OP_REPEAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>upper</name></name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt>
<goto>goto <name>greedy_check</name>;</goto>
<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_PLUS_ONE_INF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_OP_REPEAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>upper</name></name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt>
<goto>goto <name>greedy_check</name>;</goto>
<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_QMARK_ZERO_ONE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_OP_REPEAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>upper</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<label><name>greedy_check</name>:</label>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_QMARK_NON_GREEDY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>possessive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<label><name>possessive_check</name>:</label>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>TK_INTERVAL</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TK_INTERVAL</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>possessive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>greedy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>possessive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'{'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_BRACE_INTERVAL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_range_quantifier</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>greedy_check</name>;</goto></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>possessive_check</name>;</goto></block_content></block></if></if_stmt>

<goto>goto <name>greedy_check</name>;</goto>
</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'|'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_VBAR_ALT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ALT</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'('</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_LPAREN_SUBEXP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_SUBEXP_OPEN</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">')'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_LPAREN_SUBEXP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_SUBEXP_CLOSE</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_W_WORD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_WORD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'W'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_W_WORD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_WORD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_B_WORD_BOUND</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <name>ANCHOR_WORD_BOUND</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>ascii_range</name></name> <operator>=</operator> <call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator> <call><name>IS_WORD_BOUND_ALL_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'B'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_B_WORD_BOUND</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <name>ANCHOR_NOT_WORD_BOUND</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>ascii_range</name></name> <operator>=</operator> <call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator> <call><name>IS_WORD_BOUND_ALL_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_WORD_BEGIN_END</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <name>ANCHOR_WORD_BEGIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>ascii_range</name></name> <operator>=</operator> <call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <name>ANCHOR_WORD_END</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>ascii_range</name></name> <operator>=</operator> <call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_S_WHITE_SPACE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_SPACE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_S_WHITE_SPACE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_SPACE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_D_DIGIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_DIGIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_D_DIGIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_DIGIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_H_XDIGIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_XDIGIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'H'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_H_XDIGIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>=</operator> <name>ONIGENC_CTYPE_XDIGIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<label><name>begin_buf</name>:</label>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <name>ANCHOR_BEGIN_BUF</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <name>ANCHOR_SEMI_END_BUF</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'z'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<label><name>end_buf</name>:</label>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <name>ANCHOR_END_BUF</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'G'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <name>ANCHOR_BEGIN_POSITION</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'`'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<goto>goto <name>begin_buf</name>;</goto>
<break>break;</break>

<case>case <expr><literal type="char">'\''</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<goto>goto <name>end_buf</name>;</goto>
<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_X_BRACE_HEX8</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_hexadecimal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_WIDE_CHAR_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_XDIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>PPEEK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TOO_LONG_WIDE_CHAR_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>&gt;</operator> <name>prev</name> <operator>+</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CODE_POINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>num</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_X_HEX2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_hexadecimal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>prev</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_RAW_BYTE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_U_HEX4</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_hexadecimal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_SHORT_DIGITS</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>prev</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CODE_POINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_O_BRACE_OCTAL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_octal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_WIDE_CHAR_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name> <init>= <expr><name>PPEEK</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="char">'8'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TOO_LONG_WIDE_CHAR_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>&gt;</operator> <name>prev</name> <operator>+</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CODE_POINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>num</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case>
<case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>onig_scan_unsigned_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>num</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>num</name></expr></argument> &gt;</argument_list></name> <name>ONIG_MAX_BACKREF_NUM</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>skip_backref</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_DECIMAL_BACKREF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>num</name> <operator>&lt;=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>||</operator> <name>num</name> <operator>&lt;=</operator> <literal type="number">9</literal><operator>)</operator></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_STRICT_CHECK_BACKREF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>||</operator> <call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><index>[<expr><name>num</name></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_BACKREF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>num</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>ref1</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>by_name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>exist_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<label><name>skip_backref</name>:</label>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'8'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt> <expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<case>case <expr><literal type="char">'0'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ESC_OCTAL3</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_unsigned_octal_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="char">'0'</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr></then><else>:<expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <literal type="number">0xff</literal> <operator>&lt;</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_TOO_BIG_NUMBER</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>prev</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_RAW_BYTE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'k'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_K_NAMED_BACKREF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_named_backref_token</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"invalid back reference"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_G_BRACE_BACKREF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_named_backref_token</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_G_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>gnum</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>rel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>cnext</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cnext</name> <operator>=</operator> <name>PPEEK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cnext</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><call><name>get_name_end_code_point</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>cnext</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rel</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>gnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_name</name><argument_list>(<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gnum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CALL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name_end</name></name> <operator>=</operator> <name>name_end</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>gnum</name></name> <operator>=</operator> <name>gnum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"invalid subexp call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'Q'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_QUOTE_OPEN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<case>case <expr><literal type="char">'P'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR_PROPERTY</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="char">'P'</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode Property \\%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'R'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_LINEBREAK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'X'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_EXTENDED_GRAPHEME_CLUSTER</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'K'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_KEEP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>fetch_escaped_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>num</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>!=</operator> <name>c2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CODE_POINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>c2</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content> 
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>backp</name></name> <operator>+</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>backp</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>escaped</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_VARIABLE_META_CHARS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>!=</operator> <name>ONIG_INEFFECTIVE_META_CHAR</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_VARIABLE_META_CHARACTERS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ANYCHAR</name><argument_list>(<argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>any_char</name>;</goto></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ANYTIME</name><argument_list>(<argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>anytime</name>;</goto></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ZERO_OR_ONE_TIME</name><argument_list>(<argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>zero_or_one_time</name>;</goto></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ONE_OR_MORE_TIME</name><argument_list>(<argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>one_or_more_time</name>;</goto></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ANYCHAR_ANYTIME</name><argument_list>(<argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANYCHAR_ANYTIME</name></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_DOT_ANYCHAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_VARIABLE_META_CHARS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>any_char</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANYCHAR</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_ASTERISK_ZERO_INF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_VARIABLE_META_CHARS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>anytime</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_OP_REPEAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>upper</name></name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt>
<goto>goto <name>greedy_check</name>;</goto>
<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_PLUS_ONE_INF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_VARIABLE_META_CHARS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>one_or_more_time</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_OP_REPEAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>upper</name></name> <operator>=</operator> <name>REPEAT_INFINITE</name></expr>;</expr_stmt>
<goto>goto <name>greedy_check</name>;</goto>
<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_QMARK_ZERO_ONE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_VARIABLE_META_CHARS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>zero_or_one_time</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_OP_REPEAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>upper</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>greedy_check</name>;</goto>
<break>break;</break>

<case>case <expr><literal type="char">'{'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_BRACE_INTERVAL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_range_quantifier</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>greedy_check</name>;</goto></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>possessive_check</name>;</goto></block_content></block></if></if_stmt>

<goto>goto <name>greedy_check</name>;</goto>
</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'|'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_VBAR_ALT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ALT</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'('</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_GROUP_EFFECT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_IN_GROUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>MC_ESC</name><argument_list>(<argument><expr><name>syn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<goto>goto <name>start</name>;</goto>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PERL_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>PPEEK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'&amp;'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'R'</literal> <operator>||</operator> <call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>gnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'R'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_GROUP_NAME</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>name</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>numref</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>numref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_name</name><argument_list>(<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'('</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gnum</name></expr></argument>, <argument><expr><name>numref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CALL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name_end</name></name> <operator>=</operator> <name>name_end</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>gnum</name></name> <operator>=</operator> <name>gnum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>gnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>cnext</name></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>cnext</name> <operator>=</operator> <name>PPEEK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>cnext</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_name</name><argument_list>(<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'('</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gnum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CALL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name_end</name></name> <operator>=</operator> <name>name_end</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>gnum</name></name> <operator>=</operator> <name>gnum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_CAPITAL_P_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'P'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>gnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_named_backref_token</name><argument_list>(<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'('</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_name</name><argument_list>(<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'('</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gnum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CALL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name_end</name></name> <operator>=</operator> <name>name_end</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>gnum</name></name> <operator>=</operator> <name>gnum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_LPAREN_SUBEXP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_SUBEXP_OPEN</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">')'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_LPAREN_SUBEXP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_SUBEXP_CLOSE</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'^'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_LINE_ANCHOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_SINGLELINE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>ANCHOR_BEGIN_BUF</name></expr> </then><else>: <expr><name>ANCHOR_BEGIN_LINE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'$'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_LINE_ANCHOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_ANCHOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_SINGLELINE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>ANCHOR_SEMI_END_BUF</name></expr> </then><else>: <expr><name>ANCHOR_END_LINE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'['</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_OP</name><argument_list>(<argument><expr><name>syn</name></expr></argument>, <argument><expr><name>ONIG_SYN_OP_BRACKET_CC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CC_OPEN</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">']'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>src</name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>pattern</name></name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><call><name>CLOSE_BRACKET_WITHOUT_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'#'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_EXTEND</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_NEWLINE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<goto>goto <name>start</name>;</goto>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_EXTEND</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>start</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>

<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_VARIABLE_META_CHARS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>out</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_ctype_to_cc_by_range</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>ctype</name></type> <name>ARG_UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>not</name></decl></parameter>,
<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>,
<parameter><decl><type><name>OnigCodePoint</name></type> <name>sb_out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigCodePoint</name></type> <name><name>mbr</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>ONIGENC_CODE_RANGE_NUM</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>not</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <call><name>ONIGENC_CODE_RANGE_FROM</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>j</name> <operator>&lt;=</operator> <call><name>ONIGENC_CODE_RANGE_TO</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>sb_out</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <call><name>ONIGENC_CODE_RANGE_FROM</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
<argument><expr><call><name>ONIGENC_CODE_RANGE_TO</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<goto>goto <name>sb_end</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<label><name>sb_end</name>:</label>
<for>for <control>( <init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>,
<argument><expr><call><name>ONIGENC_CODE_RANGE_FROM</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ONIGENC_CODE_RANGE_TO</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>prev</name></expr>;</init>
<condition><expr><name>j</name> <operator>&lt;</operator> <call><name>ONIGENC_CODE_RANGE_FROM</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>sb_out</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>sb_end2</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>ONIGENC_CODE_RANGE_TO</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>prev</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>sb_out</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<label><name>sb_end2</name>:</label>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>sb_out</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>&lt;</operator> <call><name>ONIGENC_CODE_RANGE_FROM</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>,
<argument><expr><call><name>ONIGENC_CODE_RANGE_FROM</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>ONIGENC_CODE_RANGE_TO</name><argument_list>(<argument><expr><name>mbr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>&lt;</operator> <literal type="number">0x7fffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><literal type="number">0x7fffffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_ctype_to_cc</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ctype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>not</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ascii_range</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>maxcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>OnigCodePoint</name> <modifier>*</modifier></type><name>ranges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>sb_out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ONIGENC_GET_CTYPE_CODE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb_out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ascii_range</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CClassNode</name></type> <name>ccwork</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>initialize_cclass</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ccwork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc_by_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ccwork</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>not</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>sb_out</name></expr></argument>,
<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>not</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range_to_buf0</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ccwork</name><operator>.</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><name>ONIG_LAST_CODE_POINT</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>CClassNode</name></type> <name>ccascii</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>initialize_cclass</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ccascii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ccascii</name><operator>.</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x00</literal></expr></argument>, <argument><expr><literal type="number">0x7F</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bitset_set_range</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name><name>ccascii</name><operator>.</operator><name>bs</name></name></expr></argument>, <argument><expr><literal type="number">0x00</literal></expr></argument>, <argument><expr><literal type="number">0x7F</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>and_cclass</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ccwork</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ccascii</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>ccascii</name><operator>.</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>ccascii</name><operator>.</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>or_cclass</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ccwork</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>ccwork</name><operator>.</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>ccwork</name><operator>.</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc_by_range</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>not</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>sb_out</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ONIG_NO_SUPPORT_CONFIG</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>maxcode</name> <operator>=</operator> <ternary><condition><expr><name>ascii_range</name></expr> ?</condition><then> <expr><literal type="number">0x80</literal></expr> </then><else>: <expr><name>SINGLE_BYTE_SIZE</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>ctype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ONIGENC_CTYPE_ALPHA</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_BLANK</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_CNTRL</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_DIGIT</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_LOWER</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_PUNCT</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_SPACE</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_UPPER</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_XDIGIT</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_ASCII</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_ALNUM</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>not</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_CODE_CTYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>c</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ADD_ALL_MULTI_BYTE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_CTYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>c</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ONIGENC_CTYPE_GRAPH</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_PRINT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>not</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_CODE_CTYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>c</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call>
<operator>||</operator> <name>c</name> <operator>&gt;=</operator> <name>maxcode</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>ascii_range</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ADD_ALL_MULTI_BYTE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>maxcode</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_CTYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>c</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>ascii_range</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ADD_ALL_MULTI_BYTE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ONIGENC_CTYPE_WORD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>not</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>maxcode</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_WORD</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>ascii_range</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ADD_ALL_MULTI_BYTE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ONIGENC_CODE_TO_MBCLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> 
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator> <call><name>ONIGENC_IS_CODE_WORD</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>c</name> <operator>&gt;=</operator> <name>maxcode</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>ascii_range</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ADD_ALL_MULTI_BYTE_RANGE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_posix_bracket</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>asc_cc</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_BRACKET_CHECK_LIMIT_LENGTH</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_BRACKET_NAME_MIN_LEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PosixBracketEntryType</name></type> <name><name>PBS</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"alnum"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_ALNUM</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"alpha"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_ALPHA</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"blank"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_BLANK</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"cntrl"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_CNTRL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"digit"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_DIGIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"graph"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_GRAPH</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"lower"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_LOWER</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"print"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_PRINT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"punct"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_PUNCT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"space"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_SPACE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"upper"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_UPPER</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"xdigit"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_XDIGIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"ascii"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_ASCII</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>POSIX_BRACKET_ENTRY_INIT</name><argument_list>(<argument><expr><literal type="string">"word"</literal></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_WORD</name></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>PosixBracketEntryType</name> <modifier>*</modifier></type><name>pb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>not</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ascii_range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC_S</name></expr>;</expr_stmt>
<expr_stmt><expr><name>not</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>not</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>onigenc_strlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>POSIX_BRACKET_NAME_MIN_LEN</name> <operator>+</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>not_posix_bracket</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ascii_range</name> <operator>=</operator> <call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator> <call><name>IS_POSIX_BRACKET_ALL_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>pb</name> <operator>=</operator> <name>PBS</name></expr>;</init> <condition><expr><name>pb</name> <operator>&lt;</operator> <name>PBS</name> <operator>+</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>PBS</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pb</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>onigenc_with_ascii_strncmp</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name><name>pb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pb</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>onigenc_step</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name><name>pb</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>onigenc_with_ascii_strncmp</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">":]"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_POSIX_BRACKET_TYPE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>pb</name><operator>-&gt;</operator><name>ctype</name></name></expr></argument>, <argument><expr><name>not</name></expr></argument>, <argument><expr><name>ascii_range</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pb</name><operator>-&gt;</operator><name>ctype</name></name> <operator>!=</operator> <name>ONIGENC_CTYPE_WORD</name> <operator>&amp;&amp;</operator>
<name><name>pb</name><operator>-&gt;</operator><name>ctype</name></name> <operator>!=</operator> <name>ONIGENC_CTYPE_ASCII</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ascii_range</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><name><name>pb</name><operator>-&gt;</operator><name>ctype</name></name></expr></argument>, <argument><expr><name>not</name></expr></argument>, <argument><expr><name>ascii_range</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>PINC_S</name></expr>;</expr_stmt> <expr_stmt><expr><name>PINC_S</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<label><name>not_posix_bracket</name>:</label>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>=</operator> <name>PPEEK</name><operator>)</operator> <operator>!=</operator> <literal type="char">':'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC_S</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;</operator> <name>POSIX_BRACKET_CHECK_LIMIT_LENGTH</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>!</operator> <name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC_S</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_POSIX_BRACKET_TYPE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fetch_char_property_to_ctype</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name>PEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ONIGENC_PROPERTY_NAME_TO_CTYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_CHAR_PROPERTY_NAME</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cclass_case_fold</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>np</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>asc_cc</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_char_property</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>np</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>ctype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>fetch_char_property_to_ctype</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ctype</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_cclass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>NCCLASS_SET_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_IGNORECASE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>!=</operator> <name>ONIGENC_CTYPE_ASCII</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>cclass_case_fold</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<enum>enum <name>CCSTATE</name> <block>{
<decl><name>CCS_VALUE</name></decl>,
<decl><name>CCS_RANGE</name></decl>,
<decl><name>CCS_COMPLETE</name></decl>,
<decl><name>CCS_START</name></decl>
}</block>;</enum>

<enum>enum <name>CCVALTYPE</name> <block>{
<decl><name>CCV_SB</name></decl>,
<decl><name>CCV_CODE_POINT</name></decl>,
<decl><name>CCV_CLASS</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>next_state_class</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>asc_cc</name></decl></parameter>,
<parameter><decl><type><name>OnigCodePoint</name><modifier>*</modifier></type> <name>vs</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>CCVALTYPE</name></name><modifier>*</modifier></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>CCSTATE</name></name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>state</name> <operator>==</operator> <name>CCS_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>state</name> <operator>==</operator> <name>CCS_VALUE</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>type</name> <operator>!=</operator> <name>CCV_CLASS</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>type</name> <operator>==</operator> <name>CCV_SB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><operator>*</operator><name>vs</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT</name><argument_list>(<argument><expr><name><name>asc_cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><operator>*</operator><name>vs</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>type</name> <operator>==</operator> <name>CCV_CODE_POINT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>vs</name></expr></argument>, <argument><expr><operator>*</operator><name>vs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range0</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>asc_cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>vs</name></expr></argument>, <argument><expr><operator>*</operator><name>vs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>state</name> <operator>=</operator> <name>CCS_VALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>CCV_CLASS</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>next_state_val</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>asc_cc</name></decl></parameter>,
<parameter><decl><type><name>OnigCodePoint</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>to</name></decl></parameter>,
<parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>from_israw</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to_israw</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>CCVALTYPE</name></name></type> <name>intype</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>CCVALTYPE</name></name><modifier>*</modifier></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>CCSTATE</name></name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>state</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CCS_VALUE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>type</name> <operator>==</operator> <name>CCV_SB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><operator>*</operator><name>from</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT</name><argument_list>(<argument><expr><name><name>asc_cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><operator>*</operator><name>from</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>type</name> <operator>==</operator> <name>CCV_CODE_POINT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>from</name></expr></argument>, <argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range0</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>asc_cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>from</name></expr></argument>, <argument><expr><operator>*</operator><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CCS_RANGE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>intype</name> <operator>==</operator> <operator>*</operator><name>type</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>intype</name> <operator>==</operator> <name>CCV_SB</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>from</name> <operator>&gt;</operator> <literal type="number">0xff</literal> <operator>||</operator> <name>to</name> <operator>&gt;</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_CODE_POINT_VALUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>from</name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>ccs_range_end</name>;</goto></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bitset_set_range</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>from</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bitset_set_range</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name><name>asc_cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>from</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range0</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>asc_cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>from</name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>ccs_range_end</name>;</goto></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bitset_set_range</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>from</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><ternary><condition><expr><name>to</name> <operator>&lt;</operator> <literal type="number">0xff</literal></expr> ?</condition><then> <expr><name>to</name></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><operator>*</operator><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_set_range</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name><name>asc_cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>from</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><ternary><condition><expr><name>to</name> <operator>&lt;</operator> <literal type="number">0xff</literal></expr> ?</condition><then> <expr><name>to</name></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range0</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>asc_cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><operator>*</operator><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<label><name>ccs_range_end</name>:</label>
<expr_stmt><expr><operator>*</operator><name>state</name> <operator>=</operator> <name>CCS_COMPLETE</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CCS_COMPLETE</name></expr>:</case>
<case>case <expr><name>CCS_START</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>state</name> <operator>=</operator> <name>CCS_VALUE</name></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>from_israw</name> <operator>=</operator> <name>to_israw</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>intype</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>code_exist_check</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_escaped</name></decl></parameter>,
<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>in_esc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>in_esc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator> <name>PEND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ignore_escaped</name> <operator>&amp;&amp;</operator> <name>in_esc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in_esc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH_S</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <call><name>MC_ESC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>in_esc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_char_class</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>np</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>asc_np</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>neg</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>fetched</name></decl>, <decl><type ref="prev"/><name>and_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>v</name></decl>, <decl><type ref="prev"/><name>vs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>asc_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name> <modifier>*</modifier></type><name>cc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev_cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name> <modifier>*</modifier></type><name>asc_cc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>asc_prev_cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name></type> <name>work_cc</name></decl>, <decl><type ref="prev"/><name>asc_work_cc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>CCSTATE</name></name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>CCVALTYPE</name></name></type> <name>val_type</name></decl>, <decl><type ref="prev"/><name>in_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>val_israw</name></decl>, <decl><type ref="prev"/><name>in_israw</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <operator>*</operator><name>asc_np</name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>parse_depth</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>parse_depth</name></name> <operator>&gt;</operator> <name>ParseDepthLimit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_PARSE_DEPTH_LIMIT_OVER</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prev_cc</name> <operator>=</operator> <name>asc_prev_cc</name> <operator>=</operator> <operator>(</operator><name>CClassNode</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token_in_cc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_CHAR</name> <operator>&amp;&amp;</operator> <name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>==</operator> <literal type="char">'^'</literal> <operator>&amp;&amp;</operator> <name><name>tok</name><operator>-&gt;</operator><name>escaped</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token_in_cc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_CC_CLOSE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>code_exist_check</name><argument_list>(<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">']'</literal></expr></argument>,
<argument><expr><operator>*</operator><name>src</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>pattern_end</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_EMPTY_CHAR_CLASS</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>CC_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TK_CHAR</name></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <name>node</name> <operator>=</operator> <call><name>node_new_cclass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_IGNORECASE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>asc_np</name> <operator>=</operator> <name>asc_node</name> <operator>=</operator> <call><name>node_new_cclass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>asc_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>asc_cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><name>asc_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>asc_node</name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>asc_cc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>and_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>CCS_START</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>r</name> <operator>!=</operator> <name>TK_CC_CLOSE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fetched</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TK_CHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name> <operator>&gt;=</operator> <name>SINGLE_BYTE_SIZE</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>len</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBCLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in_type</name> <operator>=</operator> <name>CCV_CODE_POINT</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if>
<else>else <block>{<block_content>
<label><name>sb_char</name>:</label>
<expr_stmt><expr><name>in_type</name> <operator>=</operator> <name>CCV_SB</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_israw</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>val_entry2</name>;</goto>
<break>break;</break>

<case>case <expr><name>TK_RAW_BYTE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_SINGLEBYTE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>bufe</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>psave</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>base</name> <init>= <expr><name><name>tok</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ONIGENC_MBC_MAXLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token_in_cc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>TK_RAW_BYTE</name> <operator>||</operator> <name><name>tok</name><operator>-&gt;</operator><name>base</name></name> <operator>!=</operator> <name>base</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fetched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_TOO_SHORT_MULTI_BYTE_STRING</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_TOO_SHORT_MULTI_BYTE_STRING</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>psave</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fetch_token_in_cc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>
<expr_stmt><expr><name>fetched</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<goto>goto <name>raw_single</name>;</goto>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>ONIGENC_MBC_TO_CODE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in_type</name> <operator>=</operator> <name>CCV_CODE_POINT</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr>;</expr_stmt>
<label><name>raw_single</name>:</label>
<expr_stmt><expr><name>in_type</name> <operator>=</operator> <name>CCV_SB</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>in_israw</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>val_entry2</name>;</goto>
<break>break;</break>

<case>case <expr><name>TK_CODE_POINT</name></expr>:</case>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_israw</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<label><name>val_entry</name>:</label>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBCLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>in_type</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>CCV_SB</name></expr> </then><else>: <expr><name>CCV_CODE_POINT</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<label><name>val_entry2</name>:</label>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>next_state_val</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_israw</name></expr></argument>, <argument><expr><name>in_israw</name></expr></argument>, <argument><expr><name>in_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>TK_POSIX_BRACKET_OPEN</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_posix_bracket</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>CC_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>backp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_israw</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>val_entry</name>;</goto>
</block_content>}</block></if></if_stmt>
<goto>goto <name>next_class</name>;</goto>
<break>break;</break>

<case>case <expr><name>TK_CHAR_TYPE</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name></expr></argument>,
<argument><expr><call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name> <operator>!=</operator> <name>ONIGENC_CTYPE_WORD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name></expr></argument>,
<argument><expr><call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<label><name>next_class</name>:</label>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>next_state_class</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>TK_CHAR_PROPERTY</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ctype</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>fetch_char_property_to_ctype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ctype</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>!=</operator> <name>ONIGENC_CTYPE_ASCII</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>next_class</name>;</goto>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_CC_RANGE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>CCS_VALUE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token_in_cc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>fetched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_CC_CLOSE</name></expr>)</condition> <block>{<block_content> 
<label><name>range_end_val</name>:</label>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'-'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>in_israw</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>val_entry</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_CC_AND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CC_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>range_end_val</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>val_type</name> <operator>==</operator> <name>CCV_CLASS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>state</name> <operator>=</operator> <name>CCS_RANGE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>CCS_START</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_israw</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token_in_cc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>fetched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_CC_RANGE</name> <operator>||</operator> <name>and_start</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CC_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>val_entry</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>CCS_RANGE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CC_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>sb_char</name>;</goto> 
</block_content>}</block></if>
<else>else <block>{<block_content> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token_in_cc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>fetched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_CC_CLOSE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>range_end_val</name>;</goto></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_CC_AND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CC_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>range_end_val</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CC_ESC_WARN</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>range_end_val</name>;</goto> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>TK_CC_CC_OPEN</name></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>anode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>aasc_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>acc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_char_class</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aasc_node</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>acc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><name>anode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>or_cclass</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>acc</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>aasc_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>acc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><name>aasc_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>or_cclass</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><name>acc</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>anode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>aasc_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_CC_AND</name></expr>:</case> 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>CCS_VALUE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>next_state_val</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_israw</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>val_type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>val_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>and_start</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>CCS_START</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>prev_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>and_cclass</name><argument_list>(<argument><expr><name>prev_cc</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>and_cclass</name><argument_list>(<argument><expr><name>asc_prev_cc</name></expr></argument>, <argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>asc_cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>prev_cc</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>&amp;</operator><name>work_cc</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>asc_prev_cc</name> <operator>=</operator> <name>asc_cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>asc_cc</name> <operator>=</operator> <operator>&amp;</operator><name>asc_work_cc</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>initialize_cclass</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>initialize_cclass</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_EOT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_PREMATURE_END_OF_CHAR_CLASS</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_PARSER_BUG</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>fetched</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token_in_cc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>CCS_VALUE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>next_state_val</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_israw</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>val_type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>val_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>prev_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>and_cclass</name><argument_list>(<argument><expr><name>prev_cc</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>prev_cc</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>and_cclass</name><argument_list>(<argument><expr><name>asc_prev_cc</name></expr></argument>, <argument><expr><name>asc_cc</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>asc_cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>asc_cc</name> <operator>=</operator> <name>asc_prev_cc</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>neg</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NCCLASS_SET_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NCCLASS_SET_NOT</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>NCCLASS_CLEAR_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NCCLASS_CLEAR_NOT</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>is_empty</name></decl>;</decl_stmt>

<expr_stmt><expr><name>is_empty</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_empty</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_IS_EMPTY</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>is_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_empty</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_CODE</name></cpp:macro> <cpp:value>0x0a</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_NEWLINE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>NEWLINE_CODE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_CODE_TO_MBCLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>NEWLINE_CODE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT_CHKDUP</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>NEWLINE_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>NEWLINE_CODE</name></expr></argument>, <argument><expr><name>NEWLINE_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>parse_depth</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err</name>:</label>
<if_stmt><if>if <condition>(<expr><name>cc</name> <operator>!=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>asc_cc</name> <operator>!=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><operator>*</operator><name>asc_np</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>asc_cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>parse_subexp</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>term</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_enclose</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>np</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>term</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>target</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>work1</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>work2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>list_capture</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PFETCH_READY</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_GROUP_EFFECT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_IN_GROUP</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">':'</literal></expr>:</case> 
<label><name>group</name>:</label>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_subexp</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return> 
<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>onig_node_new_anchor</name><argument_list>(<argument><expr><name>ANCHOR_PREC_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'!'</literal></expr>:</case> 
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>onig_node_new_anchor</name><argument_list>(<argument><expr><name>ANCHOR_PREC_READ_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case> 
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_STOP_BACKTRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'~'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_TILDE_ABSENT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_ABSENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'\''</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>named_group1</name>;</goto>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_CAPITAL_P_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'P'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>named_group1</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>onig_node_new_anchor</name><argument_list>(<argument><expr><name>ANCHOR_LOOK_BEHIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>onig_node_new_anchor</name><argument_list>(<argument><expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'&lt;'</literal></expr>;</expr_stmt>

<label><name>named_group1</name>:</label>
<expr_stmt><expr><name>list_capture</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_CAPTURE_HISTORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>named_group2</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_name</name><argument_list>(<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_env_add_mem_entry</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>num</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>list_capture</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>BIT_STATUS_BITS_NUM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>name_add</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_enclose_memory</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>list_capture</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BIT_STATUS_ON_AT_SIMPLE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>capture_history</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_named</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><else>else <block>{<block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_CAPTURE_HISTORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'@'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>list_capture</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>named_group2</name>;</goto> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_enclose_memory</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_env_add_mem_entry</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>num</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>BIT_STATUS_BITS_NUM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIT_STATUS_ON_AT_SIMPLE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>capture_history</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<case>case <expr><literal type="char">'('</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_QMARK_LPAREN_CONDITION</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_DIGIT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>PUNFETCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_name</name><argument_list>(<argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'('</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (num &lt; 0) {
num = BACKREF_REL_TO_ABS(num, env);
if (num &lt;= 0)
return ONIGERR_INVALID_BACKREF;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_STRICT_CHECK_BACKREF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>||</operator>
<call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><index>[<expr><name>num</name></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_named_backref_token</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PPEEK_IS</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>PINC</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_USE_LEFT_MOST_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>ref1</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>




<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>num</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>refs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>ref1</name></name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_CONDITION_PATTERN</name></expr>;</return></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_CONDITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>state</name> <operator>|=</operator> <name>NST_NAME_REF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
case '|': 
if (IS_SYNTAX_OP2(env-&gt;syntax, ONIG_SYN_OP2_QMARK_VBAR_BRANCH_RESET)) {

}
else
return ONIGERR_UNDEFINED_GROUP_OPTION;
break;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'^'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PEND</name> <operator>&amp;&amp;</operator> <call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_PERL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_ASCII_RANGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_IGNORECASE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_SINGLELINE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_MULTILINE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_EXTEND</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
else if (!PEND &amp;&amp; IS_SYNTAX_OP2(env-&gt;syntax, ONIG_SYN_OP2_OPTION_RUBY)) {

ONOFF(option, ONIG_OPTION_ASCII_RANGE, 0);
ONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 0);
ONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 0);
ONOFF(option, ONIG_OPTION_IGNORECASE, 1);
ONOFF(option, ONIG_OPTION_MULTILINE, 1);
ONOFF(option, ONIG_OPTION_EXTEND, 1);
PFETCH(c);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <block>{<block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_POSIXLINE_OPTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><literal type="char">'-'</literal></expr>:</case> <case>case <expr><literal type="char">'i'</literal></expr>:</case> <case>case <expr><literal type="char">'m'</literal></expr>:</case> <case>case <expr><literal type="char">'s'</literal></expr>:</case> <case>case <expr><literal type="char">'x'</literal></expr>:</case>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> <case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'l'</literal></expr>:</case> <case>case <expr><literal type="char">'u'</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">':'</literal></expr>:</case>
<case>case <expr><literal type="char">')'</literal></expr>:</case>
<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> <expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case> <expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_EXTEND</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'i'</literal></expr>:</case> <expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_IGNORECASE</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_PERL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_MULTILINE</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_PERL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_SINGLELINE</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>neg</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_RUBY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_MULTILINE</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_POSIXLINE_OPTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_MULTILINE</name><operator>|</operator><name>ONIG_OPTION_SINGLELINE</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_PERL</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_RUBY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>neg</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_ASCII_RANGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_POSIX_BRACKET_ALL_RANGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_WORD_BOUND_ALL_RANGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_PERL</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_RUBY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>neg</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_ASCII_RANGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_POSIX_BRACKET_ALL_RANGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_WORD_BOUND_ALL_RANGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_PERL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>neg</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_ASCII_RANGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_RUBY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>neg</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_ASCII_RANGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_POSIX_BRACKET_ALL_RANGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_WORD_BOUND_ALL_RANGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_OP2</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_OP2_OPTION_PERL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>neg</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_ASCII_RANGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_option</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return> 
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>prev</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_subexp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_option</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>PEND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_END_PATTERN_IN_GROUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PFETCH</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_OPTION</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIG_IS_OPTION_ON</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><name>ONIG_OPTION_DONT_CAPTURE_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>group</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_enclose_memory</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>scan_env_add_mem_entry</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>num</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_subexp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_ANCHOR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>ENCLOSE_MEMORY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>scan_env_set_mem_node</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name></expr></argument>, <argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>ENCLOSE_CONDITION</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NT_ALT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>work1</name> <operator>=</operator> <call><name>node_new_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>work1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>work2</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>work1</name></expr></argument>, <argument><expr><name>NULL_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>work2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>work1</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>work2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>work1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>work1</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err</name>:</label>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>work1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>work2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name><name>PopularQStr</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"?"</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"??"</literal></expr>, <expr><literal type="string">"*?"</literal></expr>, <expr><literal type="string">"+?"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name><name>ReduceQStr</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"*?"</literal></expr>, <expr><literal type="string">"??"</literal></expr>, <expr><literal type="string">"+ and ??"</literal></expr>, <expr><literal type="string">"+? and ?"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_quantifier</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>qnode</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>qn</name> <operator>=</operator> <call><name>NQTFR</name><argument_list>(<argument><expr><name>qnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_STR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>group</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>str_node_can_be_split</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>n</name> <init>= <expr><call><name>str_node_split_last_char</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content> 

<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qnt</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nestq_num</name> <init>= <expr><call><name>popular_quantifier_num</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>targetq_num</name> <init>= <expr><call><name>popular_quantifier_num</name><argument_list>(<argument><expr><name>qnt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>nestq_num</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>targetq_num</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>ReduceTypeTable</name><index>[<expr><name>targetq_num</name></expr>]</index><index>[<expr><name>nestq_num</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RQ_ASIS</name></expr>:</case>
<break>break;</break>

<case>case <expr><name>RQ_DEL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>onig_warn</name> <operator>!=</operator> <name>onig_null_warn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"regular expression has redundant nested repeat operator '%s'"</literal></expr></argument>,
<argument><expr><name><name>PopularQStr</name><index>[<expr><name>targetq_num</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>warn_exit</name>;</goto>
<break>break;</break>

<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>onig_warn</name> <operator>!=</operator> <name>onig_null_warn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_syntax_warn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"nested repeat operator '%s' and '%s' was replaced with '%s' in regular expression"</literal></expr></argument>,
<argument><expr><name><name>PopularQStr</name><index>[<expr><name>targetq_num</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>PopularQStr</name><index>[<expr><name>nestq_num</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>ReduceQStr</name><index>[<expr><name><name>ReduceTypeTable</name><index>[<expr><name>targetq_num</name></expr>]</index><index>[<expr><name>nestq_num</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>warn_exit</name>;</goto>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<label><name>warn_exit</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>targetq_num</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nestq_num</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_reduce_nested_quantifier</name><argument_list>(<argument><expr><name>qnode</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>q_exit</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>targetq_num</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>targetq_num</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
<label><name>q_exit</name>:</label>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>clear_not_flag_cclass</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BBuf</name> <modifier>*</modifier></type><name>tbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitset_invert</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_SINGLEBYTE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>not_code_range_buf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bbuf_free</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name> <operator>=</operator> <name>tbuf</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NCCLASS_CLEAR_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>asc_cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>alt_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>ptail</name></decl>;</decl_stmt>
}</block></struct></type> <name>IApplyCaseFoldArg</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>i_apply_case_fold</name><parameter_list>(<parameter><decl><type><name>OnigCodePoint</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name><name>to</name><index>[]</index></name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>to_len</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>IApplyCaseFoldArg</name><modifier>*</modifier></type> <name>iarg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>asc_cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitSetRef</name></type> <name>bs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>add_flag</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>iarg</name> <operator>=</operator> <operator>(</operator><name>IApplyCaseFoldArg</name><operator>*</operator> <operator>)</operator><name>arg</name></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <name><name>iarg</name><operator>-&gt;</operator><name>env</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <name><name>iarg</name><operator>-&gt;</operator><name>cc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>asc_cc</name> <operator>=</operator> <name><name>iarg</name><operator>-&gt;</operator><name>asc_cc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bs</name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>add_flag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ONIGENC_IS_ASCII_CODE</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ONIGENC_IS_ASCII_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>to</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>add_flag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>add_flag</name> <operator>=</operator> <call><name>onig_is_code_in_cc</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>asc_cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>add_flag</name> <operator>=</operator> <operator>!</operator><name>add_flag</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>to_len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>is_in</name> <init>= <expr><call><name>onig_is_code_in_cc</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_in</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>is_in</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>add_flag</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>to</name> <operator>&gt;=</operator> <name>SINGLE_BYTE_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range0</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>to</name></expr></argument>, <argument><expr><operator>*</operator><name>to</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT</name><argument_list>(<argument><expr><name>bs</name></expr></argument>, <argument><expr><operator>*</operator><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name>is_in</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>add_flag</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>to</name> <operator>&gt;=</operator> <name>SINGLE_BYTE_SIZE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clear_not_flag_cclass</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range0</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>to</name></expr></argument>, <argument><expr><operator>*</operator><name>to</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BITSET_CLEAR_BIT</name><argument_list>(<argument><expr><name>bs</name></expr></argument>, <argument><expr><operator>*</operator><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT</name><argument_list>(<argument><expr><name>bs</name></expr></argument>, <argument><expr><operator>*</operator><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>snode</name> <init>= <expr><name>NULL_NODE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>onig_is_code_in_cc</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>to</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>snode</name> <operator>=</operator> <call><name>onig_node_new_str</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>NSTRING_SET_AMBIG</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_node_str_cat</name><argument_list>(<argument><expr><name>snode</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>iarg</name><operator>-&gt;</operator><name>ptail</name></name><operator>)</operator> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>snode</name></expr></argument>, <argument><expr><name>NULL_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>iarg</name><operator>-&gt;</operator><name>ptail</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iarg</name><operator>-&gt;</operator><name>ptail</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>NCDR</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name><name>iarg</name><operator>-&gt;</operator><name>ptail</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cclass_case_fold</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>np</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>asc_cc</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IApplyCaseFoldArg</name></type> <name>iarg</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iarg</name><operator>.</operator><name>env</name></name> <operator>=</operator> <name>env</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iarg</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iarg</name><operator>.</operator><name>asc_cc</name></name> <operator>=</operator> <name>asc_cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iarg</name><operator>.</operator><name>alt_root</name></name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iarg</name><operator>.</operator><name>ptail</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>iarg</name><operator>.</operator><name>alt_root</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ONIGENC_APPLY_ALL_CASE_FOLD</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr></argument>,
<argument><expr><name>i_apply_case_fold</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name><name>iarg</name><operator>.</operator><name>alt_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>iarg</name><operator>.</operator><name>alt_root</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>work</name> <init>= <expr><call><name>onig_node_new_alt</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>, <argument><expr><name><name>iarg</name><operator>.</operator><name>alt_root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name><name>iarg</name><operator>.</operator><name>alt_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <name>work</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>node_linebreak</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>np</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>left</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>right</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>target1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>target2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num1</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><name>num1</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><literal type="number">0x0D</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>num1</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num2</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><literal type="number">0x0A</literal></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>num1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>num2</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>node_new_str_raw</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>num1</name> <operator>+</operator> <name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>node_new_cclass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x0A</literal></expr></argument>, <argument><expr><literal type="number">0x0D</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bitset_set_range</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><literal type="number">0x0A</literal></expr></argument>, <argument><expr><literal type="number">0x0D</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_UNICODE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x85</literal></expr></argument>, <argument><expr><literal type="number">0x85</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x2028</literal></expr></argument>, <argument><expr><literal type="number">0x2029</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>target1</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>NULL_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>target1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>right</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>target2</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>target1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>target2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>target1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_STOP_BACKTRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>target2</name></expr>;</expr_stmt>
<return>return <expr><name>ONIG_NORMAL</name></expr>;</return>

<label><name>err</name>:</label>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>target1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>target2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>propname2ctype</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>propname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name</name> <init>= <expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>propname</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name_end</name> <init>= <expr><name>name</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctype</name> <init>= <expr><call><name><name>env</name><operator>-&gt;</operator><name>enc</name><operator>-&gt;</operator><name>property_name_to_ctype</name></name><argument_list>(<argument><expr><name>ONIG_ENCODING_ASCII</name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ctype</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_property_to_cc</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>propname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>not</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ctype</name> <init>= <expr><call><name>propname2ctype</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ctype</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>not</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>create_property_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>np</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>propname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_cclass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_property_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>quantify_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>np</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>upper</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>tmp</name> <init>= <expr><call><name>node_new_quantifier</name><argument_list>(<argument><expr><name>lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <operator>*</operator><name>np</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>quantify_property_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>np</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>propname</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>repetitions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lower</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>upper</name> <init>= <expr><name>REPEAT_INFINITE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>create_property_node</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>repetitions</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> <expr_stmt><expr><name>upper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'+'</literal></expr>:</case> <expr_stmt><expr><name>lower</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case> <break>break;</break>
<case>case <expr><literal type="char">'2'</literal></expr>:</case> <expr_stmt><expr><name>lower</name> <operator>=</operator> <name>upper</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
<default>default :</default> <return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><call><name>quantify_node</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>create_node_from_array</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>np</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>node_array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>tmp</name> <init>= <expr><name>NULL_NODE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>node_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL_NODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <ternary><condition><expr><name>kind</name><operator>==</operator><name>LIST</name></expr> ?</condition><then> <expr><call><name>node_new_list</name><argument_list>(<argument><expr><name><name>node_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name><name>node_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name><name>node_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node_array</name><index>[<expr><name>i</name><operator>--</operator></expr>]</index></name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>node_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>np</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_ERR</name><parameter_list>(<parameter><type><name>call</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r=(call);if(r!=0)goto err</cpp:value></cpp:define>






















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_COMMON_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>node_extended_grapheme_cluster</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>np</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>np1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>top_alt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>any_target_position</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>option</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name><name>node_common</name><index>[<expr><name>NODE_COMMON_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>alts</name> <init>= <expr><name>node_common</name><operator>+</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>NODE_COMMON_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>node_common</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt></block_content></block></for>



<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><literal type="number">0x0D</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num1</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><literal type="number">0x0A</literal></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>num1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>alts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>node_new_str_raw</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>num1</name> <operator>+</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>alts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_UNICODE_PROPERTIES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_UNICODE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>propname2ctype</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=Extend"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>







<expr_stmt><expr><name><name>alts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>node_new_cclass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>alts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><name><name>alts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_property_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=Control"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x000A</literal></expr></argument>, <argument><expr><literal type="number">0x000A</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x000D</literal></expr></argument>, <argument><expr><literal type="number">0x000D</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>BITSET_SET_BIT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BITSET_SET_BIT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><literal type="number">0x0d</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name> <init>= <expr><name>alts</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> 


<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>list</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=Prepend"</literal></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>core_alts</name> <init>= <expr><name>list</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt> 









<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>H_list</name> <init>= <expr><name>core_alts</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>H_list</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=L"</literal></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>H_alt2</name> <init>= <expr><name>H_list</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>H_alt2</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=V"</literal></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>H_list2</name> <init>= <expr><name>H_alt2</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_property_node</name><argument_list>(<argument><expr><name>H_list2</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=LV"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>H_list2</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=V"</literal></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_node_from_array</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>H_alt2</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>H_list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_property_node</name><argument_list>(<argument><expr><name>H_alt2</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=LVT"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_node_from_array</name><argument_list>(<argument><expr><name>ALT</name></expr></argument>, <argument><expr><name>H_list</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>H_alt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>H_list</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=T"</literal></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_node_from_array</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>core_alts</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>H_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>core_alts</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=L"</literal></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>core_alts</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=T"</literal></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>core_alts</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Regional_Indicator"</literal></expr></argument>, <argument><expr><literal type="char">'2'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>XP_list</name> <init>= <expr><name>core_alts</name> <operator>+</operator> <literal type="number">5</literal></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_property_node</name><argument_list>(<argument><expr><name>XP_list</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Extended_Pictographic"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>Ex_list</name> <init>= <expr><name>XP_list</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_property_node</name><argument_list>(<argument><expr><name>Ex_list</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=Extend"</literal></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><literal type="number">0x200D</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Ex_list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>node_new_str_raw</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>Ex_list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_property_node</name><argument_list>(<argument><expr><name>Ex_list</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Extended_Pictographic"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_node_from_array</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>XP_list</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>Ex_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_node</name><argument_list>(<argument><expr><name>XP_list</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>REPEAT_INFINITE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_node_from_array</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>core_alts</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>XP_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><name><name>core_alts</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>node_new_cclass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>core_alts</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><name><name>core_alts</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>BBuf</name> <modifier>*</modifier></type><name>inverted_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>dup_not_warned</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>warnings_flag</name></name> <operator>|</operator> <operator>~</operator><name>ONIG_SYN_WARN_CC_DUP</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>warnings_flag</name></name> <operator>|=</operator> <name>ONIG_SYN_WARN_CC_DUP</name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_property_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=Control"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x000A</literal></expr></argument>, <argument><expr><literal type="number">0x000A</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x000D</literal></expr></argument>, <argument><expr><literal type="number">0x000D</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>not_code_range_buf</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inverted_buf</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name> <operator>=</operator> <name>inverted_buf</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>warnings_flag</name></name> <operator>&amp;=</operator> <name>dup_not_warned</name></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_property_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=Control"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BITSET_CLEAR_BIT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BITSET_CLEAR_BIT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><literal type="number">0x0d</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_node_from_array</name><argument_list>(<argument><expr><name>ALT</name></expr></argument>, <argument><expr><name>list</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>core_alts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_property_node</name><argument_list>(<argument><expr><name>list</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=Extend"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><name><name>list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_property_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="string">"Grapheme_Cluster_Break=SpacingMark"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>add_code_range</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">0x200D</literal></expr></argument>, <argument><expr><literal type="number">0x200D</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>quantify_node</name><argument_list>(<argument><expr><name>list</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>REPEAT_INFINITE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_node_from_array</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>alts</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><name>any_target_position</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<block>{<block_content>
<expr_stmt><expr><name>any_target_position</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<expr_stmt><expr><name>np1</name> <operator>=</operator> <call><name>node_new_anychar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>np1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_MULTILINE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>node_new_option</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>np1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alts</name><index>[<expr><name>any_target_position</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>np1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_ERR</name><argument_list>(<argument><expr><call><name>create_node_from_array</name><argument_list>(<argument><expr><name>ALT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>top_alt</name></expr></argument>, <argument><expr><name>alts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_STOP_BACKTRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>top_alt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>np1</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_UNICODE_PROPERTIES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_UNICODE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>option</name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ONOFF</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIG_OPTION_IGNORECASE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_option</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>np1</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <name>np1</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ONIG_NORMAL</name></expr>;</return>

<label><name>err</name>:</label>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>np1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>NODE_COMMON_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name><name>node_common</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>r</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ONIGERR_MEMORY</name></expr> </then><else>: <expr><name>r</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R_ERR</name></cpp:undef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>countbits</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <operator>(</operator><name>bits</name> <operator>&amp;</operator> <literal type="number">0x55555555</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x55555555</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <operator>(</operator><name>bits</name> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <operator>(</operator><name>bits</name> <operator>&amp;</operator> <literal type="number">0x0f0f0f0f</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0f0f0f0f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <operator>(</operator><name>bits</name> <operator>&amp;</operator> <literal type="number">0x00ff00ff</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00ff00ff</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>bits</name> <operator>&amp;</operator> <literal type="number">0x0000ffff</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0000ffff</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_onechar_cclass</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name><modifier>*</modifier></type> <name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>OnigCodePoint</name></type> <name>not_found</name> <init>= <expr><name>ONIG_LAST_CODE_POINT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>c</name> <init>= <expr><name>not_found</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BBuf</name> <modifier>*</modifier></type><name>bbuf</name> <init>= <expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><operator>(</operator><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>c</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>BITSET_AT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>not_found</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BITSET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Bits</name></type> <name>b1</name> <init>= <expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>b1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>b1</name> <operator>&amp;</operator> <operator>(</operator><name>b1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>==</operator> <name>not_found</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>BITS_IN_ROOM</name> <operator>*</operator> <name>i</name> <operator>+</operator> <call><name>countbits</name><argument_list>(<argument><expr><name>b1</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>not_found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>code</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_exp</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>np</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>term</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>group</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>qn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>targetp</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <operator>(</operator>enum <name>TokenSyms</name> <operator>)</operator><name>term</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end_of_token</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TK_ALT</name></expr>:</case>
<case>case <expr><name>TK_EOT</name></expr>:</case>
<label><name>end_of_token</name>:</label>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
<break>break;</break>

<case>case <expr><name>TK_SUBEXP_OPEN</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_enclose</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>TK_SUBEXP_CLOSE</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>group</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>prev</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_subexp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
<return>return <expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>TK_SUBEXP_CLOSE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_UNMATCHED_CLOSE_PARENTHESIS</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>escaped</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>tk_raw_byte</name>;</goto></block_content></block></if>
<else>else<block type="pseudo"><block_content> <goto>goto <name>tk_byte</name>;</goto></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>TK_LINEBREAK</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>node_linebreak</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>TK_EXTENDED_GRAPHEME_CLUSTER</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>node_extended_grapheme_cluster</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>TK_KEEP</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>onig_node_new_anchor</name><argument_list>(<argument><expr><name>ANCHOR_KEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>TK_STRING</name></expr>:</case>
<label><name>tk_byte</name>:</label>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_str</name><argument_list>(<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>backp</name></name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>string_loop</name>:</label>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_STRING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_node_str_cat</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>backp</name></name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NUMBERED_CHAR_IS_NOT_CASE_AMBIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_CODE_POINT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>node_str_cat_codepoint</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <block>{<block_content>
<break>break;</break>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>

<label><name>string_end</name>:</label>
<expr_stmt><expr><name>targetp</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
<goto>goto <name>repeat</name>;</goto>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_RAW_BYTE</name></expr>:</case>
<label><name>tk_raw_byte</name>:</label>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_str_raw_char</name><argument_list>(<argument><expr><operator>(</operator><name>UChar</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <call><name>enclen</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTRING_CLEAR_RAW</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>string_end</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>TK_RAW_BYTE</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PAD_TO_SHORT_BYTE_CHAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>rem</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rem</name> <operator>=</operator> <call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name> <operator>)</operator><call><name>node_str_head_pad</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rem</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name> <operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>rem</name> <operator>==</operator> <call><name>enclen</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NSTRING_CLEAR_RAW</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>string_end</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>ONIGERR_TOO_SHORT_MULTI_BYTE_STRING</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>node_str_cat_char</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name> <operator>)</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_CODE_POINT</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>node_str_cat_codepoint</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NUMBERED_CHAR_IS_NOT_CASE_AMBIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>NSTRING_SET_RAW</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<goto>goto <name>string_loop</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_QUOTE_OPEN</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name><name>end_op</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>qstart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>qend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextp</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>end_op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><call><name>MC_ESC</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>end_op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><literal type="char">'E'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>qstart</name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><name>qend</name> <operator>=</operator> <call><name>find_str_position</name><argument_list>(<argument><expr><name>end_op</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>qstart</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextp</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>qend</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>qend</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_str</name><argument_list>(<argument><expr><name>qstart</name></expr></argument>, <argument><expr><name>qend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>src</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_CHAR_TYPE</name></expr>:</case>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ONIGENC_CTYPE_WORD</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_ctype</name><argument_list>(<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name></expr></argument>,
<argument><expr><call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ONIGENC_CTYPE_SPACE</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_DIGIT</name></expr>:</case>
<case>case <expr><name>ONIGENC_CTYPE_XDIGIT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_cclass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_ctype_to_cc</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>ctype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><call><name>IS_ASCII_RANGE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>prop</name><operator>.</operator><name>not</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>NCCLASS_SET_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_CHAR_PROPERTY</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_char_property</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>TK_CC_OPEN</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>asc_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_char_class</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asc_node</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>asc_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>NCCLASS</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_onechar_cclass</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>asc_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>node_str_cat_codepoint</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>string_loop</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_IGNORECASE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>cclass_case_fold</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>asc_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>asc_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>asc_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>TK_ANYCHAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_anychar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>TK_ANYCHAR_ANYTIME</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_anychar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>qn</name> <operator>=</operator> <call><name>node_new_quantifier</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>REPEAT_INFINITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <operator>*</operator><name>np</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <name>qn</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>TK_BACKREF</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_backref</name><argument_list>(<argument><expr><name>len</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>refs</name></name></expr> </then><else>: <expr><operator>&amp;</operator><operator>(</operator><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>ref1</name></name><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>by_name</name></name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>exist_level</name></name></expr></argument>,
<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name><operator>.</operator><name>level</name></name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>TK_CALL</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>gnum</name> <init>= <expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>gnum</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>gnum</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>rel</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>gnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>gnum</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>gnum</name> <operator>=</operator> <call><name>BACKREF_REL_TO_ABS</name><argument_list>(<argument><expr><name>gnum</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>gnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_call</name><argument_list>(<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>call</name><operator>.</operator><name>name_end</name></name></expr></argument>, <argument><expr><name>gnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_call</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>TK_ANCHOR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>onig_node_new_anchor</name><argument_list>(<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><operator>*</operator><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>anchor</name><operator>.</operator><name>ascii_range</name></name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>TK_OP_REPEAT</name></expr>:</case>
<case>case <expr><name>TK_INTERVAL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>np</name> <operator>=</operator> <call><name>node_new_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<goto>goto <name>tk_byte</name>;</goto>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>

<block>{<block_content>
<expr_stmt><expr><name>targetp</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>

<label><name>re_entry</name>:</label>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<label><name>repeat</name>:</label>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_OP_REPEAT</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>TK_INTERVAL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_invalid_quantifier_target</name><argument_list>(<argument><expr><operator>*</operator><name>targetp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qn</name> <operator>=</operator> <call><name>node_new_quantifier</name><argument_list>(<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>lower</name></name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>upper</name></name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>r</name> <operator>==</operator> <name>TK_INTERVAL</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>greedy</name> <operator>=</operator> <name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>greedy</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>set_quantifier</name><argument_list>(<argument><expr><name>qn</name></expr></argument>, <argument><expr><operator>*</operator><name>targetp</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>repeat</name><operator>.</operator><name>possessive</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>en</name></decl>;</decl_stmt>
<expr_stmt><expr><name>en</name> <operator>=</operator> <call><name>node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_STOP_BACKTRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>qn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>qn</name> <operator>=</operator> <name>en</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>targetp</name> <operator>=</operator> <name>qn</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>targetp</name> <operator>=</operator> <call><name>node_new_list</name><argument_list>(<argument><expr><operator>*</operator><name>targetp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>targetp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><operator>*</operator><name>targetp</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>node_new_list</name><argument_list>(<argument><expr><name>qn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>targetp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>NCAR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>re_entry</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_branch</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>term</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>headp</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_EOT</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>term</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>TK_ALT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <call><name>node_new_list</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>headp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>NCDR</name><argument_list>(<argument><expr><operator>*</operator><name>top</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name>r</name> <operator>!=</operator> <name>TK_EOT</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>term</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>TK_ALT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_LIST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>headp</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>headp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>headp</name> <operator>=</operator> <call><name>node_new_list</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>headp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>NCDR</name><argument_list>(<argument><expr><operator>*</operator><name>headp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_subexp</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>OnigToken</name><modifier>*</modifier></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>term</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>headp</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>parse_depth</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>parse_depth</name></name> <operator>&gt;</operator> <name>ParseDepthLimit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_PARSE_DEPTH_LIMIT_OVER</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_branch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>term</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_ALT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>headp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>NCDR</name><argument_list>(<argument><expr><operator>*</operator><name>top</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name>r</name> <operator>==</operator> <name>TK_ALT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_branch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>headp</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>headp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>NCDR</name><argument_list>(<argument><expr><operator>*</operator><name>headp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>tok</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <operator>(</operator>enum <name>TokenSyms</name> <operator>)</operator><name>term</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
<if_stmt><if>if <condition>(<expr><name>term</name> <operator>==</operator> <name>TK_SUBEXP_CLOSE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>parse_depth</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_regexp</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigToken</name></type> <name>tok</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fetch_token</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_subexp</name><argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tok</name></expr></argument>, <argument><expr><name>TK_EOT</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>num_call</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>np</name></decl>;</decl_stmt>
<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>node_new_enclose_memory</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <operator>*</operator><name>top</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>scan_env_set_mem_node</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_parse_make_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>names_clear</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>scan_env_clear</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>case_fold_flag</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>syntax</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>pattern</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>pattern_end</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>root</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>pattern</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_regexp</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>end</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>onig_scan_env_set_error_string</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>ecode</name></type> <name>ARG_UNUSED</name></decl></parameter>,
<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>arg_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>error_end</name></name> <operator>=</operator> <name>arg_end</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
