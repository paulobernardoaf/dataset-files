<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\eval.c">












<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PRCTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/prctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval_intern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/inits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/mjit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iseq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mjit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes_helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<macro><name>NORETURN</name><argument_list>(<argument>void rb_raise_jump(VALUE, VALUE)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function_decl><type><name>void</name></type> <name>rb_ec_clear_current_thread_trace_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rb_ec_clear_all_trace_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rb_ec_cleanup</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>ex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rb_ec_exec_node</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eLocalJumpError</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eSysStackError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ruby_static_id_signo</name></decl>, <decl><type ref="prev"/><name>ruby_static_id_status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>ID</name></type> <name>ruby_static_id_cause</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_cause</name></cpp:macro> <cpp:value>ruby_static_id_cause</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>exception_error</name></cpp:macro> <cpp:value>GET_VM()-&gt;special_exceptions[ruby_error_reenter]</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval_error.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval_jump.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_OR_MODULE_P</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!SPECIAL_CONST_P(obj) &amp;&amp; (BUILTIN_TYPE(obj) == T_CLASS || BUILTIN_TYPE(obj) == T_MODULE))</cpp:value></cpp:define>








<function><type><name>int</name></type>
<name>ruby_setup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_init_stack</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PR_SET_THP_DISABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prctl</name><argument_list>(<argument><expr><name>PR_SET_THP_DISABLE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Init_BareVM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Init_heap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_vm_encoded_insn_data_table_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Init_vm_objects</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_call_inits</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ruby_prog_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>running</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>ruby_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>state</name> <init>= <expr><call><name>ruby_setup</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error_print</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>











<function><type><name>void</name> <modifier>*</modifier></type>
<name>ruby_options</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>iseq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ruby_init_stack</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SAVE_ROOT_JMPBUF</name><argument_list>(<argument><expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>iseq</name> <operator>=</operator> <call><name>ruby_process_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_ec_clear_current_thread_trace_func</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>error_handle</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iseq</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>INT2FIX</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>iseq</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_ec_teardown</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_vm_trap_exit</name><argument_list>(<argument><expr><call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ec_exec_end_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ec_clear_all_trace_func</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_ec_finalize</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ruby_sig_finalize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_objspace_call_finalizer</name><argument_list>(<argument><expr><call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><name>void</name></type>
<name>ruby_finalize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ec_teardown</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ec_finalize</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><name>int</name></type>
<name>ruby_cleanup</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>ex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ec_cleanup</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_ec_cleanup</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>ex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name><name>errs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>Qundef</name></expr>, <expr><name>Qundef</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nerr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier><specifier>const</specifier> <specifier>volatile</specifier></type> <name>th0</name> <init>= <expr><name>th</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>sysex</name> <init>= <expr><name>EXIT_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>step</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_threadptr_interrupt</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_threadptr_check_signal</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>th</name> <operator>=</operator> <name>th0</name></expr>;</expr_stmt>
<macro><name>SAVE_ROOT_JMPBUF</name><argument_list>(<argument>th</argument>, <argument>{ RUBY_VM_CHECK_INTS(ec); }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<label><name>step_0</name>:</label> <expr_stmt><expr><name>step</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>th</name> <operator>=</operator> <name>th0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>errs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ruby_init_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>errs</name><index>[<expr><call><name>STACK_UPPER</name><argument_list>(<argument><expr><name>errs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SAVE_ROOT_JMPBUF</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><call><name>rb_ec_teardown</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>step_1</name>:</label> <expr_stmt><expr><name>step</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>th</name> <operator>=</operator> <name>th0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>THREAD_KILLED</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>errs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SAVE_ROOT_JMPBUF</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><call><name>rb_thread_terminate_all</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<switch>switch <condition>(<expr><name>step</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <goto>goto <name>step_0</name>;</goto>
<case>case <expr><literal type="number">1</literal></expr>:</case> <goto>goto <name>step_1</name>;</goto>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>ex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ex</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>th</name> <operator>=</operator> <name>th0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name><name>errs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sysex</name> <operator>=</operator> <call><name>error_handle</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>nerr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nerr</name> <operator>&lt;</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>errs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>nerr</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>err</name> <init>= <expr><call><name>ATOMIC_VALUE_EXCHANGE</name><argument_list>(<argument><expr><name><name>errs</name><index>[<expr><name>nerr</name></expr>]</index></name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>rb_eSystemExit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sysex</name> <operator>=</operator> <call><name>sysexit_status</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>rb_eSignal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>sig</name> <init>= <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>id_signo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>sysex</name> <operator>==</operator> <name>EXIT_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sysex</name> <operator>=</operator> <name>EXIT_FAILURE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>mjit_finish</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_ec_finalize</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>rb_threadptr_unlock_all_locking_mutexes</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_thread_stop_timer_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ruby_vm_destruct</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ruby_default_signal</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>sysex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_ec_exec_node</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>n</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>th</name> <init>= <expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>SAVE_ROOT_JMPBUF</name><argument_list>(<argument>th</argument>, <argument>{
rb_iseq_eval_main(iseq);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ruby_stop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><call><name>ruby_cleanup</name><argument_list>(<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><name>int</name></type>
<name>ruby_executable_node</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>n</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>v</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Qtrue</name></expr>:</case> <expr_stmt><expr><name>s</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>Qfalse</name></expr>:</case> <expr_stmt><expr><name>s</name> <operator>=</operator> <name>EXIT_FAILURE</name></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>ruby_run_node</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ruby_executable_node</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ec_cleanup</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ruby_init_stack</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_ec_cleanup</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>rb_ec_exec_node</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>ruby_exec_node</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ruby_init_stack</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_ec_exec_node</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_mod_nesting</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>rb_vm_cref</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cref</name> <operator>&amp;&amp;</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CREF_PUSHED_BY_EVAL</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_mod_s_constants</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>rb_vm_cref</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>cbase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mod</name> <operator>!=</operator> <name>rb_cModule</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_mod_constants</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>cref</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CREF_PUSHED_BY_EVAL</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>rb_mod_const_at</name><argument_list>(<argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cbase</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cbase</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>cbase</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>rb_mod_const_of</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_const_list</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>rb_class_modify_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<label><name>noclass</name>:</label>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <literal type="string">"object"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id__attached__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<case>case <expr><name>T_ICLASS</name></expr>:</case>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <literal type="string">"Module"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <literal type="string">"Class"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<case>case <expr><name>T_ICLASS</name></expr>:</case>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <literal type="string">"module"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <literal type="string">"class"</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<goto>goto <name>noclass</name>;</goto>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_frozen_error_raise</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><literal type="string">"can't modify frozen %s: %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void rb_longjmp(rb_execution_context_t *, int, volatile VALUE, VALUE)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>get_errinfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_ec_errinfo</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_ec_get_errinfo(ec)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>exc_setup_cause</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUPPORT_JOKE</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id_true_cause</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_true_cause</name></expr></argument>, <argument><expr><literal type="string">"true_cause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cause</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>rb_eFatal</name></expr></argument>, <argument><expr><name>id_true_cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cause</name> <operator>=</operator> <call><name>rb_exc_new_cstr</name><argument_list>(<argument><expr><name>rb_eFatal</name></expr></argument>, <argument><expr><literal type="string">"because using such Ruby"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>cause</name></expr></argument>, <argument><expr><name>id_cause</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">42</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>rb_eFatal</name></expr></argument>, <argument><expr><name>id_true_cause</name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>cause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>cause</name> <operator>!=</operator> <name>exc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_cause</name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_ivar_defined</name><argument_list>(<argument><expr><name>cause</name></expr></argument>, <argument><expr><name>id_cause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>cause</name></expr></argument>, <argument><expr><name>id_cause</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>exc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>
<name>exc_setup_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>cause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nocause</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nocircular</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>INTERNAL_EXCEPTION_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TAG_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nocause</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_exc_new</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nocause</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nocircular</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cause</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nocause</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cause</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nocircular</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_ivar_defined</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>id_cause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cause</name> <operator>=</operator> <call><name>get_ec_errinfo</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>nocircular</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><operator>*</operator><name>cause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><operator>*</operator><name>cause</name></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"exception object expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nocircular</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><operator>*</operator><name>cause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>cause</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cause</name> <operator>!=</operator> <name>mesg</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>cause</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>c</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>id_cause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>mesg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"circular causes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>mesg</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_exception</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>rb_source_location_cstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <specifier>volatile</specifier></type> <name>file0</name> <init>= <expr><name>file</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>file</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cause</name> <operator>!=</operator> <name>Qundef</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TAG_NONE</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>state</name> <operator>=</operator> <call><name>rb_ec_set_raised</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>bt</name> <init>= <expr><call><name>rb_get_backtrace</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>bt</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>cause</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_obj_dup</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cause</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>exc_setup_cause</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>at</name> <init>= <expr><call><name>rb_ec_backtrace_object</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>idBt_locations</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_backtrace</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ec_reset_raised</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file</name> <operator>=</operator> <name>file0</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fatal</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>mesg</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_debug</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>e</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>rb_eSystemExit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>mesg</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&amp;&amp;</operator> <name>line</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"Exception `%"</literal><name>PRIsVALUE</name><literal type="string">"' at %s:%d - %"</literal><name>PRIsVALUE</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>file</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"Exception `%"</literal><name>PRIsVALUE</name><literal type="string">"' at %s - %"</literal><name>PRIsVALUE</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"Exception `%"</literal><name>PRIsVALUE</name><literal type="string">"' - %"</literal><name>PRIsVALUE</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>warn_print_str</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_FATAL</name> <operator>&amp;&amp;</operator> <name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>==</operator> <name>exception_error</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>mesg</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>state</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ec_reset_raised</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_ec_set_raised</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<label><name>fatal</name>:</label>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>exception_error</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ec_reset_raised</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TAG_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>!=</operator> <name>TAG_FATAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RUBY_DTRACE_HOOK</name><argument_list>(<argument><expr><name>RAISE</name></expr></argument>, <argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RAISE</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>rb_ec_setup_exception</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cause</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cause</name> <operator>=</operator> <call><name>get_ec_errinfo</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cause</name> <operator>!=</operator> <name>mesg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>id_cause</name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_longjmp</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>exc_setup_message</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ec_raised_clear</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>make_exception</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isstr</name></decl></parameter>)</parameter_list>;</function_decl>








<function><type><name>void</name></type>
<name>rb_exc_raise</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>make_exception</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mesg</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_longjmp</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TAG_RAISE</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><name>void</name></type>
<name>rb_exc_fatal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>make_exception</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mesg</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_longjmp</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TAG_FATAL</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>rb_interrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_exc_new</name><argument_list>(<argument><expr><name>rb_eInterrupt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<enum>enum <block>{<decl><name>raise_opt_cause</name></decl>, <decl><name>raise_max_opt</name></decl>}</block>;</enum> 

<function><type><specifier>static</specifier> <name>int</name></type>
<name>extract_raise_opts</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>opt</name> <init>= <expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"cause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>raise_max_opt</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>argc</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>raise_max_opt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>argc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_f_raise</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>opts</name><index>[<expr><name>raise_max_opt</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type>const <name>cause</name> <init>= <expr><operator>&amp;</operator><name><name>opts</name><index>[<expr><name>raise_opt_cause</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>extract_raise_opts</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cause</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"only cause is given with no arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>get_errinfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>=</operator> <operator>&amp;</operator><name>err</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_raise_jump</name><argument_list>(<argument><expr><call><name>rb_make_exception</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>f_raise</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_f_raise</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>make_exception</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>, <decl><type ref="prev"/><name>exc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>exc</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>isstr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>exception_call</name>;</goto>

<case>case <expr><literal type="number">2</literal></expr>:</case>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name>exc</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<label><name>exception_call</name>:</label>
<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>idException</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>argv</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mesg</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"exception class/object expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>rb_error_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"exception object expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_backtrace</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>mesg</name></expr>;</return>
</block_content>}</block></function>





















<function><type><name>VALUE</name></type>
<name>rb_make_exception</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>make_exception</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>rb_raise_jump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_RETURN</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_longjmp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TAG_RAISE</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name>void</name></type>
<name>rb_jump_tag</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>tag</name> <argument_list type="generic">&lt; <argument><expr><name>TAG_RETURN</name> <operator>||</operator> <name>tag</name></expr></argument> &gt;</argument_list></name> <name>TAG_FATAL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unknown_longjmp_status</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>int</name></type>
<name>rb_block_given_p</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_vm_frame_block_handler</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>cfp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function_decl><type><name>int</name></type> <name>rb_vm_cframe_keyword_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>
<name>rb_keyword_given_p</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_vm_cframe_keyword_p</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>cfp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eThreadError</name></decl>;</decl_stmt>






<function><type><name>void</name></type>
<name>rb_need_block</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_vm_localjump_error</name><argument_list>(<argument><expr><literal type="string">"no block given"</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>























<function><type><name>VALUE</name></type>
<name>rb_rescue2</name><parameter_list>(<parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier> <name>b_proc</name>) <parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data1</name></decl></parameter>,
<parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier> <name>r_proc</name>) <parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data2</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>data2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>rb_vrescue2</name><argument_list>(<argument><expr><name>b_proc</name></expr></argument>, <argument><expr><name>data1</name></expr></argument>, <argument><expr><name>r_proc</name></expr></argument>, <argument><expr><name>data2</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>VALUE</name></type>
<name>rb_vrescue2</name><parameter_list>(<parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier> <name>b_proc</name>) <parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data1</name></decl></parameter>,
<parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier> <name>r_proc</name>) <parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data2</name></decl></parameter>,
<parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier> <specifier>volatile</specifier></type> <name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>e_info</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<label><name>retry_entry</name>:</label>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>b_proc</name>) <argument_list>(<argument><expr><name>data1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_RETRY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<goto>goto <name>retry_entry</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_vm_rewind_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_RAISE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>handle</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>eclass</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>eclass</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>, <argument><expr><name>eclass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>handle</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>handle</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r_proc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>r_proc</name>) <argument_list>(<argument><expr><name>data2</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>e_info</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>















<function><type><name>VALUE</name></type>
<name>rb_rescue</name><parameter_list>(<parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier> <name>b_proc</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data1</name></decl></parameter>,
<parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier> <name>r_proc</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_rescue2</name><argument_list>(<argument><expr><name>b_proc</name></expr></argument>, <argument><expr><name>data1</name></expr></argument>, <argument><expr><name>r_proc</name></expr></argument>, <argument><expr><name>data2</name></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>,
<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


















<function><type><name>VALUE</name></type>
<name>rb_protect</name><parameter_list>(<parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier> <name>proc</name>) <parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier> <specifier>volatile</specifier></type> <name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_vm_protect_tag</name></name></type> <name>protect_tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_jmpbuf_t</name></type> <name>org_jmpbuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>protect_tag</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>protect_tag</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>protect_tag</name></name> <operator>=</operator> <operator>&amp;</operator><name>protect_tag</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>org_jmpbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>root_jmpbuf</name></expr></argument>, <argument><expr><name>rb_jmpbuf_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SAVE_ROOT_JMPBUF</name><argument_list>(<argument><expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>proc</name>) <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_vm_rewind_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>root_jmpbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>org_jmpbuf</name></expr></argument>, <argument><expr><name>rb_jmpbuf_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>protect_tag</name></name> <operator>=</operator> <name><name>protect_tag</name><operator>.</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pstate</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>















<function><type><name>VALUE</name></type>
<name>rb_ensure</name><parameter_list>(<parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>b_proc</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data1</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>e_proc</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>errinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier> <specifier>volatile</specifier></type> <name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_ensure_list_t</name></type> <name>ensure_list</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ensure_list</name><operator>.</operator><name>entry</name><operator>.</operator><name>marker</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ensure_list</name><operator>.</operator><name>entry</name><operator>.</operator><name>e_proc</name></name> <operator>=</operator> <name>e_proc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ensure_list</name><operator>.</operator><name>entry</name><operator>.</operator><name>data2</name></name> <operator>=</operator> <name>data2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ensure_list</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>ensure_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ensure_list</name></name> <operator>=</operator> <operator>&amp;</operator><name>ensure_list</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>b_proc</name>) <argument_list>(<argument><expr><name>data1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errinfo</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>errinfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>errinfo</name></expr></argument>, <argument><expr><name>T_OBJECT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ensure_list</name></name><operator>=</operator><name><name>ensure_list</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>ensure_list</name><operator>.</operator><name>entry</name><operator>.</operator><name>e_proc</name></name>)<argument_list>(<argument><expr><name><name>ensure_list</name><operator>.</operator><name>entry</name><operator>.</operator><name>data2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>errinfo</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>frame_func_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>frame_called_id</name><parameter_list>(<parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>













<function><type><name>ID</name></type>
<name>rb_frame_this_func</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>frame_func_id</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>cfp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>












<function><type><name>ID</name></type>
<name>rb_frame_callee</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>frame_called_id</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>cfp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>
<name>previous_frame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>prev_cfp</name> <init>= <expr><call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>prev_cfp</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>prev_cfp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>prev_frame_callee</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>prev_cfp</name> <init>= <expr><call><name>previous_frame</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prev_cfp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>frame_called_id</name><argument_list>(<argument><expr><name>prev_cfp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>prev_frame_func</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>prev_cfp</name> <init>= <expr><call><name>previous_frame</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prev_cfp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>frame_func_id</name><argument_list>(<argument><expr><name>prev_cfp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><name>ID</name></type>
<name>rb_frame_last_func</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>mid</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><operator>(</operator><name>mid</name> <operator>=</operator> <call><name>frame_func_id</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call><operator>,</operator>
<operator>!</operator><call><name>RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
<return>return <expr><name>mid</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_mod_append_features</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>include</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CLASS_OR_MODULE_P</name><argument_list>(<argument><expr><name>include</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>include</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>include</name></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>module</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_mod_include</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id_append_features</name></decl>, <decl><type ref="prev"/><name>id_included</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_append_features</name></expr></argument>, <argument><expr><literal type="string">"append_features"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_included</name></expr></argument>, <argument><expr><literal type="string">"included"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<while>while <condition>(<expr><name>argc</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name></expr></argument>, <argument><expr><name>id_append_features</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name></expr></argument>, <argument><expr><name>id_included</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>module</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_mod_prepend_features</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>prepend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CLASS_OR_MODULE_P</name><argument_list>(<argument><expr><name>prepend</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>prepend</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_prepend_module</name><argument_list>(<argument><expr><name>prepend</name></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>module</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_mod_prepend</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id_prepend_features</name></decl>, <decl><type ref="prev"/><name>id_prepended</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_prepend_features</name></expr></argument>, <argument><expr><literal type="string">"prepend_features"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_prepended</name></expr></argument>, <argument><expr><literal type="string">"prepended"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<while>while <condition>(<expr><name>argc</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name></expr></argument>, <argument><expr><name>id_prepend_features</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name></expr></argument>, <argument><expr><name>id_prepended</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>module</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ensure_class_or_module</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,
<argument><expr><literal type="string">"wrong argument type %"</literal><name>PRIsVALUE</name><literal type="string">" (expected Class or Module)"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hidden_identity_hash_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>rb_ident_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>refinement_superclass</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>superclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>superclass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_include_class_new</name><argument_list>(<argument><expr><name>superclass</name></expr></argument>, <argument><expr><name>rb_cBasicObject</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>superclass</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>rb_using_refinement</name><parameter_list>(<parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>iclass</name></decl>, <decl><type ref="prev"/><name>c</name></decl>, <decl><type ref="prev"/><name>superclass</name> <init>= <expr><name>klass</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_class_or_module</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CREF_REFINEMENTS_SET</name><argument_list>(<argument><expr><name>cref</name></expr></argument>, <argument><expr><call><name>hidden_identity_hash_new</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CREF_OMOD_SHARED</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CREF_REFINEMENTS_SET</name><argument_list>(<argument><expr><name>cref</name></expr></argument>, <argument><expr><call><name>rb_hash_dup</name><argument_list>(<argument><expr><call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CREF_OMOD_SHARED_UNSET</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>c</name> <operator>=</operator> <call><name>rb_hash_lookup</name><argument_list>(<argument><expr><call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>superclass</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>c</name> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name> <operator>==</operator> <name>module</name></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>RMODULE_IS_OVERLAID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>superclass</name> <operator>=</operator> <call><name>refinement_superclass</name><argument_list>(<argument><expr><name>superclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>iclass</name> <operator>=</operator> <call><name>rb_include_class_new</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>superclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RCLASS_REFINED_CLASS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><call><name>OBJ_WB_UNPROTECT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator>
<call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><call><name>OBJ_WB_UNPROTECT</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>module</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>module</name> <operator>&amp;&amp;</operator> <name>module</name> <operator>!=</operator> <name>klass</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>RMODULE_IS_OVERLAID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>RCLASS_SET_SUPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>rb_include_class_new</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RCLASS_REFINED_CLASS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>module</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>using_refinement</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><operator>(</operator><name>rb_cref_t</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_using_refinement</name><argument_list>(<argument><expr><name>cref</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>using_module_recursive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id_refinements</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>super</name></decl>, <decl><type ref="prev"/><name>module</name></decl>, <decl><type ref="prev"/><name>refinements</name></decl>;</decl_stmt>

<expr_stmt><expr><name>super</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>super</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>using_module_recursive</name><argument_list>(<argument><expr><name>cref</name></expr></argument>, <argument><expr><name>super</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<expr_stmt><expr><name>module</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>T_ICLASS</name></expr>:</case>
<expr_stmt><expr><name>module</name> <operator>=</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong argument type %s (expected Module)"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_refinements</name></expr></argument>, <argument><expr><literal type="string">"__refinements__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>refinements</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>id_refinements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>, <argument><expr><name>using_refinement</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator> <name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>rb_using_module</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>using_module_recursive</name><argument_list>(<argument><expr><name>cref</name></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_clear_method_cache_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>VALUE</name></type>
<name>rb_refinement_module_get_refined_class</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id_refined_class</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_refined_class</name></expr></argument>, <argument><expr><literal type="string">"__refined_class__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>id_refined_class</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_activated_refinement</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>activated_refinements</name></decl></parameter>,
<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>refinement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>iclass</name></decl>, <decl><type ref="prev"/><name>c</name></decl>, <decl><type ref="prev"/><name>superclass</name> <init>= <expr><name>klass</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>c</name> <operator>=</operator> <call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>activated_refinements</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>superclass</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>c</name> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name> <operator>==</operator> <name>refinement</name></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>RMODULE_IS_OVERLAID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>superclass</name> <operator>=</operator> <call><name>refinement_superclass</name><argument_list>(<argument><expr><name>superclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>iclass</name> <operator>=</operator> <call><name>rb_include_class_new</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>superclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RCLASS_REFINED_CLASS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>refinement</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>refinement</name> <operator>&amp;&amp;</operator> <name>refinement</name> <operator>!=</operator> <name>klass</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>RMODULE_IS_OVERLAID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>RCLASS_SET_SUPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>rb_include_class_new</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RCLASS_REFINED_CLASS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>refinement</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>activated_refinements</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_mod_refine</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>refinement</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id_refinements</name></decl>, <decl><type ref="prev"/><name>id_activated_refinements</name></decl>,
<decl><type ref="prev"/><name>id_refined_class</name></decl>, <decl><type ref="prev"/><name>id_defined_at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>refinements</name></decl>, <decl><type ref="prev"/><name>activated_refinements</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>rb_vm_frame_block_handler</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no block given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>block_handler_type_iseq</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"can't pass a Proc as a block to Module#refine"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ensure_class_or_module</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>RCLASS_REFINED_BY_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_refinements</name></expr></argument>, <argument><expr><literal type="string">"__refinements__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>refinements</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>id_refinements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>refinements</name> <operator>=</operator> <call><name>hidden_identity_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>id_refinements</name></expr></argument>, <argument><expr><name>refinements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_activated_refinements</name></expr></argument>, <argument><expr><literal type="string">"__activated_refinements__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>activated_refinements</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>id_activated_refinements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>activated_refinements</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>activated_refinements</name> <operator>=</operator> <call><name>hidden_identity_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>id_activated_refinements</name></expr></argument>,
<argument><expr><name>activated_refinements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>refinement</name> <operator>=</operator> <call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>superclass</name> <init>= <expr><call><name>refinement_superclass</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>refinement</name> <operator>=</operator> <call><name>rb_module_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RCLASS_SET_SUPER</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>superclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>RMODULE_IS_REFINEMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_refined_class</name></expr></argument>, <argument><expr><literal type="string">"__refined_class__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>id_refined_class</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_defined_at</name></expr></argument>, <argument><expr><literal type="string">"__defined_at__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>id_defined_at</name></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>refinement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_activated_refinement</name><argument_list>(<argument><expr><name>activated_refinements</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>refinement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_yield_refine_block</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>activated_refinements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>refinement</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ignored_block</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>anon</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_search_class_path</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>anon</name> <operator>=</operator> <literal type="string">", maybe for Module.new"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>rb_warn</name><argument_list>(<argument><literal type="string">"%s""</literal>using doesn<literal type="char">'t call the given block""%s.", klass, anon);
}

/*
* call-seq:
* using(module) -&gt; self
*
* Import class refinements from &lt;i&gt;module&lt;/i&gt; into the current class or
* module definition.
*/

static VALUE
mod_using(VALUE self, VALUE module)
{
rb_control_frame_t *prev_cfp = previous_frame(GET_EC());

if (prev_frame_func()) {
rb_raise(rb_eRuntimeError,
"Module#using is not permitted in methods");
}
if (prev_cfp &amp;&amp; prev_cfp-&gt;self != self) {
rb_raise(rb_eRuntimeError, "Module#using is not called on self");
}
if (rb_block_given_p()) {
ignored_block(module, "Module#");
}
rb_using_module(rb_vm_cref_replace_with_duplicated_cref(), module);
return self;
}

static int
used_modules_i(VALUE _, VALUE mod, VALUE ary)
{
ID id_defined_at;
CONST_ID(id_defined_at, "__defined_at__");
while (FL_TEST(rb_class_of(mod), RMODULE_IS_REFINEMENT)) {
rb_ary_push(ary, rb_attr_get(rb_class_of(mod), id_defined_at));
mod = RCLASS_SUPER(mod);
}
return ST_CONTINUE;
}

/*
* call-seq:
* used_modules -&gt; array
*
* Returns an array of all modules used in the current scope. The ordering
* of modules in the resulting array is not defined.
*
* module A
* refine Object do
* end
* end
*
* module B
* refine Object do
* end
* end
*
* using A
* using B
* p Module.used_modules
*
* &lt;em&gt;produces:&lt;/em&gt;
*
* [B, A]
*/
static VALUE
rb_mod_s_used_modules(VALUE _)
{
const rb_cref_t *cref = rb_vm_cref();
VALUE ary = rb_ary_new();

while (cref) {
if (!NIL_P(CREF_REFINEMENTS(cref))) {
rb_hash_foreach(CREF_REFINEMENTS(cref), used_modules_i, ary);
}
cref = CREF_NEXT(cref);
}

return rb_funcall(ary, rb_intern("uniq"), 0);
}

/*!
* Calls \c #initialize method of \a obj with the given arguments.
*
* It also forwards the given block to \c #initialize if given.
*
* \param[in] obj the receiver object
* \param[in] argc the number of arguments
* \param[in] argv a pointer to the array of arguments
* \ingroup object
*/
void
rb_obj_call_init(VALUE obj, int argc, const VALUE *argv)
{
PASS_PASSED_BLOCK_HANDLER();
rb_funcallv_kw(obj, idInitialize, argc, argv, RB_NO_KEYWORDS);
}

void
rb_obj_call_init_kw(VALUE obj, int argc, const VALUE *argv, int kw_splat)
{
PASS_PASSED_BLOCK_HANDLER();
rb_funcallv_kw(obj, idInitialize, argc, argv, kw_splat);
}

/*!
* Extend the object with the module.
*
* Same as \c Module\#extend_object.
* \ingroup class
*/
void
rb_extend_object(VALUE obj, VALUE module)
{
rb_include_module(rb_singleton_class(obj), module);
}

/*
* call-seq:
* extend_object(obj) -&gt; obj
*
* Extends the specified object by adding this module'</literal>s constants and
* methods (which are added as singleton methods). This is the callback
* method used by Object#extend.
*
* module Picky
* def Picky.extend_object(o)
* if String === o
* puts <literal type="string">"Can't add Picky to a String"</literal>
* else
* puts <literal type="string">"Picky added to #{o.class}"</literal>
* super
* end
* end
* end
* (s = Array.new).extend Picky #Call Object.extend
* (s = <literal type="string">"quick brown fox"</literal>).extend Picky
*
* &lt;em&gt;produces:&lt;/em&gt;
*
* Picky added to Array
* Can<literal type="char">'t add Picky to a String
*/

static VALUE
rb_mod_extend_object(VALUE mod, VALUE obj)
{
rb_extend_object(obj, mod);
return obj;
}

/*
* call-seq:
* obj.extend(module, ...) -&gt; obj
*
* Adds to _obj_ the instance methods from each module given as a
* parameter.
*
* module Mod
* def hello
* "Hello from Mod.\n"
* end
* end
*
* class Klass
* def hello
* "Hello from Klass.\n"
* end
* end
*
* k = Klass.new
* k.hello #=&gt; "Hello from Klass.\n"
* k.extend(Mod) #=&gt; #&lt;Klass:0x401b3bc8&gt;
* k.hello #=&gt; "Hello from Mod.\n"
*/

static VALUE
rb_obj_extend(int argc, VALUE *argv, VALUE obj)
{
int i;
ID id_extend_object, id_extended;

CONST_ID(id_extend_object, "extend_object");
CONST_ID(id_extended, "extended");

rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
for (i = 0; i &lt; argc; i++)
Check_Type(argv[i], T_MODULE);
while (argc--) {
rb_funcall(argv[argc], id_extend_object, 1, obj);
rb_funcall(argv[argc], id_extended, 1, obj);
}
return obj;
}

/*
* call-seq:
* include(module, ...) -&gt; self
*
* Invokes Module.append_features on each parameter in turn.
* Effectively adds the methods and constants in each module to the
* receiver.
*/

static VALUE
top_include(int argc, VALUE *argv, VALUE self)
{
rb_thread_t *th = GET_THREAD();

if (th-&gt;top_wrapper) {
rb_warning("main.include in the wrapped load is effective only in wrapper module");
return rb_mod_include(argc, argv, th-&gt;top_wrapper);
}
return rb_mod_include(argc, argv, rb_cObject);
}

/*
* call-seq:
* using(module) -&gt; self
*
* Import class refinements from &lt;i&gt;module&lt;/i&gt; into the scope where
* #using is called.
*/

static VALUE
top_using(VALUE self, VALUE module)
{
const rb_cref_t *cref = rb_vm_cref();
rb_control_frame_t *prev_cfp = previous_frame(GET_EC());

if (CREF_NEXT(cref) || (prev_cfp &amp;&amp; rb_vm_frame_method_entry(prev_cfp))) {
rb_raise(rb_eRuntimeError, "main.using is permitted only at toplevel");
}
if (rb_block_given_p()) {
ignored_block(module, "main.");
}
rb_using_module(rb_vm_cref_replace_with_duplicated_cref(), module);
return self;
}

static const VALUE *
errinfo_place(const rb_execution_context_t *ec)
{
const rb_control_frame_t *cfp = ec-&gt;cfp;
const rb_control_frame_t *end_cfp = RUBY_VM_END_CONTROL_FRAME(ec);

while (RUBY_VM_VALID_CONTROL_FRAME_P(cfp, end_cfp)) {
if (VM_FRAME_RUBYFRAME_P(cfp)) {
if (cfp-&gt;iseq-&gt;body-&gt;type == ISEQ_TYPE_RESCUE) {
return &amp;cfp-&gt;ep[VM_ENV_INDEX_LAST_LVAR];
}
else if (cfp-&gt;iseq-&gt;body-&gt;type == ISEQ_TYPE_ENSURE &amp;&amp;
!THROW_DATA_P(cfp-&gt;ep[VM_ENV_INDEX_LAST_LVAR]) &amp;&amp;
!FIXNUM_P(cfp-&gt;ep[VM_ENV_INDEX_LAST_LVAR])) {
return &amp;cfp-&gt;ep[VM_ENV_INDEX_LAST_LVAR];
}
}
cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp);
}
return 0;
}

VALUE
rb_ec_get_errinfo(const rb_execution_context_t *ec)
{
const VALUE *ptr = errinfo_place(ec);
if (ptr) {
return *ptr;
}
else {
return ec-&gt;errinfo;
}
}

static VALUE
get_errinfo(void)
{
return get_ec_errinfo(GET_EC());
}

static VALUE
errinfo_getter(ID id, VALUE *_)
{
return get_errinfo();
}

/*! The current exception in the current thread.
*
* Same as \c $! in Ruby.
* \return the current exception or \c Qnil
* \ingroup exception
*/
VALUE
rb_errinfo(void)
{
return GET_EC()-&gt;errinfo;
}

/*! Sets the current exception (\c $!) to the given value
*
* \param[in] err an \c Exception object or \c Qnil.
* \exception TypeError if \a err is neither an exception nor \c nil.
* \note this function does not raise the exception.
* Use \c rb_raise() when you want to raise.
* \ingroup exception
*/
void
rb_set_errinfo(VALUE err)
{
if (!NIL_P(err) &amp;&amp; !rb_obj_is_kind_of(err, rb_eException)) {
rb_raise(rb_eTypeError, "assigning non-exception to $!");
}
GET_EC()-&gt;errinfo = err;
}

static VALUE
errat_getter(ID id, VALUE *_)
{
VALUE err = get_errinfo();
if (!NIL_P(err)) {
return rb_get_backtrace(err);
}
else {
return Qnil;
}
}

static void
errat_setter(VALUE val, ID id, VALUE *var)
{
VALUE err = get_errinfo();
if (NIL_P(err)) {
rb_raise(rb_eArgError, "$! not set");
}
set_backtrace(err, val);
}

/*
* call-seq:
* __method__ -&gt; symbol
*
* Returns the name at the definition of the current method as a
* Symbol.
* If called outside of a method, it returns &lt;code&gt;nil&lt;/code&gt;.
*
*/

static VALUE
rb_f_method_name(VALUE _)
{
ID fname = prev_frame_func(); /* need *method* ID */

if (fname) {
return ID2SYM(fname);
}
else {
return Qnil;
}
}

/*
* call-seq:
* __callee__ -&gt; symbol
*
* Returns the called name of the current method as a Symbol.
* If called outside of a method, it returns &lt;code&gt;nil&lt;/code&gt;.
*
*/

static VALUE
rb_f_callee_name(VALUE _)
{
ID fname = prev_frame_callee(); /* need *callee* ID */

if (fname) {
return ID2SYM(fname);
}
else {
return Qnil;
}
}

/*
* call-seq:
* __dir__ -&gt; string
*
* Returns the canonicalized absolute path of the directory of the file from
* which this method is called. It means symlinks in the path is resolved.
* If &lt;code&gt;__FILE__&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, it returns &lt;code&gt;nil&lt;/code&gt;.
* The return value equals to &lt;code&gt;File.dirname(File.realpath(__FILE__))&lt;/code&gt;.
*
*/
static VALUE
f_current_dirname(VALUE _)
{
VALUE base = rb_current_realfilepath();
if (NIL_P(base)) {
return Qnil;
}
base = rb_file_dirname(base);
return base;
}

/*
* call-seq:
* global_variables -&gt; array
*
* Returns an array of the names of global variables. This includes
* special regexp global variables such as &lt;tt&gt;$~&lt;/tt&gt; and &lt;tt&gt;$+&lt;/tt&gt;,
* but does not include the numbered regexp global variables (&lt;tt&gt;$1&lt;/tt&gt;,
* &lt;tt&gt;$2&lt;/tt&gt;, etc.).
*
* global_variables.grep /std/ #=&gt; [:$stdin, :$stdout, :$stderr]
*/

static VALUE
f_global_variables(VALUE _)
{
return rb_f_global_variables();
}

/*
* call-seq:
* trace_var(symbol, cmd ) -&gt; nil
* trace_var(symbol) {|val| block } -&gt; nil
*
* Controls tracing of assignments to global variables. The parameter
* +symbol+ identifies the variable (as either a string name or a
* symbol identifier). _cmd_ (which may be a string or a
* +Proc+ object) or block is executed whenever the variable
* is assigned. The block or +Proc+ object receives the
* variable'</literal>s new value as a parameter. Also see
* Kernel::untrace_var.
*
* trace_var :$_</argument>, <argument>proc {|v| puts <literal type="string">"$_ is now '#{v}'"</literal> }
* $_ = <literal type="string">"hello"</literal>
* $_ = <literal type="char">' there'</literal>
*
* &lt;em&gt;produces:&lt;/em&gt;
*
* $_ is now <literal type="char">'hello'</literal>
* $_ is now <literal type="char">' there'</literal>
*/

static VALUE
f_trace_var(int c, const VALUE *a, VALUE _)
{
return rb_f_trace_var(c, a);
}











static VALUE
f_untrace_var(int c, const VALUE *a, VALUE _)
{
return rb_f_untrace_var(c, a);
}

void
Init_eval(void)
{
rb_define_virtual_variable(<literal type="string">"$@"</literal>, errat_getter, errat_setter);
rb_define_virtual_variable(<literal type="string">"$!"</literal>, errinfo_getter, <literal type="number">0</literal>);

rb_define_global_function(<literal type="string">"raise"</literal>, f_raise, -<literal type="number">1</literal>);
rb_define_global_function(<literal type="string">"fail"</literal>, f_raise, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"global_variables"</literal>, f_global_variables, <literal type="number">0</literal>);

rb_define_global_function(<literal type="string">"__method__"</literal>, rb_f_method_name, <literal type="number">0</literal>);
rb_define_global_function(<literal type="string">"__callee__"</literal>, rb_f_callee_name, <literal type="number">0</literal>);
rb_define_global_function(<literal type="string">"__dir__"</literal>, f_current_dirname, <literal type="number">0</literal>);

rb_define_method(rb_cModule, <literal type="string">"include"</literal>, rb_mod_include, -<literal type="number">1</literal>);
rb_define_method(rb_cModule, <literal type="string">"prepend"</literal>, rb_mod_prepend, -<literal type="number">1</literal>);

rb_define_private_method(rb_cModule, <literal type="string">"append_features"</literal>, rb_mod_append_features, <literal type="number">1</literal>);
rb_define_private_method(rb_cModule, <literal type="string">"extend_object"</literal>, rb_mod_extend_object, <literal type="number">1</literal>);
rb_define_private_method(rb_cModule, <literal type="string">"prepend_features"</literal>, rb_mod_prepend_features, <literal type="number">1</literal>);
rb_define_private_method(rb_cModule, <literal type="string">"refine"</literal>, rb_mod_refine, <literal type="number">1</literal>);
rb_define_private_method(rb_cModule, <literal type="string">"using"</literal>, mod_using, <literal type="number">1</literal>);
rb_define_singleton_method(rb_cModule, <literal type="string">"used_modules"</literal>,
rb_mod_s_used_modules, <literal type="number">0</literal>);
rb_undef_method(rb_cClass, <literal type="string">"refine"</literal>);

rb_undef_method(rb_cClass, <literal type="string">"module_function"</literal>);

Init_vm_eval();
Init_eval_method();

rb_define_singleton_method(rb_cModule, <literal type="string">"nesting"</literal>, rb_mod_nesting, <literal type="number">0</literal>);
rb_define_singleton_method(rb_cModule, <literal type="string">"constants"</literal>, rb_mod_s_constants, -<literal type="number">1</literal>);

rb_define_private_method(rb_singleton_class(rb_vm_top_self()),
<literal type="string">"include"</literal>, top_include, -<literal type="number">1</literal>);
rb_define_private_method(rb_singleton_class(rb_vm_top_self()),
<literal type="string">"using"</literal>, top_using, <literal type="number">1</literal>);

rb_define_method(rb_mKernel, <literal type="string">"extend"</literal>, rb_obj_extend, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"trace_var"</literal>, f_trace_var, -<literal type="number">1</literal>);
rb_define_global_function(<literal type="string">"untrace_var"</literal>, f_untrace_var, -<literal type="number">1</literal>);

rb_vm_register_special_exception(ruby_error_reenter, rb_eFatal, <literal type="string">"exception reentered"</literal>);
rb_vm_register_special_exception(ruby_error_stackfatal, rb_eFatal, <literal type="string">"machine stack overflow in critical region"</literal>);

id_signo = rb_intern_const(<literal type="string">"signo"</literal>);
id_status = rb_intern_const(<literal type="string">"status"</literal>);
}</argument></argument_list></macro></block_content></block></function>
</unit>
