<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\mjit_worker.c">


















































































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__EXTENSIONS__</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_callinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mjit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/thread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/version.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PARAM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dln.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>strdup</name></cpp:undef> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHLEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlopen</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>flag</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void*)LoadLibrary(name))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlerror</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>strerror(rb_w32_map_errno(GetLastError()))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlsym</name><parameter_list>(<parameter><type><name>handle</name></type></parameter>,<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void*)GetProcAddress((handle),(name)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlclose</name><parameter_list>(<parameter><type><name>handle</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!FreeLibrary(handle))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTLD_NOW</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>waitpid</name><parameter_list>(<parameter><type><name>pid</name></type></parameter>,<parameter><type><name>stat_loc</name></type></parameter>,<parameter><type><name>options</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(WaitForSingleObject((HANDLE)(pid), INFINITE), GetExitCodeProcess((HANDLE)(pid), (LPDWORD)(stat_loc)), CloseHandle((HANDLE)pid), (pid))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIFEXITED</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((S) != STILL_ACTIVE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WEXITSTATUS</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(S)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIFSIGNALED</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<typedef>typedef <type><name>intptr_t</name></type> <name>pid_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MJIT_ATOMIC_SET</name><parameter_list>(<parameter><type><name>var</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)ATOMIC_PTR_EXCHANGE(var, val)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MJIT_TMP_PREFIX</name></cpp:macro> <cpp:value>"_ruby_mjit_"</cpp:value></cpp:define>


<struct>struct <name>rb_mjit_unit</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>o_file</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>o_file_inherited_p</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>so_file</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>char</name></type> <name>used_code_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name></type> <name>unode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_mjit_compile_info</name></name></type> <name>compile_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>cc_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cc_entries_size</name></decl>;</decl_stmt> 
}</block>;</struct>


<struct>struct <name>rb_mjit_unit_list</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name></type> <name>head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt> 
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_mutex_lock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_mutex_unlock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_mutex_initialize</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_mutex_destroy</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_cond_initialize</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_cond_destroy</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_cond_signal</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_cond_broadcast</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_native_cond_wait</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>rb_pid_t</name></type> <name>ruby_waitpid_locked</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>rb_pid_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>status</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name><name>struct</name> <name>mjit_options</name></name></type> <name>mjit_opts</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>mjit_enabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>mjit_call_p</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rb_mjit_unit_list</name></name></type> <name>unit_queue</name> <init>= <expr><block>{ <macro><name>LIST_HEAD_INIT</name><argument_list>(<argument>unit_queue.head</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rb_mjit_unit_list</name></name></type> <name>active_units</name> <init>= <expr><block>{ <macro><name>LIST_HEAD_INIT</name><argument_list>(<argument>active_units.head</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rb_mjit_unit_list</name></name></type> <name>compact_units</name> <init>= <expr><block>{ <macro><name>LIST_HEAD_INIT</name><argument_list>(<argument>compact_units.head</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rb_mjit_unit_list</name></name></type> <name>stale_units</name> <init>= <expr><block>{ <macro><name>LIST_HEAD_INIT</name><argument_list>(<argument>stale_units.head</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>current_unit_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_nativethread_lock_t</name></type> <name>mjit_engine_mutex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_nativethread_cond_t</name></type> <name>mjit_pch_wakeup</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>rb_nativethread_cond_t</name></type> <name>mjit_client_wakeup</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>rb_nativethread_cond_t</name></type> <name>mjit_worker_wakeup</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_nativethread_cond_t</name></type> <name>mjit_gc_wakeup</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>in_gc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>in_jit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>stop_worker_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>worker_stopped</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp_dir</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>valid_class_serials</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cc_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cc_common_args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cc_added_args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pch_file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_pid_t</name></type> <name>pch_owner_pid</name></decl>;</decl_stmt>


<enum><specifier>static</specifier> enum <block>{<decl><name>PCH_NOT_READY</name></decl>, <decl><name>PCH_FAILED</name></decl>, <decl><name>PCH_SUCCESS</name></decl>}</block> <decl><name>pch_status</name></decl>;</enum>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>header_file</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>libruby_pathflag</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mjit_config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr></cpp:if>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_PIC_FLAGS</name></cpp:macro> <cpp:value>"-Wfatal-errors", "-fPIC", "-shared", "-w", "-pipe",</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MJIT_CFLAGS_PIPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_PIC_FLAGS</name></cpp:macro></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MJIT_CFLAGS_PIPE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>__clang__</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_NOSTDLIB_FLAGS</name></cpp:macro> <cpp:value>"-nodefaultlibs", "-nostdlib",</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_NOSTDLIB_FLAGS</name></cpp:macro></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>CC_COMMON_ARGS</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>MJIT_CC_COMMON</name> <name>MJIT_CFLAGS</name> <name>GCC_PIC_FLAGS</name>
<name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>CC_DEBUG_ARGS</name><index>[]</index></name> <init>= <expr><block>{<expr><name>MJIT_DEBUGFLAGS</name> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>CC_OPTIMIZE_ARGS</name><index>[]</index></name> <init>= <expr><block>{<expr><name>MJIT_OPTFLAGS</name> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>CC_LDSHARED_ARGS</name><index>[]</index></name> <init>= <expr><block>{<expr><name>MJIT_LDSHARED</name> <name>GCC_PIC_FLAGS</name> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>CC_DLDFLAGS_ARGS</name><index>[]</index></name> <init>= <expr><block>{<expr><name>MJIT_DLDFLAGS</name> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>CC_LINKER_ARGS</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>__clang__</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><literal type="string">"-nostartfiles"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><name>GCC_NOSTDLIB_FLAGS</name> <name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>CC_LIBS</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>MJIT_LIBS</name> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>__clang__</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<literal type="string">"-lmsvcrt"</literal></expr>, 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><literal type="string">"-lgcc"</literal></expr>, 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__ANDROID__</name></expr></cpp:if>
<expr><literal type="string">"-lm"</literal></expr>, 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CC_CODEFLAG_ARGS</name></cpp:macro> <cpp:value>(mjit_opts.debug ? CC_DEBUG_ARGS : CC_OPTIMIZE_ARGS)</cpp:value></cpp:define>



<macro><name>PRINTF_ARGS</name><argument_list>(<argument>static void</argument>, <argument><literal type="number">2</literal></argument>, <argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>verbose</name><argument_list>(<argument>int level</argument>, <argument>const char *format</argument>, <argument>...</argument>)</argument_list></macro>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mjit_opts</name><operator>.</operator><name>verbose</name></name> <operator>&gt;=</operator> <name>level</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>full_format</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>full_format</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>full_format</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>full_format</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>full_format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<macro><name>PRINTF_ARGS</name><argument_list>(<argument>static void</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>mjit_warning</name><argument_list>(<argument>const char *format</argument>, <argument>...</argument>)</argument_list></macro>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mjit_opts</name><operator>.</operator><name>warnings</name></name> <operator>||</operator> <name><name>mjit_opts</name><operator>.</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"MJIT warning: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_to_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>mjit_length_unit_queue</name></expr></argument>, <argument><expr><name>list</name> <operator>==</operator> <operator>&amp;</operator><name>unit_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>mjit_length_active_units</name></expr></argument>, <argument><expr><name>list</name> <operator>==</operator> <operator>&amp;</operator><name>active_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>mjit_length_compact_units</name></expr></argument>, <argument><expr><name>list</name> <operator>==</operator> <operator>&amp;</operator><name>compact_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>mjit_length_stale_units</name></expr></argument>, <argument><expr><name>list</name> <operator>==</operator> <operator>&amp;</operator><name>stale_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_add_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>unit</name><operator>-&gt;</operator><name>unode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_from_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_DEBUG_COUNTER</name></expr></cpp:if>
<expr_stmt><expr><call><name>rb_debug_counter_add</name><argument_list>(<argument><expr><name>RB_DEBUG_COUNTER_mjit_length_unit_queue</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>list</name> <operator>==</operator> <operator>&amp;</operator><name>unit_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_debug_counter_add</name><argument_list>(<argument><expr><name>RB_DEBUG_COUNTER_mjit_length_active_units</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>list</name> <operator>==</operator> <operator>&amp;</operator><name>active_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_debug_counter_add</name><argument_list>(<argument><expr><name>RB_DEBUG_COUNTER_mjit_length_compact_units</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>list</name> <operator>==</operator> <operator>&amp;</operator><name>compact_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_debug_counter_add</name><argument_list>(<argument><expr><name>RB_DEBUG_COUNTER_mjit_length_stale_units</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>list</name> <operator>==</operator> <operator>&amp;</operator><name>stale_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unit</name><operator>-&gt;</operator><name>unode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>remove</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"failed to remove \"%s\": %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>clean_object_files</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>o_file</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>o_file</name> <init>= <expr><name><name>unit</name><operator>-&gt;</operator><name>o_file</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>o_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>save_temps</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>unit</name><operator>-&gt;</operator><name>o_file_inherited_p</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>o_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>o_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>so_file</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>so_file</name> <init>= <expr><name><name>unit</name><operator>-&gt;</operator><name>so_file</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>so_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_unit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name></name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>jit_func</name></name> <operator>=</operator> <operator>(</operator><name>mjit_func_t</name><operator>)</operator><name>NOT_COMPILED_JIT_ISEQ_FUNC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>jit_unit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>cc_entries</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>unit</name><operator>-&gt;</operator><name>cc_entries</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>handle</name></name> <operator>&amp;&amp;</operator> <call><name>dlclose</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"failed to close handle for u%d: %s"</literal></expr></argument>, <argument><expr><name><name>unit</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>clean_object_files</name><argument_list>(<argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CRITICAL_SECTION_START</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"Locking %s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_engine_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"Locked %s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CRITICAL_SECTION_FINISH</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"Unlocked %s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_engine_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sprint_uniq_filename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"%s/%sp%"</literal><name>PRI_PIDT_PREFIX</name><literal type="string">"uu%lu%s"</literal></expr></argument>, <argument><expr><name>tmp_dir</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>double</name></type> <name>ruby_real_ms_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>real_ms_time</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>ruby_real_ms_time()</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>real_ms_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK_GETTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>tv</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>clockid_t</name></type> <name>c</name> <init>= <expr><name>CLOCK_MONOTONIC</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>clockid_t</name></type> <name>c</name> <init>= <expr><name>CLOCK_REALTIME</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>tv</name><operator>.</operator><name>tv_nsec</name></name> <operator>/</operator> <literal type="number">1000000.0</literal> <operator>+</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000.0</literal> <operator>+</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>bool</name></type>
<name>mjit_valid_class_serial_p</name><parameter_list>(<parameter><decl><type><name>rb_serial_t</name></type> <name>class_serial</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in valid_class_serial_p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>found_p</name> <init>= <expr><call><name>rb_hash_stlike_lookup</name><argument_list>(<argument><expr><name>valid_class_serials</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>class_serial</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in valid_class_serial_p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>found_p</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type>
<name>get_from_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>best</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<macro><name>list_for_each_safe</name><argument_list>(<argument>&amp;list-&gt;head</argument>, <argument>unit</argument>, <argument>next</argument>, <argument>unode</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>remove_from_list</name><argument_list>(<argument><expr><name>unit</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_unit</name><argument_list>(<argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>best</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>best</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>total_calls</name></name> <operator>&lt;</operator> <name><name>unit</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>total_calls</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>best</name> <operator>=</operator> <name>unit</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>best</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>remove_from_list</name><argument_list>(<argument><expr><name>best</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>best</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>args_len</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>form_args</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>args_len</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>res</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>COMPILER_WARNING_PUSH</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>COMPILER_WARNING_IGNORED</name><argument_list>(<argument><expr><operator>-</operator><name>Wdeprecated</name><operator>-</operator><name>declarations</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


static <name>pid_t</name>
<name>start_process</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>abspath</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><name>argv</name></expr></argument>)</argument_list>
<block>{<block_content>


<decl_stmt><decl><type><name>int</name></type> <name>dev_null</name> <init>= <expr><call><name>rb_cloexec_open</name><argument_list>(<argument><expr><name>ruby_null_device</name></expr></argument>, <argument><expr><name>O_WRONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dev_null</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"MJIT: Failed to open a null device: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mjit_opts</name><operator>.</operator><name>verbose</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Starting process: %s"</literal></expr></argument>, <argument><expr><name>abspath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><operator>(</operator><name>arg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>HANDLE</name></type> <name>rb_w32_start_process</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abspath</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>out_fd</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>int</name></type> <name>out_fd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mjit_opts</name><operator>.</operator><name>verbose</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>out_fd</name> <operator>=</operator> <name>dev_null</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>(</operator><name>pid_t</name><operator>)</operator><call><name>rb_w32_start_process</name><argument_list>(<argument><expr><name>abspath</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>out_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"MJIT: Failed to create process: %s"</literal></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>vfork</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><literal type="number">0077</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mjit_opts</name><operator>.</operator><name>verbose</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name>dev_null</name></expr></argument>, <argument><expr><name>STDERR_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name>dev_null</name></expr></argument>, <argument><expr><name>STDOUT_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>dev_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>execv</name><argument_list>(<argument><expr><name>abspath</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 



<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"MJIT: Error in execv: %s"</literal></expr></argument>, <argument><expr><name>abspath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>dev_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>pid</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function><type><name>COMPILER_WARNING_POP</name>




<specifier>static</specifier> <name>int</name></type>
<name>exec_process</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>stat</name></decl>, <decl><type ref="prev"/><name>exit_code</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><ternary><condition><expr><name>WAITPID_USE_SIGCHLD</name></expr> ?</condition><then> <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_nativethread_cond_t</name></type> <name>cond</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vm</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_native_cond_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>waitpid_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><call><name>start_process</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition><expr><name>pid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>pid_t</name></type> <name>r</name> <init>= <expr><ternary><condition><expr><name>vm</name></expr> ?</condition><then> <expr><call><name>ruby_waitpid_locked</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[%"</literal><name>PRI_PIDT_PREFIX</name><literal type="string">"d] waitpid(%lu): %s (SIGCHLD=%d,%u)\n"</literal></expr></argument>,
<argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>pid</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>RUBY_SIGCHLD</name></expr></argument>, <argument><expr><name>SIGCHLD_LOSSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <name>pid</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>exit_code</name> <operator>=</operator> <call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>exit_code</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>vm</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>waitpid_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_native_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>exit_code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_so_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>so_file</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>so_file</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>so_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"failed to allocate memory to lazily remove '%s': %s"</literal></expr></argument>, <argument><expr><name>so_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>sprint_funcname</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>iseq</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>debug</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>debug_flags</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="string">"_mjit%d"</literal></expr></argument>, <argument><expr><name><name>unit</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lib</name> <init>= <expr><literal type="string">"/lib/"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name> <init>= <expr><literal type="string">"/"</literal> <call><name>STRINGIZE</name><argument_list>(<argument><expr><name>RUBY_API_VERSION_MAJOR</name></expr></argument>)</argument_list></call> <literal type="string">"."</literal> <call><name>STRINGIZE</name><argument_list>(<argument><expr><name>RUBY_API_VERSION_MINOR</name></expr></argument>)</argument_list></call> <literal type="string">"."</literal> <call><name>STRINGIZE</name><argument_list>(<argument><expr><name>RUBY_API_VERSION_TEENY</name></expr></argument>)</argument_list></call> <literal type="string">"/"</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>lib</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>lib</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>lib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<while>while <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>method</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>method</name> <operator>=</operator> <literal type="string">"AREF"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><literal type="string">"[]="</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>method</name> <operator>=</operator> <literal type="string">"ASET"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="string">"_mjit%d_%s_%s"</literal></expr></argument>, <argument><expr><name><name>unit</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>funcname</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><literal type="char">'a'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>funcname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>append_str2</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *)memcpy((p), str, (len))+(len))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>append_str</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>append_str2(p, str, sizeof(str)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>append_lit</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>append_str2(p, str, rb_strlen_lit(str))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>compile_c_to_so</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c_file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>so_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>files</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"-link"</literal></expr>, <expr><name>libruby_pathflag</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>files</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">"-Fe"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_lit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"-Fe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_str2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>so_file</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>



<expr_stmt><expr><name><name>files</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">"-Fo"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>rb_strlen_lit</name><argument_list>(<argument><expr><name>DLEXT</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">".obj"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>obj_file</name> <init>= <expr><name>p</name> <operator>=</operator> <call><name>append_lit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"-Fo"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_str2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>so_file</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>rb_strlen_lit</name><argument_list>(<argument><expr><name>DLEXT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_lit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">".obj"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>files</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">"-Yu"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pch_file</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_lit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"-Yu"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_str2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pch_file</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pch_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>files</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>pch_file</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_str2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pch_file</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pch_file</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">".pch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_lit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">".obj"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>files</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">"-Tc"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_lit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"-Tc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_str2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c_file</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>files</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">"-Fd"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pch_file</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_lit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"-Fd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_str2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pch_file</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pch_file</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">".pch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>append_lit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">".pdb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>form_args</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>CC_LDSHARED_ARGS</name></expr></argument>, <argument><expr><name>CC_CODEFLAG_ARGS</name></expr></argument>,
<argument><expr><name>files</name></expr></argument>, <argument><expr><name>CC_LIBS</name></expr></argument>, <argument><expr><name>CC_DLDFLAGS_ARGS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>exit_code</name> <init>= <expr><call><name>exec_process</name><argument_list>(<argument><expr><name>cc_path</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>exit_code</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>save_temps</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>before_dot</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>obj_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>before_dot</name> <operator>=</operator> <name>obj_file</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>obj_file</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">".obj"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>append_lit</name><argument_list>(<argument><expr><name>before_dot</name></expr></argument>, <argument><expr><literal type="string">".lib"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>obj_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>append_lit</name><argument_list>(<argument><expr><name>before_dot</name></expr></argument>, <argument><expr><literal type="string">".exp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>obj_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>append_lit</name><argument_list>(<argument><expr><name>before_dot</name></expr></argument>, <argument><expr><literal type="string">".pdb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>obj_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"compile_c_to_so: compile error: %d"</literal></expr></argument>, <argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>exit_code</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 


<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_pch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>rest_args</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><literal type="string">"-emit-pch"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr><name>GCC_NOSTDLIB_FLAGS</name>
<literal type="string">"-o"</literal></expr>, <expr><name>pch_file</name></expr>, <expr><name>header_file</name></expr>,
<expr><name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"Creating precompiled header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>form_args</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>cc_common_args</name></expr></argument>, <argument><expr><name>CC_CODEFLAG_ARGS</name></expr></argument>, <argument><expr><name>cc_added_args</name></expr></argument>, <argument><expr><name>rest_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"making precompiled header failed on forming args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in make_pch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pch_status</name> <operator>=</operator> <name>PCH_FAILED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in make_pch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>exit_code</name> <init>= <expr><call><name>exec_process</name><argument_list>(<argument><expr><name>cc_path</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in make_pch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>exit_code</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pch_status</name> <operator>=</operator> <name>PCH_SUCCESS</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"Making precompiled header failed on compilation. Stopping MJIT worker..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pch_status</name> <operator>=</operator> <name>PCH_FAILED</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_native_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_pch_wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in make_pch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>compile_c_to_o</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c_file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>o_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>files</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"-o"</literal></expr>, <expr><name>o_file</name></expr>, <expr><name>c_file</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><literal type="string">"-include-pch"</literal></expr>, <expr><name>pch_file</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><literal type="string">"-c"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>form_args</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>cc_common_args</name></expr></argument>, <argument><expr><name>CC_CODEFLAG_ARGS</name></expr></argument>, <argument><expr><name>cc_added_args</name></expr></argument>, <argument><expr><name>files</name></expr></argument>, <argument><expr><name>CC_LINKER_ARGS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>exit_code</name> <init>= <expr><call><name>exec_process</name><argument_list>(<argument><expr><name>cc_path</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>exit_code</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"compile_c_to_o: compile error: %d"</literal></expr></argument>, <argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>exit_code</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>link_o_to_so</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>o_files</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>so_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"-o"</literal></expr>, <expr><name>so_file</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>libruby_pathflag</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>form_args</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><name>CC_LDSHARED_ARGS</name></expr></argument>, <argument><expr><name>CC_CODEFLAG_ARGS</name></expr></argument>,
<argument><expr><name>options</name></expr></argument>, <argument><expr><name>o_files</name></expr></argument>, <argument><expr><name>CC_LIBS</name></expr></argument>, <argument><expr><name>CC_DLDFLAGS_ARGS</name></expr></argument>, <argument><expr><name>CC_LINKER_ARGS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>exit_code</name> <init>= <expr><call><name>exec_process</name><argument_list>(<argument><expr><name>cc_path</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>exit_code</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"link_o_to_so: link error: %d"</literal></expr></argument>, <argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>exit_code</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>compact_all_jit_code</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>start_time</name></decl>, <decl><type ref="prev"/><name>end_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>so_ext</name><index>[]</index></name> <init>= <expr><name>DLEXT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>so_file</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>o_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>unit</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_mjit_unit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>current_unit_num</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprint_uniq_filename</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>so_file</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>unit</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>MJIT_TMP_PREFIX</name></expr></argument>, <argument><expr><name>so_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>o_files</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>active_units</name><operator>.</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o_files</name><index>[<expr><name><name>active_units</name><operator>.</operator><name>length</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in compact_all_jit_code to keep .o files"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>list_for_each</name><argument_list>(<argument>&amp;active_units.head</argument>, <argument>cur</argument>, <argument>unode</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name><name>o_files</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>o_file</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>real_ms_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>link_o_to_so</name><argument_list>(<argument><expr><name>o_files</name></expr></argument>, <argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>real_ms_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in compact_all_jit_code to keep .o files"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><call><name>dlopen</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>, <argument><expr><name>RTLD_NOW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"failure in loading code from compacted '%s': %s"</literal></expr></argument>, <argument><expr><name>so_file</name></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>add_to_list</name><argument_list>(<argument><expr><name>unit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compact_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>save_temps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_so_file</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in compact_all_jit_code to read list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>list_for_each</name><argument_list>(<argument>&amp;active_units.head</argument>, <argument>cur</argument>, <argument>unode</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>funcname</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprint_funcname</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>func</name> <operator>=</operator> <call><name>dlsym</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"skipping to reload '%s' from '%s': %s"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>so_file</name></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>iseq</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>MJIT_ATOMIC_SET</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>jit_func</name></name></expr></argument>, <argument><expr><operator>(</operator><name>mjit_func_t</name><operator>)</operator><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in compact_all_jit_code to read list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"JIT compaction (%.1fms): Compacted %d methods -&gt; %s"</literal></expr></argument>, <argument><expr><name>end_time</name> <operator>-</operator> <name>start_time</name></expr></argument>, <argument><expr><name><name>active_units</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"JIT compaction failure (%.1fms): Failed to compact methods"</literal></expr></argument>, <argument><expr><name>end_time</name> <operator>-</operator> <name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>load_func_from_so</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>so_file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>

<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>dlopen</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>, <argument><expr><name>RTLD_NOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"failure in loading code from '%s': %s"</literal></expr></argument>, <argument><expr><name>so_file</name></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>NOT_ADDED_JIT_ISEQ_FUNC</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>dlsym</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
<return>return <expr><name>func</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>header_name_end</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>s</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>suffix</name><index>[]</index></name> <init>= <expr><literal type="string">".gch"</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&gt;</operator> <name>s</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>e</name><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>compile_prelude</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>pch_file</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>header_name_end</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"#include \""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch<condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case> <case>case <expr><literal type="char">'"'</literal></expr>:</case>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"void _pei386_runtime_relocator(void){}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"int __stdcall DllMainCRTStartup(void* hinstDLL, unsigned int fdwReason, void* lpvReserved) { return 1; }\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>mjit_func_t</name></type>
<name>convert_unit_to_func</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>c_file_buff</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c_file</name> <init>= <expr><name>c_file_buff</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>so_file</name></decl>, <decl><type ref="prev"/><name><name>funcname</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>start_time</name></decl>, <decl><type ref="prev"/><name>end_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c_file_len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>c_file_buff</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>c_ext</name><index>[]</index></name> <init>= <expr><literal type="string">".c"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>so_ext</name><index>[]</index></name> <init>= <expr><name>DLEXT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>access_mode</name> <init>=
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>O_BINARY</name><operator>|</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>O_WRONLY</name><operator>|</operator><name>O_EXCL</name><operator>|</operator><name>O_CREAT</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>o_ext</name><index>[]</index></name> <init>= <expr><literal type="string">".o"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>o_file</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>c_file_len</name> <operator>=</operator> <call><name>sprint_uniq_filename</name><argument_list>(<argument><expr><name>c_file_buff</name></expr></argument>, <argument><expr><name>c_file_len</name></expr></argument>, <argument><expr><name><name>unit</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>MJIT_TMP_PREFIX</name></expr></argument>, <argument><expr><name>c_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c_file_len</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>c_file_buff</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>c_file_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c_file</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>c_file_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c_file_len</name> <operator>=</operator> <call><name>sprint_uniq_filename</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>, <argument><expr><name>c_file_len</name></expr></argument>, <argument><expr><name><name>unit</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>MJIT_TMP_PREFIX</name></expr></argument>, <argument><expr><name>c_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>c_file_len</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>o_file</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>c_file_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>c_ext</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>o_ext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>o_file</name></expr></argument>, <argument><expr><name>c_file</name></expr></argument>, <argument><expr><name>c_file_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>c_ext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o_file</name><index>[<expr><name>c_file_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>c_ext</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>, <argument><expr><name>o_ext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>o_ext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>so_file</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>c_file_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>c_ext</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>so_ext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>, <argument><expr><name>c_file</name></expr></argument>, <argument><expr><name>c_file_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>c_ext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so_file</name><index>[<expr><name>c_file_len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>c_ext</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>, <argument><expr><name>so_ext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>so_ext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sprint_funcname</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>rb_cloexec_open</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>, <argument><expr><name>access_mode</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>f</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Failed to fopen '%s', giving up JIT for it (%s)"</literal></expr></argument>, <argument><expr><name>c_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>mjit_func_t</name><operator>)</operator><name>NOT_COMPILED_JIT_ISEQ_FUNC</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>compile_prelude</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"before mjit_compile to wait GC finish"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>in_gc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Waiting wakeup from GC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_native_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_gc_wakeup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mjit_engine_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>save_temps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>in_jit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>in_jit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"before mjit_compile to wait GC finish"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_jit</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>mjit_func_t</name><operator>)</operator><name>NOT_COMPILED_JIT_ISEQ_FUNC</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>long</name></type> <name>iseq_lineno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>iseq_lineno</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>iseq_label</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>iseq_path</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>iseq_label</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>iseq_path</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"start compilation: %s@%s:%ld -&gt; %s"</literal></expr></argument>, <argument><expr><name>iseq_label</name></expr></argument>, <argument><expr><name>iseq_path</name></expr></argument>, <argument><expr><name>iseq_lineno</name></expr></argument>, <argument><expr><name>c_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"/* %s@%s:%ld */\n\n"</literal></expr></argument>, <argument><expr><name>iseq_label</name></expr></argument>, <argument><expr><name>iseq_path</name></expr></argument>, <argument><expr><name>iseq_lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>mjit_compile</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"after mjit_compile to wakeup client for GC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in_jit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Sending wakeup signal to client in a mjit-worker for GC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_native_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_client_wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in worker to wakeup client for GC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>save_temps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"JIT failure: %s@%s:%ld -&gt; %s"</literal></expr></argument>, <argument><expr><name>iseq_label</name></expr></argument>, <argument><expr><name>iseq_path</name></expr></argument>, <argument><expr><name>iseq_lineno</name></expr></argument>, <argument><expr><name>c_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>mjit_func_t</name><operator>)</operator><name>NOT_COMPILED_JIT_ISEQ_FUNC</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>real_ms_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>compile_c_to_so</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>, <argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>success</name> <operator>=</operator> <call><name>compile_c_to_o</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>, <argument><expr><name>o_file</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>false</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>success</name> <operator>=</operator> <macro><name>link_o_to_so</name><argument_list>(<argument>(const char *[]){ o_file</argument>, <argument>NULL }</argument>, <argument>so_file</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>o_file</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>o_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>o_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mjit_warning</name><argument_list>(<argument><expr><literal type="string">"failed to allocate memory to remember '%s' (%s), removing it..."</literal></expr></argument>, <argument><expr><name>o_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>o_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>real_ms_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>save_temps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>c_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"Failed to generate so: %s"</literal></expr></argument>, <argument><expr><name>so_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>mjit_func_t</name><operator>)</operator><name>NOT_COMPILED_JIT_ISEQ_FUNC</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>load_func_from_so</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>save_temps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_so_file</name><argument_list>(<argument><expr><name>so_file</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>func</name> <operator>&gt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>LAST_JIT_ISEQ_FUNC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"JIT success (%.1fms): %s@%s:%ld -&gt; %s"</literal></expr></argument>,
<argument><expr><name>end_time</name> <operator>-</operator> <name>start_time</name></expr></argument>, <argument><expr><name>iseq_label</name></expr></argument>, <argument><expr><name>iseq_path</name></expr></argument>, <argument><expr><name>iseq_lineno</name></expr></argument>, <argument><expr><name>c_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>mjit_func_t</name><operator>)</operator><name>func</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>iseq_inline_storage_entry</name></name> <modifier>*</modifier></type><name>is_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>finish_p</name></decl>;</decl_stmt>
}</block></struct></type> <name>mjit_copy_job_t</name>;</typedef>



<decl_stmt><decl><type><specifier>static</specifier> <name>mjit_copy_job_t</name></type> <name>mjit_copy_job</name> <init>= <expr><block>{ <expr><operator>.</operator><name>iseq</name> <operator>=</operator> <name>NULL</name></expr>, <expr><operator>.</operator><name>finish_p</name> <operator>=</operator> <name>true</name></expr> }</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mjit_copy_job_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>int</name></type> <name>rb_workqueue_register</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_postponed_job_func_t</name></type></decl></parameter> , <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier><modifier>*</modifier></type>
<name>mjit_iseq_cc_entries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>body</name><operator>-&gt;</operator><name>jit_unit</name><operator>-&gt;</operator><name>cc_entries</name></name></expr>;</return>
</block_content>}</block></function>








<function><type><name>int</name></type>
<name>mjit_capture_cc_entries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>compiled_iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>captured_iseq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name> <init>= <expr><name><name>compiled_iseq</name><operator>-&gt;</operator><name>jit_unit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>new_entries_size</name> <init>= <expr><name><name>unit</name><operator>-&gt;</operator><name>cc_entries_size</name></name> <operator>+</operator> <name><name>captured_iseq</name><operator>-&gt;</operator><name>ci_size</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>captured_iseq</name><operator>-&gt;</operator><name>ci_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>cc_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cc_entries_index</name> <init>= <expr><name><name>unit</name><operator>-&gt;</operator><name>cc_entries_size</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>cc_entries_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>cc_entries</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>cc_entries</name></name> <operator>=</operator> <name>cc_entries</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_callcache</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>new_entries_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cc_entries</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cc_ptr</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>unit</name><operator>-&gt;</operator><name>cc_entries</name></name></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><name>cc_entries</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>cc_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_callcache</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>new_entries_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cc_entries</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>cc_entries</name></name> <operator>=</operator> <name>cc_entries</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cc_entries</name> <operator>+=</operator> <name>cc_entries_index</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>unit</name><operator>-&gt;</operator><name>cc_entries_size</name></name> <operator>=</operator> <name>new_entries_size</name></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>captured_iseq</name><operator>-&gt;</operator><name>ci_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>cc_entries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>captured_iseq</name><operator>-&gt;</operator><name>call_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>cc_entries_index</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>bool</name></type>
<name>mjit_copy_cache_from_main_thread</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name><name>union</name> <name>iseq_inline_storage_entry</name></name> <modifier>*</modifier></type><name>is_entries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mjit_copy_job_t</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><operator>&amp;</operator><name>mjit_copy_job</name></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in mjit_copy_cache_from_main_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>finish_p</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in mjit_copy_cache_from_main_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>is_entries</name></name> <operator>=</operator> <name>is_entries</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in mjit_copy_cache_from_main_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>in_jit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in_jit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>rb_native_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_client_wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>finish_p</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in mjit_copy_cache_from_main_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>mjit_opts</name><operator>.</operator><name>wait</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mjit_copy_job_handler</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>rb_workqueue_register</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mjit_copy_job_handler</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>job</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in MJIT copy job wait"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<while>while <condition>(<expr><operator>!</operator><name><name>job</name><operator>-&gt;</operator><name>finish_p</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>stop_worker_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_native_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_worker_wakeup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mjit_engine_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Getting wakeup from client"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in MJIT copy job wait"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in mjit_copy_cache_from_main_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>success_p</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>finish_p</name></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>finish_p</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>in_jit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>iseq</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>success_p</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in mjit_copy_cache_from_main_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>success_p</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>mjit_worker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>pch_status</name> <operator>==</operator> <name>PCH_NOT_READY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>make_pch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>pch_status</name> <operator>==</operator> <name>PCH_FAILED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mjit_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in worker to update worker_stopped"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>worker_stopped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Sending wakeup signal to client in a mjit-worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_native_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_client_wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in worker to update worker_stopped"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return> 
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><operator>!</operator><name>stop_worker_p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>unit</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in worker dequeue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><call><name>list_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unit_queue</name><operator>.</operator><name>head</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>active_units</name><operator>.</operator><name>length</name></name> <operator>&gt;=</operator> <name><name>mjit_opts</name><operator>.</operator><name>max_cache_size</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>stop_worker_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_native_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_worker_wakeup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mjit_engine_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Getting wakeup from client"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>unit</name> <operator>=</operator> <call><name>get_from_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unit_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in worker dequeue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>unit</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mjit_func_t</name></type> <name>func</name> <init>= <expr><call><name>convert_unit_to_func</name><argument_list>(<argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>mjit_compile_failures</name></expr></argument>, <argument><expr><name>func</name> <operator>==</operator> <operator>(</operator><name>mjit_func_t</name><operator>)</operator><name>NOT_COMPILED_JIT_ISEQ_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CRITICAL_SECTION_START</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in jit func replace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>in_gc</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>verbose</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Waiting wakeup from GC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_native_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mjit_gc_wakeup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mjit_engine_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name></name></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>func</name> <operator>&gt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>LAST_JIT_ISEQ_FUNC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_to_list</name><argument_list>(<argument><expr><name>unit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>active_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MJIT_ATOMIC_SET</name><argument_list>(<argument><expr><name><name>unit</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>jit_func</name></name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>free_unit</name><argument_list>(<argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>CRITICAL_SECTION_FINISH</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"in jit func replace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>mjit_opts</name><operator>.</operator><name>wait</name></name> <operator>&amp;&amp;</operator> <name><name>unit_queue</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>active_units</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator>
<operator>||</operator> <name><name>active_units</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name><name>mjit_opts</name><operator>.</operator><name>max_cache_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>compact_all_jit_code</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>


<expr_stmt><expr><name>worker_stopped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
