<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\bignum.c">










<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRINGS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_IEEEFP_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ieeefp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBGMP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GMP_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_GMP</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gmp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/bignum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/complex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/sanitizers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/warnings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/thread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_BIGNUM_TYPE_P</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RB_TYPE_P((x), T_BIGNUM)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>ruby_digitmap</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789abcdefghijklmnopqrstuvwxyz"</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SIZEOF_BDIGIT_DBL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name><operator>*</operator><literal type="number">2</literal> <operator>&lt;=</operator> <name>SIZEOF_LONG_LONG</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_BDIGIT_DBL</name></cpp:macro> <cpp:value>SIZEOF_LONG_LONG</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_BDIGIT_DBL</name></cpp:macro> <cpp:value>SIZEOF_LONG</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>sizeof_bdigit_dbl</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT_DBL</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>SIZEOF_BDIGIT_DBL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>sizeof_bdigit_dbl_signed</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT_DBL_SIGNED</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>SIZEOF_BDIGIT_DBL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>sizeof_bdigit</name></expr></argument>, <argument><expr><name>SIZEOF_BDIGIT</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>sizeof_bdigit_and_dbl</name></expr></argument>, <argument><expr><name>SIZEOF_BDIGIT</name><operator>*</operator><literal type="number">2</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT_DBL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>bdigit_signedness</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>bdigit_dbl_signedness</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>bdigit_dbl_signed_signedness</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>&gt;</operator> <operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>rbignum_embed_len_max</name></expr></argument>, <argument><expr><name>BIGNUM_EMBED_LEN_MAX</name> <operator>&lt;=</operator> <operator>(</operator><name>BIGNUM_EMBED_LEN_MASK</name> <operator>&gt;&gt;</operator> <name>BIGNUM_EMBED_LEN_SHIFT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>sizeof_long_and_sizeof_bdigit</name></expr></argument>, <argument><expr><name>SIZEOF_LONG</name> <operator>%</operator> <name>SIZEOF_BDIGIT</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>sizeof_long_and_sizeof_bdigit</name></expr></argument>, <argument><expr><name>SIZEOF_BDIGIT</name> <operator>%</operator> <name>SIZEOF_LONG</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOST_BIGENDIAN_P</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOST_BIGENDIAN_P</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSHIFTABLE</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((n) &lt; sizeof(d) * CHAR_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LSHIFTX</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!LSHIFTABLE(d, n) ? 0 : ((d) &lt;&lt; (!LSHIFTABLE(d, n) ? 0 : (n))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_LOWBITS</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>numbits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((d) &amp; LSHIFTX(~((d)*0), (numbits)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILL_LOWBITS</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>numbits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((d) | (LSHIFTX(((d)*0+1), (numbits))-1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POW2_P</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x)&amp;((x)-1))==0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BDIGITS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BIGNUM_DIGITS(x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITSPERDIG</name></cpp:macro> <cpp:value>(SIZEOF_BDIGIT*CHAR_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGRAD</name></cpp:macro> <cpp:value>((BDIGIT_DBL)1 &lt;&lt; BITSPERDIG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGRAD_HALF</name></cpp:macro> <cpp:value>((BDIGIT)(BIGRAD &gt;&gt; 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BDIGIT_MSB</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((d) &amp; BIGRAD_HALF) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGUP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LSHIFTX(((x) + (BDIGIT_DBL)0), BITSPERDIG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGDN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RSHIFT((x),BITSPERDIG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGLO</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((BDIGIT)((x) &amp; BDIGMAX))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BDIGMAX</name></cpp:macro> <cpp:value>((BDIGIT)(BIGRAD-1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BDIGIT_DBL_MAX</name></cpp:macro> <cpp:value>(~(BDIGIT_DBL)0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swap_bdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>swap16(x)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swap_bdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>swap32(x)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swap_bdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>swap64(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGZEROP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BIGNUM_LEN(x) == 0 || (BDIGITS(x)[0] == 0 &amp;&amp; (BIGNUM_LEN(x) == 1 || bigzero_p(x))))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGSIZE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BIGNUM_LEN(x) == 0 ? (size_t)0 : BDIGITS(x)[BIGNUM_LEN(x)-1] ? (size_t)(BIGNUM_LEN(x)*SIZEOF_BDIGIT - nlz(BDIGITS(x)[BIGNUM_LEN(x)-1])/CHAR_BIT) : rb_absint_size(x, NULL))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGDIVREM_EXTRA_WORDS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bdigit_roomof</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>roomof(n, SIZEOF_BDIGIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARY_ARGS</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ary, numberof(ary)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARY_ADD</name><parameter_list>(<parameter><type><name>z</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bary_add(BARY_ARGS(z), BARY_ARGS(x), BARY_ARGS(y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARY_SUB</name><parameter_list>(<parameter><type><name>z</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bary_sub(BARY_ARGS(z), BARY_ARGS(x), BARY_ARGS(y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARY_SHORT_MUL</name><parameter_list>(<parameter><type><name>z</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bary_short_mul(BARY_ARGS(z), BARY_ARGS(x), BARY_ARGS(y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARY_DIVMOD</name><parameter_list>(<parameter><type><name>q</name></type></parameter>, <parameter><type><name>r</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bary_divmod(BARY_ARGS(q), BARY_ARGS(r), BARY_ARGS(x), BARY_ARGS(y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARY_ZERO_P</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bary_zero_p(BARY_ARGS(x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGNUM_SET_NEGATIVE_SIGN</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BIGNUM_SET_SIGN(b, 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGNUM_SET_POSITIVE_SIGN</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BIGNUM_SET_SIGN(b, 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bignew</name><parameter_list>(<parameter><type><name>len</name></type></parameter>,<parameter><type><name>sign</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bignew_1(rb_cInteger,(len),(sign))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BDIGITS_ZERO</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { BDIGIT *bdigitz_zero_ptr = (ptr); size_t bdigitz_zero_n = (n); while (bdigitz_zero_n) { *bdigitz_zero_ptr++ = 0; bdigitz_zero_n--; } } while (0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARY_TRUNC</name><parameter_list>(<parameter><type><name>ds</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { while (0 &lt; (n) &amp;&amp; (ds)[(n)-1] == 0) (n)--; } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KARATSUBA_BALANCED</name><parameter_list>(<parameter><type><name>xn</name></type></parameter>, <parameter><type><name>yn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((yn)/2 &lt; (xn))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOOM3_BALANCED</name><parameter_list>(<parameter><type><name>xn</name></type></parameter>, <parameter><type><name>yn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((yn)+2)/3 * 2 &lt; (xn))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMP_MUL_DIGITS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KARATSUBA_MUL_DIGITS</name></cpp:macro> <cpp:value>70</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOOM3_MUL_DIGITS</name></cpp:macro> <cpp:value>150</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMP_DIV_DIGITS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMP_BIG2STR_DIGITS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMP_STR2BIG_DIGITS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAIVE_MUL_DIGITS</name></cpp:macro> <cpp:value>GMP_MUL_DIGITS</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAIVE_MUL_DIGITS</name></cpp:macro> <cpp:value>KARATSUBA_MUL_DIGITS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <function_decl><type><name>void</name></type> (<name>mulfunc_t</name>)<parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>mulfunc_t</name></type> <name>bary_mul_toom3_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>mulfunc_t</name></type> <name>bary_mul_karatsuba_start</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>BDIGIT</name></type> <name>bigdivrem_single</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>y</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bary_divmod</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>rds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>bigmul0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bary_mul_toom3</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>bignew_1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>bigtrunc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>bigsq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bigdivmod</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>divp</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>modp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>power_cache_get_power</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>power_level</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>numdigits_ret</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;=</operator> <name>SIZEOF_INT</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nlz</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>nlz_int</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>x</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>SIZEOF_INT</name><operator>-</operator><name>SIZEOF_BDIGIT</name><operator>)</operator> <operator>*</operator> <name>CHAR_BIT</name></expr>;</return> </block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nlz</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>nlz_long</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>x</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>SIZEOF_LONG</name><operator>-</operator><name>SIZEOF_BDIGIT</name><operator>)</operator> <operator>*</operator> <name>CHAR_BIT</name></expr>;</return> </block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;=</operator> <name>SIZEOF_LONG_LONG</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nlz</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>nlz_long_long</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>LONG_LONG</name><operator>)</operator><name>x</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>SIZEOF_LONG_LONG</name><operator>-</operator><name>SIZEOF_BDIGIT</name><operator>)</operator> <operator>*</operator> <name>CHAR_BIT</name></expr>;</return> </block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;=</operator> <name>SIZEOF_INT128_T</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nlz</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>nlz_int128</name><argument_list>(<argument><expr><operator>(</operator><name>uint128_t</name><operator>)</operator><name>x</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>SIZEOF_INT128_T</name><operator>-</operator><name>SIZEOF_BDIGIT</name><operator>)</operator> <operator>*</operator> <name>CHAR_BIT</name></expr>;</return> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U16</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint16_t)(a))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U32</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint32_t)(a))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT64_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U64</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((uint64_t)(a) &lt;&lt; 32) | (b))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT128_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U128</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((uint128_t)U64(a,b) &lt;&lt; 64) | U64(c,d))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>













































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT_DBL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>maxpow16_exp</name><index>[<expr><literal type="number">35</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">15</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>,
<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>maxpow16_num</name><index>[<expr><literal type="number">35</literal></expr>]</index></name> <init>= <expr><block>{
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00008000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x0000e6a9</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00004000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00003d09</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x0000b640</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x000041a7</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00008000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x0000e6a9</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00002710</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00003931</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00005100</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00006f91</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00009610</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x0000c5c1</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00001000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00001331</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x000016c8</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00001acb</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00001f40</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x0000242d</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00002998</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00002f87</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00003600</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00003d09</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x000044a8</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00004ce3</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x000055c0</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00005f45</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00006978</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x0000745f</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00008000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00008c61</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x00009988</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x0000a77b</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U16</name><argument_list>(<argument><expr><literal type="number">0x0000b640</literal></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT_DBL</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>maxpow32_exp</name><index>[<expr><literal type="number">35</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">31</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>,
<expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>maxpow32_num</name><index>[<expr><literal type="number">35</literal></expr>]</index></name> <init>= <expr><block>{
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x80000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0xcfd41b91</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x40000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x48c27395</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x81bf1000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x75db9c97</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x40000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0xcfd41b91</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x3b9aca00</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x8c8b6d2b</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x19a10000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x309f1021</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x57f6c100</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x98c29b81</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x10000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x18754571</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x247dbc80</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x3547667b</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x4c4b4000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x6b5a6e1d</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x94ace180</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0xcaf18367</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x0b640000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x0e8d4a51</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x1269ae40</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x17179149</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x1cb91000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x23744899</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x2b73a840</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x34e63b41</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x40000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x4cfa3cc1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x5c13d840</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x6d91b519</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U32</name><argument_list>(<argument><expr><literal type="number">0x81bf1000</literal></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT_DBL</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_UINT64_T</name></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>maxpow64_exp</name><index>[<expr><literal type="number">35</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">63</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>,
<expr><literal type="number">15</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>,
<expr><literal type="number">12</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>maxpow64_num</name><index>[<expr><literal type="number">35</literal></expr>]</index></name> <init>= <expr><block>{
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x80000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0xa8b8b452</literal></expr></argument>,<argument><expr><literal type="number">0x291fe821</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x40000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x6765c793</literal></expr></argument>,<argument><expr><literal type="number">0xfa10079d</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x41c21cb8</literal></expr></argument>,<argument><expr><literal type="number">0xe1000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x36427987</literal></expr></argument>,<argument><expr><literal type="number">0x50226111</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x80000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0xa8b8b452</literal></expr></argument>,<argument><expr><literal type="number">0x291fe821</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x8ac72304</literal></expr></argument>,<argument><expr><literal type="number">0x89e80000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x4d28cb56</literal></expr></argument>,<argument><expr><literal type="number">0xc33fa539</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x1eca170c</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x780c7372</literal></expr></argument>,<argument><expr><literal type="number">0x621bd74d</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x1e39a505</literal></expr></argument>,<argument><expr><literal type="number">0x7d810000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x5b27ac99</literal></expr></argument>,<argument><expr><literal type="number">0x3df97701</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x10000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x27b95e99</literal></expr></argument>,<argument><expr><literal type="number">0x7e21d9f1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x5da0e1e5</literal></expr></argument>,<argument><expr><literal type="number">0x3c5c8000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0xd2ae3299</literal></expr></argument>,<argument><expr><literal type="number">0xc1c4aedb</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x16bcc41e</literal></expr></argument>,<argument><expr><literal type="number">0x90000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x2d04b7fd</literal></expr></argument>,<argument><expr><literal type="number">0xd9c0ef49</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x5658597b</literal></expr></argument>,<argument><expr><literal type="number">0xcaa24000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0xa0e20737</literal></expr></argument>,<argument><expr><literal type="number">0x37609371</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x0c29e980</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x14adf4b7</literal></expr></argument>,<argument><expr><literal type="number">0x320334b9</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x226ed364</literal></expr></argument>,<argument><expr><literal type="number">0x78bfa000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x383d9170</literal></expr></argument>,<argument><expr><literal type="number">0xb85ff80b</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x5a3c23e3</literal></expr></argument>,<argument><expr><literal type="number">0x9c000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x8e651373</literal></expr></argument>,<argument><expr><literal type="number">0x88122bcd</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0xdd41bb36</literal></expr></argument>,<argument><expr><literal type="number">0xd259e000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x0aee5720</literal></expr></argument>,<argument><expr><literal type="number">0xee830681</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x10000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x172588ad</literal></expr></argument>,<argument><expr><literal type="number">0x4f5f0981</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x211e44f7</literal></expr></argument>,<argument><expr><literal type="number">0xd02c1000</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x2ee56725</literal></expr></argument>,<argument><expr><literal type="number">0xf06e5c71</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U64</name><argument_list>(<argument><expr><literal type="number">0x41c21cb8</literal></expr></argument>,<argument><expr><literal type="number">0xe1000000</literal></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT_DBL</name> <operator>==</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_UINT128_T</name></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>maxpow128_exp</name><index>[<expr><literal type="number">35</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">127</literal></expr>, <expr><literal type="number">80</literal></expr>, <expr><literal type="number">63</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>,
<expr><literal type="number">30</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">24</literal></expr>,
<expr><literal type="number">24</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint128_t</name></type> <name><name>maxpow128_num</name><index>[<expr><literal type="number">35</literal></expr>]</index></name> <init>= <expr><block>{
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x80000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x6f32f1ef</literal></expr></argument>,<argument><expr><literal type="number">0x8b18a2bc</literal></expr></argument>,<argument><expr><literal type="number">0x3cea5978</literal></expr></argument>,<argument><expr><literal type="number">0x9c79d441</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x40000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0xd0cf4b50</literal></expr></argument>,<argument><expr><literal type="number">0xcfe20765</literal></expr></argument>,<argument><expr><literal type="number">0xfff4b4e3</literal></expr></argument>,<argument><expr><literal type="number">0xf741cf6d</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x6558e2a0</literal></expr></argument>,<argument><expr><literal type="number">0x921fe069</literal></expr></argument>,<argument><expr><literal type="number">0x42860000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x5080c7b7</literal></expr></argument>,<argument><expr><literal type="number">0xd0e31ba7</literal></expr></argument>,<argument><expr><literal type="number">0x5911a67d</literal></expr></argument>,<argument><expr><literal type="number">0xdd3d35e7</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x40000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x6f32f1ef</literal></expr></argument>,<argument><expr><literal type="number">0x8b18a2bc</literal></expr></argument>,<argument><expr><literal type="number">0x3cea5978</literal></expr></argument>,<argument><expr><literal type="number">0x9c79d441</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x4b3b4ca8</literal></expr></argument>,<argument><expr><literal type="number">0x5a86c47a</literal></expr></argument>,<argument><expr><literal type="number">0x098a2240</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0xffd1390a</literal></expr></argument>,<argument><expr><literal type="number">0x0adc2fb8</literal></expr></argument>,<argument><expr><literal type="number">0xdabbb817</literal></expr></argument>,<argument><expr><literal type="number">0x4d95c99b</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x2c6fdb36</literal></expr></argument>,<argument><expr><literal type="number">0x4c25e6c0</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x384bacd6</literal></expr></argument>,<argument><expr><literal type="number">0x42c343b4</literal></expr></argument>,<argument><expr><literal type="number">0xe90c4272</literal></expr></argument>,<argument><expr><literal type="number">0x13506d29</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x31f5db32</literal></expr></argument>,<argument><expr><literal type="number">0xa34aced6</literal></expr></argument>,<argument><expr><literal type="number">0x0bf13a0e</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x20753ada</literal></expr></argument>,<argument><expr><literal type="number">0xfd1e839f</literal></expr></argument>,<argument><expr><literal type="number">0x53686d01</literal></expr></argument>,<argument><expr><literal type="number">0x3143ee01</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x10000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x68ca11d6</literal></expr></argument>,<argument><expr><literal type="number">0xb4f6d1d1</literal></expr></argument>,<argument><expr><literal type="number">0xfaa82667</literal></expr></argument>,<argument><expr><literal type="number">0x8073c2f1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x223e493b</literal></expr></argument>,<argument><expr><literal type="number">0xb3bb69ff</literal></expr></argument>,<argument><expr><literal type="number">0xa4b87d6c</literal></expr></argument>,<argument><expr><literal type="number">0x40000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0xad62418d</literal></expr></argument>,<argument><expr><literal type="number">0x14ea8247</literal></expr></argument>,<argument><expr><literal type="number">0x01c4b488</literal></expr></argument>,<argument><expr><literal type="number">0x6cc66f59</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x2863c1f5</literal></expr></argument>,<argument><expr><literal type="number">0xcdae42f9</literal></expr></argument>,<argument><expr><literal type="number">0x54000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0xa63fd833</literal></expr></argument>,<argument><expr><literal type="number">0xb9386b07</literal></expr></argument>,<argument><expr><literal type="number">0x36039e82</literal></expr></argument>,<argument><expr><literal type="number">0xbe651b25</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x1d1f7a9c</literal></expr></argument>,<argument><expr><literal type="number">0xd087a14d</literal></expr></argument>,<argument><expr><literal type="number">0x28cdf3d5</literal></expr></argument>,<argument><expr><literal type="number">0x10000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x651b5095</literal></expr></argument>,<argument><expr><literal type="number">0xc2ea8fc1</literal></expr></argument>,<argument><expr><literal type="number">0xb30e2c57</literal></expr></argument>,<argument><expr><literal type="number">0x77aaf7e1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x0ddef20e</literal></expr></argument>,<argument><expr><literal type="number">0xff760000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x29c30f10</literal></expr></argument>,<argument><expr><literal type="number">0x29939b14</literal></expr></argument>,<argument><expr><literal type="number">0x6664242d</literal></expr></argument>,<argument><expr><literal type="number">0x97d9f649</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x786a435a</literal></expr></argument>,<argument><expr><literal type="number">0xe9558b0e</literal></expr></argument>,<argument><expr><literal type="number">0x6aaf6d63</literal></expr></argument>,<argument><expr><literal type="number">0xa8000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x0c5afe6f</literal></expr></argument>,<argument><expr><literal type="number">0xf302bcbf</literal></expr></argument>,<argument><expr><literal type="number">0x94fd9829</literal></expr></argument>,<argument><expr><literal type="number">0xd87f5079</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x1fce575c</literal></expr></argument>,<argument><expr><literal type="number">0xe1692706</literal></expr></argument>,<argument><expr><literal type="number">0x07100000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x4f34497c</literal></expr></argument>,<argument><expr><literal type="number">0x8597e144</literal></expr></argument>,<argument><expr><literal type="number">0x36e91802</literal></expr></argument>,<argument><expr><literal type="number">0x00528229</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0xbf3a8e1d</literal></expr></argument>,<argument><expr><literal type="number">0x41ef2170</literal></expr></argument>,<argument><expr><literal type="number">0x7802130d</literal></expr></argument>,<argument><expr><literal type="number">0x84000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x0e7819e1</literal></expr></argument>,<argument><expr><literal type="number">0x7f1eb0fb</literal></expr></argument>,<argument><expr><literal type="number">0x6ee4fb89</literal></expr></argument>,<argument><expr><literal type="number">0x01d9531f</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x20000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x4510460d</literal></expr></argument>,<argument><expr><literal type="number">0xd9e879c0</literal></expr></argument>,<argument><expr><literal type="number">0x14a82375</literal></expr></argument>,<argument><expr><literal type="number">0x2f22b321</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x91abce3c</literal></expr></argument>,<argument><expr><literal type="number">0x4b4117ad</literal></expr></argument>,<argument><expr><literal type="number">0xe76d35db</literal></expr></argument>,<argument><expr><literal type="number">0x22000000</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x08973ea3</literal></expr></argument>,<argument><expr><literal type="number">0x55d75bc2</literal></expr></argument>,<argument><expr><literal type="number">0x2e42c391</literal></expr></argument>,<argument><expr><literal type="number">0x727d69e1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>U128</name><argument_list>(<argument><expr><literal type="number">0x10e425c5</literal></expr></argument>,<argument><expr><literal type="number">0x6daffabc</literal></expr></argument>,<argument><expr><literal type="number">0x35c10000</literal></expr></argument>,<argument><expr><literal type="number">0x00000000</literal></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>BDIGIT_DBL</name></type>
<name>maxpow_in_bdigit_dbl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>exp_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>maxpow</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exponent</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>&lt;=</operator> <name>base</name> <operator>&amp;&amp;</operator> <name>base</name> <operator>&lt;=</operator> <literal type="number">36</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT_DBL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>
<expr_stmt><expr><name>maxpow</name> <operator>=</operator> <name><name>maxpow16_num</name><index>[<expr><name>base</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>exponent</name> <operator>=</operator> <name><name>maxpow16_exp</name><index>[<expr><name>base</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT_DBL</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:elif>
<expr_stmt><expr><name>maxpow</name> <operator>=</operator> <name><name>maxpow32_num</name><index>[<expr><name>base</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>exponent</name> <operator>=</operator> <name><name>maxpow32_exp</name><index>[<expr><name>base</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT_DBL</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_UINT64_T</name></expr></cpp:elif>
<expr_stmt><expr><name>maxpow</name> <operator>=</operator> <name><name>maxpow64_num</name><index>[<expr><name>base</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>exponent</name> <operator>=</operator> <name><name>maxpow64_exp</name><index>[<expr><name>base</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_BDIGIT_DBL</name> <operator>==</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_UINT128_T</name></expr></cpp:elif>
<expr_stmt><expr><name>maxpow</name> <operator>=</operator> <name><name>maxpow128_num</name><index>[<expr><name>base</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>exponent</name> <operator>=</operator> <name><name>maxpow128_exp</name><index>[<expr><name>base</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>maxpow</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>exponent</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>maxpow</name> <operator>&lt;=</operator> <name>BDIGIT_DBL_MAX</name> <operator>/</operator> <name>base</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maxpow</name> <operator>*=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>exponent</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<expr_stmt><expr><operator>*</operator><name>exp_ret</name> <operator>=</operator> <name>exponent</name></expr>;</expr_stmt>
<return>return <expr><name>maxpow</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>BDIGIT_DBL</name></type>
<name>bary2bdigitdbl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>ds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <call><name>BIGUP</name><argument_list>(<argument><expr><name><name>ds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>ds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>bdigitdbl2bary</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BDIGIT_DBL</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>yn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;</operator> <name>yn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>yds</name><index>[<expr><name>yn</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>xn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>yds</name><index>[<expr><name>yn</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BDIGIT</name></type>
<name>bary_small_lshift</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shift</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>shift</name> <operator>&amp;&amp;</operator> <name>shift</name> <operator>&lt;</operator> <name>BITSPERDIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name>num</name> <operator>|</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><operator>*</operator><name>xds</name><operator>++</operator> <operator>&lt;&lt;</operator> <name>shift</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>zds</name><operator>++</operator> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_small_rshift</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shift</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>higher_bdigit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>shift</name> <operator>&amp;&amp;</operator> <name>shift</name> <operator>&lt;</operator> <name>BITSPERDIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGUP</name><argument_list>(<argument><expr><name>higher_bdigit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>x</name> <init>= <expr><name><name>xds</name><index>[<expr><name>n</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>num</name> <operator>|</operator> <name>x</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>shift</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>n</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGUP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_zero_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>xds</name><index>[<expr><operator>--</operator><name>xn</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>xn</name></expr>)</condition>;</do>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_neg</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ds</name><index>[<expr><name>n</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><operator>~</operator><name><name>ds</name><index>[<expr><name>n</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_2comp</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>non_zero</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>non_zero</name>:</label>
<expr_stmt><expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><operator>~</operator><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><operator>~</operator><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_swap</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>ds</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><name>ds</name> <operator>+</operator> <name>num_bdigits</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>p1</name> <operator>&lt;</operator> <name>p2</name></expr>;</condition> <incr><expr><name>p1</name><operator>++</operator></expr><operator>,</operator> <expr><name>p2</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>p1</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>p1</name> <operator>=</operator> <operator>*</operator><name>p2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p2</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEGER_PACK_WORDORDER_MASK</name></cpp:macro> <cpp:value>(INTEGER_PACK_MSWORD_FIRST | INTEGER_PACK_LSWORD_FIRST)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEGER_PACK_BYTEORDER_MASK</name></cpp:macro> <cpp:value>(INTEGER_PACK_MSBYTE_FIRST | INTEGER_PACK_LSBYTE_FIRST | INTEGER_PACK_NATIVE_BYTE_ORDER)</cpp:value></cpp:define>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_integer_pack_format</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>supported_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>wordorder_bits</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_WORDORDER_MASK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>byteorder_bits</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_BYTEORDER_MASK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>supported_flags</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unsupported flags specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>wordorder_bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>numwords</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"word order not specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>wordorder_bits</name> <operator>!=</operator> <name>INTEGER_PACK_MSWORD_FIRST</name> <operator>&amp;&amp;</operator>
<name>wordorder_bits</name> <operator>!=</operator> <name>INTEGER_PACK_LSWORD_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected word order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>byteorder_bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"byte order not specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>byteorder_bits</name> <operator>!=</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name> <operator>&amp;&amp;</operator>
<name>byteorder_bits</name> <operator>!=</operator> <name>INTEGER_PACK_LSBYTE_FIRST</name> <operator>&amp;&amp;</operator>
<name>byteorder_bits</name> <operator>!=</operator> <name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected byte order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid wordsize: %"</literal><name>PRI_SIZE_PREFIX</name><literal type="string">"u"</literal></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>SSIZE_MAX</name> <operator>&lt;</operator> <name>wordsize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big wordsize: %"</literal><name>PRI_SIZE_PREFIX</name><literal type="string">"u"</literal></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>&lt;=</operator> <name>nails</name> <operator>/</operator> <name>CHAR_BIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big nails: %"</literal><name>PRI_SIZE_PREFIX</name><literal type="string">"u"</literal></expr></argument>, <argument><expr><name>nails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>SIZE_MAX</name> <operator>/</operator> <name>wordsize</name> <operator>&lt;</operator> <name>numwords</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big numwords * wordsize: %"</literal><name>PRI_SIZE_PREFIX</name><literal type="string">"u * %"</literal><name>PRI_SIZE_PREFIX</name><literal type="string">"u"</literal></expr></argument>, <argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>integer_pack_loop_setup</name><parameter_list>(
<parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>word_num_fullbytes_ret</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>word_num_partialbits_ret</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>word_start_ret</name></decl></parameter>,
<parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>word_step_ret</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>word_last_ret</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>byte_start_ret</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>byte_step_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>wordorder_bits</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_WORDORDER_MASK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>byteorder_bits</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_BYTEORDER_MASK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>word_num_fullbytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>word_num_partialbits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>word_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>word_step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>word_last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>byte_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>byte_step</name></decl>;</decl_stmt>

<expr_stmt><expr><name>word_num_partialbits</name> <operator>=</operator> <name>CHAR_BIT</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>nails</name> <operator>%</operator> <name>CHAR_BIT</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>word_num_partialbits</name> <operator>==</operator> <name>CHAR_BIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>word_num_partialbits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>word_num_fullbytes</name> <operator>=</operator> <name>wordsize</name> <operator>-</operator> <operator>(</operator><name>nails</name> <operator>/</operator> <name>CHAR_BIT</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>word_num_partialbits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>word_num_fullbytes</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wordorder_bits</name> <operator>==</operator> <name>INTEGER_PACK_MSWORD_FIRST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>word_start</name> <operator>=</operator> <name>wordsize</name><operator>*</operator><operator>(</operator><name>numwords</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>word_step</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>ssize_t</name><operator>)</operator><name>wordsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>word_last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>word_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>word_step</name> <operator>=</operator> <name>wordsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>word_last</name> <operator>=</operator> <name>wordsize</name><operator>*</operator><operator>(</operator><name>numwords</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>byteorder_bits</name> <operator>==</operator> <name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>byteorder_bits</name> <operator>=</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>byteorder_bits</name> <operator>=</operator> <name>INTEGER_PACK_LSBYTE_FIRST</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>byteorder_bits</name> <operator>==</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>byte_start</name> <operator>=</operator> <name>wordsize</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>byte_step</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>byte_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>byte_step</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>word_num_partialbits_ret</name> <operator>=</operator> <name>word_num_partialbits</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>word_num_fullbytes_ret</name> <operator>=</operator> <name>word_num_fullbytes</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>word_start_ret</name> <operator>=</operator> <name>word_start</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>word_step_ret</name> <operator>=</operator> <name>word_step</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>word_last_ret</name> <operator>=</operator> <name>word_last</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>byte_start_ret</name> <operator>=</operator> <name>byte_start</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>byte_step_ret</name> <operator>=</operator> <name>byte_step</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>integer_pack_fill_dd</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier><modifier>*</modifier></type><name>dpp</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier><modifier>*</modifier></type><name>dep</name></decl></parameter>, <parameter><decl><type><name>BDIGIT_DBL</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numbits_in_dd_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dpp</name> <operator>&lt;</operator> <operator>*</operator><name>dep</name> <operator>&amp;&amp;</operator> <name>BITSPERDIG</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ddp</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CHAR_BIT</name> <operator>-</operator> <operator>*</operator><name>numbits_in_dd_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ddp</name> <operator>|=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>*</operator><name>dpp</name><operator>)</operator><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <operator>*</operator><name>numbits_in_dd_p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>numbits_in_dd_p</name> <operator>+=</operator> <name>BITSPERDIG</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>dpp</name> <operator>==</operator> <operator>*</operator><name>dep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>numbits_in_dd_p</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ddp</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>BDIGIT_DBL</name></type>
<name>integer_pack_take_lowbits</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BDIGIT_DBL</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numbits_in_dd_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ddp</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ddp</name> <operator>&gt;&gt;=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>numbits_in_dd_p</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytes_2comp</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>c</name> <init>= <expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>signed</name> <name>int</name></type> <name>d</name> <init>= <expr><operator>~</operator><name>c</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>e</name> <init>= <expr><name>d</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_pack</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>dp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bufend</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <name>ds</name> <operator>+</operator> <name>num_bdigits</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>validate_integer_pack_format</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>INTEGER_PACK_MSWORD_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_LSWORD_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_MSBYTE_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_LSBYTE_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_NATIVE_BYTE_ORDER</name><operator>|</operator>
<name>INTEGER_PACK_2COMP</name><operator>|</operator>
<name>INTEGER_PACK_FORCE_GENERIC_IMPLEMENTATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>de</name> <operator>&amp;&amp;</operator> <name><name>de</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>de</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>==</operator> <name>de</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_FORCE_GENERIC_IMPLEMENTATION</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<macro><name>MEMZERO</name><argument_list>(<argument>words</argument>, <argument>unsigned char</argument>, <argument>numwords * wordsize</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nails</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numwords</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>need_swap</name> <init>= <expr><name>wordsize</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_BYTEORDER_MASK</name><operator>)</operator> <operator>!=</operator> <name>INTEGER_PACK_NATIVE_BYTE_ORDER</name> <operator>&amp;&amp;</operator>
<operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name><operator>)</operator></expr> ?</condition><then> <expr><operator>!</operator><name>HOST_BIGENDIAN_P</name></expr> </then><else>: <expr><name>HOST_BIGENDIAN_P</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>sign</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>d</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>words</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>d</name> <operator>=</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>||</operator> <call><name>CLEAR_LOWBITS</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>sign</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT16_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>d</name> <operator>=</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>need_swap</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>swap16</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>words</name><operator>)</operator> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>||</operator> <call><name>CLEAR_LOWBITS</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>sign</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT32_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">4</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>d</name> <operator>=</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>need_swap</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>swap32</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>words</name><operator>)</operator> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>||</operator> <call><name>CLEAR_LOWBITS</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>sign</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT64_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">8</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>d</name> <operator>=</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>need_swap</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>swap64</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>words</name><operator>)</operator> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>||</operator> <call><name>CLEAR_LOWBITS</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>sign</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else <block>{<block_content> 
<decl_stmt><decl><type><name>BDIGIT_DBL_SIGNED</name></type> <name>d</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>words</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>d</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>||</operator> <call><name>FILL_LOWBITS</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT16_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>d</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>need_swap</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>swap16</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>words</name><operator>)</operator> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>wordsize</name> <operator>==</operator> <name>SIZEOF_BDIGIT</name> <operator>&amp;&amp;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
<expr><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>||</operator> <call><name>FILL_LOWBITS</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT32_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">4</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>d</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>need_swap</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>swap32</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>words</name><operator>)</operator> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>wordsize</name> <operator>==</operator> <name>SIZEOF_BDIGIT</name> <operator>&amp;&amp;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
<expr><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>||</operator> <call><name>FILL_LOWBITS</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT64_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">8</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>d</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>need_swap</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>swap64</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>words</name><operator>)</operator> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>wordsize</name> <operator>==</operator> <name>SIZEOF_BDIGIT</name> <operator>&amp;&amp;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
<expr><ternary><condition><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>de</name> <operator>-</operator> <name>dp</name> <operator>||</operator> <call><name>FILL_LOWBITS</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>nails</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SIZEOF_BDIGIT</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator>
<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_WORDORDER_MASK</name><operator>)</operator> <operator>==</operator> <name>INTEGER_PACK_LSWORD_FIRST</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_BYTEORDER_MASK</name><operator>)</operator> <operator>!=</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>src_size</name> <init>= <expr><operator>(</operator><name>de</name> <operator>-</operator> <name>dp</name><operator>)</operator> <operator>*</operator> <name>SIZEOF_BDIGIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>dst_size</name> <init>= <expr><name>numwords</name> <operator>*</operator> <name>wordsize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>overflow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>src_size</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>ds</name><operator>)</operator><index>[<expr><name>src_size</name><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>src_size</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>src_size</name> <operator>&lt;=</operator> <name>dst_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>words</name> <operator>+</operator> <name>src_size</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>dst_size</name> <operator>-</operator> <name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>dst_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>overflow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>zero_p</name> <init>= <expr><call><name>bytes_2comp</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>dst_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>zero_p</name> <operator>&amp;&amp;</operator> <name>overflow</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>dp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst_size</name> <operator>==</operator> <name>src_size</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<name><name>p</name><index>[<expr><name>dst_size</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>overflow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>sign</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>nails</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SIZEOF_BDIGIT</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator>
<name>wordsize</name> <operator>%</operator> <name>SIZEOF_BDIGIT</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>bdigits_per_word</name> <init>= <expr><name>wordsize</name> <operator>/</operator> <name>SIZEOF_BDIGIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>src_num_bdigits</name> <init>= <expr><name>de</name> <operator>-</operator> <name>dp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>dst_num_bdigits</name> <init>= <expr><name>numwords</name> <operator>*</operator> <name>bdigits_per_word</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>overflow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mswordfirst_p</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_MSWORD_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>msbytefirst_p</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NATIVE_BYTE_ORDER</name><operator>)</operator></expr> ?</condition><then> <expr><name>HOST_BIGENDIAN_P</name></expr> </then><else>:
<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_num_bdigits</name> <operator>&lt;=</operator> <name>dst_num_bdigits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>src_num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><operator>(</operator><name>BDIGIT</name><operator>*</operator><operator>)</operator><name>words</name> <operator>+</operator> <name>src_num_bdigits</name></expr></argument>, <argument><expr><name>dst_num_bdigits</name> <operator>-</operator> <name>src_num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>dst_num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>overflow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>zero_p</name> <init>= <expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>dst_num_bdigits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>zero_p</name> <operator>&amp;&amp;</operator> <name>overflow</name> <operator>&amp;&amp;</operator>
<name>dst_num_bdigits</name> <operator>==</operator> <name>src_num_bdigits</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<name><name>dp</name><index>[<expr><name>dst_num_bdigits</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>overflow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>msbytefirst_p</name> <operator>!=</operator> <name>HOST_BIGENDIAN_P</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dst_num_bdigits</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>d</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BDIGIT</name><operator>*</operator><operator>)</operator><name>words</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>BDIGIT</name><operator>*</operator><operator>)</operator><name>words</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <call><name>swap_bdigit</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>mswordfirst_p</name></expr> ?</condition><then> <expr><operator>!</operator><name>msbytefirst_p</name></expr> </then><else>: <expr><name>msbytefirst_p</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>words</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numwords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>bary_swap</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bdigits_per_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>bdigits_per_word</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mswordfirst_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_swap</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>dst_num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>sign</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>words</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufend</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>numwords</name> <operator>*</operator> <name>wordsize</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>bufend</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name><operator>)</operator> <operator>||</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>sign</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>de</name> <operator>-</operator> <name>dp</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>dp</name> <operator>==</operator> <name>de</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>bufend</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>de</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>&lt;</operator> <name>bufend</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>word_num_partialbits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>word_num_fullbytes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>word_step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>byte_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>byte_step</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>word_start</name></decl>, <decl><type ref="prev"/><name>word_last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>wordp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last_wordp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>dd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numbits_in_dd</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>integer_pack_loop_setup</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>word_num_fullbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_num_partialbits</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>word_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_step</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_last</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byte_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byte_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wordp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>word_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_wordp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>word_last</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>numbits_in_dd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILL_DD</name></cpp:macro> <cpp:value>integer_pack_fill_dd(&amp;dp, &amp;de, &amp;dd, &amp;numbits_in_dd)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAKE_LOWBITS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>integer_pack_take_lowbits(n, &amp;dd, &amp;numbits_in_dd)</cpp:value></cpp:define>


<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>index_in_word</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>bytep</name> <init>= <expr><name>wordp</name> <operator>+</operator> <name>byte_start</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>index_in_word</name> <operator>&lt;</operator> <name>word_num_fullbytes</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>FILL_DD</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>bytep</name> <operator>=</operator> <call><name>TAKE_LOWBITS</name><argument_list>(<argument><expr><name>CHAR_BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytep</name> <operator>+=</operator> <name>byte_step</name></expr>;</expr_stmt>
<expr_stmt><expr><name>index_in_word</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>word_num_partialbits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>FILL_DD</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>bytep</name> <operator>=</operator> <call><name>TAKE_LOWBITS</name><argument_list>(<argument><expr><name>word_num_partialbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytep</name> <operator>+=</operator> <name>byte_step</name></expr>;</expr_stmt>
<expr_stmt><expr><name>index_in_word</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>index_in_word</name> <operator>&lt;</operator> <name>wordsize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>bytep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bytep</name> <operator>+=</operator> <name>byte_step</name></expr>;</expr_stmt>
<expr_stmt><expr><name>index_in_word</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>wordp</name> <operator>==</operator> <name>last_wordp</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>wordp</name> <operator>+=</operator> <name>word_step</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>FILL_DD</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>!=</operator> <name>de</name> <operator>||</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>dd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sign</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>dd</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name><operator>)</operator> <operator>||</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>sign</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content> 

<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>de</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>dp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>de</name> <operator>-</operator> <name>dp</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> 
<call><name>POW2_P</name><argument_list>(<argument><expr><operator>*</operator><name>dp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numwords</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>word_num_partialbits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>word_num_fullbytes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>word_step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>byte_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>byte_step</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>word_start</name></decl>, <decl><type ref="prev"/><name>word_last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>wordp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last_wordp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>partialbits_mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>carry</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>integer_pack_loop_setup</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>word_num_fullbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_num_partialbits</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>word_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_step</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_last</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byte_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byte_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>partialbits_mask</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>word_num_partialbits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>words</name></expr>;</expr_stmt>
<expr_stmt><expr><name>wordp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>word_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_wordp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>word_last</name></expr>;</expr_stmt>

<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>index_in_word</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>bytep</name> <init>= <expr><name>wordp</name> <operator>+</operator> <name>byte_start</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>index_in_word</name> <operator>&lt;</operator> <name>word_num_fullbytes</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>carry</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>~</operator><operator>*</operator><name>bytep</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>bytep</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>carry</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> <operator>&gt;&gt;=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bytep</name> <operator>+=</operator> <name>byte_step</name></expr>;</expr_stmt>
<expr_stmt><expr><name>index_in_word</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>word_num_partialbits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>carry</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>bytep</name> <operator>&amp;</operator> <name>partialbits_mask</name><operator>)</operator> <operator>^</operator> <name>partialbits_mask</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>bytep</name> <operator>=</operator> <name>carry</name> <operator>&amp;</operator> <name>partialbits_mask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> <operator>&gt;&gt;=</operator> <name>word_num_partialbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bytep</name> <operator>+=</operator> <name>byte_step</name></expr>;</expr_stmt>
<expr_stmt><expr><name>index_in_word</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wordp</name> <operator>==</operator> <name>last_wordp</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>wordp</name> <operator>+=</operator> <name>word_step</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>sign</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FILL_DD</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TAKE_LOWBITS</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>integer_unpack_num_bdigits_small</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlp_bits_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>num_bits</name> <init>= <expr><operator>(</operator><name>wordsize</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>-</operator> <name>nails</name><operator>)</operator> <operator>*</operator> <name>numwords</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name> <init>= <expr><operator>(</operator><name>num_bits</name> <operator>+</operator> <name>BITSPERDIG</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>BITSPERDIG</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>nlp_bits_ret</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>num_bdigits</name> <operator>*</operator> <name>BITSPERDIG</name> <operator>-</operator> <name>num_bits</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>num_bdigits</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>integer_unpack_num_bdigits_generic</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlp_bits_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>





<decl_stmt><decl><type><name>size_t</name></type> <name>num_bytes1</name> <init>= <expr><name>wordsize</name> <operator>*</operator> <name>numwords</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>q1</name> <init>= <expr><name>numwords</name> <operator>/</operator> <name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>r1</name> <init>= <expr><name>numwords</name> <operator>%</operator> <name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>num_bytes2</name> <init>= <expr><name>num_bytes1</name> <operator>-</operator> <name>nails</name> <operator>*</operator> <name>q1</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>q2</name> <init>= <expr><name>nails</name> <operator>/</operator> <name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>r2</name> <init>= <expr><name>nails</name> <operator>%</operator> <name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>num_bytes3</name> <init>= <expr><name>num_bytes2</name> <operator>-</operator> <name>q2</name> <operator>*</operator> <name>r1</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>q3</name> <init>= <expr><name>num_bytes3</name> <operator>/</operator> <name>BITSPERDIG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>r3</name> <init>= <expr><name>num_bytes3</name> <operator>%</operator> <name>BITSPERDIG</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits1</name> <init>= <expr><name>CHAR_BIT</name> <operator>*</operator> <name>q3</name></expr></init></decl>;</decl_stmt>












<if_stmt><if>if <condition>(<expr><name>CHAR_BIT</name> <operator>*</operator> <name>r3</name> <operator>&gt;=</operator> <name>r1</name> <operator>*</operator> <name>r2</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tmp1</name> <init>= <expr><name>CHAR_BIT</name> <operator>*</operator> <name>BITSPERDIG</name> <operator>-</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>*</operator> <name>r3</name> <operator>-</operator> <name>r1</name> <operator>*</operator> <name>r2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>q4</name> <init>= <expr><name>tmp1</name> <operator>/</operator> <name>BITSPERDIG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r4</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>tmp1</name> <operator>%</operator> <name>BITSPERDIG</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits2</name> <init>= <expr><name>num_digits1</name> <operator>+</operator> <name>CHAR_BIT</name> <operator>-</operator> <name>q4</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>nlp_bits_ret</name> <operator>=</operator> <name>r4</name></expr>;</expr_stmt>
<return>return <expr><name>num_digits2</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tmp1</name> <init>= <expr><name>r1</name> <operator>*</operator> <name>r2</name> <operator>-</operator> <name>CHAR_BIT</name> <operator>*</operator> <name>r3</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>q4</name> <init>= <expr><name>tmp1</name> <operator>/</operator> <name>BITSPERDIG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r4</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>tmp1</name> <operator>%</operator> <name>BITSPERDIG</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits2</name> <init>= <expr><name>num_digits1</name> <operator>-</operator> <name>q4</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>nlp_bits_ret</name> <operator>=</operator> <name>r4</name></expr>;</expr_stmt>
<return>return <expr><name>num_digits2</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>integer_unpack_num_bdigits</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlp_bits_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>numwords</name> <operator>&lt;=</operator> <operator>(</operator><name>SIZE_MAX</name> <operator>-</operator> <operator>(</operator><name>BITSPERDIG</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>CHAR_BIT</name> <operator>/</operator> <name>wordsize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>integer_unpack_num_bdigits_small</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>nlp_bits_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_INTEGER_PACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nlp_bits1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits1</name> <init>= <expr><call><name>integer_unpack_num_bdigits_generic</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlp_bits1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>num_bdigits</name> <operator>==</operator> <name>num_bdigits1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>nlp_bits_ret</name> <operator>==</operator> <name>nlp_bits1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>integer_unpack_num_bdigits_generic</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>nlp_bits_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>num_bdigits</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>integer_unpack_push_bits</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numbits</name></decl></parameter>, <parameter><decl><type><name>BDIGIT_DBL</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numbits_in_dd_p</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier><modifier>*</modifier></type><name>dpp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>ddp</name><operator>)</operator> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name>data</name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><operator>*</operator><name>numbits_in_dd_p</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>numbits_in_dd_p</name> <operator>+=</operator> <name>numbits</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>BITSPERDIG</name> <operator>&lt;=</operator> <operator>*</operator><name>numbits_in_dd_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>dpp</name><operator>)</operator><operator>++</operator> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><operator>*</operator><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ddp</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><operator>*</operator><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>numbits_in_dd_p</name> <operator>-=</operator> <name>BITSPERDIG</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>integer_unpack_single_bdigit</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name></type> <name>u</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>dp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name><operator>)</operator></expr> ?</condition><then>
<expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>size</name> <operator>==</operator> <name>SIZEOF_BDIGIT</name> <operator>&amp;&amp;</operator> <name>u</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr> </then><else>:
<expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>u</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>size</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>|=</operator> <call><name>LSHIFTX</name><argument_list>(<argument><expr><name>BDIGMAX</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>CHAR_BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>~</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>dp</name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
<return>return <expr><name>sign</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BUILTIN___BUILTIN_ASSUME_ALIGNED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>reinterpret_cast</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(type) __builtin_assume_aligned((value), sizeof(*(type)NULL));</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>reinterpret_cast</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(type)value</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_unpack_internal</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>bdigits</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlp_bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>words</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>bdigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <name>dp</name> <operator>+</operator> <name>num_bdigits</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_FORCE_GENERIC_IMPLEMENTATION</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nails</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numwords</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>need_swap</name> <init>= <expr><name>wordsize</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_BYTEORDER_MASK</name><operator>)</operator> <operator>!=</operator> <name>INTEGER_PACK_NATIVE_BYTE_ORDER</name> <operator>&amp;&amp;</operator>
<operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name><operator>)</operator></expr> ?</condition><then> <expr><operator>!</operator><name>HOST_BIGENDIAN_P</name></expr> </then><else>: <expr><name>HOST_BIGENDIAN_P</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>integer_unpack_single_bdigit</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT16_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>u</name> <init>= <expr><operator>*</operator><call><name>reinterpret_cast</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>integer_unpack_single_bdigit</name><argument_list>(<argument><expr><ternary><condition><expr><name>need_swap</name></expr> ?</condition><then> <expr><call><name>swap16</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>u</name></expr></else></ternary></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT32_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">4</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>u</name> <init>= <expr><operator>*</operator><call><name>reinterpret_cast</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint32_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>integer_unpack_single_bdigit</name><argument_list>(<argument><expr><ternary><condition><expr><name>need_swap</name></expr> ?</condition><then> <expr><call><name>swap32</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>u</name></expr></else></ternary></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UINT64_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">8</literal> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>wordsize</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>words</name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name> <init>= <expr><operator>*</operator><call><name>reinterpret_cast</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint64_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>integer_unpack_single_bdigit</name><argument_list>(<argument><expr><ternary><condition><expr><name>need_swap</name></expr> ?</condition><then> <expr><call><name>swap64</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>u</name></expr></else></ternary></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>reinterpret_cast</name></cpp:undef>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>nails</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SIZEOF_BDIGIT</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator>
<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_WORDORDER_MASK</name><operator>)</operator> <operator>==</operator> <name>INTEGER_PACK_LSWORD_FIRST</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_BYTEORDER_MASK</name><operator>)</operator> <operator>!=</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>src_size</name> <init>= <expr><name>numwords</name> <operator>*</operator> <name>wordsize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>dst_size</name> <init>= <expr><name>num_bdigits</name> <operator>*</operator> <name>SIZEOF_BDIGIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>words</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>zero_p</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dp</name> <operator>+</operator> <name>src_size</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>dst_size</name> <operator>-</operator> <name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zero_p</name> <operator>=</operator> <call><name>bary_2comp</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><name>zero_p</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><name>src_size</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>CHAR_BIT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dp</name> <operator>+</operator> <name>src_size</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>dst_size</name> <operator>-</operator> <name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dp</name> <operator>+</operator> <name>src_size</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>dst_size</name> <operator>-</operator> <name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dp</name> <operator>+</operator> <name>src_size</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>dst_size</name> <operator>-</operator> <name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>sign</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>nails</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SIZEOF_BDIGIT</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator>
<name>wordsize</name> <operator>%</operator> <name>SIZEOF_BDIGIT</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>bdigits_per_word</name> <init>= <expr><name>wordsize</name> <operator>/</operator> <name>SIZEOF_BDIGIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mswordfirst_p</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_MSWORD_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>msbytefirst_p</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NATIVE_BYTE_ORDER</name><operator>)</operator></expr> ?</condition><then> <expr><name>HOST_BIGENDIAN_P</name></expr> </then><else>:
<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_MSBYTE_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>words</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>numwords</name><operator>*</operator><name>bdigits_per_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mswordfirst_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_swap</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>mswordfirst_p</name></expr> ?</condition><then> <expr><operator>!</operator><name>msbytefirst_p</name></expr> </then><else>: <expr><name>msbytefirst_p</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>dp</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numwords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>bary_swap</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bdigits_per_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>bdigits_per_word</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>msbytefirst_p</name> <operator>!=</operator> <name>HOST_BIGENDIAN_P</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>dp</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>de</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>d</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>swap_bdigit</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>zero_p</name> <init>= <expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><name>zero_p</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>BDIGIT_MSB</name><argument_list>(<argument><expr><name><name>de</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>sign</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num_bdigits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>word_num_partialbits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>word_num_fullbytes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>word_step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>byte_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>byte_step</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>word_start</name></decl>, <decl><type ref="prev"/><name>word_last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>wordp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last_wordp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>dd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numbits_in_dd</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>integer_pack_loop_setup</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>word_num_fullbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_num_partialbits</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>word_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_step</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_last</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byte_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byte_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wordp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>word_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_wordp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>word_last</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>numbits_in_dd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_BITS</name><parameter_list>(<parameter><type><name>data</name></type></parameter>, <parameter><type><name>numbits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>integer_unpack_push_bits(data, numbits, &amp;dd, &amp;numbits_in_dd, &amp;dp)</cpp:value></cpp:define>


<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>index_in_word</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>bytep</name> <init>= <expr><name>wordp</name> <operator>+</operator> <name>byte_start</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>index_in_word</name> <operator>&lt;</operator> <name>word_num_fullbytes</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PUSH_BITS</name><argument_list>(<argument><expr><operator>*</operator><name>bytep</name></expr></argument>, <argument><expr><name>CHAR_BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytep</name> <operator>+=</operator> <name>byte_step</name></expr>;</expr_stmt>
<expr_stmt><expr><name>index_in_word</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>word_num_partialbits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PUSH_BITS</name><argument_list>(<argument><expr><operator>*</operator><name>bytep</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>word_num_partialbits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>word_num_partialbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytep</name> <operator>+=</operator> <name>byte_step</name></expr>;</expr_stmt>
<expr_stmt><expr><name>index_in_word</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wordp</name> <operator>==</operator> <name>last_wordp</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>wordp</name> <operator>+=</operator> <name>word_step</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>dd</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><name>dd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dp</name> <operator>&lt;=</operator> <name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>de</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PUSH_BITS</name></cpp:undef>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_2COMP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nlp_bits</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>bdigits</name><index>[<expr><name>num_bdigits</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>BITSPERDIG</name> <operator>-</operator> <name>nlp_bits</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bdigits</name><index>[<expr><name>num_bdigits</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>BDIGMAX</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>BITSPERDIG</name> <operator>-</operator> <name>nlp_bits</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_NEGATIVE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><call><name>bary_zero_p</name><argument_list>(<argument><expr><name>bdigits</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num_bdigits</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>BDIGIT_MSB</name><argument_list>(<argument><expr><name><name>bdigits</name><index>[<expr><name>num_bdigits</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>num_bdigits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>bdigits</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>sign</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_unpack</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>bdigits</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nlp_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>validate_integer_pack_format</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>INTEGER_PACK_MSWORD_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_LSWORD_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_MSBYTE_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_LSBYTE_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_NATIVE_BYTE_ORDER</name><operator>|</operator>
<name>INTEGER_PACK_2COMP</name><operator>|</operator>
<name>INTEGER_PACK_FORCE_BIGNUM</name><operator>|</operator>
<name>INTEGER_PACK_NEGATIVE</name><operator>|</operator>
<name>INTEGER_PACK_FORCE_GENERIC_IMPLEMENTATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num_bdigits0</name> <operator>=</operator> <call><name>integer_unpack_num_bdigits</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlp_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>num_bdigits0</name> <operator>&lt;=</operator> <name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sign</name> <operator>=</operator> <call><name>bary_unpack_internal</name><argument_list>(<argument><expr><name>bdigits</name></expr></argument>, <argument><expr><name>num_bdigits0</name></expr></argument>, <argument><expr><name>words</name></expr></argument>, <argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>nlp_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num_bdigits0</name> <operator>&lt;</operator> <name>num_bdigits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>bdigits</name> <operator>+</operator> <name>num_bdigits0</name></expr></argument>, <argument><expr><name>num_bdigits</name> <operator>-</operator> <name>num_bdigits0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bdigits</name><index>[<expr><name>num_bdigits0</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_subb</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>borrow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL_SIGNED</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sn</name> <operator>=</operator> <ternary><condition><expr><name>xn</name> <operator>&lt;</operator> <name>yn</name></expr> ?</condition><then> <expr><name>xn</name></expr> </then><else>: <expr><name>yn</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <ternary><condition><expr><name>borrow</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>yds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>&lt;=</operator> <name>xn</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>num_is_zero</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>yn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>-=</operator> <name><name>yds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>num_is_zero</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BDIGMAX</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>num_is_zero</name>:</label>
<if_stmt><if>if <condition>(<expr><name>xds</name> <operator>==</operator> <name>zds</name> <operator>&amp;&amp;</operator> <name>xn</name> <operator>==</operator> <name>zn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_sub</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bary_subb</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_sub_one</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bary_subb</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_addc</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>carry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>tds</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tds</name> <operator>=</operator> <name>xds</name></expr>;</expr_stmt> <expr_stmt><expr><name>xds</name> <operator>=</operator> <name>yds</name></expr>;</expr_stmt> <expr_stmt><expr><name>yds</name> <operator>=</operator> <name>tds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt> <expr_stmt><expr><name>xn</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt> <expr_stmt><expr><name>yn</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <ternary><condition><expr><name>carry</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>yds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>yn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>num_is_zero</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <name><name>yds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>num_is_zero</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>num</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

<label><name>num_is_zero</name>:</label>
<if_stmt><if>if <condition>(<expr><name>yds</name> <operator>==</operator> <name>zds</name> <operator>&amp;&amp;</operator> <name>yn</name> <operator>==</operator> <name>zn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>yn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>yds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_add</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bary_addc</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_add_one</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>n</name> <init>= <expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_single</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name>x</name> <operator>*</operator> <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigitdbl2bary</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>zn</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_muladd_1xN</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>dd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zn</name> <operator>&gt;</operator> <name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dd</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>yn</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>ee</name> <init>= <expr><name>n</name> <operator>+</operator> <name>dd</name> <operator>*</operator> <name><name>yds</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ee</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>zds</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <name>ee</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>zds</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BDIGIT_DBL_SIGNED</name></type>
<name>bigdivrem_mulsub</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>t2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL_SIGNED</name></type> <name>num</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zn</name> <operator>==</operator> <name>yn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>t2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL_SIGNED</name></type> <name>ee</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t2</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>yds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ee</name> <operator>=</operator> <name>num</name> <operator>-</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>ee</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ee</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>yn</name></expr>)</condition>;</do>
<expr_stmt><expr><name>num</name> <operator>-=</operator> <operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name>t2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>zds</name><index>[<expr><name>yn</name></expr>]</index></name></expr>;</expr_stmt> 
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_mulsub_1xN</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL_SIGNED</name></type> <name>num</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zn</name> <operator>==</operator> <name>yn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>bigdivrem_mulsub</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>yn</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_normal</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>+</operator> <name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>bary_muladd_1xN</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>i</name></expr></argument>, <argument><expr><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_mul_normal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>yn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>zn</name> <init>= <expr><name>xn</name> <operator>+</operator> <name>yn</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bary_mul_normal</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_sq_fast</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>v</name></decl>, <decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>vl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>vh</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>+</operator> <name>v</name> <operator>*</operator> <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vl</name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vh</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>BIGDN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>xds</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>+</operator> <name>vl</name> <operator>*</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vh</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>+=</operator> <name>w</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>xn</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>xn</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>xn</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>+</operator> <name>v</name> <operator>*</operator> <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name> <operator>+</operator> <name>xn</name></expr>]</index></name> <operator>+=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_sq_fast</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>zn</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>xn</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bary_sq_fast</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_balance_with_mulfunc</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>, <parameter><decl><type><name>mulfunc_t</name> <modifier>*</modifier></type><name>mulfunc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>work</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>yn0</name> <init>= <expr><name>yn</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>+</operator> <name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>&lt;=</operator> <name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>KARATSUBA_BALANCED</name><argument_list>(<argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>TOOM3_BALANCED</name><argument_list>(<argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>yn</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>tds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>tn</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <ternary><condition><expr><name>xn</name> <operator>&gt;</operator> <name>yn</name></expr> ?</condition><then> <expr><name>yn</name></expr> </then><else>: <expr><name>xn</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>tn</name> <operator>=</operator> <name>xn</name> <operator>+</operator> <name>r</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>xn</name> <operator>+</operator> <name>r</name><operator>)</operator> <operator>&lt;=</operator> <name>zn</name> <operator>-</operator> <name>n</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tds</name> <operator>=</operator> <name>zds</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>xn</name> <operator>+</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mulfunc</name><argument_list>(<argument><expr><name>tds</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>xn</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>zds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>,
<argument><expr><name>zds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>,
<argument><expr><name>tds</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>wn</name> <operator>&lt;</operator> <name>xn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wn</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>wds</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>work</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tds</name> <operator>=</operator> <name>zds</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>wds</name></expr></argument>, <argument><expr><name>zds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mulfunc</name><argument_list>(<argument><expr><name>tds</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>wds</name><operator>+</operator><name>xn</name></expr></argument>, <argument><expr><name>wn</name><operator>-</operator><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>zds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>,
<argument><expr><name>zds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>,
<argument><expr><name>wds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>yn</name> <operator>-=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>xn</name><operator>+</operator><name>yn0</name></expr></argument>, <argument><expr><name>zn</name> <operator>-</operator> <operator>(</operator><name>xn</name><operator>+</operator><name>yn0</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>work</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_mul_balance</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>yn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>zn</name> <init>= <expr><name>xn</name> <operator>+</operator> <name>yn</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bary_mul_balance_with_mulfunc</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bary_mul_toom3_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_karatsuba</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>work</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sub_p</name></decl>, <decl><type ref="prev"/><name>borrow</name></decl>, <decl><type ref="prev"/><name>carry1</name></decl>, <decl><type ref="prev"/><name>carry2</name></decl>, <decl><type ref="prev"/><name>carry3</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>odd_y</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>odd_xy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xds1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>yds0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>yds1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds3</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>+</operator> <name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>&lt;=</operator> <name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>yn</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sq</name> <operator>=</operator> <name>xds</name> <operator>==</operator> <name>yds</name> <operator>&amp;&amp;</operator> <name>xn</name> <operator>==</operator> <name>yn</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>odd_y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>yn</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>&lt;</operator> <name>xn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>odd_xy</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>xn</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>yn</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;</operator> <name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wn</name> <operator>&lt;</operator> <name>n</name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><name>wn</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>wds</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>work</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>












<expr_stmt><expr><name>xds0</name> <operator>=</operator> <name>xds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>xds1</name> <operator>=</operator> <name>xds</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yds0</name> <operator>=</operator> <name>yds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yds1</name> <operator>=</operator> <name>yds</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zds0</name> <operator>=</operator> <name>zds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zds1</name> <operator>=</operator> <name>zds</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zds2</name> <operator>=</operator> <name>zds</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zds3</name> <operator>=</operator> <name>zds</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sub_p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>zds0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>xds</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>xn</name><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>zds0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sub_p</name> <operator>=</operator> <operator>!</operator><name>sub_p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>sq</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sub_p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_mul_karatsuba_start</name><argument_list>(<argument><expr><name>zds1</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zds0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>wds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>yds</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>wds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sub_p</name> <operator>=</operator> <operator>!</operator><name>sub_p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>bary_mul_karatsuba_start</name><argument_list>(<argument><expr><name>zds1</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zds0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>wds</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>wn</name><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<expr_stmt><expr><name>borrow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sub_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>borrow</name> <operator>=</operator> <operator>!</operator><call><name>bary_2comp</name><argument_list>(<argument><expr><name>zds1</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>wds</name></expr></argument>, <argument><expr><name>zds1</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bary_mul_karatsuba_start</name><argument_list>(<argument><expr><name>zds0</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>xds0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>yds0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>wds</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>wn</name><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>carry1</name> <operator>=</operator> <call><name>bary_add</name><argument_list>(<argument><expr><name>wds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry1</name> <operator>=</operator> <call><name>bary_addc</name><argument_list>(<argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>carry1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>carry2</name> <operator>=</operator> <call><name>bary_add</name><argument_list>(<argument><expr><name>zds1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>wds</name></expr></argument>, <argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bary_mul_karatsuba_start</name><argument_list>(<argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>xds1</name></expr></argument>, <argument><expr><name>xn</name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><name>yds1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>wds</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>wn</name><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>carry3</name> <operator>=</operator> <call><name>bary_add</name><argument_list>(<argument><expr><name>zds1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>carry3</name> <operator>=</operator> <call><name>bary_addc</name><argument_list>(<argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zds3</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><literal type="number">4</literal><operator>*</operator><name>n</name> <operator>&lt;</operator> <name>zn</name></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>zn</name><operator>-</operator><literal type="number">3</literal><operator>*</operator><name>n</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>carry3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>carry2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_add_one</name><argument_list>(<argument><expr><name>zds2</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>carry1</name> <operator>+</operator> <name>carry3</name> <operator>-</operator> <name>borrow</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_sub_one</name><argument_list>(<argument><expr><name>zds3</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>carry1</name> <operator>+</operator> <name>carry3</name> <operator>-</operator> <name>borrow</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>c</name> <init>= <expr><name>carry1</name> <operator>+</operator> <name>carry3</name> <operator>-</operator> <name>borrow</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>zds3</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zds3</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>












<if_stmt><if>if <condition>(<expr><name>odd_xy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_muladd_1xN</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>yn</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>yn</name></expr></argument>, <argument><expr><name><name>yds</name><index>[<expr><name>yn</name></expr>]</index></name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_muladd_1xN</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>xn</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>xn</name></expr></argument>, <argument><expr><name><name>xds</name><index>[<expr><name>xn</name></expr>]</index></name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>odd_y</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_muladd_1xN</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>yn</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>yn</name></expr></argument>, <argument><expr><name><name>yds</name><index>[<expr><name>yn</name></expr>]</index></name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>work</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_mul_karatsuba</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>yn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>zn</name> <init>= <expr><name>xn</name> <operator>+</operator> <name>yn</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>xn</name> <operator>&lt;=</operator> <name>yn</name> <operator>&amp;&amp;</operator> <name>yn</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>||</operator> <call><name>KARATSUBA_BALANCED</name><argument_list>(<argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected bignum length for karatsuba"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bary_mul_karatsuba</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_toom3</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>wnc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>work</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>x0n</name></decl>;</decl_stmt> <decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>x0ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>x1n</name></decl>;</decl_stmt> <decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>x1ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>x2n</name></decl>;</decl_stmt> <decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>x2ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>y0n</name></decl>;</decl_stmt> <decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>y0ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>y1n</name></decl>;</decl_stmt> <decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>y1ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>y2n</name></decl>;</decl_stmt> <decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>y2ds</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>u1n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>u1ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>u1p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>u2n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>u2ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>u2p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>u3n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>u3ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>u3p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>v1n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>v1ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>v1p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>v2n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>v2ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>v2p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>v3n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>v3ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>v3p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>t0n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>t0ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>t0p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>t1n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>t1ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>t1p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>t2n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>t2ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>t2p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>t3n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>t3ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>t3p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>t4n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>t4ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>t4p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>z0n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>z0ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>z1n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>z1ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>z1p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>z2n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>z2ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>z2p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>z3n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>z3ds</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>z3p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>z4n</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>z4ds</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>zzn</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zzds</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sq</name> <init>= <expr><name>xds</name> <operator>==</operator> <name>yds</name> <operator>&amp;&amp;</operator> <name>xn</name> <operator>==</operator> <name>yn</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>&lt;=</operator> <name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>+</operator> <name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>yn</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>*</operator><name>n</name> <operator>&lt;</operator> <name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wnc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>u1n</name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>u2n</name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>u3n</name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>v1n</name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>v2n</name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>v3n</name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 

<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>t0n</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>t1n</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>t2n</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>t3n</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>t4n</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name><operator>)</operator></expr>;</expr_stmt> 

<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>z1n</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>z2n</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>wnc</name> <operator>+=</operator> <operator>(</operator><name>z3n</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>wn</name> <operator>&lt;</operator> <name>wnc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wn</name> <operator>=</operator> <name>wnc</name> <operator>*</operator> <literal type="number">3</literal> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>wds</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>work</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>u1ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>u1n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>u2ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>u2n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>u3ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>u3n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v1ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>v1n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>v2n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v3ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>v3n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>t0ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>t0n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t1ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>t1n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t2ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>t2n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t3ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>t3n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t4ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>t4n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>z1ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>z1n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z2ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>z2n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z3ds</name> <operator>=</operator> <name>wds</name></expr>;</expr_stmt> <expr_stmt><expr><name>wds</name> <operator>+=</operator> <name>z3n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>wn</name> <operator>-=</operator> <name>wnc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>zzds</name> <operator>=</operator> <name>u1ds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zzn</name> <operator>=</operator> <literal type="number">6</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>x0n</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x1n</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x2n</name> <operator>=</operator> <name>xn</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x0ds</name> <operator>=</operator> <name>xds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x1ds</name> <operator>=</operator> <name>xds</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x2ds</name> <operator>=</operator> <name>xds</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sq</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y0n</name> <operator>=</operator> <name>x0n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y1n</name> <operator>=</operator> <name>x1n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y2n</name> <operator>=</operator> <name>x2n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y0ds</name> <operator>=</operator> <name>x0ds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y1ds</name> <operator>=</operator> <name>x1ds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y2ds</name> <operator>=</operator> <name>x2ds</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>y0n</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y1n</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y2n</name> <operator>=</operator> <name>yn</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y0ds</name> <operator>=</operator> <name>yds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y1ds</name> <operator>=</operator> <name>yds</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y2ds</name> <operator>=</operator> <name>yds</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




































<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>u1ds</name></expr></argument>, <argument><expr><name>u1n</name></expr></argument>, <argument><expr><name>x0ds</name></expr></argument>, <argument><expr><name>x0n</name></expr></argument>, <argument><expr><name>x2ds</name></expr></argument>, <argument><expr><name>x2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u1p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>u2ds</name></expr></argument>, <argument><expr><name>u2n</name></expr></argument>, <argument><expr><name>u1ds</name></expr></argument>, <argument><expr><name>u1n</name></expr></argument>, <argument><expr><name>x1ds</name></expr></argument>, <argument><expr><name>x1n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>u2ds</name></expr></argument>, <argument><expr><name>u2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u2p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>u2p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>u1ds</name></expr></argument>, <argument><expr><name>u1n</name></expr></argument>, <argument><expr><name>u1ds</name></expr></argument>, <argument><expr><name>u1n</name></expr></argument>, <argument><expr><name>x1ds</name></expr></argument>, <argument><expr><name>x1n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>u3p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>u2p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>, <argument><expr><name>u2ds</name></expr></argument>, <argument><expr><name>u2n</name></expr></argument>, <argument><expr><name>x2ds</name></expr></argument>, <argument><expr><name>x2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>, <argument><expr><name>x2ds</name></expr></argument>, <argument><expr><name>x2n</name></expr></argument>, <argument><expr><name>u2ds</name></expr></argument>, <argument><expr><name>u2n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u3p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bary_small_lshift</name><argument_list>(<argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>u3p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>, <argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>, <argument><expr><name>x0ds</name></expr></argument>, <argument><expr><name>x0n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>, <argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>, <argument><expr><name>x0ds</name></expr></argument>, <argument><expr><name>x0n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u3p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sq</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v1n</name> <operator>=</operator> <name>u1n</name></expr>;</expr_stmt> <expr_stmt><expr><name>v1ds</name> <operator>=</operator> <name>u1ds</name></expr>;</expr_stmt> <expr_stmt><expr><name>v1p</name> <operator>=</operator> <name>u1p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2n</name> <operator>=</operator> <name>u2n</name></expr>;</expr_stmt> <expr_stmt><expr><name>v2ds</name> <operator>=</operator> <name>u2ds</name></expr>;</expr_stmt> <expr_stmt><expr><name>v2p</name> <operator>=</operator> <name>u2p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v3n</name> <operator>=</operator> <name>u3n</name></expr>;</expr_stmt> <expr_stmt><expr><name>v3ds</name> <operator>=</operator> <name>u3ds</name></expr>;</expr_stmt> <expr_stmt><expr><name>v3p</name> <operator>=</operator> <name>u3p</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>v1ds</name></expr></argument>, <argument><expr><name>v1n</name></expr></argument>, <argument><expr><name>y0ds</name></expr></argument>, <argument><expr><name>y0n</name></expr></argument>, <argument><expr><name>y2ds</name></expr></argument>, <argument><expr><name>y2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v1p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>v2p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>v2ds</name></expr></argument>, <argument><expr><name>v2n</name></expr></argument>, <argument><expr><name>v1ds</name></expr></argument>, <argument><expr><name>v1n</name></expr></argument>, <argument><expr><name>y1ds</name></expr></argument>, <argument><expr><name>y1n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>v2ds</name></expr></argument>, <argument><expr><name>v2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v2p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>v1ds</name></expr></argument>, <argument><expr><name>v1n</name></expr></argument>, <argument><expr><name>v1ds</name></expr></argument>, <argument><expr><name>v1n</name></expr></argument>, <argument><expr><name>y1ds</name></expr></argument>, <argument><expr><name>y1n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>v3p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v2p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>, <argument><expr><name>v2ds</name></expr></argument>, <argument><expr><name>v2n</name></expr></argument>, <argument><expr><name>y2ds</name></expr></argument>, <argument><expr><name>y2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>, <argument><expr><name>y2ds</name></expr></argument>, <argument><expr><name>y2n</name></expr></argument>, <argument><expr><name>v2ds</name></expr></argument>, <argument><expr><name>v2n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v3p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bary_small_lshift</name><argument_list>(<argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v3p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>, <argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>, <argument><expr><name>y0ds</name></expr></argument>, <argument><expr><name>y0n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>, <argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>, <argument><expr><name>y0ds</name></expr></argument>, <argument><expr><name>y0n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v3p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>bary_mul_toom3_start</name><argument_list>(<argument><expr><name>t0ds</name></expr></argument>, <argument><expr><name>t0n</name></expr></argument>, <argument><expr><name>x0ds</name></expr></argument>, <argument><expr><name>x0n</name></expr></argument>, <argument><expr><name>y0ds</name></expr></argument>, <argument><expr><name>y0n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t0p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bary_mul_toom3_start</name><argument_list>(<argument><expr><name>t1ds</name></expr></argument>, <argument><expr><name>t1n</name></expr></argument>, <argument><expr><name>u1ds</name></expr></argument>, <argument><expr><name>u1n</name></expr></argument>, <argument><expr><name>v1ds</name></expr></argument>, <argument><expr><name>v1n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t1p</name> <operator>=</operator> <name>u1p</name> <operator>==</operator> <name>v1p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t1ds</name><index>[<expr><name>t1n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t1n</name><operator>--</operator></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bary_mul_toom3_start</name><argument_list>(<argument><expr><name>t2ds</name></expr></argument>, <argument><expr><name>t2n</name></expr></argument>, <argument><expr><name>u2ds</name></expr></argument>, <argument><expr><name>u2n</name></expr></argument>, <argument><expr><name>v2ds</name></expr></argument>, <argument><expr><name>v2n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t2p</name> <operator>=</operator> <name>u2p</name> <operator>==</operator> <name>v2p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t2ds</name><index>[<expr><name>t2n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t2n</name><operator>--</operator></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bary_mul_toom3_start</name><argument_list>(<argument><expr><name>t3ds</name></expr></argument>, <argument><expr><name>t3n</name></expr></argument>, <argument><expr><name>u3ds</name></expr></argument>, <argument><expr><name>u3n</name></expr></argument>, <argument><expr><name>v3ds</name></expr></argument>, <argument><expr><name>v3n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t3p</name> <operator>=</operator> <name>u3p</name> <operator>==</operator> <name>v3p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t3ds</name><index>[<expr><name>t3n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t3n</name><operator>--</operator></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bary_mul_toom3_start</name><argument_list>(<argument><expr><name>t4ds</name></expr></argument>, <argument><expr><name>t4n</name></expr></argument>, <argument><expr><name>x2ds</name></expr></argument>, <argument><expr><name>x2n</name></expr></argument>, <argument><expr><name>y2ds</name></expr></argument>, <argument><expr><name>y2n</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t4p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>






<expr_stmt><expr><name>z0n</name> <operator>=</operator> <name>t0n</name></expr>;</expr_stmt> <expr_stmt><expr><name>z0ds</name> <operator>=</operator> <name>t0ds</name></expr>;</expr_stmt>


<expr_stmt><expr><name>z4n</name> <operator>=</operator> <name>t4n</name></expr>;</expr_stmt> <expr_stmt><expr><name>z4ds</name> <operator>=</operator> <name>t4ds</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>t3p</name> <operator>==</operator> <name>t1p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z3p</name> <operator>=</operator> <name>t3p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>, <argument><expr><name>t3ds</name></expr></argument>, <argument><expr><name>t3n</name></expr></argument>, <argument><expr><name>t1ds</name></expr></argument>, <argument><expr><name>t1n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z3p</name> <operator>=</operator> <operator>!</operator><name>z3p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>z3p</name> <operator>=</operator> <name>t3p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>, <argument><expr><name>t3ds</name></expr></argument>, <argument><expr><name>t3n</name></expr></argument>, <argument><expr><name>t1ds</name></expr></argument>, <argument><expr><name>t1n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>bigdivrem_single</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>t1p</name> <operator>==</operator> <name>t2p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z1p</name> <operator>=</operator> <name>t1p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>, <argument><expr><name>t1ds</name></expr></argument>, <argument><expr><name>t1n</name></expr></argument>, <argument><expr><name>t2ds</name></expr></argument>, <argument><expr><name>t2n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z1p</name> <operator>=</operator> <operator>!</operator><name>z1p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>z1p</name> <operator>=</operator> <name>t1p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>, <argument><expr><name>t1ds</name></expr></argument>, <argument><expr><name>t1n</name></expr></argument>, <argument><expr><name>t2ds</name></expr></argument>, <argument><expr><name>t2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>bary_small_rshift</name><argument_list>(<argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>t2p</name> <operator>==</operator> <name>t0p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z2p</name> <operator>=</operator> <name>t2p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>t2ds</name></expr></argument>, <argument><expr><name>t2n</name></expr></argument>, <argument><expr><name>t0ds</name></expr></argument>, <argument><expr><name>t0n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z2p</name> <operator>=</operator> <operator>!</operator><name>z2p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>z2p</name> <operator>=</operator> <name>t2p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>t2ds</name></expr></argument>, <argument><expr><name>t2n</name></expr></argument>, <argument><expr><name>t0ds</name></expr></argument>, <argument><expr><name>t0n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>z2p</name> <operator>==</operator> <name>z3p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z3p</name> <operator>=</operator> <name>z2p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>, <argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z3p</name> <operator>=</operator> <operator>!</operator><name>z3p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>z3p</name> <operator>=</operator> <name>z2p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>, <argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>bary_small_rshift</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>z3p</name> <operator>==</operator> <name>t4p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_muladd_1xN</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>t4ds</name></expr></argument>, <argument><expr><name>t4n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bary_mulsub_1xN</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>t4ds</name></expr></argument>, <argument><expr><name>t4n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z3p</name> <operator>=</operator> <operator>!</operator><name>z3p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>z2p</name> <operator>==</operator> <name>z1p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z2p</name> <operator>=</operator> <operator>!</operator><name>z2p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>z2p</name> <operator>==</operator> <name>t4p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>t4ds</name></expr></argument>, <argument><expr><name>t4n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z2p</name> <operator>=</operator> <operator>!</operator><name>z2p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>, <argument><expr><name>t4ds</name></expr></argument>, <argument><expr><name>t4n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>z1p</name> <operator>==</operator> <name>z3p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>, <argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>, <argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z1p</name> <operator>=</operator> <operator>!</operator><name>z1p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>, <argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>, <argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>





<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>zzds</name></expr></argument>, <argument><expr><name>z0ds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>z0n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <name>z0n</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>n</name> <operator>-</operator> <name>z0n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>z4ds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>z4n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>n</name> <operator>+</operator> <name>z4n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <operator>(</operator><literal type="number">4</literal><operator>*</operator><name>n</name> <operator>+</operator> <name>z4n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>z1p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>zzds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>zzds</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>z1ds</name></expr></argument>, <argument><expr><name>z1n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>z2p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>z2ds</name></expr></argument>, <argument><expr><name>z2n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>z3p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzds</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>zzn</name> <operator>-</operator> <literal type="number">3</literal><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>z3ds</name></expr></argument>, <argument><expr><name>z3n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>zzds</name></expr></argument>, <argument><expr><name>zzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zzds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>zzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name> <operator>+</operator> <name>zzn</name></expr></argument>, <argument><expr><name>zn</name> <operator>-</operator> <name>zzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>work</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_mul_toom3</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>yn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>zn</name> <init>= <expr><name>xn</name> <operator>+</operator> <name>yn</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;</operator> <name>yn</name> <operator>||</operator> <name>yn</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator> <operator>!</operator><call><name>TOOM3_BALANCED</name><argument_list>(<argument><expr><name>xn</name></expr></argument>,<argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected bignum length for toom3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bary_mul_toom3</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>bdigits_to_mpz</name><parameter_list>(<parameter><decl><type><name>mpz_t</name></type> <name>mp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>digits</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>nails</name> <init>= <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof><operator>-</operator><name>SIZEOF_BDIGIT</name><operator>)</operator><operator>*</operator><name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>mpz_import</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>bdigits_from_mpz</name><parameter_list>(<parameter><decl><type><name>mpz_t</name></type> <name>mp</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>digits</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>nails</name> <init>= <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof><operator>-</operator><name>SIZEOF_BDIGIT</name><operator>)</operator><operator>*</operator><name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>mpz_export</name><argument_list>(<argument><expr><name>digits</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_gmp</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mpz_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>count</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>+</operator> <name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigits_to_mpz</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xds</name> <operator>==</operator> <name>yds</name> <operator>&amp;&amp;</operator> <name>xn</name> <operator>==</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mpz_mul</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bdigits_to_mpz</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_mul</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>bdigits_from_mpz</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>count</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_mul_gmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>yn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>zn</name> <init>= <expr><name>xn</name> <operator>+</operator> <name>yn</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bary_mul_gmp</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_short_mul</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>+</operator> <name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>yn</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_mul_single</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>yds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bary_mul_normal</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_thread_check_ints</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>bary_sparse_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>( <expr><name><name>ds</name><index>[<expr><call><name>rb_genrand_ulong_limited</name><argument_list>(<argument><expr><name>n</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name> <operator>/</operator> <literal type="number">4</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ds</name><index>[<expr><call><name>rb_genrand_ulong_limited</name><argument_list>(<argument><expr><name>n</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name> <operator>/</operator> <literal type="number">4</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ds</name><index>[<expr><call><name>rb_genrand_ulong_limited</name><argument_list>(<argument><expr><name>n</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name> <operator>/</operator> <literal type="number">4</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bary_mul_precheck</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier><modifier>*</modifier></type><name>zdsp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>znp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier><modifier>*</modifier></type><name>xdsp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>xnp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier><modifier>*</modifier></type><name>ydsp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>ynp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>nlsz</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name> <init>= <expr><operator>*</operator><name>zdsp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zn</name> <init>= <expr><operator>*</operator><name>znp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name> <init>= <expr><operator>*</operator><name>xdsp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><operator>*</operator><name>xnp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name> <init>= <expr><operator>*</operator><name>ydsp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>yn</name> <init>= <expr><operator>*</operator><name>ynp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>+</operator> <name>yn</name> <operator>&lt;=</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nlsz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>xn</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>xds</name><index>[<expr><name>xn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>xn</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>xds</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>xn</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nlsz</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>xn</name></expr>)</condition>;</do>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>yds</name><index>[<expr><name>yn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>yn</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>yds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>yds</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>yn</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nlsz</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>yn</name></expr>)</condition>;</do>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>nlsz</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>nlsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>+=</operator> <name>nlsz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>-=</operator> <name>nlsz</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>tds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>tn</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tds</name> <operator>=</operator> <name>xds</name></expr>;</expr_stmt> <expr_stmt><expr><name>xds</name> <operator>=</operator> <name>yds</name></expr>;</expr_stmt> <expr_stmt><expr><name>yds</name> <operator>=</operator> <name>tds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tn</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt> <expr_stmt><expr><name>xn</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt> <expr_stmt><expr><name>yn</name> <operator>=</operator> <name>tn</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>&lt;=</operator> <name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>yn</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>POW2_P</name><argument_list>(<argument><expr><name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>yn</name></expr>]</index></name> <operator>=</operator> <call><name>bary_small_lshift</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><call><name>bit_length</name><argument_list>(<argument><expr><name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>yn</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>yn</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>yds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bary_mul_normal</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>zdsp</name> <operator>=</operator> <name>zds</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>znp</name> <operator>=</operator> <name>zn</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>xdsp</name> <operator>=</operator> <name>xds</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>xnp</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ydsp</name> <operator>=</operator> <name>yds</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ynp</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_karatsuba_branch</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>KARATSUBA_MUL_DIGITS</name></expr>)</condition> <block>{<block_content>
<label><name>normal</name>:</label>
<if_stmt><if>if <condition>(<expr><name>xds</name> <operator>==</operator> <name>yds</name> <operator>&amp;&amp;</operator> <name>xn</name> <operator>==</operator> <name>yn</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_sq_fast</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_short_mul</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>bary_sparse_p</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>normal</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>bary_sparse_p</name><argument_list>(<argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_short_mul</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>KARATSUBA_BALANCED</name><argument_list>(<argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_mul_balance_with_mulfunc</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>, <argument><expr><name>bary_mul_karatsuba_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>bary_mul_karatsuba</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_karatsuba_start</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bary_mul_precheck</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bary_mul_karatsuba_branch</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_toom3_branch</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>TOOM3_MUL_DIGITS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_mul_karatsuba_branch</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TOOM3_BALANCED</name><argument_list>(<argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_mul_balance_with_mulfunc</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>, <argument><expr><name>bary_mul_toom3_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bary_mul_toom3</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul_toom3_start</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bary_mul_precheck</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bary_mul_toom3_branch</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_mul</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;=</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>NAIVE_MUL_DIGITS</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xds</name> <operator>==</operator> <name>yds</name> <operator>&amp;&amp;</operator> <name>xn</name> <operator>==</operator> <name>yn</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_sq_fast</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_short_mul</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>&lt;</operator> <name>NAIVE_MUL_DIGITS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_short_mul</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>bary_mul_gmp</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>bary_mul_toom3_start</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<struct>struct <name>big_div_struct</name> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>yn</name></decl>, <decl><type ref="prev"/><name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>stop</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>bigdivrem1</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>big_div_struct</name></name> <modifier>*</modifier></type><name>bds</name> <init>= <expr><operator>(</operator>struct <name>big_div_struct</name><operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>yn</name> <init>= <expr><name><name>bds</name><operator>-&gt;</operator><name>yn</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zn</name> <init>= <expr><name><name>bds</name><operator>-&gt;</operator><name>zn</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name> <init>= <expr><name><name>bds</name><operator>-&gt;</operator><name>yds</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name> <init>= <expr><name><name>bds</name><operator>-&gt;</operator><name>zds</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL_SIGNED</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>q</name></decl>;</decl_stmt>

<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bds</name><operator>-&gt;</operator><name>stop</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>zn</name></name> <operator>=</operator> <name>zn</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zds</name><index>[<expr><name>zn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>yds</name><index>[<expr><name>yn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>q</name> <operator>=</operator> <name>BDIGMAX</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><operator>(</operator><operator>(</operator><call><name>BIGUP</name><argument_list>(<argument><expr><name><name>zds</name><index>[<expr><name>zn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>zds</name><index>[<expr><name>zn</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>)</operator><operator>/</operator><name><name>yds</name><index>[<expr><name>yn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>bigdivrem_mulsub</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>zn</name><operator>-</operator><operator>(</operator><name>yn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>yn</name><operator>+</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><name>q</name></expr></argument>,
<argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>num</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>q</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>bary_add</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>zn</name><operator>-</operator><operator>(</operator><name>yn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>yn</name></expr></argument>,
<argument><expr><name>zds</name><operator>+</operator><name>zn</name><operator>-</operator><operator>(</operator><name>yn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>yn</name></expr></argument>,
<argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>zn</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>zn</name></expr>]</index></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>zn</name> <operator>&gt;</operator> <name>yn</name></expr>)</condition>;</do>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_big_stop</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>big_div_struct</name></name> <modifier>*</modifier></type><name>bds</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stop</name></name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BDIGIT</name></type>
<name>bigdivrem_single1</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>x_higher_bdigit</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>x_higher_bdigit</name> <operator>&lt;</operator> <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>POW2_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><name>y</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_small_rshift</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><call><name>bit_length</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>x_higher_bdigit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>t2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t2</name> <operator>=</operator> <name>x_higher_bdigit</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>BIGUP</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>qds</name><index>[<expr><name>xn</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><operator>(</operator><name>t2</name> <operator>/</operator> <name>y</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>t2</name> <operator>%=</operator> <name>y</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>BDIGIT</name><operator>)</operator><name>t2</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BDIGIT</name></type>
<name>bigdivrem_single</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bigdivrem_single1</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bigdivrem_restoring</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>big_div_struct</name></name></type> <name>bds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ynzero</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>yn</name> <operator>&lt;</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BDIGIT_MSB</name><argument_list>(<argument><expr><name><name>yds</name><index>[<expr><name>yn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zds</name><index>[<expr><name>zn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>yds</name><index>[<expr><name>yn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ynzero</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name><name>yds</name><index>[<expr><name>ynzero</name></expr>]</index></name></expr>;</condition> <incr><expr><name>ynzero</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>ynzero</name><operator>+</operator><literal type="number">1</literal> <operator>==</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>bigdivrem_single1</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>yn</name></expr></argument>, <argument><expr><name>zds</name><operator>+</operator><name>ynzero</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>yn</name></expr></argument>, <argument><expr><name><name>zds</name><index>[<expr><name>zn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>yds</name><index>[<expr><name>ynzero</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>ynzero</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>yn</name></name> <operator>=</operator> <name>yn</name> <operator>-</operator> <name>ynzero</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>zds</name></name> <operator>=</operator> <name>zds</name> <operator>+</operator> <name>ynzero</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>yds</name></name> <operator>=</operator> <name>yds</name> <operator>+</operator> <name>ynzero</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>stop</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>zn</name></name> <operator>=</operator> <name>zn</name> <operator>-</operator> <name>ynzero</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bds</name><operator>.</operator><name>zn</name></name> <operator>&gt;</operator> <literal type="number">10000</literal> <operator>||</operator> <name><name>bds</name><operator>.</operator><name>yn</name></name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition> <block>{<block_content>
<label><name>retry</name>:</label>
<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>stop</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_nogvl</name><argument_list>(<argument><expr><name>bigdivrem1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bds</name></expr></argument>, <argument><expr><name>rb_big_stop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bds</name></expr></argument>, <argument><expr><name>RB_NOGVL_UBF_ASYNC_SAFE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bds</name><operator>.</operator><name>stop</name></name> <operator>==</operator> <name>Qtrue</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>retry</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bigdivrem1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_divmod_normal</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>rds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>yyds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmpyz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>yn</name> <operator>&lt;</operator> <name>xn</name> <operator>||</operator> <operator>(</operator><name>xn</name> <operator>==</operator> <name>yn</name> <operator>&amp;&amp;</operator> <name><name>yds</name><index>[<expr><name>yn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>qds</name></expr> ?</condition><then> <expr><operator>(</operator><name>xn</name> <operator>-</operator> <name>yn</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <name>qn</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>rds</name></expr> ?</condition><then> <expr><name>yn</name> <operator>&lt;=</operator> <name>rn</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zn</name> <operator>=</operator> <name>xn</name> <operator>+</operator> <name>BIGDIVREM_EXTRA_WORDS</name></expr>;</expr_stmt>

<expr_stmt><expr><name>shift</name> <operator>=</operator> <call><name>nlz</name><argument_list>(<argument><expr><name><name>yds</name><index>[<expr><name>yn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>shift</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>alloc_y</name> <init>= <expr><operator>!</operator><name>rds</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>alloc_z</name> <init>= <expr><operator>!</operator><name>qds</name> <operator>||</operator> <name>qn</name> <operator>&lt;</operator> <name>zn</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>alloc_y</name> <operator>&amp;&amp;</operator> <name>alloc_z</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>yyds</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>tmpyz</name></expr></argument>, <argument><expr><name>yn</name><operator>+</operator><name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <name>yyds</name> <operator>+</operator> <name>yn</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>yyds</name> <operator>=</operator> <ternary><condition><expr><name>alloc_y</name></expr> ?</condition><then> <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>tmpyz</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>rds</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <ternary><condition><expr><name>alloc_z</name></expr> ?</condition><then> <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>tmpyz</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>qds</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>xn</name></expr>]</index></name> <operator>=</operator> <call><name>bary_small_lshift</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_small_lshift</name><argument_list>(<argument><expr><name>yyds</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>qds</name> <operator>&amp;&amp;</operator> <name>zn</name> <operator>&lt;=</operator> <name>qn</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <name>qds</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>tmpyz</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>xn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>yyds</name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name> <operator>*</operator><operator>)</operator><name>yds</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>bigdivrem_restoring</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>yyds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rds</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>shift</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_small_rshift</name><argument_list>(<argument><expr><name>rds</name></expr></argument>, <argument><expr><name>zds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>rds</name></expr></argument>, <argument><expr><name>zds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>rds</name><operator>+</operator><name>yn</name></expr></argument>, <argument><expr><name>rn</name><operator>-</operator><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qds</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><name>zn</name> <operator>-</operator> <name>yn</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>zds</name><operator>+</operator><name>yn</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>qds</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>qn</name><operator>-</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpyz</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>tmpyz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_divrem_normal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>yn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>qn</name></decl>, <decl><type ref="prev"/><name>rn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>yds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>qds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>q</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_num_zerodiv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>yn</name> <operator>||</operator> <operator>(</operator><name>xn</name> <operator>==</operator> <name>yn</name> <operator>&amp;&amp;</operator> <name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>yds</name><index>[<expr><name>yn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qn</name> <operator>=</operator> <name>xn</name> <operator>+</operator> <name>BIGDIVREM_EXTRA_WORDS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>qn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>qds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rn</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>rn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bary_divmod_normal</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_divmod_gmp</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>rds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mpz_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>q</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>count</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>yn</name> <operator>&lt;</operator> <name>xn</name> <operator>||</operator> <operator>(</operator><name>xn</name> <operator>==</operator> <name>yn</name> <operator>&amp;&amp;</operator> <name><name>yds</name><index>[<expr><name>yn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>qds</name></expr> ?</condition><then> <expr><operator>(</operator><name>xn</name> <operator>-</operator> <name>yn</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <name>qn</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>rds</name></expr> ?</condition><then> <expr><name>yn</name> <operator>&lt;=</operator> <name>rn</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>qds</name> <operator>||</operator> <name>rds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>qds</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rds</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bdigits_to_mpz</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigits_to_mpz</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rds</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mpz_fdiv_q</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>qds</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mpz_fdiv_r</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>mpz_fdiv_qr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qds</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bdigits_from_mpz</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>qds</name><operator>+</operator><name>count</name></expr></argument>, <argument><expr><name>qn</name><operator>-</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rds</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bdigits_from_mpz</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>rds</name><operator>+</operator><name>count</name></expr></argument>, <argument><expr><name>rn</name><operator>-</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_divrem_gmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>yn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>qn</name></decl>, <decl><type ref="prev"/><name>rn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>yds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>qds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>q</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_num_zerodiv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>yn</name> <operator>||</operator> <operator>(</operator><name>xn</name> <operator>==</operator> <name>yn</name> <operator>&amp;&amp;</operator> <name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>yds</name><index>[<expr><name>yn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qn</name> <operator>=</operator> <name>xn</name> <operator>-</operator> <name>yn</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>qn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>qds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rn</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>rn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bary_divmod_gmp</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_divmod_branch</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>rds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>GMP_DIV_DIGITS</name> <operator>&lt;</operator> <name>xn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_divmod_gmp</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>bary_divmod_normal</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_divmod</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>rds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>&lt;=</operator> <name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>yn</name> <operator>&lt;=</operator> <name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_num_zerodiv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>yn</name> <operator>||</operator> <operator>(</operator><name>xn</name> <operator>==</operator> <name>yn</name> <operator>&amp;&amp;</operator> <name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>yds</name><index>[<expr><name>yn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>rds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>rds</name><operator>+</operator><name>xn</name></expr></argument>, <argument><expr><name>rn</name><operator>-</operator><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>yn</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>qds</name><operator>+</operator><name>xn</name></expr></argument>, <argument><expr><name>qn</name><operator>-</operator><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>bigdivrem_single</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name><name>yds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>rds</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>rn</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>yn</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>x</name> <init>= <expr><call><name>bary2bdigitdbl</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>y</name> <init>= <expr><call><name>bary2bdigitdbl</name><argument_list>(<argument><expr><name>yds</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>q</name> <init>= <expr><name>x</name> <operator>/</operator> <name>y</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>r</name> <init>= <expr><name>x</name> <operator>%</operator> <name>y</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>qds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>qds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><call><name>BIGDN</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>qds</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>qn</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><call><name>BIGDN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>rds</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>rn</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bary_divmod_branch</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGNUM_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BIGNUM_DEBUG</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ON_DEBUG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x; } while (0)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_bignum</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c0x0"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"_%0*"</literal><name>PRIxBDIGIT</name></expr></argument>, <argument><expr><name>SIZEOF_BDIGIT</name><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", len=%"</literal><name>PRIuSIZE</name></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_big_dump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>dump_bignum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ON_DEBUG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bigzero_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bary_zero_p</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_bigzero_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>BIGZEROP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_cmpint</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_cmperr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIGZEROP</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGNUM_SET_LEN</name><parameter_list>(<parameter><type><name>b</name></type></parameter>,<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BIGNUM_EMBED_P(b) ? (void)(RBASIC(b)-&gt;flags = (RBASIC(b)-&gt;flags &amp; ~BIGNUM_EMBED_LEN_MASK) | ((l) &lt;&lt; BIGNUM_EMBED_LEN_SHIFT)) : (void)(RBIGNUM(b)-&gt;as.heap.len = (l)))</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_big_realloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>big</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_EMBED_P</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>BIGNUM_EMBED_LEN_MAX</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>BIGNUM_EMBED_LEN_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_UNSET_RAW</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>BIGNUM_EMBED_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>BIGNUM_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>digits</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>BIGNUM_EMBED_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_LEN</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ds</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><name>ds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>REALLOC_N</name><argument_list>(<argument><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_big_resize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>big</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_big_realloc</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_LEN</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bignew_1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>NEWOBJ_OF</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr>struct <name>RBignum</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_BIGNUM</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>RGENGC_WB_PROTECTED_BIGNUM</name></expr> ?</condition><then> <expr><name>FL_WB_PROTECTED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_SIGN</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>big</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>BIGNUM_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>BIGNUM_EMBED_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_LEN</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>big</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBIGNUM</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>big</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_new</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bignew</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>sign</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_clone</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>bignew_1</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>big_extend_carry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_big_resize</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><index>[<expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>get2comp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>big_extend_carry</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_big_2comp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<expr_stmt><expr><call><name>get2comp</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BDIGIT</name></type>
<name>abs2twocomp</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>n_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>x</name> <init>= <expr><operator>*</operator><name>xp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>bignew_1</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hibits</name> <operator>=</operator> <name>BDIGMAX</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>xp</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>n_ret</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<return>return <expr><name>hibits</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>twocomp2abs_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hibits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BIGNUM_SET_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>!</operator><name>hibits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>hibits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>get2comp</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>
<name>bigtrunc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>--</operator><name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ds</name><index>[<expr><name>len</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>len</name><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_big_resize</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>
<name>bigfixize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>u</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>u</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof><operator>/</operator><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>return_big</name>;</goto></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><call><name>BIGUP</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>return_big</name>;</goto></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <name><name>ds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>POSFIXABLE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&lt;=</operator> <operator>-</operator><name>FIXNUM_MIN</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<label><name>return_big</name>:</label>
<expr_stmt><expr><call><name>rb_big_resize</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bignorm</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>bigfixize</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_norm</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_uint2big</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>big</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_VALUE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_VALUE</name></expr></cpp:if>
<expr_stmt><expr><name><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_VALUE</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <empty_stmt>;</empty_stmt></block_content></block></while>
<expr_stmt><expr><call><name>BIGNUM_SET_LEN</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>big</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_int2big</name><parameter_list>(<parameter><decl><type><name>intptr_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>big</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>big</name> <operator>=</operator> <call><name>rb_uint2big</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIGNUM_SET_NEGATIVE_SIGN</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>big</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_uint2inum</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>POSFIXABLE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_uint2big</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_int2inum</name><parameter_list>(<parameter><decl><type><name>intptr_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FIXABLE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_int2big</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_big_pack</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>num_longs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_integer_pack</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>num_longs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_LSWORD_FIRST</name><operator>|</operator><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name><operator>|</operator>
<name>INTEGER_PACK_2COMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_unpack</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>num_longs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_integer_unpack</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>num_longs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_LSWORD_FIRST</name><operator>|</operator><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name><operator>|</operator>
<name>INTEGER_PACK_2COMP</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

















<function><type><name>size_t</name></type>
<name>rb_absint_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlz_bits_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>fixbuf</name><index>[<expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_leading_zeros</name></decl>;</decl_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>v</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name><name>fixbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>fixbuf</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>fixbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>fixbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <name>fixbuf</name> <operator>+</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>fixbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <name>dp</name> <operator>+</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<while>while <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>de</name> <operator>&amp;&amp;</operator> <name><name>de</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>de</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>==</operator> <name>de</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nlz_bits_ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>nlz_bits_ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>num_leading_zeros</name> <operator>=</operator> <call><name>nlz</name><argument_list>(<argument><expr><name><name>de</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nlz_bits_ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>nlz_bits_ret</name> <operator>=</operator> <name>num_leading_zeros</name> <operator>%</operator> <name>CHAR_BIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>de</name> <operator>-</operator> <name>dp</name><operator>)</operator> <operator>*</operator> <name>SIZEOF_BDIGIT</name> <operator>-</operator> <name>num_leading_zeros</name> <operator>/</operator> <name>CHAR_BIT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>absint_numwords_small</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numbytes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlz_bits_in_msbyte</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>word_numbits</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nlz_bits_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>val_numbits</name> <init>= <expr><name>numbytes</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>-</operator> <name>nlz_bits_in_msbyte</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>div</name> <init>= <expr><name>val_numbits</name> <operator>/</operator> <name>word_numbits</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>mod</name> <init>= <expr><name>val_numbits</name> <operator>%</operator> <name>word_numbits</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numwords</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nlz_bits</name></decl>;</decl_stmt>
<expr_stmt><expr><name>numwords</name> <operator>=</operator> <ternary><condition><expr><name>mod</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>div</name></expr> </then><else>: <expr><name>div</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>nlz_bits</name> <operator>=</operator> <ternary><condition><expr><name>mod</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>word_numbits</name> <operator>-</operator> <name>mod</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>nlz_bits_ret</name> <operator>=</operator> <name>nlz_bits</name></expr>;</expr_stmt>
<return>return <expr><name>numwords</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>absint_numwords_generic</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numbytes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlz_bits_in_msbyte</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>word_numbits</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nlz_bits_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>BDIGIT</name></type> <name><name>char_bit</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>CHAR_BIT</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>numbytes_bary</name><index>[<expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>numbytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>val_numbits_bary</name><index>[<expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>numbytes</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>nlz_bits_in_msbyte_bary</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>word_numbits_bary</name><index>[<expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>word_numbits</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>div_bary</name><index>[<expr><call><name>numberof</name><argument_list>(<argument><expr><name>val_numbits_bary</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>BIGDIVREM_EXTRA_WORDS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>mod_bary</name><index>[<expr><call><name>numberof</name><argument_list>(<argument><expr><name>word_numbits_bary</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>one</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nlz_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numwords</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>nlz_bits_in_msbyte_bary</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nlz_bits_in_msbyte</name></expr>;</expr_stmt>








<expr_stmt><expr><call><name>bary_unpack</name><argument_list>(<argument><expr><call><name>BARY_ARGS</name><argument_list>(<argument><expr><name>numbytes_bary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>numbytes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>numbytes</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_SHORT_MUL</name><argument_list>(<argument><expr><name>val_numbits_bary</name></expr></argument>, <argument><expr><name>numbytes_bary</name></expr></argument>, <argument><expr><name>char_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nlz_bits_in_msbyte</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BARY_SUB</name><argument_list>(<argument><expr><name>val_numbits_bary</name></expr></argument>, <argument><expr><name>val_numbits_bary</name></expr></argument>, <argument><expr><name>nlz_bits_in_msbyte_bary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bary_unpack</name><argument_list>(<argument><expr><call><name>BARY_ARGS</name><argument_list>(<argument><expr><name>word_numbits_bary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_numbits</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>word_numbits</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_DIVMOD</name><argument_list>(<argument><expr><name>div_bary</name></expr></argument>, <argument><expr><name>mod_bary</name></expr></argument>, <argument><expr><name>val_numbits_bary</name></expr></argument>, <argument><expr><name>word_numbits_bary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BARY_ZERO_P</name><argument_list>(<argument><expr><name>mod_bary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nlz_bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>BARY_ADD</name><argument_list>(<argument><expr><name>div_bary</name></expr></argument>, <argument><expr><name>div_bary</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_pack</name><argument_list>(<argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>BARY_ARGS</name><argument_list>(<argument><expr><name>mod_bary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>mod</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nlz_bits</name> <operator>=</operator> <name>word_numbits</name> <operator>-</operator> <name>mod</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <call><name>bary_pack</name><argument_list>(<argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>BARY_ARGS</name><argument_list>(<argument><expr><name>div_bary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>numwords</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>numwords</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC__</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>__GNUC_MINOR__</name> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>nlz_bits_ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nlz_bits_ret</name> <operator>=</operator> <name>nlz_bits</name></expr>;</expr_stmt>
<return>return <expr><name>numwords</name></expr>;</return>
</block_content>}</block></function>




















<function><type><name>size_t</name></type>
<name>rb_absint_numwords</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>word_numbits</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nlz_bits_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>numbytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nlz_bits_in_msbyte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numwords</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nlz_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>word_numbits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>numbytes</name> <operator>=</operator> <call><name>rb_absint_size</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlz_bits_in_msbyte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>numbytes</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>/</operator> <name>CHAR_BIT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>numwords</name> <operator>=</operator> <call><name>absint_numwords_small</name><argument_list>(<argument><expr><name>numbytes</name></expr></argument>, <argument><expr><name>nlz_bits_in_msbyte</name></expr></argument>, <argument><expr><name>word_numbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlz_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_INTEGER_PACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>numwords0</name></decl>, <decl><type ref="prev"/><name>nlz_bits0</name></decl>;</decl_stmt>
<expr_stmt><expr><name>numwords0</name> <operator>=</operator> <call><name>absint_numwords_generic</name><argument_list>(<argument><expr><name>numbytes</name></expr></argument>, <argument><expr><name>nlz_bits_in_msbyte</name></expr></argument>, <argument><expr><name>word_numbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlz_bits0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numwords0</name> <operator>==</operator> <name>numwords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nlz_bits0</name> <operator>==</operator> <name>nlz_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>numwords</name> <operator>=</operator> <call><name>absint_numwords_generic</name><argument_list>(<argument><expr><name>numbytes</name></expr></argument>, <argument><expr><name>nlz_bits_in_msbyte</name></expr></argument>, <argument><expr><name>word_numbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlz_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>numwords</name> <operator>==</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>numwords</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nlz_bits_ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>nlz_bits_ret</name> <operator>=</operator> <name>nlz_bits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>numwords</name></expr>;</return>
</block_content>}</block></function>





























<function><type><name>int</name></type>
<name>rb_absint_singlebit_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>fixbuf</name><index>[<expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>d</name></decl>;</decl_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>v</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name><name>fixbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>fixbuf</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>fixbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>fixbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <name>fixbuf</name> <operator>+</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>fixbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <name>dp</name> <operator>+</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<while>while <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>de</name> <operator>&amp;&amp;</operator> <name><name>de</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>de</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<while>while <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>de</name> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>==</operator> <name>de</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>!=</operator> <name>de</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>dp</name></expr>;</expr_stmt>
<return>return <expr><call><name>POW2_P</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

























































<function><type><name>int</name></type>
<name>rb_integer_pack</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>fixbuf</name><index>[<expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>v</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name><name>fixbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>fixbuf</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>fixbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <name>fixbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>fixbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <ternary><condition><expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>bary_pack</name><argument_list>(<argument><expr><name>sign</name></expr></argument>, <argument><expr><name>ds</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>words</name></expr></argument>, <argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>













































<function><type><name>VALUE</name></type>
<name>rb_integer_unpack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>numwords</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wordsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nails</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nlp_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>fixbuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>validate_integer_pack_format</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>INTEGER_PACK_MSWORD_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_LSWORD_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_MSBYTE_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_LSBYTE_FIRST</name><operator>|</operator>
<name>INTEGER_PACK_NATIVE_BYTE_ORDER</name><operator>|</operator>
<name>INTEGER_PACK_2COMP</name><operator>|</operator>
<name>INTEGER_PACK_FORCE_BIGNUM</name><operator>|</operator>
<name>INTEGER_PACK_NEGATIVE</name><operator>|</operator>
<name>INTEGER_PACK_FORCE_GENERIC_IMPLEMENTATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>integer_unpack_num_bdigits</name><argument_list>(<argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlp_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>LONG_MAX</name><operator>-</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>num_bdigits</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big to unpack as an integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>num_bdigits</name> <operator>&lt;=</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>fixbuf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_FORCE_BIGNUM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <name>fixbuf</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>num_bdigits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <call><name>bary_unpack_internal</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>words</name></expr></argument>, <argument><expr><name>numwords</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>nails</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>nlp_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>big_extend_carry</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>num_bdigits</name> <operator>==</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>fixbuf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>num_bdigits</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fixbuf</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call><index>[<expr><name>num_bdigits</name><operator>++</operator></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>ds</name><index>[<expr><name>num_bdigits</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>u</name> <init>= <expr><name><name>fixbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <call><name>BIGUP</name><argument_list>(<argument><expr><name><name>fixbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>u</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>sign</name> <operator>&amp;&amp;</operator> <call><name>POSFIXABLE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>BDIGIT_MSB</name><argument_list>(<argument><expr><name><name>fixbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>NEGFIXABLE</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name>u</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>num_bdigits</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fixbuf</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_FORCE_BIGNUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>sign</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>bary_zero_p</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_SIGN</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>INTEGER_PACK_FORCE_BIGNUM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>conv_digit</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ruby_digit36_to_number_table[(unsigned char)(c)])</cpp:value></cpp:define>

<macro><name>NORETURN</name><argument_list>(<argument>static inline void invalid_radix(int base)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>NORETURN</name><argument_list>(<argument>static inline void invalid_integer(VALUE s)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>valid_radix_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>base</name> <operator>&amp;&amp;</operator> <name>base</name> <operator>&lt;=</operator> <literal type="number">36</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>invalid_radix</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid radix %d"</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>invalid_integer</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid value for Integer(): %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>str2big_scan_digits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badcheck</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>num_digits_p</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>len_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>nondigit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_end</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name> <init>= <expr><operator>*</operator><name>len_p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>num_digits_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>len_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>badcheck</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>str</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nondigit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>badcheck</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nondigit</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>conv_digit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>c</name> <operator>&gt;=</operator> <name>base</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>nondigit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>num_digits</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>digits_end</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>--</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>badcheck</name> <operator>&amp;&amp;</operator> <name>nondigit</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>badcheck</name> <operator>&amp;&amp;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>--</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>&amp;&amp;</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>--</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<label><name>bad</name>:</label>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>num_digits_p</name> <operator>=</operator> <name>num_digits</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>len_p</name> <operator>=</operator> <name>digits_end</name> <operator>-</operator> <name>digits_start</name></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>str2big_poweroftwo</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_end</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>num_digits</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>bits_per_digit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>dd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numbits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <operator>(</operator><name>num_digits</name> <operator>/</operator> <name>BITSPERDIG</name><operator>)</operator> <operator>*</operator> <name>bits_per_digit</name> <operator>+</operator> <call><name>roomof</name><argument_list>(<argument><expr><operator>(</operator><name>num_digits</name> <operator>%</operator> <name>BITSPERDIG</name><operator>)</operator> <operator>*</operator> <name>bits_per_digit</name></expr></argument>, <argument><expr><name>BITSPERDIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>numbits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>digits_end</name></expr>;</init> <condition><expr><name>digits_start</name> <operator>&lt;</operator> <name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>conv_digit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dd</name> <operator>|=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name>c</name> <operator>&lt;&lt;</operator> <name>numbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>numbits</name> <operator>+=</operator> <name>bits_per_digit</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>BITSPERDIG</name> <operator>&lt;=</operator> <name>numbits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dd</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>numbits</name> <operator>-=</operator> <name>BITSPERDIG</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>numbits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dp</name> <operator>-</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>str2big_normal</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_end</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>blen</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>digits_start</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>digits_end</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>conv_digit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<while>while <condition>(<expr><name>i</name><operator>&lt;</operator><name>blen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name><operator>*</operator><name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>blen</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>blen</name> <operator>&lt;=</operator> <name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>str2big_karatsuba</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_end</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>num_digits</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>digits_per_bdigits_dbl</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>powerv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>unit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmpuv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>uds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>dd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>current_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>power_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<expr_stmt><expr><name>uds</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>tmpuv</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vds</name> <operator>=</operator> <name>uds</name> <operator>+</operator> <name>num_bdigits</name></expr>;</expr_stmt>

<expr_stmt><expr><name>powerv</name> <operator>=</operator> <call><name>power_cache_get_power</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>power_level</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>current_base</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> <operator>=</operator> <name>digits_per_bdigits_dbl</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num_digits</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>num_digits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>digits_end</name></expr>;</init> <condition><expr><name>digits_start</name> <operator>&lt;</operator> <name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>conv_digit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dd</name> <operator>=</operator> <name>dd</name> <operator>+</operator> <name>c</name> <operator>*</operator> <name>current_base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current_base</name> <operator>*=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num_digits</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>uds</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uds</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><call><name>BIGDN</name><argument_list>(<argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> <operator>=</operator> <name>digits_per_bdigits_dbl</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num_digits</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>num_digits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>current_base</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>unit</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>unit</name> <operator>&lt;</operator> <name>num_bdigits</name></expr>;</condition> <incr><expr><name>unit</name> <operator>*=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_bdigits</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>unit</name><operator>*</operator><literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">2</literal><operator>*</operator><name>unit</name> <operator>&lt;=</operator> <name>num_bdigits</name> <operator>-</operator> <name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_mul</name><argument_list>(<argument><expr><name>vds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>unit</name><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>powerv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>powerv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uds</name><operator>+</operator><name>i</name><operator>+</operator><name>unit</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>vds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>unit</name><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>vds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>unit</name><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>uds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>unit</name> <operator>&lt;=</operator> <name>num_bdigits</name> <operator>-</operator> <name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_mul</name><argument_list>(<argument><expr><name>vds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>num_bdigits</name><operator>-</operator><name>i</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>powerv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>powerv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uds</name><operator>+</operator><name>i</name><operator>+</operator><name>unit</name></expr></argument>, <argument><expr><name>num_bdigits</name><operator>-</operator><operator>(</operator><name>i</name><operator>+</operator><name>unit</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><name>vds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>num_bdigits</name><operator>-</operator><name>i</name></expr></argument>, <argument><expr><name>vds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>num_bdigits</name><operator>-</operator><name>i</name></expr></argument>, <argument><expr><name>uds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>vds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>uds</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>num_bdigits</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>power_level</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>powerv</name> <operator>=</operator> <call><name>power_cache_get_power</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>power_level</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tds</name> <operator>=</operator> <name>vds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vds</name> <operator>=</operator> <name>uds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>uds</name> <operator>=</operator> <name>tds</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>uds</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpuv</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>tmpuv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>str2big_gmp</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_end</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>num_digits</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mpz_t</name></type> <name>mz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zn</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>tmps</name></expr></argument>, <argument><expr><name>num_digits</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name>digits_start</name></expr>;</init> <condition><expr><name>q</name> <operator>&lt;</operator> <name>digits_end</name></expr>;</condition> <incr><expr><name>q</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>conv_digit</name><argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>q</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>mz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_set_str</name><argument_list>(<argument><expr><name>mz</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <name>num_bdigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigits_from_mpz</name><argument_list>(<argument><expr><name>mz</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>count</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>mz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmps</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>tmps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_cstr_parse_inum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>;</function_decl>

















<function><type><name>VALUE</name></type>
<name>rb_cstr_to_inum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>rb_cstr_parse_inum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>badcheck</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>end</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>badcheck</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_invalid_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"Integer()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


















<function><type><name>VALUE</name></type>
<name>rb_int_parse_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>ndigits</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ov</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>digits_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ssize_t</name></type> <name>len0</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>badcheck</name> <init>= <expr><operator>!</operator><name>endp</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADV</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (len &gt; 0 &amp;&amp; len &lt;= (n)) goto bad; str += (n); len -= (n); } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_LEN</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {assert(len != 0); if (len0 &gt;= 0) assert(s + len0 == str + len); } while (0)</cpp:value></cpp:define>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>
<label><name>bad</name>:</label>
<if_stmt><if>if <condition>(<expr><name>endp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ndigits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ndigits</name> <operator>=</operator> <name>num_digits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RB_INT_PARSE_SIGN</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ASSERT_LEN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>base</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'X'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> <case>case <expr><literal type="char">'B'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'o'</literal></expr>:</case> <case>case <expr><literal type="char">'O'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'D'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>base</name> <operator>=</operator> <operator>-</operator><name>base</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RB_INT_PARSE_PREFIX</name><operator>)</operator></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal><operator>||</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'o'</literal><operator>||</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'O'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal><operator>||</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'D'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal><operator>||</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'X'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADV</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_radix_p</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalid_radix</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num_digits</name> <operator>=</operator> <name>str</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name>us</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>str</name> <operator>+</operator> <name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>++</operator><name>num_digits</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>str</name><operator>)</operator> <operator>==</operator> <literal type="char">'0'</literal> <operator>||</operator>
<operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RB_INT_PARSE_UNDERSCORE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>us</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>num_digits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>us</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name> <operator>||</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>--</operator><name>str</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>str</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ASSERT_LEN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>str</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>conv_digit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>c</name> <operator>&gt;=</operator> <name>base</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>badcheck</name> <operator>&amp;&amp;</operator> <name>num_digits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>bad</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ndigits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ndigits</name> <operator>=</operator> <name>num_digits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>ruby_scan_digits</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_digits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ov</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ov</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><operator>&amp;</operator><name><name>str</name><index>[<expr><name>num_digits</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>num_digits</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RB_INT_PARSE_UNDERSCORE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bigparse</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>endp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ndigits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ndigits</name> <operator>+=</operator> <name>num_digits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>badcheck</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num_digits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt> 
<while>while <condition>(<expr><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>*</operator><name>end</name></expr> </then><else>: <expr><name>end</name> <operator>&lt;</operator> <name>str</name> <operator>+</operator> <name>len</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>POSFIXABLE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sign</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>result</name> <init>= <expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>big</name> <init>= <expr><call><name>rb_uint2big</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_SIGN</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<label><name>bigparse</name>:</label>
<expr_stmt><expr><name>digits_start</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str2big_scan_digits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>badcheck</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_digits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>endp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>str</name> <operator>+</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ndigits</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ndigits</name> <operator>+=</operator> <name>num_digits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>digits_end</name> <operator>=</operator> <name>digits_start</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>POW2_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>str2big_poweroftwo</name><argument_list>(<argument><expr><name>sign</name></expr></argument>, <argument><expr><name>digits_start</name></expr></argument>, <argument><expr><name>digits_end</name></expr></argument>, <argument><expr><name>num_digits</name></expr></argument>,
<argument><expr><call><name>bit_length</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>digits_per_bdigits_dbl</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>maxpow_in_bdigit_dbl</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digits_per_bdigits_dbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>roomof</name><argument_list>(<argument><expr><name>num_digits</name></expr></argument>, <argument><expr><name>digits_per_bdigits_dbl</name></expr></argument>)</argument_list></call><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>GMP_STR2BIG_DIGITS</name> <operator>&lt;</operator> <name>num_bdigits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>str2big_gmp</name><argument_list>(<argument><expr><name>sign</name></expr></argument>, <argument><expr><name>digits_start</name></expr></argument>, <argument><expr><name>digits_end</name></expr></argument>, <argument><expr><name>num_digits</name></expr></argument>,
<argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
if <condition>(<expr><name>num_bdigits</name> <operator>&lt;</operator> <name>KARATSUBA_MUL_DIGITS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>str2big_normal</name><argument_list>(<argument><expr><name>sign</name></expr></argument>, <argument><expr><name>digits_start</name></expr></argument>, <argument><expr><name>digits_end</name></expr></argument>,
<argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>str2big_karatsuba</name><argument_list>(<argument><expr><name>sign</name></expr></argument>, <argument><expr><name>digits_start</name></expr></argument>, <argument><expr><name>digits_end</name></expr></argument>, <argument><expr><name>num_digits</name></expr></argument>,
<argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>digits_per_bdigits_dbl</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_cstr_parse_inum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_int_parse_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>,
<argument><expr><name>RB_INT_PARSE_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_str_convert_to_inum</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badcheck</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>raise_exception</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_cstr_parse_inum</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>badcheck</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>end</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>badcheck</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>raise_exception</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>invalid_integer</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_str_to_inum</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_str_convert_to_inum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>badcheck</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_str2big_poweroftwo</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>positive_p</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>digits_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_radix_p</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>POW2_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalid_radix</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>positive_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>digits_start</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str2big_scan_digits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>badcheck</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_digits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>invalid_integer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>digits_end</name> <operator>=</operator> <name>digits_start</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>str2big_poweroftwo</name><argument_list>(<argument><expr><name>positive_p</name></expr></argument>, <argument><expr><name>digits_start</name></expr></argument>, <argument><expr><name>digits_end</name></expr></argument>, <argument><expr><name>num_digits</name></expr></argument>,
<argument><expr><call><name>bit_length</name><argument_list>(<argument><expr><name>base</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_str2big_normal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>positive_p</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>digits_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>digits_per_bdigits_dbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_radix_p</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalid_radix</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name> <operator>=</operator> <call><name>StringValuePtr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>positive_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>digits_start</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str2big_scan_digits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>badcheck</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_digits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>invalid_integer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>digits_end</name> <operator>=</operator> <name>digits_start</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>maxpow_in_bdigit_dbl</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digits_per_bdigits_dbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>roomof</name><argument_list>(<argument><expr><name>num_digits</name></expr></argument>, <argument><expr><name>digits_per_bdigits_dbl</name></expr></argument>)</argument_list></call><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>str2big_normal</name><argument_list>(<argument><expr><name>positive_p</name></expr></argument>, <argument><expr><name>digits_start</name></expr></argument>, <argument><expr><name>digits_end</name></expr></argument>,
<argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_str2big_karatsuba</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>positive_p</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>digits_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>digits_per_bdigits_dbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_radix_p</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalid_radix</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name> <operator>=</operator> <call><name>StringValuePtr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>positive_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>digits_start</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str2big_scan_digits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>badcheck</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_digits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>invalid_integer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>digits_end</name> <operator>=</operator> <name>digits_start</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>maxpow_in_bdigit_dbl</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digits_per_bdigits_dbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>roomof</name><argument_list>(<argument><expr><name>num_digits</name></expr></argument>, <argument><expr><name>digits_per_bdigits_dbl</name></expr></argument>)</argument_list></call><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>str2big_karatsuba</name><argument_list>(<argument><expr><name>positive_p</name></expr></argument>, <argument><expr><name>digits_start</name></expr></argument>, <argument><expr><name>digits_end</name></expr></argument>, <argument><expr><name>num_digits</name></expr></argument>,
<argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>digits_per_bdigits_dbl</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>VALUE</name></type>
<name>rb_str2big_gmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>positive_p</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>digits_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_digits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>digits_per_bdigits_dbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bdigits</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_radix_p</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalid_radix</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name> <operator>=</operator> <call><name>StringValuePtr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>positive_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>digits_start</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str2big_scan_digits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>badcheck</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_digits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>invalid_integer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>digits_end</name> <operator>=</operator> <name>digits_start</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>maxpow_in_bdigit_dbl</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digits_per_bdigits_dbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num_bdigits</name> <operator>=</operator> <call><name>roomof</name><argument_list>(<argument><expr><name>num_digits</name></expr></argument>, <argument><expr><name>digits_per_bdigits_dbl</name></expr></argument>)</argument_list></call><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>str2big_gmp</name><argument_list>(<argument><expr><name>positive_p</name></expr></argument>, <argument><expr><name>digits_start</name></expr></argument>, <argument><expr><name>digits_end</name></expr></argument>, <argument><expr><name>num_digits</name></expr></argument>, <argument><expr><name>num_bdigits</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_LONG_LONG</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ull2big</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>LONG_LONG</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>big</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG_LONG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG_LONG</name></expr></cpp:if>
<expr_stmt><expr><name><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG_LONG</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG_LONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <empty_stmt>;</empty_stmt></block_content></block></while>
<expr_stmt><expr><call><name>BIGNUM_SET_LEN</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>big</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ll2big</name><parameter_list>(<parameter><decl><type><name>LONG_LONG</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>LONG_LONG</name></type> <name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>big</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>LONG_LONG</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>big</name> <operator>=</operator> <call><name>rb_ull2big</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIGNUM_SET_NEGATIVE_SIGN</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>big</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ull2inum</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>LONG_LONG</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>POSFIXABLE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_ull2big</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ll2inum</name><parameter_list>(<parameter><decl><type><name>LONG_LONG</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FIXABLE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_ll2big</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INT128_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_uint128t2big</name><parameter_list>(<parameter><decl><type><name>uint128_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>big</name> <init>= <expr><call><name>bignew</name><argument_list>(<argument><expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_INT128_T</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_INT128_T</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><call><name>RSHIFT</name><argument_list>(<argument><expr><name>n</name></expr></argument> ,<argument><expr><name>BITSPERDIG</name><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_INT128_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <empty_stmt>;</empty_stmt></block_content></block></while>
<expr_stmt><expr><call><name>BIGNUM_SET_LEN</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>big</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_int128t2big</name><parameter_list>(<parameter><decl><type><name>int128_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint128_t</name></type> <name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>big</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>uint128_t</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>big</name> <operator>=</operator> <call><name>rb_uint128t2big</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIGNUM_SET_NEGATIVE_SIGN</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>big</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>VALUE</name></type>
<name>rb_cstr2inum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_cstr_to_inum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>base</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_str2inum</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_str_to_inum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>base</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big_shift3</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lshift_p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>shift_numdigits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shift_numbits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>s1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lshift_p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>LONG_MAX</name> <operator>&lt;</operator> <name>shift_numdigits</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>shift_numdigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <name>shift_numbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>xn</name><operator>+</operator><name>s1</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>xn</name><operator>+</operator><name>s1</name></expr>]</index></name> <operator>=</operator> <call><name>bary_small_lshift</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>s1</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibitsx</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>LONG_MAX</name> <operator>&lt;</operator> <name>shift_numdigits</name> <operator>||</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>shift_numdigits</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>bary_zero_p</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>shift_numdigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <name>shift_numbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hibitsx</name> <operator>=</operator> <call><name>abs2twocomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;=</operator> <name>s1</name></expr>)</condition> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>hibitsx</name></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <name>xn</name> <operator>-</operator> <name>s1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_small_rshift</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>xds</name><operator>+</operator><name>s1</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><ternary><condition><expr><name>hibitsx</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>BDIGMAX</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>twocomp2abs_bang</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>hibitsx</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big_shift2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lshift_p</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name><name>lens</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>shift_numdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shift_numbits</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>POW2_P</name><argument_list>(<argument><expr><name>CHAR_BIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>POW2_P</name><argument_list>(<argument><expr><name>BITSPERDIG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGZEROP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <call><name>rb_integer_pack</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>lens</name></expr></argument>, <argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>lens</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_LSWORD_FIRST</name><operator>|</operator><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lshift_p</name> <operator>=</operator> <operator>!</operator><name>lshift_p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lshift_p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>sign</name> <operator>||</operator> <name>CHAR_BIT</name> <operator>&lt;=</operator> <name><name>lens</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"shift width too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>sign</name> <operator>||</operator> <name>CHAR_BIT</name> <operator>&lt;=</operator> <name><name>lens</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>shift_numbits</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>lens</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><name>BITSPERDIG</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>shift_numdigits</name> <operator>=</operator> <operator>(</operator><name><name>lens</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <call><name>bit_length</name><argument_list>(<argument><expr><name>BITSPERDIG</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>|</operator>
<operator>(</operator><name><name>lens</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>CHAR_BIT</name><operator>*</operator><name>SIZEOF_SIZE_T</name> <operator>-</operator> <call><name>bit_length</name><argument_list>(<argument><expr><name>BITSPERDIG</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><call><name>big_shift3</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>lshift_p</name></expr></argument>, <argument><expr><name>shift_numdigits</name></expr></argument>, <argument><expr><name>shift_numbits</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big_lshift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>shift</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>s1</name> <init>= <expr><name>shift</name><operator>/</operator><name>BITSPERDIG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>shift</name><operator>%</operator><name>BITSPERDIG</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>big_shift3</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big_rshift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>shift</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>s1</name> <init>= <expr><name>shift</name><operator>/</operator><name>BITSPERDIG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>shift</name><operator>%</operator><name>BITSPERDIG</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>big_shift3</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BASE36_POWER_TABLE_ENTRIES</name></cpp:macro> <cpp:value>(SIZEOF_SIZE_T * CHAR_BIT + 1)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name><name>base36_power_cache</name><index>[<expr><literal type="number">35</literal></expr>]</index><index>[<expr><name>MAX_BASE36_POWER_TABLE_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name><name>base36_numdigits_cache</name><index>[<expr><literal type="number">35</literal></expr>]</index><index>[<expr><name>MAX_BASE36_POWER_TABLE_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>power_cache_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>
<name>power_cache_get_power</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>power_level</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>numdigits_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>














<if_stmt><if>if <condition>(<expr><name>MAX_BASE36_POWER_TABLE_ENTRIES</name> <operator>&lt;=</operator> <name>power_level</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"too big power number requested: maxpow_in_bdigit_dbl(%d)**(2**%d)"</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>power_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>power</name> <init>= <expr><name><name>base36_power_cache</name><index>[<expr><name>base</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index><index>[<expr><name>power_level</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>power</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>numdigits</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>power_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>numdigits0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>dd</name> <init>= <expr><call><name>maxpow_in_bdigit_dbl</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numdigits0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>power</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigitdbl2bary</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>power</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>numdigits</name> <operator>=</operator> <name>numdigits0</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>power</name> <operator>=</operator> <call><name>bigtrunc</name><argument_list>(<argument><expr><call><name>bigsq</name><argument_list>(<argument><expr><call><name>power_cache_get_power</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>power_level</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>numdigits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>numdigits</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>power</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>base36_power_cache</name><index>[<expr><name>base</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index><index>[<expr><name>power_level</name></expr>]</index></name> <operator>=</operator> <name>power</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>base36_numdigits_cache</name><index>[<expr><name>base</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index><index>[<expr><name>power_level</name></expr>]</index></name> <operator>=</operator> <name>numdigits</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>power</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>numdigits_ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>numdigits_ret</name> <operator>=</operator> <name><name>base36_numdigits_cache</name><index>[<expr><name>base</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index><index>[<expr><name>power_level</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>power</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>big2str_struct</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>negative</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>hbase2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hbase2_numdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>big2str_alloc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>big2str_struct</name></name> <modifier>*</modifier></type><name>b2s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>LONG_MAX</name><operator>-</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>b2s</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>rb_usascii_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name><name>b2s</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b2s</name><operator>-&gt;</operator><name>negative</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>big2str_2bdigits</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>big2str_struct</name></name> <modifier>*</modifier></type><name>b2s</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>taillen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>SIZEOF_BDIGIT_DBL</name><operator>*</operator><name>CHAR_BIT</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>beginning</name> <init>= <expr><operator>!</operator><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>bary2bdigitdbl</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beginning</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>idx</name> <init>= <expr><name>num</name> <operator>%</operator> <name><name>b2s</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>num</name> <operator>/=</operator> <name><name>b2s</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><operator>--</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>ruby_digitmap</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>num</name></expr>)</condition>;</do>
<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>big2str_alloc</name><argument_list>(<argument><expr><name>b2s</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>taillen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>b2s</name><operator>-&gt;</operator><name>hbase2_numdigits</name></name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>idx</name> <init>= <expr><name>num</name> <operator>%</operator> <name><name>b2s</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>num</name> <operator>/=</operator> <name><name>b2s</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><operator>--</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>ruby_digitmap</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>j</name></expr>)</condition>;</do>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>b2s</name><operator>-&gt;</operator><name>hbase2_numdigits</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>big2str_karatsuba</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>big2str_struct</name></name> <modifier>*</modifier></type><name>b2s</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wn</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>power_level</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>taillen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>half_numdigits</name></decl>, <decl><type ref="prev"/><name>lower_numdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lower_power_level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>bds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>





















<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>bary_zero_p</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>power_cache_get_power</name><argument_list>(<argument><expr><name><name>b2s</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>power_level</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>power_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>big2str_2bdigits</name><argument_list>(<argument><expr><name>b2s</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>taillen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lower_power_level</name> <operator>=</operator> <name>power_level</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>power_cache_get_power</name><argument_list>(<argument><expr><name><name>b2s</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>lower_power_level</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower_numdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>half_numdigits</name> <operator>=</operator> <name>lower_numdigits</name></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>lower_power_level</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>xn</name> <operator>&lt;</operator> <name>bn</name> <operator>||</operator>
<operator>(</operator><name>xn</name> <operator>==</operator> <name>bn</name> <operator>&amp;&amp;</operator> <call><name>bary_cmp</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>bds</name></expr></argument>, <argument><expr><name>bn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lower_power_level</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>power_cache_get_power</name><argument_list>(<argument><expr><name><name>b2s</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>lower_power_level</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower_numdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>lower_power_level</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>xn</name> <operator>&lt;</operator> <name>bn</name> <operator>||</operator>
<operator>(</operator><name>xn</name> <operator>==</operator> <name>bn</name> <operator>&amp;&amp;</operator> <call><name>bary_cmp</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>bds</name></expr></argument>, <argument><expr><name>bn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>half_numdigits</name> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <name>lower_numdigits</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>big2str_2bdigits</name><argument_list>(<argument><expr><name>b2s</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>taillen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>qn</name></decl>, <decl><type ref="prev"/><name>rn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>tds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lower_power_level</name> <operator>!=</operator> <name>power_level</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>half_numdigits</name> <operator>-</operator> <name>lower_numdigits</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2s</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>shift</name> <operator>=</operator> <call><name>nlz</name><argument_list>(<argument><expr><name><name>bds</name><index>[<expr><name>bn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qn</name> <operator>=</operator> <name>xn</name> <operator>+</operator> <name>BIGDIVREM_EXTRA_WORDS</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shift</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>tds</name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name> <operator>*</operator><operator>)</operator><name>bds</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>xds</name><index>[<expr><name>xn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>


<expr_stmt><expr><name>tds</name> <operator>=</operator> <name>xds</name> <operator>+</operator> <name>qn</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>qn</name> <operator>+</operator> <name>bn</name> <operator>&lt;=</operator> <name>xn</name> <operator>+</operator> <name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_small_lshift</name><argument_list>(<argument><expr><name>tds</name></expr></argument>, <argument><expr><name>bds</name></expr></argument>, <argument><expr><name>bn</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>xds</name><index>[<expr><name>xn</name></expr>]</index></name> <operator>=</operator> <call><name>bary_small_lshift</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>bigdivrem_restoring</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>, <argument><expr><name>tds</name></expr></argument>, <argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rds</name> <operator>=</operator> <name>xds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rn</name> <operator>=</operator> <name>bn</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qds</name> <operator>=</operator> <name>xds</name> <operator>+</operator> <name>bn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>qn</name> <operator>=</operator> <name>qn</name> <operator>-</operator> <name>bn</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shift</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_small_rshift</name><argument_list>(<argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>qn</name> <operator>&lt;=</operator> <name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>big2str_karatsuba</name><argument_list>(<argument><expr><name>b2s</name></expr></argument>, <argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>, <argument><expr><name>xn</name><operator>+</operator><name>wn</name> <operator>-</operator> <operator>(</operator><name>rn</name><operator>+</operator><name>qn</name><operator>)</operator></expr></argument>, <argument><expr><name>lower_power_level</name></expr></argument>, <argument><expr><name>lower_numdigits</name><operator>+</operator><name>taillen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>big2str_karatsuba</name><argument_list>(<argument><expr><name>b2s</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>xn</name><operator>+</operator><name>wn</name> <operator>-</operator> <name>rn</name></expr></argument>, <argument><expr><name>lower_power_level</name></expr></argument>, <argument><expr><name>taillen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big2str_base_poweroftwo</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>word_numbits</name> <init>= <expr><call><name>ffs</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numwords</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>numwords</name> <operator>=</operator> <call><name>rb_absint_numwords</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>word_numbits</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>LONG_MAX</name><operator>-</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>numwords</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_usascii_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>numwords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>LONG_MAX</name> <operator>&lt;</operator> <name>numwords</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_usascii_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numwords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_integer_pack</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>numwords</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>CHAR_BIT</name><operator>-</operator><name>word_numbits</name></expr></argument>,
<argument><expr><name>INTEGER_PACK_BIG_ENDIAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>numwords</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name><name>ruby_digitmap</name><index>[<expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>numwords</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big2str_poweroftwo</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>big2str_base_poweroftwo</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big2str_generic</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>big2str_struct</name></name></type> <name>b2s_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>power_level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>power</name></decl>;</decl_stmt>

<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_radix_p</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>invalid_radix</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;=</operator> <name>LONG_MAX</name><operator>/</operator><name>BITSPERDIG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum too big to convert into `string'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>power_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>power</name> <operator>=</operator> <call><name>power_cache_get_power</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>power_level</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>power_level</name> <operator>&lt;</operator> <name>MAX_BASE36_POWER_TABLE_ENTRIES</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>size_t</name><operator>)</operator><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>power</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>xn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>power_level</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>power</name> <operator>=</operator> <call><name>power_cache_get_power</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>power_level</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>power_level</name> <operator>!=</operator> <name>MAX_BASE36_POWER_TABLE_ENTRIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>power</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>xn</name></expr>)</condition> <block>{<block_content>










<expr_stmt><expr><name>power_level</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>b2s_data</name><operator>.</operator><name>negative</name></name> <operator>=</operator> <call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2s_data</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2s_data</name><operator>.</operator><name>hbase2</name></name> <operator>=</operator> <call><name>maxpow_in_bdigit_dbl</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b2s_data</name><operator>.</operator><name>hbase2_numdigits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>b2s_data</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2s_data</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>power_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>big2str_2bdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b2s_data</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmpw</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>wds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>wn</name></decl>;</decl_stmt>
<expr_stmt><expr><name>wn</name> <operator>=</operator> <name>power_level</name> <operator>*</operator> <name>BIGDIVREM_EXTRA_WORDS</name> <operator>+</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>power</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wds</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>tmpw</name></expr></argument>, <argument><expr><name>xn</name> <operator>+</operator> <name>wn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>wds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>big2str_karatsuba</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b2s_data</name></expr></argument>, <argument><expr><name>wds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>wn</name></expr></argument>, <argument><expr><name>power_level</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpw</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>tmpw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name><name>b2s_data</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name><name>b2s_data</name><operator>.</operator><name>result</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name><name>b2s_data</name><operator>.</operator><name>ptr</name></name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name><name>b2s_data</name><operator>.</operator><name>result</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>b2s_data</name><operator>.</operator><name>result</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big2str_generic</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>big2str_generic</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big2str_gmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mpz_t</name></type> <name>mx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>mx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigits_to_mpz</name><argument_list>(<argument><expr><name>mx</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mpz_sizeinbase</name><argument_list>(<argument><expr><name>mx</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mpz_neg</name><argument_list>(<argument><expr><name>mx</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_usascii_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_usascii_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>mpz_get_str</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>mx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big2str_gmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>big2str_gmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_big2str1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_fix2str</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_radix_p</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>invalid_radix</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;=</operator> <name>LONG_MAX</name><operator>/</operator><name>BITSPERDIG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum too big to convert into `string'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>POW2_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>big2str_base_poweroftwo</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>GMP_BIG2STR_DIGITS</name> <operator>&lt;</operator> <name>xn</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>big2str_gmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>big2str_generic</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big2str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_big2str1</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>big2ulong</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGSIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum too big to convert into `%s'"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>ds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>&lt;&lt;=</operator> <name>BITSPERDIG</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>ds</name><index>[<expr><name>len</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> 
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>long</name></type>
<name>rb_big2ulong</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>num</name> <init>= <expr><call><name>big2ulong</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"unsigned long"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>LONG_MIN</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>num</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum out of range of unsigned long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>long</name></type>
<name>rb_big2long</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>num</name> <init>= <expr><call><name>big2ulong</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"long"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <name>LONG_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>num</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>LONG_MIN</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>num</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum too big to convert into `long'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_LONG_LONG</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>LONG_LONG</name></type>
<name>big2ull</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> <operator>&gt;</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>LONG_LONG</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGSIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>SIZEOF_LONG_LONG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum too big to convert into `%s'"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> <operator>&lt;=</operator> <name>SIZEOF_BDIGIT</name></expr></cpp:if>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>LONG_LONG</name><operator>)</operator><name><name>ds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGUP</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <name><name>ds</name><index>[<expr><name>len</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>LONG_LONG</name></type>
<name>rb_big2ull</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>LONG_LONG</name></type> <name>num</name> <init>= <expr><call><name>big2ull</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"unsigned long long"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><name>unsigned</name> <name>LONG_LONG</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>LLONG_MIN</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><operator>(</operator><name>LONG_LONG</name><operator>)</operator><operator>(</operator><name>num</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum out of range of unsigned long long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LONG_LONG</name></type>
<name>rb_big2ll</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>LONG_LONG</name></type> <name>num</name> <init>= <expr><call><name>big2ull</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="string">"long long"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <name>LLONG_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>num</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><name>unsigned</name> <name>LONG_LONG</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>LLONG_MIN</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><operator>(</operator><name>LONG_LONG</name><operator>)</operator><operator>(</operator><name>num</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum too big to convert into `long long'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>dbl2big</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>digits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>u</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>d</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then><expr><operator>-</operator><name>d</name></expr></then><else>:<expr><name>d</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eFloatDomainError</name></expr></argument>, <argument><expr><ternary><condition><expr><name>d</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"-Infinity"</literal></expr> </then><else>: <expr><literal type="string">"Infinity"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eFloatDomainError</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1.0</literal> <operator>&lt;=</operator> <name>u</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>/=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>BIGRAD</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>d</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>digits</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>*=</operator> <name>BIGRAD</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name> <operator>-=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_dbl2big</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><call><name>dbl2big</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>big2dbl</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><operator>(</operator><call><name>bigtrunc</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>, <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>, <decl><type ref="prev"/><name>lo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>dl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>BITSPERDIG</name> <operator>-</operator> <call><name>nlz</name><argument_list>(<argument><expr><name><name>ds</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&gt;</operator> <name>DBL_MANT_DIG</name><operator>+</operator><name>DBL_MAX_EXP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name>HUGE_VAL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&gt;</operator> <name>DBL_MANT_DIG</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>(</operator><name>bits</name> <operator>-=</operator> <name>DBL_MANT_DIG</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>BITSPERDIG</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;</operator> <name>lo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>BIGRAD</name><operator>*</operator><name>d</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>dl</name> <operator>=</operator> <name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>dl</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>BDIGIT</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>bits</name> <operator>%=</operator> <name>BITSPERDIG</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>carry</name> <init>= <expr><operator>(</operator><name>dl</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>BDIGMAX</name> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>carry</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>carry</name> <operator>=</operator> <name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>carry</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>carry</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>mask</name> <init>= <expr><name>BDIGMAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>bit</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>mask</name> <operator>&lt;&lt;=</operator> <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bit</name> <operator>&lt;&lt;=</operator> <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dl</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dl</name> <operator>+=</operator> <name>bit</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dl</name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>dl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dl</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name>dl</name> <operator>+</operator> <name>BIGRAD</name><operator>*</operator><name>d</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lo</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lo</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <name>BITSPERDIG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name>HUGE_VAL</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>INT_MIN</name> <operator>/</operator> <name>BITSPERDIG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ldexp</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>lo</name> <operator>*</operator> <name>BITSPERDIG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>-</operator><name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>double</name></type>
<name>rb_big2dbl</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><call><name>big2dbl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"Bignum out of Float range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>-</operator><name>HUGE_VAL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name>HUGE_VAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_integer_float_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>yd</name> <init>= <expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>yi</name></decl>, <decl><type ref="prev"/><name>yf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>rel</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>yd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>yd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>yd</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>yf</name> <operator>=</operator> <call><name>modf</name><argument_list>(<argument><expr><name>yd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>&lt;</operator> <name>DBL_MANT_DIG</name></expr></cpp:if> 
<decl_stmt><decl><type><name>double</name></type> <name>xd</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>xd</name> <operator>&lt;</operator> <name>yd</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xd</name> <operator>&gt;</operator> <name>yd</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name></decl>, <decl><type ref="prev"/><name>yn</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>yi</name> <operator>&lt;</operator> <name>FIXNUM_MIN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>FIXNUM_MAX</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;=</operator> <name>yi</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yn</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>yi</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>yn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;</operator> <name>yn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>yf</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0.0</literal> <operator>&lt;</operator> <name>yf</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_dbl2big</name><argument_list>(<argument><expr><name>yi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>rb_big_cmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>yf</name> <operator>==</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>rel</name> <operator>!=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>rel</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>yf</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>&gt;=</operator> <name>DBL_MANT_DIG</name></expr></cpp:if> 
<decl_stmt><decl><type><name>COMPILER_WARNING_PUSH</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>__has_warning</name><argument_list>(<argument><expr><literal type="string">"-Wimplicit-int-float-conversion"</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<name>COMPILER_WARNING_IGNORED</name><argument_list>(<argument><expr><operator>-</operator><name>Wimplicit</name><operator>-</operator><name>int</name><operator>-</operator><name>float</name><operator>-</operator><name>conversion</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
static const <name>double</name> <name>LONG_MAX_as_double</name> <init>= <expr><name>LONG_MAX</name></expr></init></decl>;</decl_stmt>
<function><type><name>COMPILER_WARNING_POP</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>VALUE</name></type>
<name>rb_integer_float_eq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>yd</name> <init>= <expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>yi</name></decl>, <decl><type ref="prev"/><name>yf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>yd</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>yd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>yf</name> <operator>=</operator> <call><name>modf</name><argument_list>(<argument><expr><name>yd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>yf</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>&lt;</operator> <name>DBL_MANT_DIG</name></expr></cpp:if> 
<decl_stmt><decl><type><name>double</name></type> <name>xd</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>xd</name> <operator>!=</operator> <name>yd</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name></decl>, <decl><type ref="prev"/><name>yn</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>yi</name> <operator>&lt;</operator> <name>LONG_MIN</name> <operator>||</operator> <name>LONG_MAX_as_double</name> <operator>&lt;=</operator> <name>yi</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yn</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>yi</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>!=</operator> <name>yn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_dbl2big</name><argument_list>(<argument><expr><name>yi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_big_eq</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>VALUE</name></type>
<name>rb_big_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>bigfixize</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>sx</name> <init>= <expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>x</name></expr></init></decl>, <decl><type ref="prev"/><name>sy</name> <init>= <expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>y</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sx</name> <operator>&lt;</operator> <name>sy</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>sx</name> <operator>&gt;</operator> <name>sy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>bary_cmp</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>cmp</name></expr> </then><else>: <expr><operator>-</operator><name>cmp</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_integer_float_cmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_cmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>idCmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>big_op_t</name> <block>{
<decl><name>big_op_gt</name></decl>,
<decl><name>big_op_ge</name></decl>,
<decl><name>big_op_lt</name></decl>,
<decl><name>big_op_le</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big_op</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>big_op_t</name></name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>rel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>rb_big_cmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>rb_integer_float_cmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>big_op_gt</name></expr>:</case> <expr_stmt><expr><name>id</name> <operator>=</operator> <literal type="char">'&gt;'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>big_op_ge</name></expr>:</case> <expr_stmt><expr><name>id</name> <operator>=</operator> <name>idGE</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>big_op_lt</name></expr>:</case> <expr_stmt><expr><name>id</name> <operator>=</operator> <literal type="char">'&lt;'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>big_op_le</name></expr>:</case> <expr_stmt><expr><name>id</name> <operator>=</operator> <name>idLE</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
<return>return <expr><call><name>rb_num_coerce_relop</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>big_op_gt</name></expr>:</case> <return>return <expr><ternary><condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
<case>case <expr><name>big_op_ge</name></expr>:</case> <return>return <expr><ternary><condition><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
<case>case <expr><name>big_op_lt</name></expr>:</case> <return>return <expr><ternary><condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
<case>case <expr><name>big_op_le</name></expr>:</case> <return>return <expr><ternary><condition><expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>Qundef</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_gt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>big_op</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>big_op_gt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_ge</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>big_op</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>big_op_ge</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_lt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>big_op</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>big_op_lt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_le</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>big_op</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>big_op_le</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>












<function><type><name>VALUE</name></type>
<name>rb_big_eq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><ternary><condition><expr><call><name>bignorm</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>y</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_integer_float_eq</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MEMCMP</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>BDIGIT</name></expr></argument>,<argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_eql</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MEMCMP</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>BDIGIT</name></expr></argument>,<argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_uminus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>rb_big_clone</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BIGNUM_NEGATE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_comp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><call><name>rb_big_clone</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bary_add_one</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>big_extend_carry</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_NEGATIVE_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>bary_neg</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>bary_add_one</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bary_neg</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_POSITIVE_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigsub</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>yds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name></decl>, <decl><type ref="prev"/><name>yn</name></decl>, <decl><type ref="prev"/><name>zn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <ternary><condition><expr><name>xn</name> <operator>&lt;</operator> <name>yn</name></expr> ?</condition><then> <expr><name>yn</name></expr> </then><else>: <expr><name>xn</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bary_sub</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bary_2comp</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_NEGATIVE_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>bigadd_int</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>y</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigsub_int</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>y0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name></decl>, <decl><type ref="prev"/><name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL_SIGNED</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <name>y0</name></expr>;</expr_stmt>
<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><operator>-</operator><name>y0</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>zn</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>zn</name> <operator>&lt;</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>xn</name> <operator>==</operator> <name>zn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>y</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIGNUM_NEGATE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><operator>-</operator><name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>y_is_zero_x</name>;</goto></block_content></block></if></if_stmt>
<goto>goto <name>finish</name>;</goto>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>y_is_zero_x</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL_SIGNED</name><operator>)</operator><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>y_is_zero_z</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>-=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<goto>goto <name>finish</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>y_is_zero_x</name>:</label>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>num_is_zero_x</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>y_is_zero_z</name>:</label>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>num_is_zero_z</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<goto>goto <name>finish</name>;</goto>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>num_is_zero_x</name>:</label>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>num_is_zero_z</name>:</label>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<goto>goto <name>finish</name>;</goto>

<label><name>finish</name>:</label>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>num</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>num</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>get2comp</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_NEGATE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigadd_int</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name></decl>, <decl><type ref="prev"/><name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>zn</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>zn</name> <operator>&lt;</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>zn</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>y_is_zero_x</name>;</goto></block_content></block></if></if_stmt>
<goto>goto <name>y_is_zero_z</name>;</goto>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>y_is_zero_x</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>y_is_zero_z</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<goto>goto <name>finish</name>;</goto>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init>;</init><condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>y_is_zero_x</name>:</label>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>num_is_zero_x</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>y_is_zero_z</name>:</label>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>num_is_zero_z</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<goto>goto <name>finish</name>;</goto>

<for>for <control>(<init>;</init><condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>num_is_zero_x</name>:</label>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>num_is_zero_z</name>:</label>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<goto>goto <name>finish</name>;</goto>

<label><name>finish</name>:</label>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigadd</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>(</operator><name>sign</name> <operator>==</operator> <call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>sign</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sign</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>bigsub</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>bigsub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bary_add</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_plus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>!=</operator> <call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>bigsub_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>bigadd_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><call><name>bigadd</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>rb_big2dbl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_minus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>!=</operator> <call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>bigadd_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>bigsub_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><call><name>bigadd</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>rb_big2dbl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigsq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name></decl>, <decl><type ref="prev"/><name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>

<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>xn</name></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>NAIVE_MUL_DIGITS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_sq_fast</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bary_mul</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigmul0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name></decl>, <decl><type ref="prev"/><name>yn</name></decl>, <decl><type ref="prev"/><name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>yds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>bigsq</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <name>xn</name> <operator>+</operator> <name>yn</name></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bary_mul</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_mul</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_int2big</name><argument_list>(<argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>rb_big2dbl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><call><name>bigmul0</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigdivrem</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>divp</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>modp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>xn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>yn</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>yds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>dd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>q</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>r</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>qds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>qn</name></decl>, <decl><type ref="prev"/><name>rn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>yds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_num_zerodiv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&lt;</operator> <name>yn</name> <operator>||</operator> <operator>(</operator><name>xn</name> <operator>==</operator> <name>yn</name> <operator>&amp;&amp;</operator> <name><name>xds</name><index>[<expr><name>xn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>yds</name><index>[<expr><name>yn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>divp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>divp</name> <operator>=</operator> <call><name>rb_int2big</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>modp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>modp</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>yn</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dd</name> <operator>=</operator> <name><name>yds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>xn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dd</name> <operator>=</operator> <call><name>bigdivrem_single</name><argument_list>(<argument><expr><name>zds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>modp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>modp</name> <operator>=</operator> <call><name>rb_uint2big</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_SIGN</name><argument_list>(<argument><expr><operator>*</operator><name>modp</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>divp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>divp</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>yn</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>x0</name> <init>= <expr><call><name>bary2bdigitdbl</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>y0</name> <init>= <expr><call><name>bary2bdigitdbl</name><argument_list>(<argument><expr><name>yds</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>q0</name> <init>= <expr><name>x0</name> <operator>/</operator> <name>y0</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>r0</name> <init>= <expr><name>x0</name> <operator>%</operator> <name>y0</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>divp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT_DBL</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>q0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><call><name>BIGDN</name><argument_list>(<argument><expr><name>q0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>divp</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>modp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT_DBL</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>r0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><call><name>BIGDN</name><argument_list>(<argument><expr><name>r0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>modp</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>divp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>qn</name> <operator>=</operator> <name>xn</name> <operator>+</operator> <name>BIGDIVREM_EXTRA_WORDS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>qn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>qds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>qn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>qds</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>modp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rn</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>rn</name></expr></argument>, <argument><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>rn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rds</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>bary_divmod_branch</name><argument_list>(<argument><expr><name>qds</name></expr></argument>, <argument><expr><name>qn</name></expr></argument>, <argument><expr><name>rds</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>divp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>divp</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>modp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>modp</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bigdivmod</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>divp</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>modp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>mod</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bigdivrem</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>divp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BIGZEROP</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>divp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>divp</name> <operator>=</operator> <call><name>bigadd</name><argument_list>(<argument><expr><operator>*</operator><name>divp</name></expr></argument>, <argument><expr><call><name>rb_int2big</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>modp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>modp</name> <operator>=</operator> <call><name>bigadd</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>modp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>modp</name> <operator>=</operator> <name>mod</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_big_divide</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_int2big</name><argument_list>(<argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>dx</name> <init>= <expr><call><name>rb_big2dbl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>rb_flo_div_flo</name><argument_list>(<argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>dy</name> <init>= <expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dy</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_num_zerodiv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_big_divide</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_dbl2big</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>bigdivmod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_div</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_big_divide</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_idiv</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_big_divide</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>idDiv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_modulo</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_int2big</name><argument_list>(<argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bigdivmod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_remainder</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_int2big</name><argument_list>(<argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"remainder"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bigdivrem</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_divmod</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>div</name></decl>, <decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_int2big</name><argument_list>(<argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>idDivmod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bigdivmod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>div</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>bignorm</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bignorm</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>big_shift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>big_lshift</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>big_rshift</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <block>{<decl><name>DBL_BIGDIG</name> <init>= <expr><operator>(</operator><operator>(</operator><name>DBL_MANT_DIG</name> <operator>+</operator> <name>BITSPERDIG</name><operator>)</operator> <operator>/</operator> <name>BITSPERDIG</name><operator>)</operator></expr></init></decl>}</block>;</enum>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>big_fdiv</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>ey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>ex</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ex</name> <operator>=</operator> <name>l</name> <operator>*</operator> <name>BITSPERDIG</name> <operator>-</operator> <call><name>nlz</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><index>[<expr><name>l</name><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ex</name> <operator>-=</operator> <literal type="number">2</literal> <operator>*</operator> <name>DBL_BIGDIG</name> <operator>*</operator> <name>BITSPERDIG</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ex</name> <operator>&gt;</operator> <name>BITSPERDIG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ex</name> <operator>-=</operator> <name>BITSPERDIG</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ex</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>big_shift</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bigdivrem</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name>ex</name> <operator>-</operator> <name>ey</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>HUGE_VAL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>ldexp</name><argument_list>(<argument><expr><call><name>big2dbl</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>big_fdiv_int</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>ey</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ey</name> <operator>=</operator> <name>l</name> <operator>*</operator> <name>BITSPERDIG</name> <operator>-</operator> <call><name>nlz</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><index>[<expr><name>l</name><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ey</name> <operator>-=</operator> <name>DBL_BIGDIG</name> <operator>*</operator> <name>BITSPERDIG</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ey</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>big_shift</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>ey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>big_fdiv</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>ey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>big_fdiv_float</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>dbl2big</name><argument_list>(<argument><expr><call><name>ldexp</name><argument_list>(<argument><expr><call><name>frexp</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DBL_MANT_DIG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>big_fdiv</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <name>DBL_MANT_DIG</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>double</name></type>
<name>rb_big_fdiv_double</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>dx</name></decl>, <decl><type ref="prev"/><name>dy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dx</name> <operator>=</operator> <call><name>big2dbl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dy</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>big_fdiv_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>rb_int2big</name><argument_list>(<argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>big_fdiv_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dy</name> <operator>=</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>dy</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>big_fdiv_float</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>NUM2DBL</name><argument_list>(<argument><expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>idFdiv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_flo_div_flo</name><argument_list>(<argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>NUM2DBL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_fdiv</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>rb_big_fdiv_double</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_pow</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>yy</name></decl>;</decl_stmt>

<label><name>again</name>:</label>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BIGZEROP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_dbl_complex_new_polar_pi</name><argument_list>(<argument><expr><call><name>pow</name><argument_list>(<argument><expr><operator>-</operator><call><name>rb_big2dbl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>bignorm</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>again</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"in a**b, b may be too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>rb_big2dbl</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>yy</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>yy</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_big_pow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>INT2NUM</name><argument_list>(<argument><expr><operator>-</operator><name>yy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>rb_rational_raw</name><argument_list>(<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>/</operator> <call><name>NUM2DBL</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>xbits</name> <init>= <expr><call><name>rb_absint_numwords</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>BIGLEN_LIMIT</name> <init>= <expr><literal type="number">32</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>xbits</name> <operator>==</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<operator>(</operator><name>xbits</name> <operator>&gt;</operator> <name>BIGLEN_LIMIT</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>xbits</name> <operator>*</operator> <name>yy</name> <operator>&gt;</operator> <name>BIGLEN_LIMIT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"in a**b, b may be too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>yy</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>mask</name> <operator>=</operator> <name>FIXNUM_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>mask</name></expr>;</condition> <incr><expr><name>mask</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>z</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bigsq</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>yy</name> <operator>&amp;</operator> <name>mask</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <ternary><condition><expr><name>z</name></expr> ?</condition><then> <expr><call><name>bigtrunc</name><argument_list>(<argument><expr><call><name>bigmul0</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bin</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>idPow</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>pow</name><argument_list>(<argument><expr><call><name>rb_big2dbl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigand_int</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>hibitsx</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibitsy</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><name>hibitsx</name></expr> ?</condition><then> <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <ternary><condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>y</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BDIGMAX</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hibitsy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>&amp;=</operator> <name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>zn</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>hibitsx</name> <operator>&amp;&amp;</operator> <name>zn</name> <operator>&lt;</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>y</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>y</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>hibitsx</name> <operator>&amp;</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for <control>(<init>;</init><condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>hibitsy</name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init><condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>hibitsx</name> <operator>&amp;</operator> <name>hibitsy</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>twocomp2abs_bang</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>hibitsx</name> <operator>&amp;&amp;</operator> <name>hibitsy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_and</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ds2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>xn</name></decl>, <decl><type ref="prev"/><name>yn</name></decl>, <decl><type ref="prev"/><name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibitsx</name></decl>, <decl><type ref="prev"/><name>hibitsy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibits1</name></decl>, <decl><type ref="prev"/><name>hibits2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmpv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>tmph</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>tmpn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bit</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hibitsx</name> <operator>=</operator> <call><name>abs2twocomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>bigand_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>hibitsx</name></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <call><name>abs2twocomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmpv</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt> <expr_stmt><expr><name>y</name> <operator>=</operator> <name>tmpv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpn</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt> <expr_stmt><expr><name>xn</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt> <expr_stmt><expr><name>yn</name> <operator>=</operator> <name>tmpn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmph</name> <operator>=</operator> <name>hibitsx</name></expr>;</expr_stmt> <expr_stmt><expr><name>hibitsx</name> <operator>=</operator> <name>hibitsy</name></expr>;</expr_stmt> <expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <name>tmph</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ds1</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ds2</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hibits1</name> <operator>=</operator> <name>hibitsx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hibits2</name> <operator>=</operator> <name>hibitsy</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hibits1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>n2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ds1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name><name>ds2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n2</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>hibits1</name> <operator>&amp;</operator> <name><name>ds2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>twocomp2abs_bang</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>hibits1</name> <operator>&amp;&amp;</operator> <name>hibits2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigor_int</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>hibitsx</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibitsy</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><name>hibitsx</name></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <ternary><condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>y</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BDIGMAX</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>zn</name> <operator>&lt;</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>y_is_fixed_point</name>;</goto></block_content></block></if></if_stmt>
<goto>goto <name>finish</name>;</goto>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>y</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>y_is_fixed_point</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>hibitsx</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fill_hibits</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>y</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>y_is_fixed_point</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<goto>goto <name>finish</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>y_is_fixed_point</name>:</label>
<if_stmt><if>if <condition>(<expr><name>hibitsy</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fill_hibits</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>hibitsx</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fill_hibits</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<goto>goto <name>finish</name>;</goto>

<label><name>fill_hibits</name>:</label>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BDIGMAX</name></expr>;</expr_stmt>
</block_content>}</block></for>

<label><name>finish</name>:</label>
<expr_stmt><expr><call><name>twocomp2abs_bang</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>hibitsx</name> <operator>||</operator> <name>hibitsy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_or</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ds2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>xn</name></decl>, <decl><type ref="prev"/><name>yn</name></decl>, <decl><type ref="prev"/><name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibitsx</name></decl>, <decl><type ref="prev"/><name>hibitsy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibits1</name></decl>, <decl><type ref="prev"/><name>hibits2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmpv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>tmph</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>tmpn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bit</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hibitsx</name> <operator>=</operator> <call><name>abs2twocomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>bigor_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>hibitsx</name></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <call><name>abs2twocomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmpv</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt> <expr_stmt><expr><name>y</name> <operator>=</operator> <name>tmpv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpn</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt> <expr_stmt><expr><name>xn</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt> <expr_stmt><expr><name>yn</name> <operator>=</operator> <name>tmpn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmph</name> <operator>=</operator> <name>hibitsx</name></expr>;</expr_stmt> <expr_stmt><expr><name>hibitsx</name> <operator>=</operator> <name>hibitsy</name></expr>;</expr_stmt> <expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <name>tmph</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ds1</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ds2</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hibits1</name> <operator>=</operator> <name>hibitsx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hibits2</name> <operator>=</operator> <name>hibitsy</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hibits1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>n2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ds1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|</operator> <name><name>ds2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n2</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>hibits1</name> <operator>|</operator> <name><name>ds2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>twocomp2abs_bang</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>hibits1</name> <operator>||</operator> <name>hibits2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>bigxor_int</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><name>BDIGIT</name></type> <name>hibitsx</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibitsy</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <ternary><condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>y</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BDIGMAX</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>zn</name> <operator>&lt;</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>bdigit_roomof</name><argument_list>(<argument><expr><name>SIZEOF_LONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>hibitsx</name> <operator>^</operator> <call><name>BIGLO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>BIGDN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name>hibitsy</name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>hibitsx</name> <operator>^</operator> <name>hibitsy</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>twocomp2abs_bang</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>hibitsx</name> <operator>^</operator> <name>hibitsy</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_xor</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>ds1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ds2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>xn</name></decl>, <decl><type ref="prev"/><name>yn</name></decl>, <decl><type ref="prev"/><name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibitsx</name></decl>, <decl><type ref="prev"/><name>hibitsy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>hibits1</name></decl>, <decl><type ref="prev"/><name>hibits2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmpv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>tmph</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>tmpn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_num_coerce_bit</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hibitsx</name> <operator>=</operator> <call><name>abs2twocomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>bigxor_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>hibitsx</name></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <call><name>abs2twocomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xn</name> <operator>&gt;</operator> <name>yn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmpv</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt> <expr_stmt><expr><name>y</name> <operator>=</operator> <name>tmpv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpn</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt> <expr_stmt><expr><name>xn</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt> <expr_stmt><expr><name>yn</name> <operator>=</operator> <name>tmpn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmph</name> <operator>=</operator> <name>hibitsx</name></expr>;</expr_stmt> <expr_stmt><expr><name>hibitsx</name> <operator>=</operator> <name>hibitsy</name></expr>;</expr_stmt> <expr_stmt><expr><name>hibitsy</name> <operator>=</operator> <name>tmph</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <name>xn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name>yn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ds1</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ds2</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hibits1</name> <operator>=</operator> <name>hibitsx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hibits2</name> <operator>=</operator> <name>hibitsy</name></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>n2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ds1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name><name>ds2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n2</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>hibitsx</name> <operator>^</operator> <name><name>ds2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>twocomp2abs_bang</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>hibits1</name> <operator>^</operator> <name>hibits2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_lshift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lshift_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>shift_numdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shift_numbits</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>shift</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>l</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lshift_p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>lshift_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>l</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>shift_numbits</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>shift</name> <operator>&amp;</operator> <operator>(</operator><name>BITSPERDIG</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>shift_numdigits</name> <operator>=</operator> <name>shift</name> <operator>&gt;&gt;</operator> <call><name>bit_length</name><argument_list>(<argument><expr><name>BITSPERDIG</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><call><name>big_shift3</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>lshift_p</name></expr></argument>, <argument><expr><name>shift_numdigits</name></expr></argument>, <argument><expr><name>shift_numbits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><call><name>big_shift2</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_rshift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lshift_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>shift_numdigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shift_numbits</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>shift</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>l</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lshift_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>lshift_p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>l</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>shift_numbits</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>shift</name> <operator>&amp;</operator> <operator>(</operator><name>BITSPERDIG</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>shift_numdigits</name> <operator>=</operator> <name>shift</name> <operator>&gt;&gt;</operator> <call><name>bit_length</name><argument_list>(<argument><expr><name>BITSPERDIG</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><call><name>big_shift3</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>lshift_p</name></expr></argument>, <argument><expr><name>shift_numdigits</name></expr></argument>, <argument><expr><name>shift_numbits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>bignorm</name><argument_list>(<argument><expr><call><name>big_shift2</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>bit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bigtrunc</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGSIZE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<label><name>out_of_range</name>:</label>
<return>return <expr><ternary><condition><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> <operator>&lt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <call><name>big2ulong</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="string">"long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <call><name>big2ull</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="string">"long long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>l</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>shift</name><operator>/</operator><name>BITSPERDIG</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <name>shift</name><operator>%</operator><name>BITSPERDIG</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bit</name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>s2</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&gt;=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>out_of_range</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>xds</name> <operator>=</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>xds</name><index>[<expr><name>s1</name></expr>]</index></name> <operator>&amp;</operator> <name>bit</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>xds</name><index>[<expr><name>s1</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><name>bit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>xds</name><index>[<expr><name>s1</name></expr>]</index></name> <operator>&amp;</operator> <name>bit</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>s1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>xds</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>xds</name><index>[<expr><name>s1</name></expr>]</index></name> <operator>&amp;</operator> <name>bit</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>xds</name><index>[<expr><name>s1</name></expr>]</index></name> <operator>&amp;</operator> <name>bit</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>hash</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_memhash</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof><operator>*</operator><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>^</operator> <call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_int_coerce</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_Float</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_Float</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_abs</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_big_clone</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIGNUM_SET_POSITIVE_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_big_sign</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>rb_big_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>big</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>BIGSIZE</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_size_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>big</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><call><name>rb_big_size</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_bit_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>big</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nlz_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numbytes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>BDIGIT</name></type> <name><name>char_bit</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>CHAR_BIT</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>numbytes_bary</name><index>[<expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>nlz_bary</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>result_bary</name><index>[<expr><call><name>bdigit_roomof</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>numbytes</name> <operator>=</operator> <call><name>rb_absint_size</name><argument_list>(<argument><expr><name>big</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlz_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>numbytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_NEGATIVE_P</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_absint_singlebit_p</name><argument_list>(<argument><expr><name>big</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nlz_bits</name> <operator>!=</operator> <name>CHAR_BIT</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nlz_bits</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>nlz_bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>numbytes</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>numbytes</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>/</operator> <name>CHAR_BIT</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name>numbytes</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>-</operator> <name>nlz_bits</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>nlz_bary</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nlz_bits</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bary_unpack</name><argument_list>(<argument><expr><call><name>BARY_ARGS</name><argument_list>(<argument><expr><name>numbytes_bary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>numbytes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>numbytes</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_SHORT_MUL</name><argument_list>(<argument><expr><name>result_bary</name></expr></argument>, <argument><expr><name>numbytes_bary</name></expr></argument>, <argument><expr><name>char_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BARY_SUB</name><argument_list>(<argument><expr><name>result_bary</name></expr></argument>, <argument><expr><name>result_bary</name></expr></argument>, <argument><expr><name>nlz_bary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_integer_unpack</name><argument_list>(<argument><expr><name>result_bary</name></expr></argument>, <argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>result_bary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_LSWORD_FIRST</name><operator>|</operator><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_odd_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_even_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>BDIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>unsigned</name> <name>long</name></type> <name>rb_ulong_isqrt</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>long</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name><operator>*</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<function_decl><type><name>BDIGIT</name></type> <name>rb_bdigit_dbl_isqrt</name><parameter_list>(<parameter><decl><type><name>BDIGIT_DBL</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ULL_TO_DOUBLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BDIGIT_DBL_TO_DOUBLE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ULL_TO_DOUBLE(n)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_bdigit_dbl_isqrt</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BDIGIT)rb_ulong_isqrt(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BDIGIT_DBL_TO_DOUBLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BDIGIT_DBL_TO_DOUBLE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(double)(n)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>BDIGIT</name> <modifier>*</modifier></type>
<name>estimate_initial_sqrt</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>nds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<enum>enum <block>{<decl><name>dbl_per_bdig</name> <init>= <macro><name>roomof</name><argument_list>(<argument>DBL_MANT_DIG</argument>,<argument>BITSPERDIG</argument>)</argument_list></macro></init></decl>}</block>;</enum>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>zbits</name> <init>= <expr><call><name>nlz</name><argument_list>(<argument><expr><name><name>nds</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>x</name> <init>= <expr><operator>*</operator><name>xp</name> <operator>=</operator> <call><name>bignew_1</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT_DBL</name></type> <name>d</name> <init>= <expr><call><name>bary2bdigitdbl</name><argument_list>(<argument><expr><name>nds</name><operator>+</operator><name>len</name><operator>-</operator><name>dbl_per_bdig</name></expr></argument>, <argument><expr><name>dbl_per_bdig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>lowbits</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rshift</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>BITSPERDIG</name><operator>*</operator><literal type="number">2</literal><operator>-</operator><name>zbits</name><operator>+</operator><operator>(</operator><name>len</name><operator>&amp;</operator><name>BITSPERDIG</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>DBL_MANT_DIG</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rshift</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lowbits</name> <operator>=</operator> <operator>(</operator><name>BDIGIT</name><operator>)</operator><name>d</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>BDIGIT</name><operator>)</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>rshift</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <name>rshift</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>rshift</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>&lt;&lt;=</operator> <operator>-</operator><name>rshift</name></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>|=</operator> <name><name>nds</name><index>[<expr><name>len</name><operator>-</operator><name>dbl_per_bdig</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>BITSPERDIG</name><operator>+</operator><name>rshift</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><call><name>BDIGIT_DBL_TO_DOUBLE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BDIGIT_DBL_TO_DOUBLE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>f</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lowbits</name> <operator>||</operator> <operator>(</operator><name>lowbits</name> <operator>=</operator> <operator>!</operator><call><name>bary_zero_p</name><argument_list>(<argument><expr><name>nds</name></expr></argument>, <argument><expr><name>len</name><operator>-</operator><name>dbl_per_bdig</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>lowbits</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>rshift</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rshift</name> <operator>+=</operator> <operator>(</operator><literal type="number">2</literal><operator>-</operator><operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>*</operator><name>BITSPERDIG</name><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rshift</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>nlz</name><argument_list>(<argument><expr><operator>(</operator><name>BDIGIT</name><operator>)</operator><name>d</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>rshift</name> <operator>&gt;=</operator> <name>BITSPERDIG</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>BDIGIT_DBL</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>&lt;&lt;=</operator> <name>rshift</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigitdbl2bary</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xds</name><index>[<expr><name>xn</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lowbits</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> 
<return>return <expr><name>xds</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_big_isqrt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>nds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name> <init>= <expr><operator>(</operator><name>len</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BDIGIT</name></type> <name>sq</name> <init>= <expr><call><name>rb_bdigit_dbl_isqrt</name><argument_list>(<argument><expr><call><name>bary2bdigitdbl</name><argument_list>(<argument><expr><name>nds</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_BDIGIT</name> <operator>&gt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>
<return>return <expr><call><name>ULL2NUM</name><argument_list>(<argument><expr><name>sq</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>ULONG2NUM</name><argument_list>(<argument><expr><name>sq</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>xds</name> <operator>=</operator> <call><name>estimate_initial_sqrt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>nds</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tn</name> <init>= <expr><name>xn</name> <operator>+</operator> <name>BIGDIVREM_EXTRA_WORDS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>t</name> <init>= <expr><call><name>bignew_1</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>tds</name> <init>= <expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><call><name>bary_divmod_branch</name><argument_list>(<argument><expr><name>tds</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nds</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>bary_cmp</name><argument_list>(<argument><expr><name>tds</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>carry</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>BARY_TRUNC</name><argument_list>(<argument><expr><name>tds</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>bary_add</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><name>tds</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_small_rshift</name><argument_list>(<argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>rb_big_realloc</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_force_recycle</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>rb_cInteger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bary_powm_gmp</name><parameter_list>(<parameter><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>zds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>xds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>yds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>yn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BDIGIT</name> <modifier>*</modifier></type><name>mds</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mpz_t</name></type> <name>z</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>count</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_init</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigits_to_mpz</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>xds</name></expr></argument>, <argument><expr><name>xn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigits_to_mpz</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>yds</name></expr></argument>, <argument><expr><name>yn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigits_to_mpz</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>mds</name></expr></argument>, <argument><expr><name>mn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_powm</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bdigits_from_mpz</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BDIGITS_ZERO</name><argument_list>(<argument><expr><name>zds</name><operator>+</operator><name>count</name></expr></argument>, <argument><expr><name>zn</name><operator>-</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mpz_clear</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>int_pow_tmp3</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nega_flg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>xn</name></decl>, <decl><type ref="prev"/><name>yn</name></decl>, <decl><type ref="prev"/><name>mn</name></decl>, <decl><type ref="prev"/><name>zn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_int2big</name><argument_list>(<argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>rb_int2big</name><argument_list>(<argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RB_BIGNUM_TYPE_P</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mn</name> <operator>=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <name>mn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>bignew</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bary_powm_gmp</name><argument_list>(<argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>yn</name></expr></argument>, <argument><expr><call><name>BDIGITS</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nega_flg</name> <operator>&amp;</operator> <call><name>BIGNUM_POSITIVE_P</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>rb_big_minus</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_big_norm</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">1L</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>yy</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>!</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y</name> <operator>=</operator> <call><name>rb_big_rshift</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">1L</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_int_odd_p</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_int_mul</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_int_modulo</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_int_mul</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_int_modulo</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>yy</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>yy</name></expr>;</condition> <incr><expr><name>yy</name> <operator>&gt;&gt;=</operator> <literal type="number">1L</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>yy</name> <operator>&amp;</operator> <literal type="number">1L</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_int_mul</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_int_modulo</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_int_mul</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_int_modulo</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>nega_flg</name> <operator>&amp;&amp;</operator> <call><name>rb_int_positive_p</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_int_minus</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>tmp</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>int_pow_tmp1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>mm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nega_flg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>xx</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>tmp</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>yy</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>!</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y</name> <operator>=</operator> <call><name>rb_big_rshift</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">1L</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_int_odd_p</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>tmp</name> <operator>*</operator> <name>xx</name><operator>)</operator> <operator>%</operator> <name>mm</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>xx</name> <operator>=</operator> <operator>(</operator><name>xx</name> <operator>*</operator> <name>xx</name><operator>)</operator> <operator>%</operator> <name>mm</name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>yy</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>yy</name></expr>;</condition> <incr><expr><name>yy</name> <operator>&gt;&gt;=</operator> <literal type="number">1L</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>yy</name> <operator>&amp;</operator> <literal type="number">1L</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>tmp</name> <operator>*</operator> <name>xx</name><operator>)</operator> <operator>%</operator> <name>mm</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>xx</name> <operator>=</operator> <operator>(</operator><name>xx</name> <operator>*</operator> <name>xx</name><operator>)</operator> <operator>%</operator> <name>mm</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>nega_flg</name> <operator>&amp;&amp;</operator> <name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>-=</operator> <name>mm</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>int_pow_tmp2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>mm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nega_flg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>tmp</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>yy</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DLONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>DLONG</name></type> <name>m</name> <init>= <expr><name>mm</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>tmp2</name> <init>= <expr><name>tmp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>xx</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUL_MODULO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(long)(((DLONG)(a) * (DLONG)(b)) % (c))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>m</name> <init>= <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp2</name> <init>= <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>xx</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUL_MODULO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_int_modulo(rb_fix_mul_fix((a), (b)), (c))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init>;</init> <condition><expr><operator>!</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y</name> <operator>=</operator> <call><name>rb_big_rshift</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">1L</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_int_odd_p</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>MUL_MODULO</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>, <argument><expr><name>xx</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>xx</name> <operator>=</operator> <call><name>MUL_MODULO</name><argument_list>(<argument><expr><name>xx</name></expr></argument>, <argument><expr><name>xx</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>yy</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>yy</name></expr>;</condition> <incr><expr><name>yy</name> <operator>&gt;&gt;=</operator> <literal type="number">1L</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>yy</name> <operator>&amp;</operator> <literal type="number">1L</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>MUL_MODULO</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>, <argument><expr><name>xx</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>xx</name> <operator>=</operator> <call><name>MUL_MODULO</name><argument_list>(<argument><expr><name>xx</name></expr></argument>, <argument><expr><name>xx</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DLONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>tmp2</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>nega_flg</name> <operator>&amp;&amp;</operator> <name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>-=</operator> <name>mm</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>












<function><type><name>VALUE</name></type>
<name>rb_int_powm</name><parameter_list>(<parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <specifier>const</specifier></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_int_pow</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <specifier>const</specifier></type> <name>a</name> <init>= <expr><name>num</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name> <specifier>const</specifier></type> <name>b</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>m</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nega_flg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>( <expr><operator>!</operator> <call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"Integer#pow() 2nd argument not allowed unless a 1st argument is integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_int_negative_p</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"Integer#pow() 1st argument cannot be negative when 2nd argument specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"Integer#pow() 2nd argument not allowed unless all arguments are integers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_int_negative_p</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>rb_int_uminus</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nega_flg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name> <specifier>const</specifier></type> <name>half_val</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><name>HALF_LONG_MSB</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <specifier>const</specifier></type> <name>mm</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mm</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_num_zerodiv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mm</name> <operator>&lt;=</operator> <name>half_val</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>int_pow_tmp1</name><argument_list>(<argument><expr><call><name>rb_int_modulo</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>nega_flg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>int_pow_tmp2</name><argument_list>(<argument><expr><call><name>rb_int_modulo</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>, <argument><expr><name>nega_flg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_bigzero_p</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_num_zerodiv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>int_pow_tmp3</name><argument_list>(<argument><expr><call><name>rb_int_modulo</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>nega_flg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



















<function><type><name>void</name></type>
<name>Init_Bignum</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><literal type="string">"Bignum"</literal></expr></argument>, <argument><expr><name>rb_cInteger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_deprecate_constant</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><literal type="string">"Bignum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cInteger</name></expr></argument>, <argument><expr><literal type="string">"coerce"</literal></expr></argument>, <argument><expr><name>rb_int_coerce</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cInteger</name></expr></argument>, <argument><expr><literal type="string">"GMP_VERSION"</literal></expr></argument>, <argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"GMP %s"</literal></expr></argument>, <argument><expr><name>gmp_version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>power_cache_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
