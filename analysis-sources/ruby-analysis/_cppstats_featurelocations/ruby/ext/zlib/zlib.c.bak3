







#include <ruby.h>
#include <zlib.h>
#include <time.h>
#include <ruby/io.h>
#include <ruby/thread.h>

#ifdef HAVE_VALGRIND_MEMCHECK_H
#include <valgrind/memcheck.h>
#ifndef VALGRIND_MAKE_MEM_DEFINED
#define VALGRIND_MAKE_MEM_DEFINED(p, n) VALGRIND_MAKE_READABLE((p), (n))
#endif
#ifndef VALGRIND_MAKE_MEM_UNDEFINED
#define VALGRIND_MAKE_MEM_UNDEFINED(p, n) VALGRIND_MAKE_WRITABLE((p), (n))
#endif
#else
#define VALGRIND_MAKE_MEM_DEFINED(p, n) 0
#define VALGRIND_MAKE_MEM_UNDEFINED(p, n) 0
#endif

#define RUBY_ZLIB_VERSION "1.1.0"

#ifndef RB_PASS_CALLED_KEYWORDS
#define rb_class_new_instance_kw(argc, argv, klass, kw_splat) rb_class_new_instance(argc, argv, klass)
#endif

#ifndef GZIP_SUPPORT
#define GZIP_SUPPORT 1
#endif


#ifndef DEF_MEM_LEVEL
#if MAX_MEM_LEVEL >= 8
#define DEF_MEM_LEVEL 8
#else
#define DEF_MEM_LEVEL MAX_MEM_LEVEL
#endif
#endif

#if SIZEOF_LONG > SIZEOF_INT
static inline uInt
max_uint(long n)
{
if (n > UINT_MAX) n = UINT_MAX;
return (uInt)n;
}
#define MAX_UINT(n) max_uint(n)
#else
#define MAX_UINT(n) (uInt)(n)
#endif

static ID id_dictionaries;



static NORETURN(void raise_zlib_error(int, const char*));
static VALUE rb_zlib_version(VALUE);
static VALUE do_checksum(int, VALUE*, uLong (*)(uLong, const Bytef*, uInt));
static VALUE rb_zlib_adler32(int, VALUE*, VALUE);
static VALUE rb_zlib_crc32(int, VALUE*, VALUE);
static VALUE rb_zlib_crc_table(VALUE);
static voidpf zlib_mem_alloc(voidpf, uInt, uInt);
static void zlib_mem_free(voidpf, voidpf);
static void finalizer_warn(const char*);

struct zstream;
struct zstream_funcs;
struct zstream_run_args;
static void zstream_init(struct zstream*, const struct zstream_funcs*);
static void zstream_expand_buffer(struct zstream*);
static void zstream_expand_buffer_into(struct zstream*, unsigned long);
static int zstream_expand_buffer_non_stream(struct zstream *z);
static void zstream_append_buffer(struct zstream*, const Bytef*, long);
static VALUE zstream_detach_buffer(struct zstream*);
static VALUE zstream_shift_buffer(struct zstream*, long);
static void zstream_buffer_ungets(struct zstream*, const Bytef*, unsigned long);
static void zstream_buffer_ungetbyte(struct zstream*, int);
static void zstream_append_input(struct zstream*, const Bytef*, long);
static void zstream_discard_input(struct zstream*, long);
static void zstream_reset_input(struct zstream*);
static void zstream_passthrough_input(struct zstream*);
static VALUE zstream_detach_input(struct zstream*);
static void zstream_reset(struct zstream*);
static VALUE zstream_end(struct zstream*);
static VALUE zstream_ensure_end(VALUE v);
static void zstream_run(struct zstream*, Bytef*, long, int);
static VALUE zstream_sync(struct zstream*, Bytef*, long);
static void zstream_mark(void*);
static void zstream_free(void*);
static VALUE zstream_new(VALUE, const struct zstream_funcs*);
static struct zstream *get_zstream(VALUE);
static void zstream_finalize(struct zstream*);

static VALUE rb_zstream_end(VALUE);
static VALUE rb_zstream_reset(VALUE);
static VALUE rb_zstream_finish(VALUE);
static VALUE rb_zstream_flush_next_in(VALUE);
static VALUE rb_zstream_flush_next_out(VALUE);
static VALUE rb_zstream_avail_out(VALUE);
static VALUE rb_zstream_set_avail_out(VALUE, VALUE);
static VALUE rb_zstream_avail_in(VALUE);
static VALUE rb_zstream_total_in(VALUE);
static VALUE rb_zstream_total_out(VALUE);
static VALUE rb_zstream_data_type(VALUE);
static VALUE rb_zstream_adler(VALUE);
static VALUE rb_zstream_finished_p(VALUE);
static VALUE rb_zstream_closed_p(VALUE);

static VALUE rb_deflate_s_allocate(VALUE);
static VALUE rb_deflate_initialize(int, VALUE*, VALUE);
static VALUE rb_deflate_init_copy(VALUE, VALUE);
static VALUE deflate_run(VALUE);
static VALUE rb_deflate_s_deflate(int, VALUE*, VALUE);
static void do_deflate(struct zstream*, VALUE, int);
static VALUE rb_deflate_deflate(int, VALUE*, VALUE);
static VALUE rb_deflate_addstr(VALUE, VALUE);
static VALUE rb_deflate_flush(int, VALUE*, VALUE);
static VALUE rb_deflate_params(VALUE, VALUE, VALUE);
static VALUE rb_deflate_set_dictionary(VALUE, VALUE);

static VALUE inflate_run(VALUE);
static VALUE rb_inflate_s_allocate(VALUE);
static VALUE rb_inflate_initialize(int, VALUE*, VALUE);
static VALUE rb_inflate_s_inflate(VALUE, VALUE);
static void do_inflate(struct zstream*, VALUE);
static VALUE rb_inflate_inflate(VALUE, VALUE);
static VALUE rb_inflate_addstr(VALUE, VALUE);
static VALUE rb_inflate_sync(VALUE, VALUE);
static VALUE rb_inflate_sync_point_p(VALUE);
static VALUE rb_inflate_set_dictionary(VALUE, VALUE);

#if GZIP_SUPPORT
struct gzfile;
static void gzfile_mark(void*);
static void gzfile_free(void*);
static VALUE gzfile_new(VALUE, const struct zstream_funcs*, void (*) _((struct gzfile*)));
static void gzfile_reset(struct gzfile*);
static void gzfile_close(struct gzfile*, int);
static void gzfile_write_raw(struct gzfile*);
static VALUE gzfile_read_raw_partial(VALUE);
static VALUE gzfile_read_raw_rescue(VALUE,VALUE);
static VALUE gzfile_read_raw(struct gzfile*, VALUE outbuf);
static int gzfile_read_raw_ensure(struct gzfile*, long, VALUE outbuf);
static char *gzfile_read_raw_until_zero(struct gzfile*, long);
static unsigned int gzfile_get16(const unsigned char*);
static unsigned long gzfile_get32(const unsigned char*);
static void gzfile_set32(unsigned long n, unsigned char*);
static void gzfile_make_header(struct gzfile*);
static void gzfile_make_footer(struct gzfile*);
static void gzfile_read_header(struct gzfile*, VALUE outbuf);
static void gzfile_check_footer(struct gzfile*, VALUE outbuf);
static void gzfile_write(struct gzfile*, Bytef*, long);
static long gzfile_read_more(struct gzfile*, VALUE outbuf);
static void gzfile_calc_crc(struct gzfile*, VALUE);
static VALUE gzfile_read(struct gzfile*, long);
static VALUE gzfile_read_all(struct gzfile*);
static void gzfile_ungets(struct gzfile*, const Bytef*, long);
static void gzfile_ungetbyte(struct gzfile*, int);
static VALUE gzfile_writer_end_run(VALUE);
static void gzfile_writer_end(struct gzfile*);
static VALUE gzfile_reader_end_run(VALUE);
static void gzfile_reader_end(struct gzfile*);
static void gzfile_reader_rewind(struct gzfile*);
static VALUE gzfile_reader_get_unused(struct gzfile*);
static struct gzfile *get_gzfile(VALUE);
static VALUE gzfile_ensure_close(VALUE);
static VALUE rb_gzfile_s_wrap(int, VALUE*, VALUE);
static VALUE gzfile_s_open(int, VALUE*, VALUE, const char*);
NORETURN(static void gzfile_raise(struct gzfile *, VALUE, const char *));
static VALUE gzfile_error_inspect(VALUE);

static VALUE rb_gzfile_to_io(VALUE);
static VALUE rb_gzfile_crc(VALUE);
static VALUE rb_gzfile_mtime(VALUE);
static VALUE rb_gzfile_level(VALUE);
static VALUE rb_gzfile_os_code(VALUE);
static VALUE rb_gzfile_orig_name(VALUE);
static VALUE rb_gzfile_comment(VALUE);
static VALUE rb_gzfile_lineno(VALUE);
static VALUE rb_gzfile_set_lineno(VALUE, VALUE);
static VALUE rb_gzfile_set_mtime(VALUE, VALUE);
static VALUE rb_gzfile_set_orig_name(VALUE, VALUE);
static VALUE rb_gzfile_set_comment(VALUE, VALUE);
static VALUE rb_gzfile_close(VALUE);
static VALUE rb_gzfile_finish(VALUE);
static VALUE rb_gzfile_closed_p(VALUE);
static VALUE rb_gzfile_eof_p(VALUE);
static VALUE rb_gzfile_sync(VALUE);
static VALUE rb_gzfile_set_sync(VALUE, VALUE);
static VALUE rb_gzfile_total_in(VALUE);
static VALUE rb_gzfile_total_out(VALUE);
static VALUE rb_gzfile_path(VALUE);

static VALUE rb_gzwriter_s_allocate(VALUE);
static VALUE rb_gzwriter_s_open(int, VALUE*, VALUE);
static VALUE rb_gzwriter_initialize(int, VALUE*, VALUE);
static VALUE rb_gzwriter_flush(int, VALUE*, VALUE);
static VALUE rb_gzwriter_write(int, VALUE*, VALUE);
static VALUE rb_gzwriter_putc(VALUE, VALUE);

static VALUE rb_gzreader_s_allocate(VALUE);
static VALUE rb_gzreader_s_open(int, VALUE*, VALUE);
static VALUE rb_gzreader_initialize(int, VALUE*, VALUE);
static VALUE rb_gzreader_rewind(VALUE);
static VALUE rb_gzreader_unused(VALUE);
static VALUE rb_gzreader_read(int, VALUE*, VALUE);
static VALUE rb_gzreader_getc(VALUE);
static VALUE rb_gzreader_readchar(VALUE);
static VALUE rb_gzreader_each_byte(VALUE);
static VALUE rb_gzreader_ungetc(VALUE, VALUE);
static VALUE rb_gzreader_ungetbyte(VALUE, VALUE);
static void gzreader_skip_linebreaks(struct gzfile*);
static VALUE gzreader_gets(int, VALUE*, VALUE);
static VALUE rb_gzreader_gets(int, VALUE*, VALUE);
static VALUE rb_gzreader_readline(int, VALUE*, VALUE);
static VALUE rb_gzreader_each(int, VALUE*, VALUE);
static VALUE rb_gzreader_readlines(int, VALUE*, VALUE);
#endif 









































































void Init_zlib(void);



static VALUE cZError, cStreamEnd, cNeedDict;
static VALUE cStreamError, cDataError, cMemError, cBufError, cVersionError;

static void
raise_zlib_error(int err, const char *msg)
{
VALUE exc;

if (!msg) {
msg = zError(err);
}

switch(err) {
case Z_STREAM_END:
exc = rb_exc_new2(cStreamEnd, msg);
break;
case Z_NEED_DICT:
exc = rb_exc_new2(cNeedDict, msg);
break;
case Z_STREAM_ERROR:
exc = rb_exc_new2(cStreamError, msg);
break;
case Z_DATA_ERROR:
exc = rb_exc_new2(cDataError, msg);
break;
case Z_BUF_ERROR:
exc = rb_exc_new2(cBufError, msg);
break;
case Z_VERSION_ERROR:
exc = rb_exc_new2(cVersionError, msg);
break;
case Z_MEM_ERROR:
exc = rb_exc_new2(cMemError, msg);
break;
case Z_ERRNO:
rb_sys_fail(msg);

default:
exc = rb_exc_new_str(cZError,
rb_sprintf("unknown zlib error %d: %s", err, msg));
}

rb_exc_raise(exc);
}




static void
finalizer_warn(const char *msg)
{
fprintf(stderr, "zlib(finalizer): %s\n", msg);
}









static VALUE
rb_zlib_version(VALUE klass)
{
return rb_str_new2(zlibVersion());
}

#if SIZEOF_LONG > SIZEOF_INT
static uLong
checksum_long(uLong (*func)(uLong, const Bytef*, uInt), uLong sum, const Bytef *ptr, long len)
{
if (len > UINT_MAX) {
do {
sum = func(sum, ptr, UINT_MAX);
ptr += UINT_MAX;
len -= UINT_MAX;
} while (len >= UINT_MAX);
}
if (len > 0) sum = func(sum, ptr, (uInt)len);
return sum;
}
#else
#define checksum_long(func, sum, ptr, len) (func)((sum), (ptr), (len))
#endif

static VALUE
do_checksum(int argc, VALUE *argv, uLong (*func)(uLong, const Bytef*, uInt))
{
VALUE str, vsum;
unsigned long sum;

rb_scan_args(argc, argv, "02", &str, &vsum);

if (!NIL_P(vsum)) {
sum = NUM2ULONG(vsum);
}
else if (NIL_P(str)) {
sum = 0;
}
else {
sum = func(0, Z_NULL, 0);
}

if (NIL_P(str)) {
sum = func(sum, Z_NULL, 0);
}
else {
StringValue(str);
sum = checksum_long(func, sum, (Bytef*)RSTRING_PTR(str), RSTRING_LEN(str));
}
return rb_uint2inum(sum);
}



















static VALUE
rb_zlib_adler32(int argc, VALUE *argv, VALUE klass)
{
return do_checksum(argc, argv, adler32);
}

#ifdef HAVE_ADLER32_COMBINE










static VALUE
rb_zlib_adler32_combine(VALUE klass, VALUE adler1, VALUE adler2, VALUE len2)
{
return ULONG2NUM(
adler32_combine(NUM2ULONG(adler1), NUM2ULONG(adler2), NUM2LONG(len2)));
}
#else
#define rb_zlib_adler32_combine rb_f_notimplement
#endif












static VALUE
rb_zlib_crc32(int argc, VALUE *argv, VALUE klass)
{
return do_checksum(argc, argv, crc32);
}

#ifdef HAVE_CRC32_COMBINE










static VALUE
rb_zlib_crc32_combine(VALUE klass, VALUE crc1, VALUE crc2, VALUE len2)
{
return ULONG2NUM(
crc32_combine(NUM2ULONG(crc1), NUM2ULONG(crc2), NUM2LONG(len2)));
}
#else
#define rb_zlib_crc32_combine rb_f_notimplement
#endif






static VALUE
rb_zlib_crc_table(VALUE obj)
{
#if !defined(HAVE_TYPE_Z_CRC_T)

typedef unsigned long z_crc_t;
#endif
const z_crc_t *crctbl;
VALUE dst;
int i;

crctbl = get_crc_table();
dst = rb_ary_new2(256);

for (i = 0; i < 256; i++) {
rb_ary_push(dst, rb_uint2inum(crctbl[i]));
}
return dst;
}





struct zstream {
unsigned long flags;
VALUE buf;
VALUE input;
z_stream stream;
const struct zstream_funcs {
int (*reset)(z_streamp);
int (*end)(z_streamp);
int (*run)(z_streamp, int);
} *func;
};

#define ZSTREAM_FLAG_READY 0x1
#define ZSTREAM_FLAG_IN_STREAM 0x2
#define ZSTREAM_FLAG_FINISHED 0x4
#define ZSTREAM_FLAG_CLOSING 0x8
#define ZSTREAM_FLAG_GZFILE 0x10 

#define ZSTREAM_FLAG_UNUSED 0x20

#define ZSTREAM_READY(z) ((z)->flags |= ZSTREAM_FLAG_READY)
#define ZSTREAM_IS_READY(z) ((z)->flags & ZSTREAM_FLAG_READY)
#define ZSTREAM_IS_FINISHED(z) ((z)->flags & ZSTREAM_FLAG_FINISHED)
#define ZSTREAM_IS_CLOSING(z) ((z)->flags & ZSTREAM_FLAG_CLOSING)
#define ZSTREAM_IS_GZFILE(z) ((z)->flags & ZSTREAM_FLAG_GZFILE)
#define ZSTREAM_BUF_FILLED(z) (NIL_P((z)->buf) ? 0 : RSTRING_LEN((z)->buf))

#define ZSTREAM_EXPAND_BUFFER_OK 0



#define ZSTREAM_INITIAL_BUFSIZE 1024

#define ZSTREAM_AVAIL_OUT_STEP_MAX 16384
#define ZSTREAM_AVAIL_OUT_STEP_MIN 2048

static const struct zstream_funcs deflate_funcs = {
deflateReset, deflateEnd, deflate,
};

static const struct zstream_funcs inflate_funcs = {
inflateReset, inflateEnd, inflate,
};

struct zstream_run_args {
struct zstream * z;
int flush; 
int interrupt; 
int jump_state; 
int stream_output; 
};

static voidpf
zlib_mem_alloc(voidpf opaque, uInt items, uInt size)
{
voidpf p = xmalloc2(items, size);




(void)VALGRIND_MAKE_MEM_DEFINED(p, items * size);
return p;
}

static void
zlib_mem_free(voidpf opaque, voidpf address)
{
xfree(address);
}

static void
zstream_init(struct zstream *z, const struct zstream_funcs *func)
{
z->flags = 0;
z->buf = Qnil;
z->input = Qnil;
z->stream.zalloc = zlib_mem_alloc;
z->stream.zfree = zlib_mem_free;
z->stream.opaque = Z_NULL;
z->stream.msg = Z_NULL;
z->stream.next_in = Z_NULL;
z->stream.avail_in = 0;
z->stream.next_out = Z_NULL;
z->stream.avail_out = 0;
z->func = func;
}

#define zstream_init_deflate(z) zstream_init((z), &deflate_funcs)
#define zstream_init_inflate(z) zstream_init((z), &inflate_funcs)

static void
zstream_expand_buffer(struct zstream *z)
{
if (NIL_P(z->buf)) {
zstream_expand_buffer_into(z, ZSTREAM_INITIAL_BUFSIZE);
return;
}

if (!ZSTREAM_IS_GZFILE(z) && rb_block_given_p()) {
long buf_filled = ZSTREAM_BUF_FILLED(z);
if (buf_filled >= ZSTREAM_AVAIL_OUT_STEP_MAX) {
int state = 0;

rb_obj_reveal(z->buf, rb_cString);

rb_protect(rb_yield, z->buf, &state);

z->buf = Qnil;
zstream_expand_buffer_into(z, ZSTREAM_AVAIL_OUT_STEP_MAX);

if (state)
rb_jump_tag(state);

return;
}
else {
zstream_expand_buffer_into(z,
ZSTREAM_AVAIL_OUT_STEP_MAX - buf_filled);
}
}
else {
zstream_expand_buffer_non_stream(z);
}
}

static void
zstream_expand_buffer_into(struct zstream *z, unsigned long size)
{
if (NIL_P(z->buf)) {


z->buf = rb_str_buf_new(size);
z->stream.next_out = (Bytef*)RSTRING_PTR(z->buf);
z->stream.avail_out = MAX_UINT(size);
rb_obj_hide(z->buf);
}
else if (z->stream.avail_out != size) {
rb_str_modify_expand(z->buf, size);
z->stream.next_out = (Bytef*)RSTRING_END(z->buf);
z->stream.avail_out = MAX_UINT(size);
}
}

static void *
zstream_expand_buffer_protect(void *ptr)
{
struct zstream *z = (struct zstream *)ptr;
int state = 0;

rb_protect((VALUE (*)(VALUE))zstream_expand_buffer, (VALUE)z, &state);

return (void *)(VALUE)state;
}

static int
zstream_expand_buffer_non_stream(struct zstream *z)
{
long inc, len = ZSTREAM_BUF_FILLED(z);

if (rb_str_capacity(z->buf) - len >= ZSTREAM_AVAIL_OUT_STEP_MAX) {
z->stream.avail_out = ZSTREAM_AVAIL_OUT_STEP_MAX;
}
else {
inc = len / 2;
if (inc < ZSTREAM_AVAIL_OUT_STEP_MIN) {
inc = ZSTREAM_AVAIL_OUT_STEP_MIN;
}

rb_str_modify_expand(z->buf, inc);
z->stream.avail_out = (inc < ZSTREAM_AVAIL_OUT_STEP_MAX) ?
(int)inc : ZSTREAM_AVAIL_OUT_STEP_MAX;
}
z->stream.next_out = (Bytef*)RSTRING_END(z->buf);

return ZSTREAM_EXPAND_BUFFER_OK;
}

static void
zstream_append_buffer(struct zstream *z, const Bytef *src, long len)
{
if (NIL_P(z->buf)) {
z->buf = rb_str_buf_new(len);
rb_str_buf_cat(z->buf, (const char*)src, len);
z->stream.next_out = (Bytef*)RSTRING_PTR(z->buf);
z->stream.avail_out = 0;
rb_obj_hide(z->buf);
return;
}

if ((long)rb_str_capacity(z->buf) < ZSTREAM_BUF_FILLED(z) + len) {
rb_str_modify_expand(z->buf, len);
z->stream.avail_out = 0;
}
else {
if (z->stream.avail_out >= (uInt)len) {
z->stream.avail_out -= (uInt)len;
}
else {
z->stream.avail_out = 0;
}
}
rb_str_cat(z->buf, (const char *)src, len);
z->stream.next_out = (Bytef*)RSTRING_END(z->buf);
}

#define zstream_append_buffer2(z,v) zstream_append_buffer((z),(Bytef*)RSTRING_PTR(v),RSTRING_LEN(v))


static VALUE
zstream_detach_buffer(struct zstream *z)
{
VALUE dst;

if (!ZSTREAM_IS_FINISHED(z) && !ZSTREAM_IS_GZFILE(z) &&
rb_block_given_p()) {


return Qnil;
}

if (NIL_P(z->buf)) {
dst = rb_str_new(0, 0);
}
else {
dst = z->buf;
rb_obj_reveal(dst, rb_cString);
}

z->buf = Qnil;
z->stream.next_out = 0;
z->stream.avail_out = 0;

if (!ZSTREAM_IS_GZFILE(z) && rb_block_given_p()) {
rb_yield(dst);
dst = Qnil;
}

return dst;
}

static VALUE
zstream_shift_buffer(struct zstream *z, long len)
{
VALUE dst;
char *bufptr;
long buflen = ZSTREAM_BUF_FILLED(z);

if (buflen <= len) {
return zstream_detach_buffer(z);
}

bufptr = RSTRING_PTR(z->buf);
dst = rb_str_new(bufptr, len);
buflen -= len;
memmove(bufptr, bufptr + len, buflen);
rb_str_set_len(z->buf, buflen);
z->stream.next_out = (Bytef*)RSTRING_END(z->buf);
buflen = (long)rb_str_capacity(z->buf) - ZSTREAM_BUF_FILLED(z);
if (buflen > ZSTREAM_AVAIL_OUT_STEP_MAX) {
buflen = ZSTREAM_AVAIL_OUT_STEP_MAX;
}
z->stream.avail_out = (uInt)buflen;

return dst;
}

static void
zstream_buffer_ungets(struct zstream *z, const Bytef *b, unsigned long len)
{
char *bufptr;
long filled;

if (NIL_P(z->buf) || (long)rb_str_capacity(z->buf) <= ZSTREAM_BUF_FILLED(z)) {
zstream_expand_buffer_into(z, len);
}

RSTRING_GETMEM(z->buf, bufptr, filled);
memmove(bufptr + len, bufptr, filled);
memmove(bufptr, b, len);
rb_str_set_len(z->buf, filled + len);
if (z->stream.avail_out > 0) {
if (len > z->stream.avail_out) len = z->stream.avail_out;
z->stream.next_out+=len;
z->stream.avail_out-=(uInt)len;
}
}

static void
zstream_buffer_ungetbyte(struct zstream *z, int c)
{
Bytef cc = (Bytef)c;
zstream_buffer_ungets(z, &cc, 1);
}

static void
zstream_append_input(struct zstream *z, const Bytef *src, long len)
{
if (len <= 0) return;

if (NIL_P(z->input)) {
z->input = rb_str_buf_new(len);
rb_str_buf_cat(z->input, (const char*)src, len);
rb_obj_hide(z->input);
}
else {
rb_str_buf_cat(z->input, (const char*)src, len);
}
}

#define zstream_append_input2(z,v)RB_GC_GUARD(v),zstream_append_input((z), (Bytef*)RSTRING_PTR(v), RSTRING_LEN(v))



static void
zstream_discard_input(struct zstream *z, long len)
{
if (NIL_P(z->input)) {
}
else if (RBASIC_CLASS(z->input) == 0) {

char *ptr;
long oldlen, newlen;

RSTRING_GETMEM(z->input, ptr, oldlen);
newlen = oldlen - len;
if (newlen > 0) {
memmove(ptr, ptr + len, newlen);
}
if (newlen < 0) {
newlen = 0;
}
rb_str_resize(z->input, newlen);
if (newlen == 0) {
rb_gc_force_recycle(z->input);
z->input = Qnil;
}
else {
rb_str_set_len(z->input, newlen);
}
}
else { 
if (RSTRING_LEN(z->input) <= len) {
z->input = Qnil;
}
else {
z->input = rb_str_substr(z->input, len,
RSTRING_LEN(z->input) - len);
}
}
}

static void
zstream_reset_input(struct zstream *z)
{
if (!NIL_P(z->input) && RBASIC_CLASS(z->input) == 0) {
rb_str_resize(z->input, 0);
}
else {
z->input = Qnil;
}
}

static void
zstream_passthrough_input(struct zstream *z)
{
if (!NIL_P(z->input)) {
zstream_append_buffer2(z, z->input);
z->input = Qnil;
}
}

static VALUE
zstream_detach_input(struct zstream *z)
{
VALUE dst;

if (NIL_P(z->input)) {
dst = rb_str_new(0, 0);
}
else {
dst = z->input;
rb_obj_reveal(dst, rb_cString);
}
z->input = Qnil;
return dst;
}

static void
zstream_reset(struct zstream *z)
{
int err;

err = z->func->reset(&z->stream);
if (err != Z_OK) {
raise_zlib_error(err, z->stream.msg);
}
z->flags = ZSTREAM_FLAG_READY;
z->buf = Qnil;
z->stream.next_out = 0;
z->stream.avail_out = 0;
zstream_reset_input(z);
}

static VALUE
zstream_end(struct zstream *z)
{
int err;

if (!ZSTREAM_IS_READY(z)) {
rb_warning("attempt to close uninitialized zstream; ignored.");
return Qnil;
}
if (z->flags & ZSTREAM_FLAG_IN_STREAM) {
rb_warning("attempt to close unfinished zstream; reset forced.");
zstream_reset(z);
}

zstream_reset_input(z);
err = z->func->end(&z->stream);
if (err != Z_OK) {
raise_zlib_error(err, z->stream.msg);
}
z->flags = 0;
return Qnil;
}

static VALUE
zstream_ensure_end(VALUE v)
{
return zstream_end((struct zstream *)v);
}

static void *
zstream_run_func(void *ptr)
{
struct zstream_run_args *args = (struct zstream_run_args *)ptr;
int err, state, flush = args->flush;
struct zstream *z = args->z;
uInt n;

err = Z_OK;
while (!args->interrupt) {
n = z->stream.avail_out;
err = z->func->run(&z->stream, flush);
rb_str_set_len(z->buf, ZSTREAM_BUF_FILLED(z) + (n - z->stream.avail_out));

if (err == Z_STREAM_END) {
z->flags &= ~ZSTREAM_FLAG_IN_STREAM;
z->flags |= ZSTREAM_FLAG_FINISHED;
break;
}

if (err != Z_OK && err != Z_BUF_ERROR)
break;

if (z->stream.avail_out > 0) {
z->flags |= ZSTREAM_FLAG_IN_STREAM;
break;
}

if (z->stream.avail_in == 0 && z->func == &inflate_funcs) {



z->flags |= ZSTREAM_FLAG_IN_STREAM;
break;
}

if (args->stream_output) {
state = (int)(VALUE)rb_thread_call_with_gvl(zstream_expand_buffer_protect,
(void *)z);
}
else {
state = zstream_expand_buffer_non_stream(z);
}

if (state) {
err = Z_OK; 
args->jump_state = state;
break;
}
}

return (void *)(VALUE)err;
}





static void
zstream_unblock_func(void *ptr)
{
struct zstream_run_args *args = (struct zstream_run_args *)ptr;

args->interrupt = 1;
}

static void
zstream_run(struct zstream *z, Bytef *src, long len, int flush)
{
struct zstream_run_args args;
int err;
VALUE old_input = Qnil;

args.z = z;
args.flush = flush;
args.interrupt = 0;
args.jump_state = 0;
args.stream_output = !ZSTREAM_IS_GZFILE(z) && rb_block_given_p();

if (NIL_P(z->input) && len == 0) {
z->stream.next_in = (Bytef*)"";
z->stream.avail_in = 0;
}
else {
zstream_append_input(z, src, len);



old_input = zstream_detach_input(z);
rb_obj_hide(old_input); 
z->stream.next_in = (Bytef*)RSTRING_PTR(old_input);
z->stream.avail_in = MAX_UINT(RSTRING_LEN(old_input));
}

if (z->stream.avail_out == 0) {
zstream_expand_buffer(z);
}

loop:
#ifndef RB_NOGVL_UBF_ASYNC_SAFE
err = (int)(VALUE)rb_thread_call_without_gvl(zstream_run_func, (void *)&args,
zstream_unblock_func, (void *)&args);
#else
err = (int)(VALUE)rb_nogvl(zstream_run_func, (void *)&args,
zstream_unblock_func, (void *)&args,
RB_NOGVL_UBF_ASYNC_SAFE);
#endif

if (flush != Z_FINISH && err == Z_BUF_ERROR
&& z->stream.avail_out > 0) {
z->flags |= ZSTREAM_FLAG_IN_STREAM;
}

zstream_reset_input(z);

if (err != Z_OK && err != Z_STREAM_END) {
if (z->stream.avail_in > 0) {
zstream_append_input(z, z->stream.next_in, z->stream.avail_in);
}
if (err == Z_NEED_DICT) {
VALUE self = (VALUE)z->stream.opaque;
if (self) {
VALUE dicts = rb_ivar_get(self, id_dictionaries);
VALUE dict = rb_hash_aref(dicts, rb_uint2inum(z->stream.adler));
if (!NIL_P(dict)) {
rb_inflate_set_dictionary(self, dict);
goto loop;
}
}
}
raise_zlib_error(err, z->stream.msg);
}

if (z->stream.avail_in > 0) {
zstream_append_input(z, z->stream.next_in, z->stream.avail_in);
}
if (!NIL_P(old_input)) {
rb_str_resize(old_input, 0);
rb_gc_force_recycle(old_input);
}

if (args.jump_state)
rb_jump_tag(args.jump_state);
}

static VALUE
zstream_sync(struct zstream *z, Bytef *src, long len)
{

int err;

if (!NIL_P(z->input)) {
z->stream.next_in = (Bytef*)RSTRING_PTR(z->input);
z->stream.avail_in = MAX_UINT(RSTRING_LEN(z->input));
err = inflateSync(&z->stream);
if (err == Z_OK) {
zstream_discard_input(z,
RSTRING_LEN(z->input) - z->stream.avail_in);
zstream_append_input(z, src, len);
return Qtrue;
}
zstream_reset_input(z);
if (err != Z_DATA_ERROR) {

raise_zlib_error(err, z->stream.msg);
}
}

if (len <= 0) return Qfalse;

z->stream.next_in = src;
z->stream.avail_in = MAX_UINT(len);
err = inflateSync(&z->stream);
if (err == Z_OK) {
zstream_append_input(z, z->stream.next_in, z->stream.avail_in);
return Qtrue;
}
if (err != Z_DATA_ERROR) {

raise_zlib_error(err, z->stream.msg);
}
return Qfalse;
}

static void
zstream_mark(void *p)
{
struct zstream *z = p;
rb_gc_mark(z->buf);
rb_gc_mark(z->input);
}

static void
zstream_finalize(struct zstream *z)
{
int err = z->func->end(&z->stream);
if (err == Z_STREAM_ERROR)
finalizer_warn("the stream state was inconsistent.");
if (err == Z_DATA_ERROR)
finalizer_warn("the stream was freed prematurely.");
}

static void
zstream_free(void *p)
{
struct zstream *z = p;

if (ZSTREAM_IS_READY(z)) {
zstream_finalize(z);
}
xfree(z);
}

static size_t
zstream_memsize(const void *p)
{

return sizeof(struct zstream);
}

static const rb_data_type_t zstream_data_type = {
"zstream",
{ zstream_mark, zstream_free, zstream_memsize, },
0, 0, RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE
zstream_new(VALUE klass, const struct zstream_funcs *funcs)
{
VALUE obj;
struct zstream *z;

obj = TypedData_Make_Struct(klass, struct zstream, &zstream_data_type, z);
zstream_init(z, funcs);
z->stream.opaque = (voidpf)obj;
return obj;
}

#define zstream_deflate_new(klass) zstream_new((klass), &deflate_funcs)
#define zstream_inflate_new(klass) zstream_new((klass), &inflate_funcs)

static struct zstream *
get_zstream(VALUE obj)
{
struct zstream *z;

TypedData_Get_Struct(obj, struct zstream, &zstream_data_type, z);
if (!ZSTREAM_IS_READY(z)) {
rb_raise(cZError, "stream is not ready");
}
return z;
}





































































static VALUE
rb_zstream_end(VALUE obj)
{
zstream_end(get_zstream(obj));
return Qnil;
}





static VALUE
rb_zstream_reset(VALUE obj)
{
zstream_reset(get_zstream(obj));
return Qnil;
}










static VALUE
rb_zstream_finish(VALUE obj)
{
struct zstream *z = get_zstream(obj);

zstream_run(z, (Bytef*)"", 0, Z_FINISH);

return zstream_detach_buffer(z);
}






static VALUE
rb_zstream_flush_next_in(VALUE obj)
{
struct zstream *z;
VALUE dst;

TypedData_Get_Struct(obj, struct zstream, &zstream_data_type, z);
dst = zstream_detach_input(z);
return dst;
}










static VALUE
rb_zstream_flush_next_out(VALUE obj)
{
struct zstream *z;

TypedData_Get_Struct(obj, struct zstream, &zstream_data_type, z);

return zstream_detach_buffer(z);
}





static VALUE
rb_zstream_avail_out(VALUE obj)
{
struct zstream *z;
TypedData_Get_Struct(obj, struct zstream, &zstream_data_type, z);
return rb_uint2inum(z->stream.avail_out);
}







static VALUE
rb_zstream_set_avail_out(VALUE obj, VALUE size)
{
struct zstream *z = get_zstream(obj);

zstream_expand_buffer_into(z, FIX2INT(size));
return size;
}




static VALUE
rb_zstream_avail_in(VALUE obj)
{
struct zstream *z;
TypedData_Get_Struct(obj, struct zstream, &zstream_data_type, z);
return INT2FIX(NIL_P(z->input) ? 0 : (int)(RSTRING_LEN(z->input)));
}




static VALUE
rb_zstream_total_in(VALUE obj)
{
return rb_uint2inum(get_zstream(obj)->stream.total_in);
}




static VALUE
rb_zstream_total_out(VALUE obj)
{
return rb_uint2inum(get_zstream(obj)->stream.total_out);
}






static VALUE
rb_zstream_data_type(VALUE obj)
{
return INT2FIX(get_zstream(obj)->stream.data_type);
}




static VALUE
rb_zstream_adler(VALUE obj)
{
return rb_uint2inum(get_zstream(obj)->stream.adler);
}




static VALUE
rb_zstream_finished_p(VALUE obj)
{
return ZSTREAM_IS_FINISHED(get_zstream(obj)) ? Qtrue : Qfalse;
}




static VALUE
rb_zstream_closed_p(VALUE obj)
{
struct zstream *z;
TypedData_Get_Struct(obj, struct zstream, &zstream_data_type, z);
return ZSTREAM_IS_READY(z) ? Qfalse : Qtrue;
}











#define FIXNUMARG(val, ifnil) (NIL_P((val)) ? (ifnil) : (FIX2INT((val))))



#define ARG_LEVEL(val) FIXNUMARG((val), Z_DEFAULT_COMPRESSION)
#define ARG_WBITS(val) FIXNUMARG((val), MAX_WBITS)
#define ARG_MEMLEVEL(val) FIXNUMARG((val), DEF_MEM_LEVEL)
#define ARG_STRATEGY(val) FIXNUMARG((val), Z_DEFAULT_STRATEGY)
#define ARG_FLUSH(val) FIXNUMARG((val), Z_NO_FLUSH)


static VALUE
rb_deflate_s_allocate(VALUE klass)
{
return zstream_deflate_new(klass);
}










































































static VALUE
rb_deflate_initialize(int argc, VALUE *argv, VALUE obj)
{
struct zstream *z;
VALUE level, wbits, memlevel, strategy;
int err;

rb_scan_args(argc, argv, "04", &level, &wbits, &memlevel, &strategy);
TypedData_Get_Struct(obj, struct zstream, &zstream_data_type, z);

err = deflateInit2(&z->stream, ARG_LEVEL(level), Z_DEFLATED,
ARG_WBITS(wbits), ARG_MEMLEVEL(memlevel),
ARG_STRATEGY(strategy));
if (err != Z_OK) {
raise_zlib_error(err, z->stream.msg);
}
ZSTREAM_READY(z);

return obj;
}






static VALUE
rb_deflate_init_copy(VALUE self, VALUE orig)
{
struct zstream *z1, *z2;
int err;

TypedData_Get_Struct(self, struct zstream, &zstream_data_type, z1);
z2 = get_zstream(orig);

if (z1 == z2) return self;
err = deflateCopy(&z1->stream, &z2->stream);
if (err != Z_OK) {
raise_zlib_error(err, 0);
}
z1->input = NIL_P(z2->input) ? Qnil : rb_str_dup(z2->input);
z1->buf = NIL_P(z2->buf) ? Qnil : rb_str_dup(z2->buf);
z1->flags = z2->flags;

return self;
}

static VALUE
deflate_run(VALUE args)
{
struct zstream *z = (struct zstream*)((VALUE*)args)[0];
VALUE src = ((VALUE*)args)[1];

zstream_run(z, (Bytef*)RSTRING_PTR(src), RSTRING_LEN(src), Z_FINISH);
return zstream_detach_buffer(z);
}
























static VALUE
rb_deflate_s_deflate(int argc, VALUE *argv, VALUE klass)
{
struct zstream z;
VALUE src, level, dst, args[2];
int err, lev;

rb_scan_args(argc, argv, "11", &src, &level);

lev = ARG_LEVEL(level);
StringValue(src);
zstream_init_deflate(&z);
err = deflateInit(&z.stream, lev);
if (err != Z_OK) {
raise_zlib_error(err, z.stream.msg);
}
ZSTREAM_READY(&z);

args[0] = (VALUE)&z;
args[1] = src;
dst = rb_ensure(deflate_run, (VALUE)args, zstream_ensure_end, (VALUE)&z);

return dst;
}

static void
do_deflate(struct zstream *z, VALUE src, int flush)
{
if (NIL_P(src)) {
zstream_run(z, (Bytef*)"", 0, Z_FINISH);
return;
}
StringValue(src);
if (flush != Z_NO_FLUSH || RSTRING_LEN(src) > 0) { 
zstream_run(z, (Bytef*)RSTRING_PTR(src), RSTRING_LEN(src), flush);
}
}



























static VALUE
rb_deflate_deflate(int argc, VALUE *argv, VALUE obj)
{
struct zstream *z = get_zstream(obj);
VALUE src, flush;

rb_scan_args(argc, argv, "11", &src, &flush);
do_deflate(z, src, ARG_FLUSH(flush));

return zstream_detach_buffer(z);
}










static VALUE
rb_deflate_addstr(VALUE obj, VALUE src)
{
do_deflate(get_zstream(obj), src, Z_NO_FLUSH);
return obj;
}
















static VALUE
rb_deflate_flush(int argc, VALUE *argv, VALUE obj)
{
struct zstream *z = get_zstream(obj);
VALUE v_flush;
int flush;

rb_scan_args(argc, argv, "01", &v_flush);
flush = FIXNUMARG(v_flush, Z_SYNC_FLUSH);
if (flush != Z_NO_FLUSH) { 
zstream_run(z, (Bytef*)"", 0, flush);
}

return zstream_detach_buffer(z);
}













static VALUE
rb_deflate_params(VALUE obj, VALUE v_level, VALUE v_strategy)
{
struct zstream *z = get_zstream(obj);
int level, strategy;
int err;
uInt n;
long filled;

level = ARG_LEVEL(v_level);
strategy = ARG_STRATEGY(v_strategy);

n = z->stream.avail_out;
err = deflateParams(&z->stream, level, strategy);
filled = n - z->stream.avail_out;
while (err == Z_BUF_ERROR) {
rb_warning("deflateParams() returned Z_BUF_ERROR");
zstream_expand_buffer(z);
rb_str_set_len(z->buf, RSTRING_LEN(z->buf) + filled);
n = z->stream.avail_out;
err = deflateParams(&z->stream, level, strategy);
filled = n - z->stream.avail_out;
}
if (err != Z_OK) {
raise_zlib_error(err, z->stream.msg);
}
rb_str_set_len(z->buf, RSTRING_LEN(z->buf) + filled);

return Qnil;
}















static VALUE
rb_deflate_set_dictionary(VALUE obj, VALUE dic)
{
struct zstream *z = get_zstream(obj);
VALUE src = dic;
int err;

StringValue(src);
err = deflateSetDictionary(&z->stream,
(Bytef*)RSTRING_PTR(src), RSTRING_LENINT(src));
if (err != Z_OK) {
raise_zlib_error(err, z->stream.msg);
}

return dic;
}












static VALUE
rb_inflate_s_allocate(VALUE klass)
{
VALUE inflate = zstream_inflate_new(klass);
rb_ivar_set(inflate, id_dictionaries, rb_hash_new());
return inflate;
}














































static VALUE
rb_inflate_initialize(int argc, VALUE *argv, VALUE obj)
{
struct zstream *z;
VALUE wbits;
int err;

rb_scan_args(argc, argv, "01", &wbits);
TypedData_Get_Struct(obj, struct zstream, &zstream_data_type, z);

err = inflateInit2(&z->stream, ARG_WBITS(wbits));
if (err != Z_OK) {
raise_zlib_error(err, z->stream.msg);
}
ZSTREAM_READY(z);

return obj;
}

static VALUE
inflate_run(VALUE args)
{
struct zstream *z = (struct zstream*)((VALUE*)args)[0];
VALUE src = ((VALUE*)args)[1];

zstream_run(z, (Bytef*)RSTRING_PTR(src), RSTRING_LEN(src), Z_SYNC_FLUSH);
zstream_run(z, (Bytef*)"", 0, Z_FINISH); 
return zstream_detach_buffer(z);
}
























static VALUE
rb_inflate_s_inflate(VALUE obj, VALUE src)
{
struct zstream z;
VALUE dst, args[2];
int err;

StringValue(src);
zstream_init_inflate(&z);
err = inflateInit(&z.stream);
if (err != Z_OK) {
raise_zlib_error(err, z.stream.msg);
}
ZSTREAM_READY(&z);

args[0] = (VALUE)&z;
args[1] = src;
dst = rb_ensure(inflate_run, (VALUE)args, zstream_ensure_end, (VALUE)&z);

return dst;
}

static void
do_inflate(struct zstream *z, VALUE src)
{
if (NIL_P(src)) {
zstream_run(z, (Bytef*)"", 0, Z_FINISH);
return;
}
StringValue(src);
if (RSTRING_LEN(src) > 0 || z->stream.avail_in > 0) { 
zstream_run(z, (Bytef*)RSTRING_PTR(src), RSTRING_LEN(src), Z_SYNC_FLUSH);
}
}










static VALUE
rb_inflate_add_dictionary(VALUE obj, VALUE dictionary)
{
VALUE dictionaries = rb_ivar_get(obj, id_dictionaries);
VALUE checksum = do_checksum(1, &dictionary, adler32);

rb_hash_aset(dictionaries, checksum, dictionary);

return obj;
}






































static VALUE
rb_inflate_inflate(VALUE obj, VALUE src)
{
struct zstream *z = get_zstream(obj);
VALUE dst;

if (ZSTREAM_IS_FINISHED(z)) {
if (NIL_P(src)) {
dst = zstream_detach_buffer(z);
}
else {
StringValue(src);
zstream_append_buffer2(z, src);
dst = rb_str_new(0, 0);
}
}
else {
do_inflate(z, src);
dst = zstream_detach_buffer(z);
if (ZSTREAM_IS_FINISHED(z)) {
zstream_passthrough_input(z);
}
}

return dst;
}








static VALUE
rb_inflate_addstr(VALUE obj, VALUE src)
{
struct zstream *z = get_zstream(obj);

if (ZSTREAM_IS_FINISHED(z)) {
if (!NIL_P(src)) {
StringValue(src);
zstream_append_buffer2(z, src);
}
}
else {
do_inflate(z, src);
if (ZSTREAM_IS_FINISHED(z)) {
zstream_passthrough_input(z);
}
}

return obj;
}









static VALUE
rb_inflate_sync(VALUE obj, VALUE src)
{
struct zstream *z = get_zstream(obj);

StringValue(src);
return zstream_sync(z, (Bytef*)RSTRING_PTR(src), RSTRING_LEN(src));
}








static VALUE
rb_inflate_sync_point_p(VALUE obj)
{
struct zstream *z = get_zstream(obj);
int err;

err = inflateSyncPoint(&z->stream);
if (err == 1) {
return Qtrue;
}
if (err != Z_OK) {
raise_zlib_error(err, z->stream.msg);
}
return Qfalse;
}








static VALUE
rb_inflate_set_dictionary(VALUE obj, VALUE dic)
{
struct zstream *z = get_zstream(obj);
VALUE src = dic;
int err;

StringValue(src);
err = inflateSetDictionary(&z->stream,
(Bytef*)RSTRING_PTR(src), RSTRING_LENINT(src));
if (err != Z_OK) {
raise_zlib_error(err, z->stream.msg);
}

return dic;
}



#if GZIP_SUPPORT








#define GZ_MAGIC1 0x1f
#define GZ_MAGIC2 0x8b
#define GZ_METHOD_DEFLATE 8
#define GZ_FLAG_MULTIPART 0x2
#define GZ_FLAG_EXTRA 0x4
#define GZ_FLAG_ORIG_NAME 0x8
#define GZ_FLAG_COMMENT 0x10
#define GZ_FLAG_ENCRYPT 0x20
#define GZ_FLAG_UNKNOWN_MASK 0xc0

#define GZ_EXTRAFLAG_FAST 0x4
#define GZ_EXTRAFLAG_SLOW 0x2


#define OS_MSDOS 0x00
#define OS_AMIGA 0x01
#define OS_VMS 0x02
#define OS_UNIX 0x03
#define OS_ATARI 0x05
#define OS_OS2 0x06
#define OS_MACOS 0x07
#define OS_TOPS20 0x0a
#define OS_WIN32 0x0b

#define OS_VMCMS 0x04
#define OS_ZSYSTEM 0x08
#define OS_CPM 0x09
#define OS_QDOS 0x0c
#define OS_RISCOS 0x0d
#define OS_UNKNOWN 0xff

#ifndef OS_CODE
#define OS_CODE OS_UNIX
#endif

static ID id_write, id_read, id_readpartial, id_flush, id_seek, id_close, id_path, id_input;
static VALUE cGzError, cNoFooter, cCRCError, cLengthError;





struct gzfile {
struct zstream z;
VALUE io;
int level;
int os_code; 
time_t mtime; 
VALUE orig_name; 
VALUE comment; 
unsigned long crc;
int ecflags;
int lineno;
long ungetc;
void (*end)(struct gzfile *);
rb_encoding *enc;
rb_encoding *enc2;
rb_econv_t *ec;
VALUE ecopts;
VALUE path;
};
#define GZFILE_CBUF_CAPA 10

#define GZFILE_FLAG_SYNC ZSTREAM_FLAG_UNUSED
#define GZFILE_FLAG_HEADER_FINISHED (ZSTREAM_FLAG_UNUSED << 1)
#define GZFILE_FLAG_FOOTER_FINISHED (ZSTREAM_FLAG_UNUSED << 2)
#define GZFILE_FLAG_MTIME_IS_SET (ZSTREAM_FLAG_UNUSED << 3)

#define GZFILE_IS_FINISHED(gz) (ZSTREAM_IS_FINISHED(&(gz)->z) && ZSTREAM_BUF_FILLED(&(gz)->z) == 0)


#define GZFILE_READ_SIZE 2048

struct read_raw_arg {
VALUE io;
union {
const VALUE argv[2]; 
struct {
VALUE len;
VALUE buf;
} in;
} as;
};

static void
gzfile_mark(void *p)
{
struct gzfile *gz = p;

rb_gc_mark(gz->io);
rb_gc_mark(gz->orig_name);
rb_gc_mark(gz->comment);
zstream_mark(&gz->z);
rb_gc_mark(gz->ecopts);
rb_gc_mark(gz->path);
}

static void
gzfile_free(void *p)
{
struct gzfile *gz = p;
struct zstream *z = &gz->z;

if (ZSTREAM_IS_READY(z)) {
if (z->func == &deflate_funcs) {
finalizer_warn("Zlib::GzipWriter object must be closed explicitly.");
}
zstream_finalize(z);
}
xfree(gz);
}

static size_t
gzfile_memsize(const void *p)
{
return sizeof(struct gzfile);
}

static const rb_data_type_t gzfile_data_type = {
"gzfile",
{ gzfile_mark, gzfile_free, gzfile_memsize, },
0, 0, RUBY_TYPED_FREE_IMMEDIATELY
};

static void
gzfile_init(struct gzfile *gz, const struct zstream_funcs *funcs, void (*endfunc)(struct gzfile *))
{
zstream_init(&gz->z, funcs);
gz->z.flags |= ZSTREAM_FLAG_GZFILE;
gz->io = Qnil;
gz->level = 0;
gz->mtime = 0;
gz->os_code = OS_CODE;
gz->orig_name = Qnil;
gz->comment = Qnil;
gz->crc = crc32(0, Z_NULL, 0);
gz->lineno = 0;
gz->ungetc = 0;
gz->end = endfunc;
gz->enc = rb_default_external_encoding();
gz->enc2 = 0;
gz->ec = NULL;
gz->ecflags = 0;
gz->ecopts = Qnil;
gz->path = Qnil;
}

static VALUE
gzfile_new(VALUE klass, const struct zstream_funcs *funcs, void (*endfunc)(struct gzfile *))
{
VALUE obj;
struct gzfile *gz;

obj = TypedData_Make_Struct(klass, struct gzfile, &gzfile_data_type, gz);
gzfile_init(gz, funcs, endfunc);
return obj;
}

#define gzfile_writer_new(gz) gzfile_new((gz),&deflate_funcs,gzfile_writer_end)
#define gzfile_reader_new(gz) gzfile_new((gz),&inflate_funcs,gzfile_reader_end)

static void
gzfile_reset(struct gzfile *gz)
{
zstream_reset(&gz->z);
gz->z.flags |= ZSTREAM_FLAG_GZFILE;
gz->crc = crc32(0, Z_NULL, 0);
gz->lineno = 0;
gz->ungetc = 0;
if (gz->ec) {
rb_econv_close(gz->ec);
gz->ec = rb_econv_open_opts(gz->enc2->name, gz->enc->name,
gz->ecflags, gz->ecopts);
}
}

static void
gzfile_close(struct gzfile *gz, int closeflag)
{
VALUE io = gz->io;

gz->end(gz);
gz->io = Qnil;
gz->orig_name = Qnil;
gz->comment = Qnil;
if (closeflag && rb_respond_to(io, id_close)) {
rb_funcall(io, id_close, 0);
}
}

static void
gzfile_write_raw(struct gzfile *gz)
{
VALUE str;

if (ZSTREAM_BUF_FILLED(&gz->z) > 0) {
str = zstream_detach_buffer(&gz->z);
rb_funcall(gz->io, id_write, 1, str);
if ((gz->z.flags & GZFILE_FLAG_SYNC)
&& rb_respond_to(gz->io, id_flush))
rb_funcall(gz->io, id_flush, 0);
}
}

static VALUE
gzfile_read_raw_partial(VALUE arg)
{
struct read_raw_arg *ra = (struct read_raw_arg *)arg;
VALUE str;
int argc = NIL_P(ra->as.argv[1]) ? 1 : 2;

str = rb_funcallv(ra->io, id_readpartial, argc, ra->as.argv);
Check_Type(str, T_STRING);
return str;
}

static VALUE
gzfile_read_raw_rescue(VALUE arg, VALUE _)
{
struct read_raw_arg *ra = (struct read_raw_arg *)arg;
VALUE str = Qnil;
if (rb_obj_is_kind_of(rb_errinfo(), rb_eNoMethodError)) {
int argc = NIL_P(ra->as.argv[1]) ? 1 : 2;
str = rb_funcallv(ra->io, id_read, argc, ra->as.argv);
if (!NIL_P(str)) {
Check_Type(str, T_STRING);
}
}
return str; 
}

static VALUE
gzfile_read_raw(struct gzfile *gz, VALUE outbuf)
{
struct read_raw_arg ra;

ra.io = gz->io;
ra.as.in.len = INT2FIX(GZFILE_READ_SIZE);
ra.as.in.buf = outbuf;

return rb_rescue2(gzfile_read_raw_partial, (VALUE)&ra,
gzfile_read_raw_rescue, (VALUE)&ra,
rb_eEOFError, rb_eNoMethodError, (VALUE)0);
}

static int
gzfile_read_raw_ensure(struct gzfile *gz, long size, VALUE outbuf)
{
VALUE str;

if (gz->io == Qundef) { 
if (NIL_P(gz->z.input) || RSTRING_LEN(gz->z.input) < size)
rb_raise(cGzError, "unexpected end of string");
}
while (NIL_P(gz->z.input) || RSTRING_LEN(gz->z.input) < size) {
str = gzfile_read_raw(gz, outbuf);
if (NIL_P(str)) return 0;
zstream_append_input2(&gz->z, str);
}
return 1;
}

static char *
gzfile_read_raw_until_zero(struct gzfile *gz, long offset)
{
VALUE str;
char *p;

for (;;) {
p = memchr(RSTRING_PTR(gz->z.input) + offset, '\0',
RSTRING_LEN(gz->z.input) - offset);
if (p) break;
str = gzfile_read_raw(gz, Qnil);
if (NIL_P(str)) {
rb_raise(cGzError, "unexpected end of file");
}
offset = RSTRING_LEN(gz->z.input);
zstream_append_input2(&gz->z, str);
}
return p;
}

static unsigned int
gzfile_get16(const unsigned char *src)
{
unsigned int n;
n = *(src++) & 0xff;
n |= (*(src++) & 0xff) << 8;
return n;
}

static unsigned long
gzfile_get32(const unsigned char *src)
{
unsigned long n;
n = *(src++) & 0xff;
n |= (*(src++) & 0xff) << 8;
n |= (*(src++) & 0xff) << 16;
n |= (*(src++) & 0xffU) << 24;
return n;
}

static void
gzfile_set32(unsigned long n, unsigned char *dst)
{
*(dst++) = n & 0xff;
*(dst++) = (n >> 8) & 0xff;
*(dst++) = (n >> 16) & 0xff;
*dst = (n >> 24) & 0xff;
}

static void
gzfile_raise(struct gzfile *gz, VALUE klass, const char *message)
{
VALUE exc = rb_exc_new2(klass, message);
if (!NIL_P(gz->z.input)) {
rb_ivar_set(exc, id_input, rb_str_resurrect(gz->z.input));
}
rb_exc_raise(exc);
}






static VALUE
gzfile_error_inspect(VALUE error)
{
VALUE str = rb_call_super(0, 0);
VALUE input = rb_attr_get(error, id_input);

if (!NIL_P(input)) {
rb_str_resize(str, RSTRING_LEN(str)-1);
rb_str_cat2(str, ", input=");
rb_str_append(str, rb_str_inspect(input));
rb_str_cat2(str, ">");
}
return str;
}

static void
gzfile_make_header(struct gzfile *gz)
{
Bytef buf[10]; 
unsigned char flags = 0, extraflags = 0;

if (!NIL_P(gz->orig_name)) {
flags |= GZ_FLAG_ORIG_NAME;
}
if (!NIL_P(gz->comment)) {
flags |= GZ_FLAG_COMMENT;
}
if (!(gz->z.flags & GZFILE_FLAG_MTIME_IS_SET)) {
gz->mtime = time(0);
}

if (gz->level == Z_BEST_SPEED) {
extraflags |= GZ_EXTRAFLAG_FAST;
}
else if (gz->level == Z_BEST_COMPRESSION) {
extraflags |= GZ_EXTRAFLAG_SLOW;
}

buf[0] = GZ_MAGIC1;
buf[1] = GZ_MAGIC2;
buf[2] = GZ_METHOD_DEFLATE;
buf[3] = flags;
gzfile_set32((unsigned long)gz->mtime, &buf[4]);
buf[8] = extraflags;
buf[9] = gz->os_code;
zstream_append_buffer(&gz->z, buf, (long)sizeof(buf));

if (!NIL_P(gz->orig_name)) {
zstream_append_buffer2(&gz->z, gz->orig_name);
zstream_append_buffer(&gz->z, (Bytef*)"\0", 1);
}
if (!NIL_P(gz->comment)) {
zstream_append_buffer2(&gz->z, gz->comment);
zstream_append_buffer(&gz->z, (Bytef*)"\0", 1);
}

gz->z.flags |= GZFILE_FLAG_HEADER_FINISHED;
}

static void
gzfile_make_footer(struct gzfile *gz)
{
Bytef buf[8]; 

gzfile_set32(gz->crc, buf);
gzfile_set32(gz->z.stream.total_in, &buf[4]);
zstream_append_buffer(&gz->z, buf, (long)sizeof(buf));
gz->z.flags |= GZFILE_FLAG_FOOTER_FINISHED;
}

static void
gzfile_read_header(struct gzfile *gz, VALUE outbuf)
{
const unsigned char *head;
long len;
char flags, *p;


if (!gzfile_read_raw_ensure(gz, 10, outbuf)) {
gzfile_raise(gz, cGzError, "not in gzip format");
}

head = (unsigned char*)RSTRING_PTR(gz->z.input);

if (head[0] != GZ_MAGIC1 || head[1] != GZ_MAGIC2) {
gzfile_raise(gz, cGzError, "not in gzip format");
}
if (head[2] != GZ_METHOD_DEFLATE) {
rb_raise(cGzError, "unsupported compression method %d", head[2]);
}

flags = head[3];
if (flags & GZ_FLAG_MULTIPART) {
rb_raise(cGzError, "multi-part gzip file is not supported");
}
else if (flags & GZ_FLAG_ENCRYPT) {
rb_raise(cGzError, "encrypted gzip file is not supported");
}
else if (flags & GZ_FLAG_UNKNOWN_MASK) {
rb_raise(cGzError, "unknown flags 0x%02x", flags);
}

if (head[8] & GZ_EXTRAFLAG_FAST) {
gz->level = Z_BEST_SPEED;
}
else if (head[8] & GZ_EXTRAFLAG_SLOW) {
gz->level = Z_BEST_COMPRESSION;
}
else {
gz->level = Z_DEFAULT_COMPRESSION;
}

gz->mtime = gzfile_get32(&head[4]);
gz->os_code = head[9];
zstream_discard_input(&gz->z, 10);

if (flags & GZ_FLAG_EXTRA) {
if (!gzfile_read_raw_ensure(gz, 2, outbuf)) {
rb_raise(cGzError, "unexpected end of file");
}
len = gzfile_get16((Bytef*)RSTRING_PTR(gz->z.input));
if (!gzfile_read_raw_ensure(gz, 2 + len, outbuf)) {
rb_raise(cGzError, "unexpected end of file");
}
zstream_discard_input(&gz->z, 2 + len);
}
if (flags & GZ_FLAG_ORIG_NAME) {
if (!gzfile_read_raw_ensure(gz, 1, outbuf)) {
rb_raise(cGzError, "unexpected end of file");
}
p = gzfile_read_raw_until_zero(gz, 0);
len = p - RSTRING_PTR(gz->z.input);
gz->orig_name = rb_str_new(RSTRING_PTR(gz->z.input), len);
zstream_discard_input(&gz->z, len + 1);
}
if (flags & GZ_FLAG_COMMENT) {
if (!gzfile_read_raw_ensure(gz, 1, outbuf)) {
rb_raise(cGzError, "unexpected end of file");
}
p = gzfile_read_raw_until_zero(gz, 0);
len = p - RSTRING_PTR(gz->z.input);
gz->comment = rb_str_new(RSTRING_PTR(gz->z.input), len);
zstream_discard_input(&gz->z, len + 1);
}

if (gz->z.input != Qnil && RSTRING_LEN(gz->z.input) > 0) {
zstream_run(&gz->z, 0, 0, Z_SYNC_FLUSH);
}
}

static void
gzfile_check_footer(struct gzfile *gz, VALUE outbuf)
{
unsigned long crc, length;

gz->z.flags |= GZFILE_FLAG_FOOTER_FINISHED;


if (!gzfile_read_raw_ensure(gz, 8, outbuf)) {
gzfile_raise(gz, cNoFooter, "footer is not found");
}

crc = gzfile_get32((Bytef*)RSTRING_PTR(gz->z.input));
length = gzfile_get32((Bytef*)RSTRING_PTR(gz->z.input) + 4);

gz->z.stream.total_in += 8; 
zstream_discard_input(&gz->z, 8);

if (gz->crc != crc) {
rb_raise(cCRCError, "invalid compressed data -- crc error");
}
if ((uint32_t)gz->z.stream.total_out != length) {
rb_raise(cLengthError, "invalid compressed data -- length error");
}
}

static void
gzfile_write(struct gzfile *gz, Bytef *str, long len)
{
if (!(gz->z.flags & GZFILE_FLAG_HEADER_FINISHED)) {
gzfile_make_header(gz);
}

if (len > 0 || (gz->z.flags & GZFILE_FLAG_SYNC)) {
gz->crc = checksum_long(crc32, gz->crc, str, len);
zstream_run(&gz->z, str, len, (gz->z.flags & GZFILE_FLAG_SYNC)
? Z_SYNC_FLUSH : Z_NO_FLUSH);
}
gzfile_write_raw(gz);
}

static long
gzfile_read_more(struct gzfile *gz, VALUE outbuf)
{
VALUE str;

while (!ZSTREAM_IS_FINISHED(&gz->z)) {
str = gzfile_read_raw(gz, outbuf);
if (NIL_P(str)) {
if (!ZSTREAM_IS_FINISHED(&gz->z)) {
rb_raise(cGzError, "unexpected end of file");
}
break;
}
if (RSTRING_LEN(str) > 0) { 
zstream_run(&gz->z, (Bytef*)RSTRING_PTR(str), RSTRING_LEN(str),
Z_SYNC_FLUSH);
RB_GC_GUARD(str);
}
if (ZSTREAM_BUF_FILLED(&gz->z) > 0) break;
}
return ZSTREAM_BUF_FILLED(&gz->z);
}

static void
gzfile_calc_crc(struct gzfile *gz, VALUE str)
{
if (RSTRING_LEN(str) <= gz->ungetc) {
gz->ungetc -= RSTRING_LEN(str);
}
else {
gz->crc = checksum_long(crc32, gz->crc, (Bytef*)RSTRING_PTR(str) + gz->ungetc,
RSTRING_LEN(str) - gz->ungetc);
gz->ungetc = 0;
}
}

static VALUE
gzfile_newstr(struct gzfile *gz, VALUE str)
{
if (!gz->enc2) {
rb_enc_associate(str, gz->enc);
return str;
}
if (gz->ec && rb_enc_dummy_p(gz->enc2)) {
str = rb_econv_str_convert(gz->ec, str, ECONV_PARTIAL_INPUT);
rb_enc_associate(str, gz->enc);
return str;
}
return rb_str_conv_enc_opts(str, gz->enc2, gz->enc,
gz->ecflags, gz->ecopts);
}

static long
gzfile_fill(struct gzfile *gz, long len)
{
if (len < 0)
rb_raise(rb_eArgError, "negative length %ld given", len);
if (len == 0)
return 0;
while (!ZSTREAM_IS_FINISHED(&gz->z) && ZSTREAM_BUF_FILLED(&gz->z) < len) {
gzfile_read_more(gz, Qnil);
}
if (GZFILE_IS_FINISHED(gz)) {
if (!(gz->z.flags & GZFILE_FLAG_FOOTER_FINISHED)) {
gzfile_check_footer(gz, Qnil);
}
return -1;
}
return len < ZSTREAM_BUF_FILLED(&gz->z) ? len : ZSTREAM_BUF_FILLED(&gz->z);
}

static VALUE
gzfile_read(struct gzfile *gz, long len)
{
VALUE dst;

len = gzfile_fill(gz, len);
if (len == 0) return rb_str_new(0, 0);
if (len < 0) return Qnil;
dst = zstream_shift_buffer(&gz->z, len);
if (!NIL_P(dst)) gzfile_calc_crc(gz, dst);
return dst;
}

static VALUE
gzfile_readpartial(struct gzfile *gz, long len, VALUE outbuf)
{
VALUE dst;

if (len < 0)
rb_raise(rb_eArgError, "negative length %ld given", len);

if (len == 0) {
if (NIL_P(outbuf))
return rb_str_new(0, 0);
else {
rb_str_resize(outbuf, 0);
return outbuf;
}
}
while (!ZSTREAM_IS_FINISHED(&gz->z) && ZSTREAM_BUF_FILLED(&gz->z) == 0) {
gzfile_read_more(gz, outbuf);
}
if (GZFILE_IS_FINISHED(gz)) {
if (!(gz->z.flags & GZFILE_FLAG_FOOTER_FINISHED)) {
gzfile_check_footer(gz, outbuf);
}
if (!NIL_P(outbuf))
rb_str_resize(outbuf, 0);
rb_raise(rb_eEOFError, "end of file reached");
}

dst = zstream_shift_buffer(&gz->z, len);
gzfile_calc_crc(gz, dst);

if (!NIL_P(outbuf)) {
rb_str_resize(outbuf, RSTRING_LEN(dst));
memcpy(RSTRING_PTR(outbuf), RSTRING_PTR(dst), RSTRING_LEN(dst));
rb_str_resize(dst, 0);
rb_gc_force_recycle(dst);
dst = outbuf;
}
return dst;
}

static VALUE
gzfile_read_all(struct gzfile *gz)
{
VALUE dst;

while (!ZSTREAM_IS_FINISHED(&gz->z)) {
gzfile_read_more(gz, Qnil);
}
if (GZFILE_IS_FINISHED(gz)) {
if (!(gz->z.flags & GZFILE_FLAG_FOOTER_FINISHED)) {
gzfile_check_footer(gz, Qnil);
}
return rb_str_new(0, 0);
}

dst = zstream_detach_buffer(&gz->z);
if (NIL_P(dst)) return dst;
gzfile_calc_crc(gz, dst);
return gzfile_newstr(gz, dst);
}

static VALUE
gzfile_getc(struct gzfile *gz)
{
VALUE buf, dst = 0;
int len;

len = rb_enc_mbmaxlen(gz->enc);
while (!ZSTREAM_IS_FINISHED(&gz->z) && ZSTREAM_BUF_FILLED(&gz->z) < len) {
gzfile_read_more(gz, Qnil);
}
if (GZFILE_IS_FINISHED(gz)) {
if (!(gz->z.flags & GZFILE_FLAG_FOOTER_FINISHED)) {
gzfile_check_footer(gz, Qnil);
}
return Qnil;
}

if (gz->ec && rb_enc_dummy_p(gz->enc2)) {
const unsigned char *ss, *sp, *se;
unsigned char *ds, *dp, *de;
VALUE cbuf = rb_enc_str_new(0, GZFILE_CBUF_CAPA, gz->enc);

ss = sp = (const unsigned char*)RSTRING_PTR(gz->z.buf);
se = sp + ZSTREAM_BUF_FILLED(&gz->z);
ds = dp = (unsigned char *)RSTRING_PTR(cbuf);
de = (unsigned char *)ds + GZFILE_CBUF_CAPA;
(void)rb_econv_convert(gz->ec, &sp, se, &dp, de, ECONV_PARTIAL_INPUT|ECONV_AFTER_OUTPUT);
rb_econv_check_error(gz->ec);
dst = zstream_shift_buffer(&gz->z, sp - ss);
gzfile_calc_crc(gz, dst);
rb_str_resize(cbuf, dp - ds);
return cbuf;
}
else {
buf = gz->z.buf;
len = rb_enc_mbclen(RSTRING_PTR(buf), RSTRING_END(buf), gz->enc);
dst = gzfile_read(gz, len);
if (NIL_P(dst)) return dst;
return gzfile_newstr(gz, dst);
}
}

static void
gzfile_ungets(struct gzfile *gz, const Bytef *b, long len)
{
zstream_buffer_ungets(&gz->z, b, len);
gz->ungetc+=len;
}

static void
gzfile_ungetbyte(struct gzfile *gz, int c)
{
zstream_buffer_ungetbyte(&gz->z, c);
gz->ungetc++;
}

static VALUE
gzfile_writer_end_run(VALUE arg)
{
struct gzfile *gz = (struct gzfile *)arg;

if (!(gz->z.flags & GZFILE_FLAG_HEADER_FINISHED)) {
gzfile_make_header(gz);
}

zstream_run(&gz->z, (Bytef*)"", 0, Z_FINISH);
gzfile_make_footer(gz);
gzfile_write_raw(gz);

return Qnil;
}

static void
gzfile_writer_end(struct gzfile *gz)
{
if (ZSTREAM_IS_CLOSING(&gz->z)) return;
gz->z.flags |= ZSTREAM_FLAG_CLOSING;

rb_ensure(gzfile_writer_end_run, (VALUE)gz, zstream_ensure_end, (VALUE)&gz->z);
}

static VALUE
gzfile_reader_end_run(VALUE arg)
{
struct gzfile *gz = (struct gzfile *)arg;

if (GZFILE_IS_FINISHED(gz)
&& !(gz->z.flags & GZFILE_FLAG_FOOTER_FINISHED)) {
gzfile_check_footer(gz, Qnil);
}

return Qnil;
}

static void
gzfile_reader_end(struct gzfile *gz)
{
if (ZSTREAM_IS_CLOSING(&gz->z)) return;
gz->z.flags |= ZSTREAM_FLAG_CLOSING;

rb_ensure(gzfile_reader_end_run, (VALUE)gz, zstream_ensure_end, (VALUE)&gz->z);
}

static void
gzfile_reader_rewind(struct gzfile *gz)
{
long n;

n = gz->z.stream.total_in;
if (!NIL_P(gz->z.input)) {
n += RSTRING_LEN(gz->z.input);
}

rb_funcall(gz->io, id_seek, 2, rb_int2inum(-n), INT2FIX(1));
gzfile_reset(gz);
}

static VALUE
gzfile_reader_get_unused(struct gzfile *gz)
{
VALUE str;

if (!ZSTREAM_IS_READY(&gz->z)) return Qnil;
if (!GZFILE_IS_FINISHED(gz)) return Qnil;
if (!(gz->z.flags & GZFILE_FLAG_FOOTER_FINISHED)) {
gzfile_check_footer(gz, Qnil);
}
if (NIL_P(gz->z.input)) return Qnil;

str = rb_str_resurrect(gz->z.input);
return str;
}

static struct gzfile *
get_gzfile(VALUE obj)
{
struct gzfile *gz;

TypedData_Get_Struct(obj, struct gzfile, &gzfile_data_type, gz);
if (!ZSTREAM_IS_READY(&gz->z)) {
rb_raise(cGzError, "closed gzip stream");
}
return gz;
}










































typedef struct {
int argc;
VALUE *argv;
VALUE klass;
} new_wrap_arg_t;

static VALUE
new_wrap(VALUE tmp)
{
new_wrap_arg_t *arg = (new_wrap_arg_t *)tmp;
return rb_class_new_instance_kw(arg->argc, arg->argv, arg->klass, RB_PASS_CALLED_KEYWORDS);
}

static VALUE
gzfile_ensure_close(VALUE obj)
{
struct gzfile *gz;

TypedData_Get_Struct(obj, struct gzfile, &gzfile_data_type, gz);
if (ZSTREAM_IS_READY(&gz->z)) {
gzfile_close(gz, 1);
}
return Qnil;
}

static VALUE
gzfile_wrap(int argc, VALUE *argv, VALUE klass, int close_io_on_error)
{
VALUE obj;

if (close_io_on_error) {
int state = 0;
new_wrap_arg_t arg;
arg.argc = argc;
arg.argv = argv;
arg.klass = klass;
obj = rb_protect(new_wrap, (VALUE)&arg, &state);
if (state) {
rb_io_close(argv[0]);
rb_jump_tag(state);
}
}
else {
obj = rb_class_new_instance_kw(argc, argv, klass, RB_PASS_CALLED_KEYWORDS);
}

if (rb_block_given_p()) {
return rb_ensure(rb_yield, obj, gzfile_ensure_close, obj);
}
else {
return obj;
}
}
















static VALUE
rb_gzfile_s_wrap(int argc, VALUE *argv, VALUE klass)
{
return gzfile_wrap(argc, argv, klass, 0);
}






static VALUE
gzfile_s_open(int argc, VALUE *argv, VALUE klass, const char *mode)
{
VALUE io, filename;

rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
filename = argv[0];
io = rb_file_open_str(filename, mode);
argv[0] = io;
return gzfile_wrap(argc, argv, klass, 1);
}






static VALUE
rb_gzfile_to_io(VALUE obj)
{
return get_gzfile(obj)->io;
}






static VALUE
rb_gzfile_crc(VALUE obj)
{
return rb_uint2inum(get_gzfile(obj)->crc);
}






static VALUE
rb_gzfile_mtime(VALUE obj)
{
return rb_time_new(get_gzfile(obj)->mtime, (time_t)0);
}






static VALUE
rb_gzfile_level(VALUE obj)
{
return INT2FIX(get_gzfile(obj)->level);
}






static VALUE
rb_gzfile_os_code(VALUE obj)
{
return INT2FIX(get_gzfile(obj)->os_code);
}







static VALUE
rb_gzfile_orig_name(VALUE obj)
{
VALUE str = get_gzfile(obj)->orig_name;
if (!NIL_P(str)) {
str = rb_str_dup(str);
}
return str;
}







static VALUE
rb_gzfile_comment(VALUE obj)
{
VALUE str = get_gzfile(obj)->comment;
if (!NIL_P(str)) {
str = rb_str_dup(str);
}
return str;
}






static VALUE
rb_gzfile_lineno(VALUE obj)
{
return INT2NUM(get_gzfile(obj)->lineno);
}






static VALUE
rb_gzfile_set_lineno(VALUE obj, VALUE lineno)
{
struct gzfile *gz = get_gzfile(obj);
gz->lineno = NUM2INT(lineno);
return lineno;
}




















static VALUE
rb_gzfile_set_mtime(VALUE obj, VALUE mtime)
{
struct gzfile *gz = get_gzfile(obj);
VALUE val;

if (gz->z.flags & GZFILE_FLAG_HEADER_FINISHED) {
rb_raise(cGzError, "header is already written");
}

val = rb_Integer(mtime);
gz->mtime = NUM2UINT(val);
gz->z.flags |= GZFILE_FLAG_MTIME_IS_SET;

return mtime;
}






static VALUE
rb_gzfile_set_orig_name(VALUE obj, VALUE str)
{
struct gzfile *gz = get_gzfile(obj);
VALUE s;
char *p;

if (gz->z.flags & GZFILE_FLAG_HEADER_FINISHED) {
rb_raise(cGzError, "header is already written");
}
s = rb_str_dup(rb_str_to_str(str));
p = memchr(RSTRING_PTR(s), '\0', RSTRING_LEN(s));
if (p) {
rb_str_resize(s, p - RSTRING_PTR(s));
}
gz->orig_name = s;
return str;
}






static VALUE
rb_gzfile_set_comment(VALUE obj, VALUE str)
{
struct gzfile *gz = get_gzfile(obj);
VALUE s;
char *p;

if (gz->z.flags & GZFILE_FLAG_HEADER_FINISHED) {
rb_raise(cGzError, "header is already written");
}
s = rb_str_dup(rb_str_to_str(str));
p = memchr(RSTRING_PTR(s), '\0', RSTRING_LEN(s));
if (p) {
rb_str_resize(s, p - RSTRING_PTR(s));
}
gz->comment = s;
return str;
}







static VALUE
rb_gzfile_close(VALUE obj)
{
struct gzfile *gz;
VALUE io;

TypedData_Get_Struct(obj, struct gzfile, &gzfile_data_type, gz);
if (!ZSTREAM_IS_READY(&gz->z)) {
return Qnil;
}
io = gz->io;
gzfile_close(gz, 1);
return io;
}








static VALUE
rb_gzfile_finish(VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
VALUE io;

io = gz->io;
gzfile_close(gz, 0);
return io;
}







static VALUE
rb_gzfile_closed_p(VALUE obj)
{
struct gzfile *gz;
TypedData_Get_Struct(obj, struct gzfile, &gzfile_data_type, gz);
return NIL_P(gz->io) ? Qtrue : Qfalse;
}






static VALUE
rb_gzfile_eof_p(VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
return GZFILE_IS_FINISHED(gz) ? Qtrue : Qfalse;
}







static VALUE
rb_gzfile_sync(VALUE obj)
{
return (get_gzfile(obj)->z.flags & GZFILE_FLAG_SYNC) ? Qtrue : Qfalse;
}










static VALUE
rb_gzfile_set_sync(VALUE obj, VALUE mode)
{
struct gzfile *gz = get_gzfile(obj);

if (RTEST(mode)) {
gz->z.flags |= GZFILE_FLAG_SYNC;
}
else {
gz->z.flags &= ~GZFILE_FLAG_SYNC;
}
return mode;
}






static VALUE
rb_gzfile_total_in(VALUE obj)
{
return rb_uint2inum(get_gzfile(obj)->z.stream.total_in);
}






static VALUE
rb_gzfile_total_out(VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
uLong total_out = gz->z.stream.total_out;
long buf_filled = ZSTREAM_BUF_FILLED(&gz->z);

if (total_out >= (uLong)buf_filled) {
return rb_uint2inum(total_out - buf_filled);
} else {
return LONG2FIX(-(buf_filled - (long)total_out));
}
}









static VALUE
rb_gzfile_path(VALUE obj)
{
struct gzfile *gz;
TypedData_Get_Struct(obj, struct gzfile, &gzfile_data_type, gz);
return gz->path;
}

static void
rb_gzfile_ecopts(struct gzfile *gz, VALUE opts)
{
if (!NIL_P(opts)) {
rb_io_extract_encoding_option(opts, &gz->enc, &gz->enc2, NULL);
}
if (gz->enc2) {
gz->ecflags = rb_econv_prepare_opts(opts, &opts);
gz->ec = rb_econv_open_opts(gz->enc2->name, gz->enc->name,
gz->ecflags, opts);
gz->ecopts = opts;
}
}




































static VALUE
rb_gzwriter_s_allocate(VALUE klass)
{
return gzfile_writer_new(klass);
}








static VALUE
rb_gzwriter_s_open(int argc, VALUE *argv, VALUE klass)
{
return gzfile_s_open(argc, argv, klass, "wb");
}














static VALUE
rb_gzwriter_initialize(int argc, VALUE *argv, VALUE obj)
{
struct gzfile *gz;
VALUE io, level, strategy, opt = Qnil;
int err;

if (argc > 1) {
opt = rb_check_convert_type(argv[argc-1], T_HASH, "Hash", "to_hash");
if (!NIL_P(opt)) argc--;
}

rb_scan_args(argc, argv, "12", &io, &level, &strategy);
TypedData_Get_Struct(obj, struct gzfile, &gzfile_data_type, gz);


gz->level = ARG_LEVEL(level);
err = deflateInit2(&gz->z.stream, gz->level, Z_DEFLATED,
-MAX_WBITS, DEF_MEM_LEVEL, ARG_STRATEGY(strategy));
if (err != Z_OK) {
raise_zlib_error(err, gz->z.stream.msg);
}
gz->io = io;
ZSTREAM_READY(&gz->z);
rb_gzfile_ecopts(gz, opt);

if (rb_respond_to(io, id_path)) {
gz->path = rb_funcall(gz->io, id_path, 0);
rb_define_singleton_method(obj, "path", rb_gzfile_path, 0);
}

return obj;
}








static VALUE
rb_gzwriter_flush(int argc, VALUE *argv, VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
VALUE v_flush;
int flush;

rb_scan_args(argc, argv, "01", &v_flush);

flush = FIXNUMARG(v_flush, Z_SYNC_FLUSH);
if (flush != Z_NO_FLUSH) { 
zstream_run(&gz->z, (Bytef*)"", 0, flush);
}

gzfile_write_raw(gz);
if (rb_respond_to(gz->io, id_flush)) {
rb_funcall(gz->io, id_flush, 0);
}
return obj;
}




static VALUE
rb_gzwriter_write(int argc, VALUE *argv, VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
size_t total = 0;

while (argc-- > 0) {
VALUE str = *argv++;
if (!RB_TYPE_P(str, T_STRING))
str = rb_obj_as_string(str);
if (gz->enc2 && gz->enc2 != rb_ascii8bit_encoding()) {
str = rb_str_conv_enc(str, rb_enc_get(str), gz->enc2);
}
gzfile_write(gz, (Bytef*)RSTRING_PTR(str), RSTRING_LEN(str));
total += RSTRING_LEN(str);
RB_GC_GUARD(str);
}
return SIZET2NUM(total);
}




static VALUE
rb_gzwriter_putc(VALUE obj, VALUE ch)
{
struct gzfile *gz = get_gzfile(obj);
char c = NUM2CHR(ch);

gzfile_write(gz, (Bytef*)&c, 1);
return ch;
}







#define rb_gzwriter_addstr rb_io_addstr




#define rb_gzwriter_printf rb_io_printf




#define rb_gzwriter_print rb_io_print




#define rb_gzwriter_puts rb_io_puts
























































static VALUE
rb_gzreader_s_allocate(VALUE klass)
{
return gzfile_reader_new(klass);
}










static VALUE
rb_gzreader_s_open(int argc, VALUE *argv, VALUE klass)
{
return gzfile_s_open(argc, argv, klass, "rb");
}


















static VALUE
rb_gzreader_initialize(int argc, VALUE *argv, VALUE obj)
{
VALUE io, opt = Qnil;
struct gzfile *gz;
int err;

TypedData_Get_Struct(obj, struct gzfile, &gzfile_data_type, gz);
rb_scan_args(argc, argv, "1:", &io, &opt);


err = inflateInit2(&gz->z.stream, -MAX_WBITS);
if (err != Z_OK) {
raise_zlib_error(err, gz->z.stream.msg);
}
gz->io = io;
ZSTREAM_READY(&gz->z);
gzfile_read_header(gz, Qnil);
rb_gzfile_ecopts(gz, opt);

if (rb_respond_to(io, id_path)) {
gz->path = rb_funcall(gz->io, id_path, 0);
rb_define_singleton_method(obj, "path", rb_gzfile_path, 0);
}

return obj;
}







static VALUE
rb_gzreader_rewind(VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
gzfile_reader_rewind(gz);
return INT2FIX(0);
}







static VALUE
rb_gzreader_unused(VALUE obj)
{
struct gzfile *gz;
TypedData_Get_Struct(obj, struct gzfile, &gzfile_data_type, gz);
return gzfile_reader_get_unused(gz);
}






static VALUE
rb_gzreader_read(int argc, VALUE *argv, VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
VALUE vlen;
long len;

rb_scan_args(argc, argv, "01", &vlen);
if (NIL_P(vlen)) {
return gzfile_read_all(gz);
}

len = NUM2INT(vlen);
if (len < 0) {
rb_raise(rb_eArgError, "negative length %ld given", len);
}
return gzfile_read(gz, len);
}













static VALUE
rb_gzreader_readpartial(int argc, VALUE *argv, VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
VALUE vlen, outbuf;
long len;

rb_scan_args(argc, argv, "11", &vlen, &outbuf);

len = NUM2INT(vlen);
if (len < 0) {
rb_raise(rb_eArgError, "negative length %ld given", len);
}
if (!NIL_P(outbuf))
Check_Type(outbuf, T_STRING);
return gzfile_readpartial(gz, len, outbuf);
}






static VALUE
rb_gzreader_getc(VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);

return gzfile_getc(gz);
}






static VALUE
rb_gzreader_readchar(VALUE obj)
{
VALUE dst;
dst = rb_gzreader_getc(obj);
if (NIL_P(dst)) {
rb_raise(rb_eEOFError, "end of file reached");
}
return dst;
}






static VALUE
rb_gzreader_getbyte(VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
VALUE dst;

dst = gzfile_read(gz, 1);
if (!NIL_P(dst)) {
dst = INT2FIX((unsigned int)(RSTRING_PTR(dst)[0]) & 0xff);
}
return dst;
}






static VALUE
rb_gzreader_readbyte(VALUE obj)
{
VALUE dst;
dst = rb_gzreader_getbyte(obj);
if (NIL_P(dst)) {
rb_raise(rb_eEOFError, "end of file reached");
}
return dst;
}






static VALUE
rb_gzreader_each_char(VALUE obj)
{
VALUE c;

RETURN_ENUMERATOR(obj, 0, 0);

while (!NIL_P(c = rb_gzreader_getc(obj))) {
rb_yield(c);
}
return Qnil;
}






static VALUE
rb_gzreader_each_byte(VALUE obj)
{
VALUE c;

RETURN_ENUMERATOR(obj, 0, 0);

while (!NIL_P(c = rb_gzreader_getbyte(obj))) {
rb_yield(c);
}
return Qnil;
}






static VALUE
rb_gzreader_bytes(VALUE obj)
{
rb_warn("Zlib::GzipReader#bytes is deprecated; use #each_byte instead");
if (!rb_block_given_p())
return rb_enumeratorize(obj, ID2SYM(rb_intern("each_byte")), 0, 0);
return rb_gzreader_each_byte(obj);
}






static VALUE
rb_gzreader_ungetc(VALUE obj, VALUE s)
{
struct gzfile *gz;

if (FIXNUM_P(s))
return rb_gzreader_ungetbyte(obj, s);
gz = get_gzfile(obj);
StringValue(s);
if (gz->enc2 && gz->enc2 != rb_ascii8bit_encoding()) {
s = rb_str_conv_enc(s, rb_enc_get(s), gz->enc2);
}
gzfile_ungets(gz, (const Bytef*)RSTRING_PTR(s), RSTRING_LEN(s));
RB_GC_GUARD(s);
return Qnil;
}






static VALUE
rb_gzreader_ungetbyte(VALUE obj, VALUE ch)
{
struct gzfile *gz = get_gzfile(obj);
gzfile_ungetbyte(gz, NUM2CHR(ch));
return Qnil;
}

static void
gzreader_skip_linebreaks(struct gzfile *gz)
{
VALUE str;
char *p;
int n;

while (ZSTREAM_BUF_FILLED(&gz->z) == 0) {
if (GZFILE_IS_FINISHED(gz)) return;
gzfile_read_more(gz, Qnil);
}
n = 0;
p = RSTRING_PTR(gz->z.buf);

while (n++, *(p++) == '\n') {
if (n >= ZSTREAM_BUF_FILLED(&gz->z)) {
str = zstream_detach_buffer(&gz->z);
gzfile_calc_crc(gz, str);
while (ZSTREAM_BUF_FILLED(&gz->z) == 0) {
if (GZFILE_IS_FINISHED(gz)) return;
gzfile_read_more(gz, Qnil);
}
n = 0;
p = RSTRING_PTR(gz->z.buf);
}
}

str = zstream_shift_buffer(&gz->z, n - 1);
gzfile_calc_crc(gz, str);
}

static void
rscheck(const char *rsptr, long rslen, VALUE rs)
{
if (RSTRING_PTR(rs) != rsptr && RSTRING_LEN(rs) != rslen)
rb_raise(rb_eRuntimeError, "rs modified");
}

static long
gzreader_charboundary(struct gzfile *gz, long n)
{
char *s = RSTRING_PTR(gz->z.buf);
char *e = s + ZSTREAM_BUF_FILLED(&gz->z);
char *p = rb_enc_left_char_head(s, s + n, e, gz->enc);
long l = p - s;
if (l < n) {
n = rb_enc_precise_mbclen(p, e, gz->enc);
if (MBCLEN_NEEDMORE_P(n)) {
if ((l = gzfile_fill(gz, l + MBCLEN_NEEDMORE_LEN(n))) > 0) {
return l;
}
}
else if (MBCLEN_CHARFOUND_P(n)) {
return l + MBCLEN_CHARFOUND_LEN(n);
}
}
return n;
}

static VALUE
gzreader_gets(int argc, VALUE *argv, VALUE obj)
{
struct gzfile *gz = get_gzfile(obj);
VALUE rs;
VALUE dst;
const char *rsptr;
char *p, *res;
long rslen, n, limit = -1;
int rspara;
rb_encoding *enc = gz->enc;
int maxlen = rb_enc_mbmaxlen(enc);

if (argc == 0) {
rs = rb_rs;
}
else {
VALUE lim, tmp;

rb_scan_args(argc, argv, "11", &rs, &lim);
if (!NIL_P(lim)) {
if (!NIL_P(rs)) StringValue(rs);
}
else if (!NIL_P(rs)) {
tmp = rb_check_string_type(rs);
if (NIL_P(tmp)) {
lim = rs;
rs = rb_rs;
}
else {
rs = tmp;
}
}
if (!NIL_P(lim)) {
limit = NUM2LONG(lim);
if (limit == 0) return rb_str_new(0,0);
}
}

if (NIL_P(rs)) {
if (limit < 0) {
dst = gzfile_read_all(gz);
if (RSTRING_LEN(dst) == 0) return Qnil;
}
else if ((n = gzfile_fill(gz, limit)) <= 0) {
return Qnil;
}
else {
if (maxlen > 1 && n >= limit && !GZFILE_IS_FINISHED(gz)) {
n = gzreader_charboundary(gz, n);
}
else {
n = limit;
}
dst = zstream_shift_buffer(&gz->z, n);
if (NIL_P(dst)) return dst;
gzfile_calc_crc(gz, dst);
dst = gzfile_newstr(gz, dst);
}
gz->lineno++;
return dst;
}

if (RSTRING_LEN(rs) == 0) {
rsptr = "\n\n";
rslen = 2;
rspara = 1;
}
else {
rsptr = RSTRING_PTR(rs);
rslen = RSTRING_LEN(rs);
rspara = 0;
}

if (rspara) {
gzreader_skip_linebreaks(gz);
}

while (ZSTREAM_BUF_FILLED(&gz->z) < rslen) {
if (ZSTREAM_IS_FINISHED(&gz->z)) {
if (ZSTREAM_BUF_FILLED(&gz->z) > 0) gz->lineno++;
return gzfile_read(gz, rslen);
}
gzfile_read_more(gz, Qnil);
}

p = RSTRING_PTR(gz->z.buf);
n = rslen;
for (;;) {
long filled;
if (n > ZSTREAM_BUF_FILLED(&gz->z)) {
if (ZSTREAM_IS_FINISHED(&gz->z)) break;
gzfile_read_more(gz, Qnil);
p = RSTRING_PTR(gz->z.buf) + n - rslen;
}
if (!rspara) rscheck(rsptr, rslen, rs);
filled = ZSTREAM_BUF_FILLED(&gz->z);
if (limit > 0 && filled >= limit) {
filled = limit;
}
res = memchr(p, rsptr[0], (filled - n + 1));
if (!res) {
n = filled;
if (limit > 0 && filled >= limit) break;
n++;
}
else {
n += (long)(res - p);
p = res;
if (rslen == 1 || memcmp(p, rsptr, rslen) == 0) break;
p++, n++;
}
}
if (maxlen > 1 && n == limit && (ZSTREAM_BUF_FILLED(&gz->z) > n || !ZSTREAM_IS_FINISHED(&gz->z))) {
n = gzreader_charboundary(gz, n);
}

gz->lineno++;
dst = gzfile_read(gz, n);
if (NIL_P(dst)) return dst;
if (rspara) {
gzreader_skip_linebreaks(gz);
}
RB_GC_GUARD(rs);

return gzfile_newstr(gz, dst);
}






static VALUE
rb_gzreader_gets(int argc, VALUE *argv, VALUE obj)
{
VALUE dst;
dst = gzreader_gets(argc, argv, obj);
if (!NIL_P(dst)) {
rb_lastline_set(dst);
}
return dst;
}






static VALUE
rb_gzreader_readline(int argc, VALUE *argv, VALUE obj)
{
VALUE dst;
dst = rb_gzreader_gets(argc, argv, obj);
if (NIL_P(dst)) {
rb_raise(rb_eEOFError, "end of file reached");
}
return dst;
}






static VALUE
rb_gzreader_each(int argc, VALUE *argv, VALUE obj)
{
VALUE str;

RETURN_ENUMERATOR(obj, 0, 0);

while (!NIL_P(str = gzreader_gets(argc, argv, obj))) {
rb_yield(str);
}
return obj;
}






static VALUE
rb_gzreader_lines(int argc, VALUE *argv, VALUE obj)
{
rb_warn("Zlib::GzipReader#lines is deprecated; use #each_line instead");
if (!rb_block_given_p())
return rb_enumeratorize(obj, ID2SYM(rb_intern("each_line")), argc, argv);
return rb_gzreader_each(argc, argv, obj);
}






static VALUE
rb_gzreader_readlines(int argc, VALUE *argv, VALUE obj)
{
VALUE str, dst;
dst = rb_ary_new();
while (!NIL_P(str = gzreader_gets(argc, argv, obj))) {
rb_ary_push(dst, str);
}
return dst;
}






static VALUE
rb_gzreader_external_encoding(VALUE self)
{
return rb_enc_from_encoding(get_gzfile(self)->enc);
}

static VALUE
zlib_gzip_end_rescue(VALUE arg)
{
struct gzfile *gz = (struct gzfile *)arg;
gz->end(gz);
return Qnil;
}

static VALUE
zlib_gzip_ensure(VALUE arg)
{
return rb_rescue(zlib_gzip_end_rescue, arg, NULL, Qnil);
}

static void
zlib_gzip_end(struct gzfile *gz)
{
gz->z.flags |= ZSTREAM_FLAG_CLOSING;
zstream_run(&gz->z, (Bytef*)"", 0, Z_FINISH);
gzfile_make_footer(gz);
zstream_end(&gz->z);
}

#define OPTHASH_GIVEN_P(opts) (argc > 0 && !NIL_P((opts) = rb_check_hash_type(argv[argc-1])) && (--argc, 1))

static ID id_level, id_strategy;
static VALUE zlib_gzip_run(VALUE arg);























static VALUE
zlib_s_gzip(int argc, VALUE *argv, VALUE klass)
{
struct gzfile gz0;
struct gzfile *gz = &gz0;
int err;
VALUE src, opts, level=Qnil, strategy=Qnil, args[2];

if (OPTHASH_GIVEN_P(opts)) {
ID keyword_ids[2];
VALUE kwargs[2];
keyword_ids[0] = id_level;
keyword_ids[1] = id_strategy;
rb_get_kwargs(opts, keyword_ids, 0, 2, kwargs);
if (kwargs[0] != Qundef) {
level = kwargs[0];
}
if (kwargs[1] != Qundef) {
strategy = kwargs[1];
}
}
rb_scan_args(argc, argv, "10", &src);
StringValue(src);
gzfile_init(gz, &deflate_funcs, zlib_gzip_end);
gz->level = ARG_LEVEL(level);
err = deflateInit2(&gz->z.stream, gz->level, Z_DEFLATED,
-MAX_WBITS, DEF_MEM_LEVEL, ARG_STRATEGY(strategy));
if (err != Z_OK) {
zlib_gzip_end(gz);
raise_zlib_error(err, gz->z.stream.msg);
}
ZSTREAM_READY(&gz->z);
args[0] = (VALUE)gz;
args[1] = src;
return rb_ensure(zlib_gzip_run, (VALUE)args, zlib_gzip_ensure, (VALUE)gz);
}

static VALUE
zlib_gzip_run(VALUE arg)
{
VALUE *args = (VALUE *)arg;
struct gzfile *gz = (struct gzfile *)args[0];
VALUE src = args[1];
long len;

gzfile_make_header(gz);
len = RSTRING_LEN(src);
if (len > 0) {
Bytef *ptr = (Bytef *)RSTRING_PTR(src);
gz->crc = checksum_long(crc32, gz->crc, ptr, len);
zstream_run(&gz->z, ptr, len, Z_NO_FLUSH);
}
gzfile_close(gz, 0);
return zstream_detach_buffer(&gz->z);
}

static void
zlib_gunzip_end(struct gzfile *gz)
{
gz->z.flags |= ZSTREAM_FLAG_CLOSING;
zstream_end(&gz->z);
}

static VALUE zlib_gunzip_run(VALUE arg);



















static VALUE
zlib_gunzip(VALUE klass, VALUE src)
{
struct gzfile gz0;
struct gzfile *gz = &gz0;
int err;

StringValue(src);

gzfile_init(gz, &inflate_funcs, zlib_gunzip_end);
err = inflateInit2(&gz->z.stream, -MAX_WBITS);
if (err != Z_OK) {
raise_zlib_error(err, gz->z.stream.msg);
}
gz->io = Qundef;
gz->z.input = src;
ZSTREAM_READY(&gz->z);
return rb_ensure(zlib_gunzip_run, (VALUE)gz, zlib_gzip_ensure, (VALUE)gz);
}

static VALUE
zlib_gunzip_run(VALUE arg)
{
struct gzfile *gz = (struct gzfile *)arg;
VALUE dst;

gzfile_read_header(gz, Qnil);
dst = zstream_detach_buffer(&gz->z);
gzfile_calc_crc(gz, dst);
if (!ZSTREAM_IS_FINISHED(&gz->z)) {
rb_raise(cGzError, "unexpected end of file");
}
if (NIL_P(gz->z.input)) {
rb_raise(cNoFooter, "footer is not found");
}
gzfile_check_footer(gz, Qnil);
return dst;
}

#endif 

void
Init_zlib(void)
{
#undef rb_intern
VALUE mZlib, cZStream, cDeflate, cInflate;
#if GZIP_SUPPORT
VALUE cGzipFile, cGzipWriter, cGzipReader;
#endif

mZlib = rb_define_module("Zlib");

id_dictionaries = rb_intern("@dictionaries");

cZError = rb_define_class_under(mZlib, "Error", rb_eStandardError);
cStreamEnd = rb_define_class_under(mZlib, "StreamEnd", cZError);
cNeedDict = rb_define_class_under(mZlib, "NeedDict", cZError);
cDataError = rb_define_class_under(mZlib, "DataError", cZError);
cStreamError = rb_define_class_under(mZlib, "StreamError", cZError);
cMemError = rb_define_class_under(mZlib, "MemError", cZError);
cBufError = rb_define_class_under(mZlib, "BufError", cZError);
cVersionError = rb_define_class_under(mZlib, "VersionError", cZError);

rb_define_module_function(mZlib, "zlib_version", rb_zlib_version, 0);
rb_define_module_function(mZlib, "adler32", rb_zlib_adler32, -1);
rb_define_module_function(mZlib, "adler32_combine", rb_zlib_adler32_combine, 3);
rb_define_module_function(mZlib, "crc32", rb_zlib_crc32, -1);
rb_define_module_function(mZlib, "crc32_combine", rb_zlib_crc32_combine, 3);
rb_define_module_function(mZlib, "crc_table", rb_zlib_crc_table, 0);


rb_define_const(mZlib, "VERSION", rb_str_new2(RUBY_ZLIB_VERSION));

rb_define_const(mZlib, "ZLIB_VERSION", rb_str_new2(ZLIB_VERSION));

cZStream = rb_define_class_under(mZlib, "ZStream", rb_cObject);
rb_undef_alloc_func(cZStream);
rb_define_method(cZStream, "avail_out", rb_zstream_avail_out, 0);
rb_define_method(cZStream, "avail_out=", rb_zstream_set_avail_out, 1);
rb_define_method(cZStream, "avail_in", rb_zstream_avail_in, 0);
rb_define_method(cZStream, "total_in", rb_zstream_total_in, 0);
rb_define_method(cZStream, "total_out", rb_zstream_total_out, 0);
rb_define_method(cZStream, "data_type", rb_zstream_data_type, 0);
rb_define_method(cZStream, "adler", rb_zstream_adler, 0);
rb_define_method(cZStream, "finished?", rb_zstream_finished_p, 0);
rb_define_method(cZStream, "stream_end?", rb_zstream_finished_p, 0);
rb_define_method(cZStream, "closed?", rb_zstream_closed_p, 0);
rb_define_method(cZStream, "ended?", rb_zstream_closed_p, 0);
rb_define_method(cZStream, "close", rb_zstream_end, 0);
rb_define_method(cZStream, "end", rb_zstream_end, 0);
rb_define_method(cZStream, "reset", rb_zstream_reset, 0);
rb_define_method(cZStream, "finish", rb_zstream_finish, 0);
rb_define_method(cZStream, "flush_next_in", rb_zstream_flush_next_in, 0);
rb_define_method(cZStream, "flush_next_out", rb_zstream_flush_next_out, 0);




rb_define_const(mZlib, "BINARY", INT2FIX(Z_BINARY));







rb_define_const(mZlib, "ASCII", INT2FIX(Z_ASCII));

#ifdef Z_TEXT



rb_define_const(mZlib, "TEXT", INT2FIX(Z_TEXT));
#endif




rb_define_const(mZlib, "UNKNOWN", INT2FIX(Z_UNKNOWN));

cDeflate = rb_define_class_under(mZlib, "Deflate", cZStream);
rb_define_singleton_method(cDeflate, "deflate", rb_deflate_s_deflate, -1);
rb_define_singleton_method(mZlib, "deflate", rb_deflate_s_deflate, -1);
rb_define_alloc_func(cDeflate, rb_deflate_s_allocate);
rb_define_method(cDeflate, "initialize", rb_deflate_initialize, -1);
rb_define_method(cDeflate, "initialize_copy", rb_deflate_init_copy, 1);
rb_define_method(cDeflate, "deflate", rb_deflate_deflate, -1);
rb_define_method(cDeflate, "<<", rb_deflate_addstr, 1);
rb_define_method(cDeflate, "flush", rb_deflate_flush, -1);
rb_define_method(cDeflate, "params", rb_deflate_params, 2);
rb_define_method(cDeflate, "set_dictionary", rb_deflate_set_dictionary, 1);

cInflate = rb_define_class_under(mZlib, "Inflate", cZStream);
rb_define_singleton_method(cInflate, "inflate", rb_inflate_s_inflate, 1);
rb_define_singleton_method(mZlib, "inflate", rb_inflate_s_inflate, 1);
rb_define_alloc_func(cInflate, rb_inflate_s_allocate);
rb_define_method(cInflate, "initialize", rb_inflate_initialize, -1);
rb_define_method(cInflate, "add_dictionary", rb_inflate_add_dictionary, 1);
rb_define_method(cInflate, "inflate", rb_inflate_inflate, 1);
rb_define_method(cInflate, "<<", rb_inflate_addstr, 1);
rb_define_method(cInflate, "sync", rb_inflate_sync, 1);
rb_define_method(cInflate, "sync_point?", rb_inflate_sync_point_p, 0);
rb_define_method(cInflate, "set_dictionary", rb_inflate_set_dictionary, 1);




rb_define_const(mZlib, "NO_COMPRESSION", INT2FIX(Z_NO_COMPRESSION));

rb_define_const(mZlib, "BEST_SPEED", INT2FIX(Z_BEST_SPEED));

rb_define_const(mZlib, "BEST_COMPRESSION", INT2FIX(Z_BEST_COMPRESSION));



rb_define_const(mZlib, "DEFAULT_COMPRESSION",
INT2FIX(Z_DEFAULT_COMPRESSION));







rb_define_const(mZlib, "FILTERED", INT2FIX(Z_FILTERED));


rb_define_const(mZlib, "HUFFMAN_ONLY", INT2FIX(Z_HUFFMAN_ONLY));

#ifdef Z_RLE



rb_define_const(mZlib, "RLE", INT2FIX(Z_RLE));
#endif

#ifdef Z_FIXED



rb_define_const(mZlib, "FIXED", INT2FIX(Z_FIXED));
#endif


rb_define_const(mZlib, "DEFAULT_STRATEGY", INT2FIX(Z_DEFAULT_STRATEGY));





rb_define_const(mZlib, "MAX_WBITS", INT2FIX(MAX_WBITS));



rb_define_const(mZlib, "DEF_MEM_LEVEL", INT2FIX(DEF_MEM_LEVEL));



rb_define_const(mZlib, "MAX_MEM_LEVEL", INT2FIX(MAX_MEM_LEVEL));





rb_define_const(mZlib, "NO_FLUSH", INT2FIX(Z_NO_FLUSH));






rb_define_const(mZlib, "SYNC_FLUSH", INT2FIX(Z_SYNC_FLUSH));







rb_define_const(mZlib, "FULL_FLUSH", INT2FIX(Z_FULL_FLUSH));


rb_define_const(mZlib, "FINISH", INT2FIX(Z_FINISH));

#if GZIP_SUPPORT
id_write = rb_intern("write");
id_read = rb_intern("read");
id_readpartial = rb_intern("readpartial");
id_flush = rb_intern("flush");
id_seek = rb_intern("seek");
id_close = rb_intern("close");
id_path = rb_intern("path");
id_input = rb_intern("@input");

cGzipFile = rb_define_class_under(mZlib, "GzipFile", rb_cObject);
cGzError = rb_define_class_under(cGzipFile, "Error", cZError);


rb_define_attr(cGzError, "input", 1, 0);
rb_define_method(cGzError, "inspect", gzfile_error_inspect, 0);

cNoFooter = rb_define_class_under(cGzipFile, "NoFooter", cGzError);
cCRCError = rb_define_class_under(cGzipFile, "CRCError", cGzError);
cLengthError = rb_define_class_under(cGzipFile,"LengthError",cGzError);

cGzipWriter = rb_define_class_under(mZlib, "GzipWriter", cGzipFile);
cGzipReader = rb_define_class_under(mZlib, "GzipReader", cGzipFile);
rb_include_module(cGzipReader, rb_mEnumerable);

rb_define_singleton_method(cGzipFile, "wrap", rb_gzfile_s_wrap, -1);
rb_undef_alloc_func(cGzipFile);
rb_define_method(cGzipFile, "to_io", rb_gzfile_to_io, 0);
rb_define_method(cGzipFile, "crc", rb_gzfile_crc, 0);
rb_define_method(cGzipFile, "mtime", rb_gzfile_mtime, 0);
rb_define_method(cGzipFile, "level", rb_gzfile_level, 0);
rb_define_method(cGzipFile, "os_code", rb_gzfile_os_code, 0);
rb_define_method(cGzipFile, "orig_name", rb_gzfile_orig_name, 0);
rb_define_method(cGzipFile, "comment", rb_gzfile_comment, 0);
rb_define_method(cGzipReader, "lineno", rb_gzfile_lineno, 0);
rb_define_method(cGzipReader, "lineno=", rb_gzfile_set_lineno, 1);
rb_define_method(cGzipWriter, "mtime=", rb_gzfile_set_mtime, 1);
rb_define_method(cGzipWriter, "orig_name=", rb_gzfile_set_orig_name,1);
rb_define_method(cGzipWriter, "comment=", rb_gzfile_set_comment, 1);
rb_define_method(cGzipFile, "close", rb_gzfile_close, 0);
rb_define_method(cGzipFile, "finish", rb_gzfile_finish, 0);
rb_define_method(cGzipFile, "closed?", rb_gzfile_closed_p, 0);
rb_define_method(cGzipReader, "eof", rb_gzfile_eof_p, 0);
rb_define_method(cGzipReader, "eof?", rb_gzfile_eof_p, 0);
rb_define_method(cGzipFile, "sync", rb_gzfile_sync, 0);
rb_define_method(cGzipFile, "sync=", rb_gzfile_set_sync, 1);
rb_define_method(cGzipReader, "pos", rb_gzfile_total_out, 0);
rb_define_method(cGzipWriter, "pos", rb_gzfile_total_in, 0);
rb_define_method(cGzipReader, "tell", rb_gzfile_total_out, 0);
rb_define_method(cGzipWriter, "tell", rb_gzfile_total_in, 0);

rb_define_singleton_method(cGzipWriter, "open", rb_gzwriter_s_open,-1);
rb_define_alloc_func(cGzipWriter, rb_gzwriter_s_allocate);
rb_define_method(cGzipWriter, "initialize", rb_gzwriter_initialize,-1);
rb_define_method(cGzipWriter, "flush", rb_gzwriter_flush, -1);
rb_define_method(cGzipWriter, "write", rb_gzwriter_write, -1);
rb_define_method(cGzipWriter, "putc", rb_gzwriter_putc, 1);
rb_define_method(cGzipWriter, "<<", rb_gzwriter_addstr, 1);
rb_define_method(cGzipWriter, "printf", rb_gzwriter_printf, -1);
rb_define_method(cGzipWriter, "print", rb_gzwriter_print, -1);
rb_define_method(cGzipWriter, "puts", rb_gzwriter_puts, -1);

rb_define_singleton_method(cGzipReader, "open", rb_gzreader_s_open,-1);
rb_define_alloc_func(cGzipReader, rb_gzreader_s_allocate);
rb_define_method(cGzipReader, "initialize", rb_gzreader_initialize, -1);
rb_define_method(cGzipReader, "rewind", rb_gzreader_rewind, 0);
rb_define_method(cGzipReader, "unused", rb_gzreader_unused, 0);
rb_define_method(cGzipReader, "read", rb_gzreader_read, -1);
rb_define_method(cGzipReader, "readpartial", rb_gzreader_readpartial, -1);
rb_define_method(cGzipReader, "getc", rb_gzreader_getc, 0);
rb_define_method(cGzipReader, "getbyte", rb_gzreader_getbyte, 0);
rb_define_method(cGzipReader, "readchar", rb_gzreader_readchar, 0);
rb_define_method(cGzipReader, "readbyte", rb_gzreader_readbyte, 0);
rb_define_method(cGzipReader, "each_byte", rb_gzreader_each_byte, 0);
rb_define_method(cGzipReader, "each_char", rb_gzreader_each_char, 0);
rb_define_method(cGzipReader, "bytes", rb_gzreader_bytes, 0);
rb_define_method(cGzipReader, "ungetc", rb_gzreader_ungetc, 1);
rb_define_method(cGzipReader, "ungetbyte", rb_gzreader_ungetbyte, 1);
rb_define_method(cGzipReader, "gets", rb_gzreader_gets, -1);
rb_define_method(cGzipReader, "readline", rb_gzreader_readline, -1);
rb_define_method(cGzipReader, "each", rb_gzreader_each, -1);
rb_define_method(cGzipReader, "each_line", rb_gzreader_each, -1);
rb_define_method(cGzipReader, "lines", rb_gzreader_lines, -1);
rb_define_method(cGzipReader, "readlines", rb_gzreader_readlines, -1);
rb_define_method(cGzipReader, "external_encoding", rb_gzreader_external_encoding, 0);

rb_define_singleton_method(mZlib, "gzip", zlib_s_gzip, -1);
rb_define_singleton_method(mZlib, "gunzip", zlib_gunzip, 1);


rb_define_const(mZlib, "OS_CODE", INT2FIX(OS_CODE));

rb_define_const(mZlib, "OS_MSDOS", INT2FIX(OS_MSDOS));

rb_define_const(mZlib, "OS_AMIGA", INT2FIX(OS_AMIGA));

rb_define_const(mZlib, "OS_VMS", INT2FIX(OS_VMS));

rb_define_const(mZlib, "OS_UNIX", INT2FIX(OS_UNIX));

rb_define_const(mZlib, "OS_ATARI", INT2FIX(OS_ATARI));

rb_define_const(mZlib, "OS_OS2", INT2FIX(OS_OS2));

rb_define_const(mZlib, "OS_MACOS", INT2FIX(OS_MACOS));

rb_define_const(mZlib, "OS_TOPS20", INT2FIX(OS_TOPS20));

rb_define_const(mZlib, "OS_WIN32", INT2FIX(OS_WIN32));

rb_define_const(mZlib, "OS_VMCMS", INT2FIX(OS_VMCMS));

rb_define_const(mZlib, "OS_ZSYSTEM", INT2FIX(OS_ZSYSTEM));

rb_define_const(mZlib, "OS_CPM", INT2FIX(OS_CPM));

rb_define_const(mZlib, "OS_QDOS", INT2FIX(OS_QDOS));

rb_define_const(mZlib, "OS_RISCOS", INT2FIX(OS_RISCOS));

rb_define_const(mZlib, "OS_UNKNOWN", INT2FIX(OS_UNKNOWN));

id_level = rb_intern("level");
id_strategy = rb_intern("strategy");
#endif 
}






















































































































