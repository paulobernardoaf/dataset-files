<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\ext\racc\cparse\cparse.c">












<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ruby.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FALSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRUE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RACC_VERSION</name></cpp:macro> <cpp:value>"1.4.15"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TOKEN</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_TOKEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINAL_TOKEN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vDEFAULT_TOKEN</name></cpp:macro> <cpp:value>INT2FIX(DEFAULT_TOKEN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vERROR_TOKEN</name></cpp:macro> <cpp:value>INT2FIX(ERROR_TOKEN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vFINAL_TOKEN</name></cpp:macro> <cpp:value>INT2FIX(FINAL_TOKEN)</cpp:value></cpp:define>





<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>RaccBug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>CparseParams</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_yydebug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_nexttoken</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_onerror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_noreduce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_errstatus</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_d_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_d_reduce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_d_accept</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_d_read_token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_d_next_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_d_e_pop</name></decl>;</decl_stmt>






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ID2SYM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ID2SYM</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ULONG2NUM(i)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SYM2ID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYM2ID</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ID)NUM2ULONG(v))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SYMBOL_P</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYMBOL_P</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FIXNUM_P(v)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LONG2NUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG2NUM</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>INT2NUM(i)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RB_ARY_SUBSEQ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_ary_subseq</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>beg</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_ary_new4(len, RARRAY_PTR(ary) + beg)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name> <name>value_to_id</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>v</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name> <name>num_to_long</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>n</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>value_to_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"not symbol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>
<name>num_to_long</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AREF</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((0 &lt;= idx &amp;&amp; idx &lt; RARRAY_LEN(s)) ? rb_ary_entry(s, idx) : Qnil)</cpp:value></cpp:define>






<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name> <name>get_stack_tail</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>stack</name><operator>,</operator> <name>long</name> <name>len</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>cut_stack_tail</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>stack</name><operator>,</operator> <name>long</name> <name>len</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>get_stack_tail</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>stack</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_ary_subseq</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cut_stack_tail</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>stack</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_pop</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_INIT_LEN</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_STACK</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>rb_ary_new2(STACK_INIT_LEN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_ary_store(s, RARRAY_LEN(s), i)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_ary_pop(s)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST_I</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((RARRAY_LEN(s) &gt; 0) ? rb_ary_entry(s, RARRAY_LEN(s) - 1) : Qnil)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_TAIL</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>get_stack_tail(s, len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CUT_TAIL</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cut_stack_tail(s, len)</cpp:value></cpp:define>





<struct>struct <name>cparse_params</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>value_v</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>parser</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>lex_is_iterator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>lexer</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ID</name></type> <name>lexmid</name></decl>;</decl_stmt> 




<decl_stmt><decl><type><name>VALUE</name></type> <name>action_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>action_check</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>action_default</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>action_pointer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>goto_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>goto_check</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>goto_default</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>goto_pointer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>nt_base</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VALUE</name></type> <name>reduce_table</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VALUE</name></type> <name>token_table</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>VALUE</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>curstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>vstack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tstack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>shift_n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>reduce_n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>ruleno</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>errstatus</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>nerr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>use_result_var</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>retval</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>fin</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_FIN_ACCEPT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_FIN_EOT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_FIN_CANTPOP</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>debug</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sys_debug</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt> 
}</block>;</struct>





<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name> <name>racc_cparse</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>parser</name><operator>,</operator> <name>VALUE</name> <name>arg</name><operator>,</operator> <name>VALUE</name> <name>sysdebug</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name> <name>racc_yyparse</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>parser</name><operator>,</operator> <name>VALUE</name> <name>lexer</name><operator>,</operator> <name>VALUE</name> <name>lexmid</name><operator>,</operator>
<name>VALUE</name> <name>arg</name><operator>,</operator> <name>VALUE</name> <name>sysdebug</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>call_lexer</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator>struct <name>cparse_params</name> <operator>*</operator><name>v</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name> <name>lexer_i</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name> <name>assert_array</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>a</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name> <name>assert_integer</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>n</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name> <name>assert_hash</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>h</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name> <name>initialize_params</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <name>vparams</name><operator>,</operator> <name>VALUE</name> <name>parser</name><operator>,</operator> <name>VALUE</name> <name>arg</name><operator>,</operator>
<name>VALUE</name> <name>lexer</name><operator>,</operator> <name>VALUE</name> <name>lexmid</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>cparse_params_mark</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><name>ptr</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name> <name>cparse_params_memsize</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><name>ptr</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>parse_main</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator>struct <name>cparse_params</name> <operator>*</operator><name>v</name><operator>,</operator>
<name>VALUE</name> <name>tok</name><operator>,</operator> <name>VALUE</name> <name>val</name><operator>,</operator> <name>int</name> <name>resume</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>extract_user_token</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator>struct <name>cparse_params</name> <operator>*</operator><name>v</name><operator>,</operator>
<name>VALUE</name> <name>block_args</name><operator>,</operator> <name>VALUE</name> <operator>*</operator><name>tok</name><operator>,</operator> <name>VALUE</name> <operator>*</operator><name>val</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>shift</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator>struct <name>cparse_params</name><operator>*</operator> <name>v</name><operator>,</operator> <name>long</name> <name>act</name><operator>,</operator> <name>VALUE</name> <name>tok</name><operator>,</operator> <name>VALUE</name> <name>val</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <name>reduce</name></type> <name>_</name><argument_list>(<argument><expr><operator>(</operator>struct <name>cparse_params</name><operator>*</operator> <name>v</name><operator>,</operator> <name>long</name> <name>act</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>rb_block_call_func</name></type> <name>reduce0</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D_puts</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (v-&gt;sys_debug) puts(msg)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D_printf</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>,<parameter><type><name>arg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (v-&gt;sys_debug) printf(fmt,arg)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D_puts</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D_printf</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>,<parameter><type><name>arg</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RUBY_UNTYPED_DATA_WARNING</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_UNTYPED_DATA_WARNING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>cparse_params_type</name> <init>= <expr><block>{
<expr><literal type="string">"racc/cparse"</literal></expr>,
<expr><block>{
<expr><name>cparse_params_mark</name></expr>,
<expr><name>RUBY_TYPED_DEFAULT_FREE</name></expr>,
<expr><name>cparse_params_memsize</name></expr>,
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>racc_cparse</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sysdebug</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>vparams</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vparams</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>CparseParams</name></expr></argument>, <argument><expr>struct <name>cparse_params</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>cparse_params_type</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"starting cparse"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>sys_debug</name></name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>sysdebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vparams</name> <operator>=</operator> <call><name>initialize_params</name><argument_list>(<argument><expr><name>vparams</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lex_is_iterator</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_main</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>vparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>v</name><operator>-&gt;</operator><name>retval</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>racc_yyparse</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>lexer</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>lexmid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sysdebug</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>vparams</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vparams</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>CparseParams</name></expr></argument>, <argument><expr>struct <name>cparse_params</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>cparse_params_type</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>sys_debug</name></name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>sysdebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"start C yyparse"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vparams</name> <operator>=</operator> <call><name>initialize_params</name><argument_list>(<argument><expr><name>vparams</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>lexer</name></expr></argument>, <argument><expr><name>lexmid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lex_is_iterator</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"params initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_main</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_lexer</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>fin</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"%s() is finished before EndOfToken"</literal></expr></argument>,
<argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lexmid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>vparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>v</name><operator>-&gt;</operator><name>retval</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RB_BLOCK_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>call_lexer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_block_call</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lexer</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>lexmid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lexer_i</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>value_v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>lexer_iter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cparse_params_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lexer</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>lexmid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>call_lexer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_iterate</name><argument_list>(<argument><expr><name>lexer_iter</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>value_v</name></name></expr></argument>, <argument><expr><name>lexer_i</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>value_v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>
<name>lexer_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cparse_params_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tok</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>fin</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"extra token after EndOfToken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>extract_user_token</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>block_args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_main</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>fin</name></name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>fin</name></name> <operator>!=</operator> <name>CP_FIN_ACCEPT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_iter_break</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>assert_array</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>assert_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>assert_integer</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>initialize_params</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>vparams</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>lexer</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>lexmid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>vparams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cparse_params_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>value_v</name></name> <operator>=</operator> <name>vparams</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lexer</name></name> <operator>=</operator> <name>lexer</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>lexmid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lexmid</name></name> <operator>=</operator> <call><name>value_to_id</name><argument_list>(<argument><expr><name>lexmid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>id_yydebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><literal type="number">13</literal> <operator>&lt;=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">14</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>RaccBug</name></expr></argument>, <argument><expr><literal type="string">"[Racc Bug] wrong arg.size %ld"</literal></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>action_table</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>action_check</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>action_default</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>action_pointer</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>goto_table</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>goto_check</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>goto_default</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>goto_pointer</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nt_base</name></name> <operator>=</operator> <call><name>assert_integer</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>reduce_table</name></name> <operator>=</operator> <call><name>assert_array</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>token_table</name></name> <operator>=</operator> <call><name>assert_hash</name> <argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>shift_n</name></name> <operator>=</operator> <call><name>assert_integer</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>reduce_n</name></name> <operator>=</operator> <call><name>assert_integer</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">13</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>use_result_var</name></name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>use_result_var</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name> <operator>=</operator> <ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr> ?</condition><then> <expr><call><name>NEW_STACK</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name> <operator>=</operator> <call><name>NEW_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <call><name>NEW_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>FINAL_TOKEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nerr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>id_errstatus</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>fin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lex_is_iterator</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_iv_set</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="string">"@vstack"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_iv_set</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="string">"@tstack"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_iv_set</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="string">"@tstack"</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>vparams</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cparse_params_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator>struct <name>cparse_params</name><operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>value_v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lexer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_check</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_pointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>goto_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>goto_check</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>goto_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>goto_pointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>reduce_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>token_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>cparse_params_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>cparse_params</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extract_user_token</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_args</name></decl></parameter>,
<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>tok</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>tok</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="string">"$"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,
<argument><expr><literal type="string">"%s() %s %"</literal><name>PRIsVALUE</name><literal type="string">" (must be Array[2])"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>lex_is_iterator</name></name></expr> ?</condition><then> <expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lexmid</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"next_token"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>lex_is_iterator</name></name></expr> ?</condition><then> <expr><literal type="string">"yielded"</literal></expr> </then><else>: <expr><literal type="string">"returned"</literal></expr></else></ternary></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>,
<argument><expr><literal type="string">"%s() %s wrong size of array (%ld for 2)"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>lex_is_iterator</name></name></expr> ?</condition><then> <expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lexmid</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"next_token"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>lex_is_iterator</name></name></expr> ?</condition><then> <expr><literal type="string">"yielded"</literal></expr> </then><else>: <expr><literal type="string">"returned"</literal></expr></else></ternary></expr></argument>,
<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>tok</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name>block_args</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHIFT</name><parameter_list>(<parameter><type><name>v</name></type></parameter>,<parameter><type><name>act</name></type></parameter>,<parameter><type><name>tok</name></type></parameter>,<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>shift(v,act,tok,val)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDUCE</name><parameter_list>(<parameter><type><name>v</name></type></parameter>,<parameter><type><name>act</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {switch (reduce(v,act)) { case 0: break; case 1: goto user_yyerror; case 2: D_puts("u accept"); goto accept; default: break; } } while (0)</cpp:value></cpp:define>













<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_main</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>resume</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>act</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VALUE</name></type> <name>act_value</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>read_next</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>resume</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>resume</name>;</goto></block_content></block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"---- enter new loop ----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(act) k1=%ld\n"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_pointer</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>notfound</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(act) pointer[k1] ok"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"read_next=%d\n"</literal></expr></argument>, <argument><expr><name>read_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>read_next</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>t</name></name> <operator>!=</operator> <name>vFINAL_TOKEN</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>lex_is_iterator</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"resuming..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>fin</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"token given after EOF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> 
<return>return;</return>
<label><name>resume</name>:</label>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"resumed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>i</name></name></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"next_token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_nexttoken</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>extract_user_token</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tok</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>token_table</name></name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>vERROR_TOKEN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(act) t(k2)=%ld\n"</literal></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_d_read_token</name></expr></argument>,
<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>read_next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(act) i=%ld\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>notfound</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>act_value</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_table</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>act_value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>notfound</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>act</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>act_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(act) table[i]=%ld\n"</literal></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_check</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>notfound</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>notfound</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(act) check[i]=%ld\n"</literal></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(act) found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>act_fixed</name>:</label>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"act=%ld\n"</literal></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>handle_act</name>;</goto>

<label><name>notfound</name>:</label>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(act) not found: use default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>act_value</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_default</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>act</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>act_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>act_fixed</name>;</goto>


<label><name>handle_act</name>:</label>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>act</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>shift_n</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"shift"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_errstatus</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SHIFT</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>act</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>read_next</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>act</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>act</name></expr></argument> &gt;</argument_list></name> <operator>-</operator><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>reduce_n</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"reduce"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REDUCE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>act</name> <operator>==</operator> <operator>-</operator><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>reduce_n</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>error</name>;</goto>
<label><name>error_recovered</name>:</label>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>act</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>shift_n</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"accept"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>accept</name>;</goto>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>RaccBug</name></expr></argument>, <argument><expr><literal type="string">"[Racc Bug] unknown act value %ld"</literal></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_d_next_state</name></expr></argument>,
<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>



<label><name>accept</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_d_accept</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>fin</name></name> <operator>=</operator> <name>CP_FIN_ACCEPT</name></expr>;</expr_stmt>
<return>return;</return>


<label><name>error</name>:</label>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"error detected, status=%ld\n"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nerr</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_onerror</name></expr></argument>,
<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<label><name>user_yyerror</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>vFINAL_TOKEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>fin</name></name> <operator>=</operator> <name>CP_FIN_EOT</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>read_next</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_errstatus</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(err) k1=%ld\n"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(err) k2=%d (error)\n"</literal></expr></argument>, <argument><expr><name>ERROR_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_pointer</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error_pop</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(err) pointer[k1] ok"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>ERROR_TOKEN</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(err) i=%ld\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error_pop</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>act_value</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_table</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>act_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(err) table[i] == nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error_pop</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>act</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>act_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(err) table[i]=%ld\n"</literal></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>action_check</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(err) check[i] == nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error_pop</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(err) check[i] != k1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error_pop</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(err) found: can handle error token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<label><name>error_pop</name>:</label>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(err) act not found: can't handle error token; pop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>fin</name></name> <operator>=</operator> <name>CP_FIN_CANTPOP</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>POP</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>POP</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name> <operator>=</operator> <call><name>num_to_long</name><argument_list>(<argument><expr><call><name>LAST_I</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>POP</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_d_e_pop</name></expr></argument>,
<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>act</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>act</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>shift_n</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"e shift"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SHIFT</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>act</name></expr></argument>, <argument><expr><name>ERROR_TOKEN</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>act</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>act</name></expr></argument> &gt;</argument_list></name> <operator>-</operator><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>reduce_n</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"e reduce"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REDUCE</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>act</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>shift_n</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"e accept"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>accept</name>;</goto>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>RaccBug</name></expr></argument>, <argument><expr><literal type="string">"[Racc Bug] unknown act value %ld"</literal></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>error_recovered</name>;</goto>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>shift</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>act</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_d_shift</name></expr></argument>,
<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name> <operator>=</operator> <name>act</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>reduce</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>act</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>code</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>ruleno</name></name> <operator>=</operator> <operator>-</operator><name>act</name> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rb_catch</name><argument_list>(<argument><expr><literal type="string">"racc_jump"</literal></expr></argument>, <argument><expr><name>reduce0</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>value_v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>errstatus</name></name> <operator>=</operator> <call><name>num_to_long</name><argument_list>(<argument><expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_errstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>
<name>reduce0</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>_</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cparse_params</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cparse_params_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>reduce_to</name></decl>, <decl><type ref="prev"/><name>reduce_len</name></decl>, <decl><type ref="prev"/><name>method_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>mid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>tmp_t</name> <init>= <expr><name>Qundef</name></expr></init></decl>, <decl><type ref="prev"/><name>tmp_v</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k1</name></decl>, <decl><type ref="prev"/><name>k2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>goto_state</name></decl>;</decl_stmt>

<expr_stmt><expr><name>reduce_len</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>reduce_table</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>ruleno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reduce_to</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>reduce_table</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>ruleno</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>method_id</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>reduce_table</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>ruleno</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>reduce_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mid</name> <operator>=</operator> <call><name>value_to_id</name><argument_list>(<argument><expr><name>method_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>!=</operator> <name>id_noreduce</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp_v</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp_t</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>!=</operator> <name>id_noreduce</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp_v</name> <operator>=</operator> <call><name>GET_TAIL</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>tmp_v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>CUT_TAIL</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp_t</name> <operator>=</operator> <call><name>GET_TAIL</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CUT_TAIL</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>CUT_TAIL</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>!=</operator> <name>id_noreduce</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>use_result_var</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>mid</name></expr></argument>,
<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>tmp_v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>mid</name></expr></argument>,
<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>tmp_v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>, <argument><expr><name>reduce_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>id_d_reduce</name></expr></argument>,
<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>tmp_t</name></expr></argument>, <argument><expr><name>reduce_to</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>tstack</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>RaccBug</name></expr></argument>, <argument><expr><literal type="string">"state stack unexpectedly empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>k2</name> <operator>=</operator> <call><name>num_to_long</name><argument_list>(<argument><expr><call><name>LAST_I</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>k1</name> <operator>=</operator> <call><name>num_to_long</name><argument_list>(<argument><expr><name>reduce_to</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>v</name><operator>-&gt;</operator><name>nt_base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(goto) k1=%ld\n"</literal></expr></argument>, <argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(goto) k2=%ld\n"</literal></expr></argument>, <argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>goto_pointer</name></name></expr></argument>, <argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>notfound</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>k2</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(goto) i=%ld\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>notfound</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>goto_state</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>goto_table</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>goto_state</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(goto) table[i] == nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>notfound</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(goto) table[i]=%ld (goto_state)\n"</literal></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>goto_state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>goto_check</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(goto) check[i] == nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>notfound</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <call><name>LONG2NUM</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(goto) check[i] != table[i]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>notfound</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>D_printf</name><argument_list>(<argument><expr><literal type="string">"(goto) check[i]=%ld\n"</literal></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(goto) found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>transit</name>:</label>
<expr_stmt><expr><call><name>PUSH</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>goto_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>curstate</name></name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>goto_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

<label><name>notfound</name>:</label>
<expr_stmt><expr><call><name>D_puts</name><argument_list>(<argument><expr><literal type="string">"(goto) not found: use default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>goto_state</name> <operator>=</operator> <call><name>AREF</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>goto_default</name></name></expr></argument>, <argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>transit</name>;</goto>
</block_content>}</block></decl></decl_stmt>





<function><type><name>void</name></type>
<name>Init_cparse</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_intern</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_intern_const(str)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>VALUE</name></type> <name>Racc</name></decl>, <decl><type ref="prev"/><name>Parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id_racc</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"Racc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_const_defined</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>id_racc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Racc</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>id_racc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Parser</name> <operator>=</operator> <call><name>rb_const_get_at</name><argument_list>(<argument><expr><name>Racc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"Parser"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>Racc</name> <operator>=</operator> <call><name>rb_define_module</name><argument_list>(<argument><expr><literal type="string">"Racc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Parser</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>Racc</name></expr></argument>, <argument><expr><literal type="string">"Parser"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_define_private_method</name><argument_list>(<argument><expr><name>Parser</name></expr></argument>, <argument><expr><literal type="string">"_racc_do_parse_c"</literal></expr></argument>, <argument><expr><name>racc_cparse</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_private_method</name><argument_list>(<argument><expr><name>Parser</name></expr></argument>, <argument><expr><literal type="string">"_racc_yyparse_c"</literal></expr></argument>, <argument><expr><name>racc_yyparse</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>Parser</name></expr></argument>, <argument><expr><literal type="string">"Racc_Runtime_Core_Version_C"</literal></expr></argument>,
<argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name>RACC_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>Parser</name></expr></argument>, <argument><expr><literal type="string">"Racc_Runtime_Core_Id_C"</literal></expr></argument>,
<argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"$originalId: cparse.c,v 1.8 2006/07/06 11:39:46 aamine Exp $"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>CparseParams</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>Racc</name></expr></argument>, <argument><expr><literal type="string">"CparseParams"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>CparseParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><name>CparseParams</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><name>CparseParams</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>RaccBug</name> <operator>=</operator> <name>rb_eRuntimeError</name></expr>;</expr_stmt>

<expr_stmt><expr><name>id_yydebug</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"@yydebug"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_nexttoken</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"next_token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_onerror</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"on_error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_noreduce</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_reduce_none"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_errstatus</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"@racc_error_status"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_d_shift</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"racc_shift"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_d_reduce</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"racc_reduce"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_d_accept</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"racc_accept"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_d_read_token</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"racc_read_token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_d_next_state</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"racc_next_state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_d_e_pop</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"racc_e_pop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
