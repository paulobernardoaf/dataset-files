<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\st.c">





































































































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NOT_RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"st.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/bits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/sanitizers.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFETCH</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>write_p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_prefetch(addr, write_p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_expect(expr, val)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTRIBUTE_UNUSED</name></cpp:macro> <cpp:value>__attribute__((unused))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFETCH</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>write_p</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(expr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTRIBUTE_UNUSED</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<typedef>typedef <type><name>st_index_t</name></type> <name>st_hash_t</name>;</typedef>

<struct>struct <name>st_table_entry</name> <block>{
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>record</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>type_numhash</name></cpp:macro> <cpp:value>st_hashtype_num</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>st_hashtype_num</name> <init>= <expr><block>{
<expr><name>st_numcmp</name></expr>,
<expr><name>st_numhash</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>st_strcmp</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>st_index_t</name></type> <name>strhash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>type_strhash</name> <init>= <expr><block>{
<expr><name>st_strcmp</name></expr>,
<expr><name>strhash</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>st_locale_insensitive_strcasecmp_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>rhs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>st_index_t</name></type> <name>strcasehash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>type_strcasehash</name> <init>= <expr><block>{
<expr><name>st_locale_insensitive_strcasecmp_i</name></expr>,
<expr><name>strcasehash</name></expr>,
}</block></expr></init></decl>;</decl_stmt>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_INIT_VAL</name></cpp:macro> <cpp:value>0xafafafafafafafaf</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_INIT_VAL_BYTE</name></cpp:macro> <cpp:value>0xafa</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>malloc</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>realloc</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>calloc</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>free</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc</name></cpp:macro> <cpp:value>ruby_xmalloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>calloc</name></cpp:macro> <cpp:value>ruby_xcalloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>realloc</name></cpp:macro> <cpp:value>ruby_xrealloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>free</name></cpp:macro> <cpp:value>ruby_xfree</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EQUAL</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>,<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == (y) || (*(tab)-&gt;type-&gt;compare)((x),(y)) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR_EQUAL</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>hash_val</name></type></parameter>, <parameter><type><name>key_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ptr)-&gt;hash == (hash_val) &amp;&amp; EQUAL((tab), (key_), (ptr)-&gt;key))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_PTR_EQUAL_CHECK</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>hash_val</name></type></parameter>, <parameter><type><name>key</name></type></parameter>, <parameter><type><name>res</name></type></parameter>, <parameter><type><name>rebuilt_p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned int _old_rebuilds_num = (tab)-&gt;rebuilds_num; res = PTR_EQUAL(tab, ptr, hash_val, key); rebuilt_p = _old_rebuilds_num != (tab)-&gt;rebuilds_num; } while (FALSE)</cpp:value></cpp:define>







<struct>struct <name>st_features</name> <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>entry_power</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>bin_power</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>size_ind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>st_index_t</name></type> <name>bins_words</name></decl>;</decl_stmt>
}</block>;</struct>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_ST_INDEX_T</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_POWER2</name></cpp:macro> <cpp:value>62</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_features</name></name></type> <name><name>features</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x0</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x1</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x1</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x2</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x4</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x8</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x10</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x20</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x80</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x100</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x200</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x400</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x800</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x1000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x2000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">15</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x4000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x10000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x20000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">18</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x40000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x80000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x100000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x200000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x400000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">23</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x800000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">24</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x1000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">25</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x2000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x4000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x8000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">28</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x10000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x20000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x40000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x80000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">32</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x200000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">33</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x400000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">34</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x800000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">35</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x1000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">36</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x2000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">37</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x4000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">38</literal></expr>, <expr><literal type="number">39</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x8000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">39</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x10000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">40</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x20000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x40000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">42</literal></expr>, <expr><literal type="number">43</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x80000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">43</literal></expr>, <expr><literal type="number">44</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x100000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">44</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x200000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">45</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x400000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">46</literal></expr>, <expr><literal type="number">47</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x800000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">47</literal></expr>, <expr><literal type="number">48</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x1000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">48</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x2000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">49</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x4000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">50</literal></expr>, <expr><literal type="number">51</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x8000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">51</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x10000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">52</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x20000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">53</literal></expr>, <expr><literal type="number">54</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x40000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">54</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x80000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">55</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x100000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">56</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x200000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">57</literal></expr>, <expr><literal type="number">58</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x400000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">58</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x800000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">59</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x1000000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">60</literal></expr>, <expr><literal type="number">61</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x2000000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">61</literal></expr>, <expr><literal type="number">62</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x4000000000000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">62</literal></expr>, <expr><literal type="number">63</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0x8000000000000000</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_POWER2</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_features</name></name></type> <name><name>features</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x1</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x1</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x2</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x4</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x8</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x10</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x20</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0x40</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x100</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x200</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x400</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x800</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x1000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x2000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x4000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">15</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0x8000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x20000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x40000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">18</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x80000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x100000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x200000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x400000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x800000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">23</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x1000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">24</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x2000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">25</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x4000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x8000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x10000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">28</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x20000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x40000000</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0x80000000</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESERVED_HASH_VAL</name></cpp:macro> <cpp:value>(~(st_hash_t) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESERVED_HASH_SUBSTITUTION_VAL</name></cpp:macro> <cpp:value>((st_hash_t) 0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>st_hash_t</name></type> <name>st_reserved_hash_val</name> <init>= <expr><name>RESERVED_HASH_VAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>st_hash_t</name></type> <name>st_reserved_hash_substitution_val</name> <init>= <expr><name>RESERVED_HASH_SUBSTITUTION_VAL</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_hash_t</name></type>
<name>do_hash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash</name> <init>= <expr><operator>(</operator><name>st_hash_t</name><operator>)</operator><operator>(</operator><name><name>tab</name><operator>-&gt;</operator><name>type</name><operator>-&gt;</operator><name>hash</name></name><operator>)</operator><operator>(</operator><name>key</name><operator>)</operator></expr></init></decl>;</decl_stmt>



<return>return <expr><ternary><condition><expr><name>hash</name> <operator>==</operator> <name>RESERVED_HASH_VAL</name></expr> ?</condition><then> <expr><name>RESERVED_HASH_SUBSTITUTION_VAL</name></expr> </then><else>: <expr><name>hash</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIMAL_POWER2</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MINIMAL_POWER2</name> <operator>&lt;</operator> <literal type="number">2</literal></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"MINIMAL_POWER2 should be &gt;= 2"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_POWER2_FOR_TABLES_WITHOUT_BINS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_power2</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name> <init>= <expr><name>ST_INDEX_BITS</name> <operator>-</operator> <call><name>nlz_intptr</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <name>MAX_POWER2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>n</name> <operator>&lt;</operator> <name>MINIMAL_POWER2</name></expr> ?</condition><then> <expr><name>MINIMAL_POWER2</name></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NOT_RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"st_table too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>get_bin</name><parameter_list>(<parameter><decl><type><name>st_index_t</name> <modifier>*</modifier></type><name>bins</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>bins</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index></expr>
</then><else>: <expr><ternary><condition><expr><name>s</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>short</name> <operator>*</operator><operator>)</operator> <name>bins</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index></expr>
</then><else>: <expr><ternary><condition><expr><name>s</name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <name>bins</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index></expr>
</then><else>: <expr><operator>(</operator><operator>(</operator><name>st_index_t</name> <operator>*</operator><operator>)</operator> <name>bins</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index></expr></else></ternary></expr></else></ternary></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>set_bin</name><parameter_list>(<parameter><decl><type><name>st_index_t</name> <modifier>*</modifier></type><name>bins</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>bins</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>short</name> <operator>*</operator><operator>)</operator> <name>bins</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <name>bins</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>st_index_t</name> <operator>*</operator><operator>)</operator> <name>bins</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY_BIN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELETED_BIN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTRY_BASE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_BIN_EMPTY</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(set_bin((tab)-&gt;bins, get_size_ind(tab), i, EMPTY_BIN))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDEFINED_ENTRY_IND</name></cpp:macro> <cpp:value>(~(st_index_t) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDEFINED_BIN_IND</name></cpp:macro> <cpp:value>(~(st_index_t) 0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REBUILT_TABLE_ENTRY_IND</name></cpp:macro> <cpp:value>(~(st_index_t) 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REBUILT_TABLE_BIN_IND</name></cpp:macro> <cpp:value>(~(st_index_t) 1)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_BIN_DELETED</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { set_bin((tab)-&gt;bins, get_size_ind(tab), i, DELETED_BIN); } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY_BIN_P</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((b) == EMPTY_BIN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELETED_BIN_P</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((b) == DELETED_BIN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY_OR_DELETED_BIN_P</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((b) &lt;= DELETED_BIN)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IND_EMPTY_BIN_P</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(EMPTY_BIN_P(get_bin((tab)-&gt;bins, get_size_ind(tab), i)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IND_DELETED_BIN_P</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(DELETED_BIN_P(get_bin((tab)-&gt;bins, get_size_ind(tab), i)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IND_EMPTY_OR_DELETED_BIN_P</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(EMPTY_OR_DELETED_BIN_P(get_bin((tab)-&gt;bins, get_size_ind(tab), i)))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_ENTRY_DELETED</name><parameter_list>(<parameter><type><name>e_ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((e_ptr)-&gt;hash = RESERVED_HASH_VAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELETED_ENTRY_P</name><parameter_list>(<parameter><type><name>e_ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((e_ptr)-&gt;hash == RESERVED_HASH_VAL)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type>
<name>get_size_ind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>tab</name><operator>-&gt;</operator><name>size_ind</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>get_bins_num</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>st_index_t</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name><name>tab</name><operator>-&gt;</operator><name>bin_power</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>bins_mask</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>get_bins_num</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>hash_bin</name><parameter_list>(<parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>hash_value</name> <operator>&amp;</operator> <call><name>bins_mask</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>get_allocated_entries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>st_index_t</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name><name>tab</name><operator>-&gt;</operator><name>entry_power</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>bins_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>features</name><index>[<expr><name><name>tab</name><operator>-&gt;</operator><name>entry_power</name></name></expr>]</index></name><operator>.</operator><name>bins_words</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_bins</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>bins_size</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_tab_empty</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>initialize_bins</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_LOG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>all</name></decl>, <decl><type ref="prev"/><name>total</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"/><name>str</name></decl>, <decl><type ref="prev"/><name>strcase</name></decl>;</decl_stmt>
}</block> <decl><name>collision</name></decl>;</struct>



<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>init_st</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>stat_col</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>fname</name><index>[<expr><literal type="number">10</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>collision</name><operator>.</operator><name>total</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><operator>(</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"/tmp/col%ld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator> <name>fname</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"collision: %d / %d (%6.2f)\n"</literal></expr></argument>, <argument><expr><name><name>collision</name><operator>.</operator><name>all</name></name></expr></argument>, <argument><expr><name><name>collision</name><operator>.</operator><name>total</name></name></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>collision</name><operator>.</operator><name>all</name></name> <operator>/</operator> <operator>(</operator><name><name>collision</name><operator>.</operator><name>total</name></name><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"num: %d, str: %d, strcase: %d\n"</literal></expr></argument>, <argument><expr><name><name>collision</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>collision</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>collision</name><operator>.</operator><name>strcase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_init_table_with_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_LOG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HASH_LOG</name><operator>+</operator><literal type="number">0</literal> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"ST_HASH_LOG"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>e</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>init_st</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>init_st</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>init_st</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>stat_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_power2</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>st_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entry_power</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bin_power</name></name> <operator>=</operator> <name><name>features</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>bin_power</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>size_ind</name></name> <operator>=</operator> <name><name>features</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>size_ind</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <name>MAX_POWER2_FOR_TABLES_WITHOUT_BINS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>=</operator> <operator>(</operator><name>st_index_t</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>bins_size</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <operator>(</operator><name>st_table_entry</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call>
<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_table_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>make_tab_empty</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rebuilds_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>tab</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_init_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table_with_size</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_init_numtable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_numhash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_init_numtable_with_size</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_numhash</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_init_strtable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_strhash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_init_strtable_with_size</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_strhash</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_init_strcasetable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_strcasehash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_init_strcasetable_with_size</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_strcasehash</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>st_clear</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>make_tab_empty</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rebuilds_num</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>st_free_table</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>size_t</name></type>
<name>st_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return<expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>st_table</name></expr></argument>)</argument_list></sizeof>
<operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>bins_size</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator>
<operator>+</operator> <call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_table_entry</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>find_table_entry_ind</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>find_table_bin_ind</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>find_table_bin_ind_direct</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>find_table_bin_ptr_and_reserve</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name> <modifier>*</modifier></type><name>hash_value</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name> <modifier>*</modifier></type><name>bin_ind</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_LOG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>count_collision</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>collision</name><operator>.</operator><name>all</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <operator>&amp;</operator><name>type_numhash</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>collision</name><operator>.</operator><name>num</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <operator>&amp;</operator><name>type_strhash</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>collision</name><operator>.</operator><name>strcase</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <operator>&amp;</operator><name>type_strcasehash</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>collision</name><operator>.</operator><name>str</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLISION</name></cpp:macro> <cpp:value>(collision_check ? count_collision(tab-&gt;type) : (void)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUND_BIN</name></cpp:macro> <cpp:value>(collision_check ? collision.total++ : (void)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>collision_check</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLISION</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUND_BIN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REBUILD_THRESHOLD</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>REBUILD_THRESHOLD</name> <operator>&lt;</operator> <literal type="number">2</literal></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"REBUILD_THRESHOLD should be &gt;= 2"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>rebuild_table</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ni</name></decl>, <decl><type ref="prev"/><name>bound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>new_tab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entries</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>curr_entry_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name> <modifier>*</modifier></type><name>bins</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin_ind</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bound</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&lt;=</operator> <call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>REBUILD_THRESHOLD</name> <operator>*</operator> <name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;</operator> <call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>MINIMAL_POWER2</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>initialize_bins</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <name>tab</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_entries</name> <operator>=</operator> <name>entries</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <call><name>st_init_table_with_size</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
<argument><expr><literal type="number">2</literal> <operator>*</operator> <name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_entries</name> <operator>=</operator> <name><name>new_tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ni</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bins</name> <operator>=</operator> <name><name>new_tab</name><operator>-&gt;</operator><name>bins</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>size_ind</name> <operator>=</operator> <call><name>get_size_ind</name><argument_list>(<argument><expr><name>new_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PREFETCH</name><argument_list>(<argument><expr><name>entries</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><call><name>DELETED_ENTRY_P</name><argument_list>(<argument><expr><name>curr_entry_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>&amp;</operator><name><name>new_entries</name><index>[<expr><name>ni</name></expr>]</index></name> <operator>!=</operator> <name>curr_entry_ptr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>new_entries</name><index>[<expr><name>ni</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>curr_entry_ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bins</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <call><name>find_table_bin_ind_direct</name><argument_list>(<argument><expr><name>new_tab</name></expr></argument>, <argument><expr><name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>,
<argument><expr><name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_bin</name><argument_list>(<argument><expr><name>bins</name></expr></argument>, <argument><expr><name>size_ind</name></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>, <argument><expr><name>ni</name> <operator>+</operator> <name>ENTRY_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>new_tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ni</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>new_tab</name> <operator>!=</operator> <name>tab</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entry_power</name></name> <operator>=</operator> <name><name>new_tab</name><operator>-&gt;</operator><name>entry_power</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bin_power</name></name> <operator>=</operator> <name><name>new_tab</name><operator>-&gt;</operator><name>bin_power</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>size_ind</name></name> <operator>=</operator> <name><name>new_tab</name><operator>-&gt;</operator><name>size_ind</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>=</operator> <name><name>new_tab</name><operator>-&gt;</operator><name>bins</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name><name>new_tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rebuilds_num</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>secondary_hash</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>ind</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name> <modifier>*</modifier></type><name>perterb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>perterb</name> <operator>&gt;&gt;=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <operator>(</operator><name>ind</name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>ind</name> <operator>+</operator> <operator>*</operator><name>perterb</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><call><name>hash_bin</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>find_entry</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>eq_p</name></decl>, <decl><type ref="prev"/><name>rebuilt_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bound</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>DO_PTR_EQUAL_CHECK</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>eq_p</name></expr></argument>, <argument><expr><name>rebuilt_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>rebuilt_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>REBUILT_TABLE_ENTRY_IND</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eq_p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>UNDEFINED_ENTRY_IND</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>find_table_entry_ind</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>eq_p</name></decl>, <decl><type ref="prev"/><name>rebuilt_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>ind</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>d</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>peterb</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>peterb</name> <operator>=</operator> <name>hash_value</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>FOUND_BIN</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>get_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>EMPTY_OR_DELETED_BIN_P</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DO_PTR_EQUAL_CHECK</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entries</name><index>[<expr><name>bin</name> <operator>-</operator> <name>ENTRY_BASE</name></expr>]</index></name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>eq_p</name></expr></argument>, <argument><expr><name>rebuilt_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>rebuilt_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>REBUILT_TABLE_ENTRY_IND</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eq_p</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>EMPTY_BIN_P</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>UNDEFINED_ENTRY_IND</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>ind</name> <operator>+</operator> <name>d</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>secondary_hash</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peterb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>COLLISION</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>bin</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>find_table_bin_ind</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>eq_p</name></decl>, <decl><type ref="prev"/><name>rebuilt_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>ind</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>d</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>peterb</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>peterb</name> <operator>=</operator> <name>hash_value</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>FOUND_BIN</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>get_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>EMPTY_OR_DELETED_BIN_P</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DO_PTR_EQUAL_CHECK</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entries</name><index>[<expr><name>bin</name> <operator>-</operator> <name>ENTRY_BASE</name></expr>]</index></name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>eq_p</name></expr></argument>, <argument><expr><name>rebuilt_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>rebuilt_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>REBUILT_TABLE_BIN_IND</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eq_p</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>EMPTY_BIN_P</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>UNDEFINED_BIN_IND</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>ind</name> <operator>+</operator> <name>d</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>secondary_hash</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peterb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>COLLISION</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ind</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>find_table_bin_ind_direct</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>ind</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>d</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>peterb</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>peterb</name> <operator>=</operator> <name>hash_value</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>FOUND_BIN</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>get_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EMPTY_OR_DELETED_BIN_P</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ind</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>ind</name> <operator>+</operator> <name>d</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>secondary_hash</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peterb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>COLLISION</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>find_table_bin_ptr_and_reserve</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name> <modifier>*</modifier></type><name>hash_value</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name> <modifier>*</modifier></type><name>bin_ind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>eq_p</name></decl>, <decl><type ref="prev"/><name>rebuilt_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>curr_hash_value</name> <init>= <expr><operator>*</operator><name>hash_value</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>d</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>peterb</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>entry_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>first_deleted_bin_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>curr_hash_value</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>peterb</name> <operator>=</operator> <name>curr_hash_value</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>FOUND_BIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>first_deleted_bin_ind</name> <operator>=</operator> <name>UNDEFINED_BIN_IND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>entry_index</name> <operator>=</operator> <call><name>get_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EMPTY_BIN_P</name><argument_list>(<argument><expr><name>entry_index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>entry_index</name> <operator>=</operator> <name>UNDEFINED_ENTRY_IND</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>first_deleted_bin_ind</name> <operator>!=</operator> <name>UNDEFINED_BIN_IND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ind</name> <operator>=</operator> <name>first_deleted_bin_ind</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MARK_BIN_EMPTY</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <call><name>DELETED_BIN_P</name><argument_list>(<argument><expr><name>entry_index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DO_PTR_EQUAL_CHECK</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entries</name><index>[<expr><name>entry_index</name> <operator>-</operator> <name>ENTRY_BASE</name></expr>]</index></name></expr></argument>, <argument><expr><name>curr_hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>eq_p</name></expr></argument>, <argument><expr><name>rebuilt_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>rebuilt_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>REBUILT_TABLE_ENTRY_IND</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eq_p</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>first_deleted_bin_ind</name> <operator>==</operator> <name>UNDEFINED_BIN_IND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_deleted_bin_ind</name> <operator>=</operator> <name>ind</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>ind</name> <operator>+</operator> <name>d</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>secondary_hash</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peterb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>COLLISION</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>bin_ind</name> <operator>=</operator> <name>ind</name></expr>;</expr_stmt>
<return>return <expr><name>entry_index</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>int</name></type>
<name>st_lookup</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash</name> <init>= <expr><call><name>do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<label><name>retry</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_table_entry_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bin</name> <operator>-=</operator> <name>ENTRY_BASE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name><operator>.</operator><name>record</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<function><type><name>int</name></type>
<name>st_get_key</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash</name> <init>= <expr><call><name>do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<label><name>retry</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_table_entry_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bin</name> <operator>-=</operator> <name>ENTRY_BASE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name><operator>.</operator><name>key</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>rebuild_table_if_necessary</name> <parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bound</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bound</name> <operator>==</operator> <call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rebuild_table</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>st_insert</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash_value</name> <operator>=</operator> <call><name>do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>retry</name>:</label>
<expr_stmt><expr><call><name>rebuild_table_if_necessary</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>new_p</name> <operator>=</operator> <name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <name>UNDEFINED_BIN_IND</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_table_bin_ptr_and_reserve</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_value</name></expr></argument>,
<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bin_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>new_p</name> <operator>=</operator> <name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bin</name> <operator>-=</operator> <name>ENTRY_BASE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>new_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>ind</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>hash_value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bin_ind</name> <operator>!=</operator> <name>UNDEFINED_BIN_IND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>, <argument><expr><name>ind</name> <operator>+</operator> <name>ENTRY_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name><operator>.</operator><name>record</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>st_add_direct_with_hash</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin_ind</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rebuild_table_if_necessary</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>ind</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <call><name>find_table_bin_ind_direct</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>, <argument><expr><name>ind</name> <operator>+</operator> <name>ENTRY_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type>
<name>st_add_direct</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash_value</name> <operator>=</operator> <call><name>do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_add_direct_with_hash</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>st_insert2</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>,
<parameter><function_decl><type><name>st_data_t</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>st_data_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash_value</name> <operator>=</operator> <call><name>do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>retry</name>:</label>
<expr_stmt><expr><call><name>rebuild_table_if_necessary</name> <argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>new_p</name> <operator>=</operator> <name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <name>UNDEFINED_BIN_IND</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_table_bin_ptr_and_reserve</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_value</name></expr></argument>,
<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bin_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>new_p</name> <operator>=</operator> <name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bin</name> <operator>-=</operator> <name>ENTRY_BASE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>new_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>ind</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>hash_value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bin_ind</name> <operator>!=</operator> <name>UNDEFINED_BIN_IND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>, <argument><expr><name>ind</name> <operator>+</operator> <name>ENTRY_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name><operator>.</operator><name>record</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>st_copy</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>old_tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>new_tab</name></decl>;</decl_stmt>

<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>st_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>new_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>*</operator><name>new_tab</name> <operator>=</operator> <operator>*</operator><name>old_tab</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>old_tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>new_tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>new_tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>=</operator> <operator>(</operator><name>st_index_t</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>bins_size</name><argument_list>(<argument><expr><name>old_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>new_tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>new_tab</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <operator>(</operator><name>st_table_entry</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>old_tab</name></expr></argument>)</argument_list></call>
<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_table_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>new_tab</name><operator>-&gt;</operator><name>entries</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>new_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name><name>new_tab</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>old_tab</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name>st_table_entry</name></expr></argument>,
<argument><expr><call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>old_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>old_tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name><name>new_tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><name><name>old_tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>bins_size</name><argument_list>(<argument><expr><name>old_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>new_tab</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>update_range_for_deleted</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name> <operator>==</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name> <operator>=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>st_general_delete</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>do_hash</name><argument_list>(<argument><expr><operator>*</operator><name>key</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>retry</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <call><name>find_table_bin_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin_ind</name> <operator>==</operator> <name>REBUILT_TABLE_BIN_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bin_ind</name> <operator>==</operator> <name>UNDEFINED_BIN_IND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>get_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>ENTRY_BASE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MARK_BIN_DELETED</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>key</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>record</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>MARK_ENTRY_DELETED</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_range_for_deleted</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>st_delete</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_general_delete</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type>
<name>st_delete_safe</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name> <name>never</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_general_delete</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>st_shift</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entries</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>curr_entry_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin_ind</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bound</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>DELETED_ENTRY_P</name><argument_list>(<argument><expr><name>curr_entry_ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>entry_hash</name> <init>= <expr><name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>hash</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>entry_key</name> <init>= <expr><name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>key</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>record</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>key</name> <operator>=</operator> <name>entry_key</name></expr>;</expr_stmt>
<label><name>retry</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>entry_hash</name></expr></argument>, <argument><expr><name>entry_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<goto>goto <name>retry</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <call><name>find_table_bin_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>entry_hash</name></expr></argument>, <argument><expr><name>entry_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin_ind</name> <operator>==</operator> <name>REBUILT_TABLE_BIN_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<goto>goto <name>retry</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><call><name>get_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>)</argument_list></call>
<operator>-</operator> <name>ENTRY_BASE</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MARK_BIN_DELETED</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>MARK_ENTRY_DELETED</name><argument_list>(<argument><expr><name>curr_entry_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_range_for_deleted</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>st_cleanup_safe</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier><name>tab</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name> <name>never</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>









<function><type><name>int</name></type>
<name>st_update</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>,
<parameter><decl><type><name>st_update_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>old_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>, <decl><type ref="prev"/><name>existing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash</name> <init>= <expr><call><name>do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<label><name>retry</name>:</label>
<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>existing</name> <operator>=</operator> <name>bin</name> <operator>!=</operator> <name>UNDEFINED_ENTRY_IND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <name>UNDEFINED_BIN_IND</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <call><name>find_table_bin_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin_ind</name> <operator>==</operator> <name>REBUILT_TABLE_BIN_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>existing</name> <operator>=</operator> <name>bin_ind</name> <operator>!=</operator> <name>UNDEFINED_BIN_IND</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>get_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>ENTRY_BASE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>record</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>old_key</name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ST_CONTINUE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_add_direct_with_hash</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>old_key</name> <operator>!=</operator> <name>key</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ST_DELETE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bin_ind</name> <operator>!=</operator> <name>UNDEFINED_BIN_IND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MARK_BIN_DELETED</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>MARK_ENTRY_DELETED</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_range_for_deleted</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>existing</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>st_general_foreach</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_foreach_check_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_update_callback_func</name> <modifier>*</modifier></type><name>replace</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>check_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>entries</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>curr_entry_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>st_retval</name></name></type> <name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rebuilds_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error_p</name></decl>, <decl><type ref="prev"/><name>packed_p</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><call><name>DELETED_ENTRY_P</name><argument_list>(<argument><expr><name>curr_entry_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>rebuilds_num</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>rebuilds_num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>hash</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>record</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>ST_REPLACE</name> <operator>&amp;&amp;</operator> <name>replace</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>record</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>replace</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rebuilds_num</name> <operator>!=</operator> <name><name>tab</name><operator>-&gt;</operator><name>rebuilds_num</name></name></expr>)</condition> <block>{<block_content>
<label><name>retry</name>:</label>
<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>packed_p</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>packed_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>error_p</name> <operator>=</operator> <name>i</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>find_table_entry_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>error_p</name> <operator>=</operator> <name>i</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>-=</operator> <name>ENTRY_BASE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>error_p</name> <operator>&amp;&amp;</operator> <name>check_p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ST_REPLACE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ST_CONTINUE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ST_CHECK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>check_p</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<case>case <expr><name>ST_STOP</name></expr>:</case>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><name>ST_DELETE</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name> <init>= <expr><name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>key</name></name></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>
<if_stmt><if>if <condition>(<expr><name>packed_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>find_entry</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin</name> <operator>==</operator> <name>REBUILT_TABLE_ENTRY_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>again</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>UNDEFINED_ENTRY_IND</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>bin_ind</name> <operator>=</operator> <call><name>find_table_bin_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>bin_ind</name> <operator>==</operator> <name>REBUILT_TABLE_BIN_IND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>again</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bin_ind</name> <operator>==</operator> <name>UNDEFINED_BIN_IND</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>get_bin</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>ENTRY_BASE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MARK_BIN_DELETED</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bin_ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MARK_ENTRY_DELETED</name><argument_list>(<argument><expr><name>curr_entry_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_range_for_deleted</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>st_foreach_with_replace</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_foreach_check_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_update_callback_func</name> <modifier>*</modifier></type><name>replace</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_general_foreach</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>functor</name> <block>{
<decl_stmt><decl><type><name>st_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>apply_functor</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>functor</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>d</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>st_foreach</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>functor</name></name></type> <name>f</name> <init>= <expr><block>{ <expr><name>func</name></expr>, <expr><name>arg</name></expr> }</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>st_general_foreach</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>apply_functor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>st_foreach_check</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_foreach_check_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name> <name>never</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_general_foreach</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>st_general_keys</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>curr_entry_ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>entries</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bound</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>keys_start</name> <operator>=</operator> <name>keys</name></expr>;</expr_stmt>
<expr_stmt><expr><name>keys_end</name> <operator>=</operator> <name>keys</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>keys</name> <operator>==</operator> <name>keys_end</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>DELETED_ENTRY_P</name><argument_list>(<argument><expr><name>curr_entry_ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>keys</name><operator>++</operator> <operator>=</operator> <name>key</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>keys</name> <operator>-</operator> <name>keys_start</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>st_index_t</name></type>
<name>st_keys</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_general_keys</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>st_index_t</name></type>
<name>st_keys_check</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name> <name>never</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_general_keys</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>st_general_values</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>values_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>values_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>curr_entry_ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>entries</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>values_start</name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
<expr_stmt><expr><name>values_end</name> <operator>=</operator> <name>values</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bound</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>values</name> <operator>==</operator> <name>values_end</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>curr_entry_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>DELETED_ENTRY_P</name><argument_list>(<argument><expr><name>curr_entry_ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>values</name><operator>++</operator> <operator>=</operator> <name><name>curr_entry_ptr</name><operator>-&gt;</operator><name>record</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>values</name> <operator>-</operator> <name>values_start</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>st_index_t</name></type>
<name>st_values</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_general_values</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>st_index_t</name></type>
<name>st_values_check</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name> <name>never</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_general_values</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNV1_32A_INIT</name></cpp:macro> <cpp:value>0x811c9dc5</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNV_32_PRIME</name></cpp:macro> <cpp:value>0x01000193</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_WORD_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_AMD64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__powerpc64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__mc68020__</name></expr></argument>)</argument_list></call></expr></cpp:if>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_WORD_ACCESS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_WORD_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_WORD_ACCESS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG_CONSTANT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((st_index_t)(x)&lt;&lt;32|(st_index_t)(y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROTL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)&lt;&lt;(n)|(x)&gt;&gt;(SIZEOF_ST_INDEX_T*CHAR_BIT-(n)))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ST_INDEX_BITS</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C1</name></cpp:macro> <cpp:value>(st_index_t)0xcc9e2d51</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C2</name></cpp:macro> <cpp:value>(st_index_t)0x1b873593</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C1</name></cpp:macro> <cpp:value>BIG_CONSTANT(0x87c37b91,0x114253d5);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C2</name></cpp:macro> <cpp:value>BIG_CONSTANT(0x4cf5ad43,0x2745937f);</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>NO_SANITIZE</name><argument_list>(<argument><literal type="string">"unsigned-integer-overflow"</literal></argument>, <argument>static inline st_index_t murmur_step(st_index_t h, st_index_t k)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>NO_SANITIZE</name><argument_list>(<argument><literal type="string">"unsigned-integer-overflow"</literal></argument>, <argument>static inline st_index_t murmur_finish(st_index_t h)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>NO_SANITIZE</name><argument_list>(<argument><literal type="string">"unsigned-integer-overflow"</literal></argument>, <argument>extern st_index_t st_hash(const void *ptr, size_t len, st_index_t h)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>murmur_step</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ST_INDEX_BITS</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r1</name></cpp:macro> <cpp:value>(17)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r2</name></cpp:macro> <cpp:value>(11)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r1</name></cpp:macro> <cpp:value>(33)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r2</name></cpp:macro> <cpp:value>(24)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>k</name> <operator>*=</operator> <name>C1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <call><name>ROTL</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>C2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>ROTL</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>r1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>r2</name></cpp:undef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_index_t</name></type>
<name>murmur_finish</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ST_INDEX_BITS</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r1</name></cpp:macro> <cpp:value>(16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r2</name></cpp:macro> <cpp:value>(13)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r3</name></cpp:macro> <cpp:value>(16)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>const</specifier> <name>st_index_t</name></type> <name>c1</name> <init>= <expr><literal type="number">0x85ebca6b</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>st_index_t</name></type> <name>c2</name> <init>= <expr><literal type="number">0xc2b2ae35</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r1</name></cpp:macro> <cpp:value>(30)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r2</name></cpp:macro> <cpp:value>(27)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r3</name></cpp:macro> <cpp:value>(31)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>const</specifier> <name>st_index_t</name></type> <name>c1</name> <init>= <expr><call><name>BIG_CONSTANT</name><argument_list>(<argument><expr><literal type="number">0xbf58476d</literal></expr></argument>,<argument><expr><literal type="number">0x1ce4e5b9</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>st_index_t</name></type> <name>c2</name> <init>= <expr><call><name>BIG_CONSTANT</name><argument_list>(<argument><expr><literal type="number">0x94d049bb</literal></expr></argument>,<argument><expr><literal type="number">0x133111eb</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ST_INDEX_BITS</name> <operator>&gt;</operator> <literal type="number">64</literal></expr></cpp:if>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>c2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <literal type="number">65</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>c1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>c2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r3</name></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>r1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>r2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>r3</name></cpp:undef>

<function><type><name>st_index_t</name></type>
<name>st_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>data_at</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(st_index_t)((unsigned char)data[(n)])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD_4</name></cpp:macro> <cpp:value>UNALIGNED_ADD(2); UNALIGNED_ADD(1); UNALIGNED_ADD(0)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_ST_INDEX_T</name> <operator>&gt;</operator> <literal type="number">4</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD_8</name></cpp:macro> <cpp:value>UNALIGNED_ADD(6); UNALIGNED_ADD(5); UNALIGNED_ADD(4); UNALIGNED_ADD(3); UNALIGNED_ADD_4</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_ST_INDEX_T</name> <operator>&gt;</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD_16</name></cpp:macro> <cpp:value>UNALIGNED_ADD(14); UNALIGNED_ADD(13); UNALIGNED_ADD(12); UNALIGNED_ADD(11); UNALIGNED_ADD(10); UNALIGNED_ADD(9); UNALIGNED_ADD(8); UNALIGNED_ADD(7); UNALIGNED_ADD_8</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD_ALL</name></cpp:macro> <cpp:value>UNALIGNED_ADD_16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD_ALL</name></cpp:macro> <cpp:value>UNALIGNED_ADD_8</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD_ALL</name></cpp:macro> <cpp:value>UNALIGNED_ADD_4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SKIP_TAIL</name></cpp:undef>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>UNALIGNED_WORD_ACCESS</name></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>align</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>st_data_t</name><operator>)</operator><name>data</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>align</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sl</name></decl>, <decl><type ref="prev"/><name>sr</name></decl>, <decl><type ref="prev"/><name>pack</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>align</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case SIZEOF_ST_INDEX_T - (n) - 1: t |= data_at(n) &lt;&lt; CHAR_BIT*(SIZEOF_ST_INDEX_T - (n) - 2)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case SIZEOF_ST_INDEX_T - (n) - 1: t |= data_at(n) &lt;&lt; CHAR_BIT*(n)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>UNALIGNED_ADD_ALL</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UNALIGNED_ADD</name></cpp:undef>
</block_content>}</block></switch>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>t</name> <operator>&gt;&gt;=</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>*</operator> <name>align</name><operator>)</operator> <operator>-</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>t</name> <operator>&lt;&lt;=</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>*</operator> <name>align</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof><operator>-</operator><name>align</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof><operator>-</operator><name>align</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sl</name> <operator>=</operator> <name>CHAR_BIT</name> <operator>*</operator> <operator>(</operator><name>SIZEOF_ST_INDEX_T</name><operator>-</operator><name>align</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sr</name> <operator>=</operator> <name>CHAR_BIT</name> <operator>*</operator> <name>align</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>len</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>st_index_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <name>sr</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>d</name> <operator>&gt;&gt;</operator> <name>sl</name><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>&gt;&gt;</operator> <name>sr</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>d</name> <operator>&lt;&lt;</operator> <name>sl</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>murmur_step</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>pack</name> <operator>=</operator> <ternary><condition><expr><name>len</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>align</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr> </then><else>: <expr><name>align</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>pack</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case (n) + 1: d |= data_at(n) &lt;&lt; CHAR_BIT*(SIZEOF_ST_INDEX_T - (n) - 1)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case (n) + 1: d |= data_at(n) &lt;&lt; CHAR_BIT*(n)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>UNALIGNED_ADD_ALL</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UNALIGNED_ADD</name></cpp:undef>
</block_content>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <name>sr</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>d</name> <operator>&gt;&gt;</operator> <name>sl</name><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>&gt;&gt;</operator> <name>sr</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>d</name> <operator>&lt;&lt;</operator> <name>sl</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>align</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>skip_tail</name>;</goto></block_content></block></if></if_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_TAIL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>murmur_step</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>pack</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>pack</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BUILTIN___BUILTIN_ASSUME_ALIGNED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>aligned_data</name></cpp:macro> <cpp:value>__builtin_assume_aligned(data, sizeof(st_index_t))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>aligned_data</name></cpp:macro> <cpp:value>data</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<do>do <block>{<block_content>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>murmur_step</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>st_index_t</name> <operator>*</operator><operator>)</operator><name>aligned_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>len</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>st_index_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition>;</do>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNALIGNED_WORD_ACCESS</name> <operator>&amp;&amp;</operator> <name>SIZEOF_ST_INDEX_T</name> <operator>&lt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>CHAR_BIT</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_ST_INDEX_T</name> <operator>&gt;</operator> <literal type="number">4</literal></expr></cpp:if>
<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>t</name> <operator>|=</operator> <call><name>data_at</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>t</name> <operator>|=</operator> <call><name>data_at</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>t</name> <operator>|=</operator> <call><name>data_at</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name>t</name> <operator>|=</operator> <operator>(</operator><name>st_index_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><name>aligned_data</name></expr>;</expr_stmt>
<goto>goto <name>skip_tail</name>;</goto>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_TAIL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>t</name> <operator>|=</operator> <call><name>data_at</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>t</name> <operator>|=</operator> <call><name>data_at</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>t</name> <operator>|=</operator> <call><name>data_at</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case (n) + 1: t |= data_at(n) &lt;&lt; CHAR_BIT*(SIZEOF_ST_INDEX_T - (n) - 1)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNALIGNED_ADD</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case (n) + 1: t |= data_at(n) &lt;&lt; CHAR_BIT*(n)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>UNALIGNED_ADD_ALL</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UNALIGNED_ADD</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SKIP_TAIL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>skip_tail</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>t</name></expr>;</expr_stmt> <expr_stmt><expr><name>h</name> <operator>-=</operator> <call><name>ROTL</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>C2</name></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>l</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>aligned_data</name></cpp:undef>

<return>return <expr><call><name>murmur_finish</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>st_index_t</name></type>
<name>st_hash_uint32</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>murmur_step</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>NO_SANITIZE</name><argument_list>(<argument><literal type="string">"unsigned-integer-overflow"</literal></argument>, <argument>extern st_index_t st_hash_uint(st_index_t h, st_index_t i)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function><type><name>st_index_t</name></type>
<name>st_hash_uint</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>h</name></expr>;</expr_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_ST_INDEX_T</name><operator>*</operator><name>CHAR_BIT</name> <operator>&gt;</operator> <literal type="number">8</literal><operator>*</operator><literal type="number">8</literal></expr></cpp:if>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>murmur_step</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>*</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>murmur_step</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>st_index_t</name></type>
<name>st_hash_end</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>murmur_finish</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>st_hash_start</name></cpp:undef>
<function><type><name>st_index_t</name></type>
<name>rb_st_hash_start</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>strhash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>st_hash</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FNV1_32A_INIT</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>st_locale_insensitive_strcasecmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>s1</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s2</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>c2</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>c1</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c1</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>c2</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c2</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>&gt;</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>st_locale_insensitive_strncasecmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>s1</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s2</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>c2</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>c1</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c1</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>c2</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c2</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>&gt;</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>st_strcmp</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>rhs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>lhs</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rhs</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>st_locale_insensitive_strcasecmp_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>rhs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>lhs</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rhs</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>st_locale_insensitive_strcasecmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>NO_SANITIZE</name><argument_list>(<argument><expr><literal type="string">"unsigned-integer-overflow"</literal></expr></argument>, <argument><expr><macro><name>PUREFUNC</name><argument_list>(<argument>static st_index_t strcasehash(st_data_t)</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>strcasehash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>register</specifier> <name>st_index_t</name></type> <name>hval</name> <init>= <expr><name>FNV1_32A_INIT</name></expr></init></decl>;</decl_stmt>




<while>while <condition>(<expr><operator>*</operator><name>string</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>string</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator> <operator>&lt;=</operator> <operator>(</operator><literal type="char">'Z'</literal> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hval</name> <operator>^=</operator> <name>c</name></expr>;</expr_stmt>


<expr_stmt><expr><name>hval</name> <operator>*=</operator> <name>FNV_32_PRIME</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>hval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>st_numcmp</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>x</name> <operator>!=</operator> <name>y</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>st_index_t</name></type>
<name>st_numhash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<enum>enum <block>{<decl><name>s1</name> <init>= <expr><literal type="number">11</literal></expr></init></decl>, <decl><name>s2</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>}</block>;</enum>
<return>return <expr><operator>(</operator><name>st_index_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name><operator>&gt;&gt;</operator><name>s1</name><operator>|</operator><operator>(</operator><name>n</name><operator>&lt;&lt;</operator><name>s2</name><operator>)</operator><operator>)</operator> <operator>^</operator> <operator>(</operator><name>n</name><operator>&gt;&gt;</operator><name>s2</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>st_expand_table</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>siz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>siz</name> <operator>&lt;=</operator> <call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>st_init_table_with_size</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>siz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_allocated_entries</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name>st_table_entry</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>bins</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entry_power</name></name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>entry_power</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bin_power</name></name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>bin_power</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>size_ind</name></name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>size_ind</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rebuilds_num</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>st_rehash_linear</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>eq_p</name></decl>, <decl><type ref="prev"/><name>rebuilt_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DELETED_ENTRY_P</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DELETED_ENTRY_P</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>DO_PTR_EQUAL_CHECK</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>eq_p</name></expr></argument>, <argument><expr><name>rebuilt_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>rebuilt_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eq_p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>q</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MARK_ENTRY_DELETED</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_range_for_deleted</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>st_rehash_indexed</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>eq_p</name></decl>, <decl><type ref="prev"/><name>rebuilt_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name> <specifier>const</specifier></type> <name>n</name> <init>= <expr><call><name>bins_size</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name> <specifier>const</specifier></type> <name>size_ind</name> <init>= <expr><call><name>get_size_ind</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name> <modifier>*</modifier></type><name>bins</name> <init>= <expr><call><name>realloc</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>bins</name></name> <operator>=</operator> <name>bins</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>initialize_bins</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>ind</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>d</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>peterb</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>hash</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>DELETED_ENTRY_P</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>bin</name> <init>= <expr><call><name>get_bin</name><argument_list>(<argument><expr><name>bins</name></expr></argument>, <argument><expr><name>size_ind</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EMPTY_OR_DELETED_BIN_P</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>set_bin</name><argument_list>(<argument><expr><name>bins</name></expr></argument>, <argument><expr><name>size_ind</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>ENTRY_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>st_table_entry</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>bin</name> <operator>-</operator> <name>ENTRY_BASE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>DO_PTR_EQUAL_CHECK</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>eq_p</name></expr></argument>, <argument><expr><name>rebuilt_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EXPECT</name><argument_list>(<argument><expr><name>rebuilt_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eq_p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>record</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MARK_ENTRY_DELETED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_range_for_deleted</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if>
<else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>QUADRATIC_PROBE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>hash_bin</name><argument_list>(<argument><expr><name>ind</name> <operator>+</operator> <name>d</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>secondary_hash</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peterb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>st_rehash</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rebuilt_p</name></decl>;</decl_stmt>

<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bin_power</name></name> <operator>&lt;=</operator> <name>MAX_POWER2_FOR_TABLES_WITHOUT_BINS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rebuilt_p</name> <operator>=</operator> <call><name>st_rehash_linear</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>rebuilt_p</name> <operator>=</operator> <call><name>st_rehash_indexed</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><name>rebuilt_p</name></expr>)</condition>;</do>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>st_data_t</name></type>
<name>st_stringify</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_OBJ_FROZEN</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
<expr><call><name>rb_hash_key_str</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>key</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>st_insert_single</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>k</name> <init>= <expr><call><name>st_stringify</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table_entry</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>e</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <call><name>do_hash</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>.</operator><name>record</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>st_insert_linear</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>k</name> <init>= <expr><call><name>st_stringify</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>v</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>st_insert_generic</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>st_insert_single</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>st_rehash</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type>
<name>rb_hash_bulk_insert_into_st_table</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><name>argc</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>RHASH_TBL_RAW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>entries_bound</name></name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_expand_table</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>st_insert_generic</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>st_insert_single</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>bin_power</name></name> <operator>&lt;=</operator> <name>MAX_POWER2_FOR_TABLES_WITHOUT_BINS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>st_insert_linear</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>st_insert_generic</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
