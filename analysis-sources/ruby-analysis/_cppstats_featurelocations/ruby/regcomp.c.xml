<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\regcomp.c">





























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regparse.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>OnigDefaultCaseFoldFlag</name> <init>= <expr><name>ONIGENC_CASE_FOLD_MIN</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>extern</specifier> <name>OnigCaseFoldType</name></type>
<name>onig_get_default_case_fold_flag</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>OnigDefaultCaseFoldFlag</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_set_default_case_fold_flag</name><parameter_list>(<parameter><decl><type><name>OnigCaseFoldType</name></type> <name>case_fold_flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>OnigDefaultCaseFoldFlag</name> <operator>=</operator> <name>case_fold_flag</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PLATFORM_UNALIGNED_WORD_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>PadBuf</name><index>[<expr><name>WORD_ALIGNMENT_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static UChar*
str_dup(UChar* s, UChar* end)
{
ptrdiff_t len = end - s;

if (len &gt; 0) {
UChar* r = (UChar* )xmalloc(len + 1);
CHECK_NULL_RETURN(r);
xmemcpy(r, s, len);
r[len] = (UChar )0;
return r;
}
else return NULL;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>swap_node</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>a</name></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>a</name> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>b</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_STR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>capa</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_STR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>capa</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OnigDistance</name></type>
<name>distance_add</name><parameter_list>(<parameter><decl><type><name>OnigDistance</name></type> <name>d1</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>d2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>d1</name> <operator>==</operator> <name>ONIG_INFINITE_DISTANCE</name> <operator>||</operator> <name>d2</name> <operator>==</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIG_INFINITE_DISTANCE</name></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>d1</name> <operator>&lt;=</operator> <name>ONIG_INFINITE_DISTANCE</name> <operator>-</operator> <name>d2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>d1</name> <operator>+</operator> <name>d2</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><name>ONIG_INFINITE_DISTANCE</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OnigDistance</name></type>
<name>distance_multiply</name><parameter_list>(<parameter><decl><type><name>OnigDistance</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <name>ONIG_INFINITE_DISTANCE</name> <operator>/</operator> <name>m</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>d</name> <operator>*</operator> <name>m</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ONIG_INFINITE_DISTANCE</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bitset_is_empty</name><parameter_list>(<parameter><decl><type><name>BitSetRef</name></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BITSET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bitset_on_num</name><parameter_list>(<parameter><decl><type><name>BitSetRef</name></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BITSET_AT</name><argument_list>(<argument><expr><name>bs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_bbuf_init</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return<expr><operator>(</operator><name>ONIGERR_MEMORY</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name> <operator>)</operator><name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>unset_addr_list_init</name><parameter_list>(<parameter><decl><type><name>UnsetAddrList</name><modifier>*</modifier></type> <name>uslist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UnsetAddr</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>UnsetAddr</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnsetAddr</name></expr></argument>)</argument_list></sizeof><operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uslist</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uslist</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uslist</name><operator>-&gt;</operator><name>us</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unset_addr_list_end</name><parameter_list>(<parameter><decl><type><name>UnsetAddrList</name><modifier>*</modifier></type> <name>uslist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>uslist</name><operator>-&gt;</operator><name>us</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>uslist</name><operator>-&gt;</operator><name>us</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>unset_addr_list_add</name><parameter_list>(<parameter><decl><type><name>UnsetAddrList</name><modifier>*</modifier></type> <name>uslist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UnsetAddr</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>uslist</name><operator>-&gt;</operator><name>num</name></name> <operator>&gt;=</operator> <name><name>uslist</name><operator>-&gt;</operator><name>alloc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>uslist</name><operator>-&gt;</operator><name>alloc</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>UnsetAddr</name><operator>*</operator> <operator>)</operator><call><name>xrealloc</name><argument_list>(<argument><expr><name><name>uslist</name><operator>-&gt;</operator><name>us</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnsetAddr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uslist</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uslist</name><operator>-&gt;</operator><name>us</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>uslist</name><operator>-&gt;</operator><name>us</name><index>[<expr><name><name>uslist</name><operator>-&gt;</operator><name>num</name></name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uslist</name><operator>-&gt;</operator><name>us</name><index>[<expr><name><name>uslist</name><operator>-&gt;</operator><name>num</name></name></expr>]</index></name><operator>.</operator><name>target</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uslist</name><operator>-&gt;</operator><name>num</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 


<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_opcode</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BBUF_ADD1</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_state_check_num</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>StateCheckNumType</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>StateCheckNumType</name> <operator>)</operator><name>num</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BBUF_ADD</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>SIZE_STATE_CHECK_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_rel_addr</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>RelAddrType</name></type> <name>ra</name> <init>= <expr><operator>(</operator><name>RelAddrType</name> <operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BBUF_ADD</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ra</name></expr></argument>, <argument><expr><name>SIZE_RELADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_abs_addr</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AbsAddrType</name></type> <name>ra</name> <init>= <expr><operator>(</operator><name>AbsAddrType</name> <operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BBUF_ADD</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ra</name></expr></argument>, <argument><expr><name>SIZE_ABSADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_length</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LengthType</name></type> <name>l</name> <init>= <expr><operator>(</operator><name>LengthType</name> <operator>)</operator><name>len</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BBUF_ADD</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>SIZE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_mem_num</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MemNumType</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>MemNumType</name> <operator>)</operator><name>num</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BBUF_ADD</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>SIZE_MEMNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static int
add_pointer(regex_t* reg, void* addr)
{
PointerType ptr = (PointerType )addr;

BBUF_ADD(reg, &amp;ptr, SIZE_POINTER);
return 0;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_option</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>OnigOptionType</name></type> <name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BBUF_ADD</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>, <argument><expr><name>SIZE_OPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_opcode_rel_addr</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_bytes</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BBUF_ADD</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_bitset</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>BitSetRef</name></type> <name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BBUF_ADD</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>bs</name></expr></argument>, <argument><expr><name>SIZE_BITSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_opcode_option</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>, <parameter><decl><type><name>OnigOptionType</name></type> <name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_option</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compile_length_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compile_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NEED_STR_LEN_OP_EXACT</name><parameter_list>(<parameter><type><name>op</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((op) == OP_EXACTN || (op) == OP_EXACTMB2N ||(op) == OP_EXACTMB3N || (op) == OP_EXACTMBN || (op) == OP_EXACTN_IC)</cpp:value></cpp:define>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>select_str_opcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mb_len</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>byte_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_case</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>str_len</name> <init>= <expr><operator>(</operator><name>byte_len</name> <operator>+</operator> <name>mb_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>mb_len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>str_len</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACT1_IC</name></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACTN_IC</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>
<switch>switch <condition>(<expr><name>mb_len</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<switch>switch <condition>(<expr><name>str_len</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACT1</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACT2</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACT3</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACT4</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACT5</name></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACTN</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>
<switch>switch <condition>(<expr><name>str_len</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACTMB2N1</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACTMB2N2</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACTMB2N3</name></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACTMB2N</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACTMB3N</name></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EXACTMBN</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_tree_empty_check</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>empty_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>saved_num_null_check</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>num_null_check</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_info</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_NULL_CHECK_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>num_null_check</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_null_check</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_info</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>empty_info</name> <operator>==</operator> <name>NQ_TARGET_IS_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_NULL_CHECK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>empty_info</name> <operator>==</operator> <name>NQ_TARGET_IS_EMPTY_MEM</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_NULL_CHECK_END_MEMST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>empty_info</name> <operator>==</operator> <name>NQ_TARGET_IS_EMPTY_REC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_NULL_CHECK_END_MEMST_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>saved_num_null_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_call</name><parameter_list>(<parameter><decl><type><name>CallNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>unset_addr_list_add</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>unset_addr_list</name></name></expr></argument>, <argument><expr><call><name>BBUF_GET_OFFSET_POS</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_abs_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_tree_n_times</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_compile_string_length</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier> <name>s</name></type> <name>ARG_UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mb_len</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>byte_len</name></decl></parameter>,
<parameter><decl><type><name>regex_t</name><modifier>*</modifier> <name>reg</name></type> <name>ARG_UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_case</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><call><name>select_str_opcode</name><argument_list>(<argument><expr><name>mb_len</name></expr></argument>, <argument><expr><name>byte_len</name></expr></argument>, <argument><expr><name>ignore_case</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OPCODE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_EXACTMBN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_LENGTH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NEED_STR_LEN_OP_EXACT</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_LENGTH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>byte_len</name></expr>;</expr_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_compile_string</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mb_len</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>byte_len</name></decl></parameter>,
<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_case</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><call><name>select_str_opcode</name><argument_list>(<argument><expr><name>mb_len</name></expr></argument>, <argument><expr><name>byte_len</name></expr></argument>, <argument><expr><name>ignore_case</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_EXACTMBN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>mb_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NEED_STR_LEN_OP_EXACT</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_EXACTN_IC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>byte_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>byte_len</name> <operator>/</operator> <name>mb_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>byte_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_string_node</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rlen</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>prev_len</name></decl>, <decl><type ref="prev"/><name>blen</name></decl>, <decl><type ref="prev"/><name>ambig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sn</name> <operator>=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>&lt;=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ambig</name> <operator>=</operator> <call><name>NSTRING_IS_AMBIG</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>prev_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>blen</name> <operator>=</operator> <name>prev_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>prev_len</name> <operator>||</operator> <name>ambig</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>blen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_compile_string_length</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>prev_len</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ambig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rlen</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>blen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_compile_string_length</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>prev_len</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ambig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rlen</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
<return>return <expr><name>rlen</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_string_raw_node</name><parameter_list>(<parameter><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>&lt;=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>add_compile_string_length</name><argument_list>(<argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> , <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_string_node</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>prev_len</name></decl>, <decl><type ref="prev"/><name>blen</name></decl>, <decl><type ref="prev"/><name>ambig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sn</name> <operator>=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>&lt;=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ambig</name> <operator>=</operator> <call><name>NSTRING_IS_AMBIG</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>prev_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>blen</name> <operator>=</operator> <name>prev_len</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>prev_len</name> <operator>||</operator> <name>ambig</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>blen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_compile_string</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>prev_len</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ambig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>blen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>add_compile_string</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>prev_len</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ambig</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_string_raw_node</name><parameter_list>(<parameter><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>&lt;=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>add_compile_string</name><argument_list>(<argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> , <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_multi_byte_cclass</name><parameter_list>(<parameter><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>mbuf</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PLATFORM_UNALIGNED_WORD_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mbuf</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mbuf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>mbuf</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>pad_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>BBUF_GET_ADD_ADDRESS</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>SIZE_LENGTH</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GET_ALIGNMENT_PAD_SIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pad_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mbuf</name><operator>-&gt;</operator><name>used</name></name> <operator>+</operator> <operator>(</operator><name>WORD_ALIGNMENT_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pad_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>PadBuf</name></expr></argument>, <argument><expr><name>pad_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mbuf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>mbuf</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>pad_size</name> <operator>=</operator> <operator>(</operator><name>WORD_ALIGNMENT_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>pad_size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pad_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>PadBuf</name></expr></argument>, <argument><expr><name>pad_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_cclass_node</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OPCODE</name> <operator>+</operator> <name>SIZE_BITSET</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>bitset_is_empty</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OPCODE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OPCODE</name> <operator>+</operator> <name>SIZE_BITSET</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PLATFORM_UNALIGNED_WORD_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_LENGTH</name> <operator>+</operator> <name><name>cc</name><operator>-&gt;</operator><name>mbuf</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_LENGTH</name> <operator>+</operator> <name><name>cc</name><operator>-&gt;</operator><name>mbuf</name><operator>-&gt;</operator><name>used</name></name> <operator>+</operator> <operator>(</operator><name>WORD_ALIGNMENT_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_cclass_node</name><parameter_list>(<parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CCLASS_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_bitset</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>bitset_is_empty</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CCLASS_MB_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CCLASS_MB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_multi_byte_cclass</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CCLASS_MIX_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CCLASS_MIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_bitset</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_multi_byte_cclass</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>entry_repeat_range</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>upper</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPEAT_RANGE_ALLOC</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<decl_stmt><decl><type><name>OnigRepeatRange</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range_alloc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>OnigRepeatRange</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OnigRepeatRange</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>REPEAT_RANGE_ALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range_alloc</name></name> <operator>=</operator> <name>REPEAT_RANGE_ALLOC</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range_alloc</name></name> <operator>&lt;=</operator> <name>id</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>repeat_range_alloc</name></name> <operator>+</operator> <name>REPEAT_RANGE_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>OnigRepeatRange</name><operator>*</operator> <operator>)</operator><call><name>xrealloc</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OnigRepeatRange</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range_alloc</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>repeat_range</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>lower</name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>upper</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0x7fffffff</literal></expr> </then><else>: <expr><name>upper</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_range_repeat_node</name><parameter_list>(<parameter><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>empty_info</name></decl></parameter>,
<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_repeat</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>num_repeat</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr> ?</condition><then> <expr><name>OP_REPEAT</name></expr> </then><else>: <expr><name>OP_REPEAT_NG</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>num_repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_repeat</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>target_len</name> <operator>+</operator> <name>SIZE_OP_REPEAT_INC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>entry_repeat_range</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>num_repeat</name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_empty_check</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name><name>reg</name><operator>-&gt;</operator><name>num_call</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<call><name>IS_QUANTIFIER_IN_REPEAT</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr> ?</condition><then> <expr><name>OP_REPEAT_INC_SG</name></expr> </then><else>: <expr><name>OP_REPEAT_INC_NG_SG</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr> ?</condition><then> <expr><name>OP_REPEAT_INC</name></expr> </then><else>: <expr><name>OP_REPEAT_INC_NG</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>num_repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_anychar_star_quantifier</name><parameter_list>(<parameter><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>NTYPE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_CANY</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUANTIFIER_EXPAND_LIMIT_SIZE</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CKN_ON</name></cpp:macro> <cpp:value>(ckn &gt; 0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_quantifier_node</name><parameter_list>(<parameter><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>mod_tlen</name></decl>, <decl><type ref="prev"/><name>cklen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ckn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>infinite</name> <init>= <expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>empty_info</name> <init>= <expr><name><name>qn</name><operator>-&gt;</operator><name>target_empty_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tlen</name> <init>= <expr><call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ckn</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>num_comb_exp_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>qn</name><operator>-&gt;</operator><name>comb_exp_check_num</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>cklen</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>CKN_ON</name></expr> ?</condition><then> <expr><name>SIZE_STATE_CHECK_NUM</name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_CANY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <name>infinite</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>CKN_ON</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SIZE_OP_ANYCHAR_STAR_PEEK_NEXT</name> <operator>+</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>+</operator> <name>cklen</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>SIZE_OP_ANYCHAR_STAR</name> <operator>+</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>+</operator> <name>cklen</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_info</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mod_tlen</name> <operator>=</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><name>SIZE_OP_NULL_CHECK_START</name> <operator>+</operator> <name>SIZE_OP_NULL_CHECK_END</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>mod_tlen</name> <operator>=</operator> <name>tlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>infinite</name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_OP_PUSH</name> <operator>+</operator> <name>cklen</name> <operator>+</operator> <name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_PUSH</name> <operator>+</operator> <name>cklen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>is_referred</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_JUMP</name> <operator>+</operator> <name>tlen</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_STATE_CHECK_PUSH</name> <operator>+</operator> <name>tlen</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_PUSH</name> <operator>+</operator> <name>tlen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>tlen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_PUSH</name> <operator>+</operator> <name>cklen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name> <operator>+</operator> <name>tlen</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_REPEAT_INC</name>
<operator>+</operator> <name>mod_tlen</name> <operator>+</operator> <name>SIZE_OPCODE</name> <operator>+</operator> <name>SIZE_RELADDR</name> <operator>+</operator> <name>SIZE_MEMNUM</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_OP_STATE_CHECK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_quantifier_node</name><parameter_list>(<parameter><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>mod_tlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ckn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>infinite</name> <init>= <expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>empty_info</name> <init>= <expr><name><name>qn</name><operator>-&gt;</operator><name>target_empty_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tlen</name> <init>= <expr><call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ckn</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>num_comb_exp_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>qn</name><operator>-&gt;</operator><name>comb_exp_check_num</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_anychar_star_quantifier</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_n_times</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>CKN_ON</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_MULTILINE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ANYCHAR_ML_STAR_PEEK_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ANYCHAR_STAR_PEEK_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_state_check_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ckn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_MULTILINE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>CKN_ON</name></expr> ?</condition><then>
<expr><name>OP_STATE_CHECK_ANYCHAR_ML_STAR</name></expr>
</then><else>: <expr><name>OP_ANYCHAR_ML_STAR</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>CKN_ON</name></expr> ?</condition><then>
<expr><name>OP_STATE_CHECK_ANYCHAR_STAR</name></expr>
</then><else>: <expr><name>OP_ANYCHAR_STAR</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_state_check_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ckn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_info</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mod_tlen</name> <operator>=</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><name>SIZE_OP_NULL_CHECK_START</name> <operator>+</operator> <name>SIZE_OP_NULL_CHECK_END</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>mod_tlen</name> <operator>=</operator> <name>tlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>infinite</name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>CKN_ON</name></expr> ?</condition><then> <expr><name>SIZE_OP_STATE_CHECK_PUSH</name></expr> </then><else>: <expr><name>SIZE_OP_PUSH</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_STATE_CHECK_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_state_check_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ckn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_empty_check</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>,
<argument><expr><operator>-</operator><operator>(</operator><name>mod_tlen</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_JUMP</name>
<operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><ternary><condition><expr><name>CKN_ON</name></expr> ?</condition><then> <expr><name>SIZE_OP_STATE_CHECK_PUSH</name></expr> </then><else>: <expr><name>SIZE_OP_PUSH</name></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>mod_tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_empty_check</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_STATE_CHECK_PUSH_OR_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_state_check_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ckn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>,
<argument><expr><operator>-</operator><operator>(</operator><name>mod_tlen</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_STATE_CHECK_PUSH_OR_JUMP</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>mod_tlen</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_PUSH</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>is_referred</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_STATE_CHECK_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_state_check_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ckn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_STATE_CHECK_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_state_check_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ckn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_range_repeat_node</name><argument_list>(<argument><expr><name>qn</name></expr></argument>, <argument><expr><name>mod_tlen</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CKN_ON</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_STATE_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_state_check_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>ckn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_quantifier_node</name><parameter_list>(<parameter><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>mod_tlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>infinite</name> <init>= <expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>empty_info</name> <init>= <expr><name><name>qn</name><operator>-&gt;</operator><name>target_empty_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tlen</name> <init>= <expr><call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_CANY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <name>infinite</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SIZE_OP_ANYCHAR_STAR_PEEK_NEXT</name> <operator>+</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>SIZE_OP_ANYCHAR_STAR</name> <operator>+</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_info</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mod_tlen</name> <operator>=</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><name>SIZE_OP_NULL_CHECK_START</name> <operator>+</operator> <name>SIZE_OP_NULL_CHECK_END</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>mod_tlen</name> <operator>=</operator> <name>tlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>infinite</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <name>QUANTIFIER_EXPAND_LIMIT_SIZE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>tlen</name> <operator>&gt;</operator> <name>QUANTIFIER_EXPAND_LIMIT_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_OP_PUSH_OR_JUMP_EXACT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_OP_PUSH_OR_JUMP_EXACT1</name> <operator>+</operator> <name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_OP_PUSH_IF_PEEK_NEXT</name> <operator>+</operator> <name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_OP_PUSH</name> <operator>+</operator> <name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_OP_JUMP</name> <operator>+</operator> <name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_PUSH</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>is_referred</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_JUMP</name> <operator>+</operator> <name>tlen</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>infinite</name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>tlen</name> <operator>+</operator> <name>SIZE_OP_PUSH</name><operator>)</operator> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name>
<operator>&lt;=</operator> <name>QUANTIFIER_EXPAND_LIMIT_SIZE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>SIZE_OP_PUSH</name> <operator>+</operator> <name>tlen</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>-</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_PUSH</name> <operator>+</operator> <name>SIZE_OP_JUMP</name> <operator>+</operator> <name>tlen</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_REPEAT_INC</name>
<operator>+</operator> <name>mod_tlen</name> <operator>+</operator> <name>SIZE_OPCODE</name> <operator>+</operator> <name>SIZE_RELADDR</name> <operator>+</operator> <name>SIZE_MEMNUM</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_quantifier_node</name><parameter_list>(<parameter><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>mod_tlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>infinite</name> <init>= <expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>empty_info</name> <init>= <expr><name><name>qn</name><operator>-&gt;</operator><name>target_empty_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tlen</name> <init>= <expr><call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_anychar_star_quantifier</name><argument_list>(<argument><expr><name>qn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_n_times</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_MULTILINE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ANYCHAR_ML_STAR_PEEK_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ANYCHAR_STAR_PEEK_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_MULTILINE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ANYCHAR_ML_STAR</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ANYCHAR_STAR</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_info</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mod_tlen</name> <operator>=</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><name>SIZE_OP_NULL_CHECK_START</name> <operator>+</operator> <name>SIZE_OP_NULL_CHECK_END</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>mod_tlen</name> <operator>=</operator> <name>tlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>infinite</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <name>QUANTIFIER_EXPAND_LIMIT_SIZE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>tlen</name> <operator>&gt;</operator> <name>QUANTIFIER_EXPAND_LIMIT_SIZE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_OP_PUSH_OR_JUMP_EXACT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>SIZE_OP_PUSH_OR_JUMP_EXACT1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>SIZE_OP_PUSH_IF_PEEK_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>SIZE_OP_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_n_times</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_OP_PUSH_OR_JUMP_EXACT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH_OR_JUMP_EXACT1</name></expr></argument>,
<argument><expr><name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>head_exact</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_empty_check</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>,
<argument><expr><operator>-</operator><operator>(</operator><name>mod_tlen</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_JUMP</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_PUSH_OR_JUMP_EXACT1</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH_IF_PEEK_NEXT</name></expr></argument>,
<argument><expr><name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_bytes</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_empty_check</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>,
<argument><expr><operator>-</operator><operator>(</operator><name>mod_tlen</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_JUMP</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_PUSH_IF_PEEK_NEXT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><name>mod_tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_empty_check</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>,
<argument><expr><operator>-</operator><operator>(</operator><name>mod_tlen</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_JUMP</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_PUSH</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>mod_tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_empty_check</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>mod_tlen</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_PUSH</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>is_referred</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>infinite</name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>tlen</name> <operator>+</operator> <name>SIZE_OP_PUSH</name><operator>)</operator> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name>
<operator>&lt;=</operator> <name>QUANTIFIER_EXPAND_LIMIT_SIZE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>-</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_n_times</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>,
<argument><expr><operator>(</operator><name>n</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><name>n</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>SIZE_OP_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_range_repeat_node</name><argument_list>(<argument><expr><name>qn</name></expr></argument>, <argument><expr><name>mod_tlen</name></expr></argument>, <argument><expr><name>empty_info</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_option_node</name><parameter_list>(<parameter><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>prev</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_DYNAMIC_OPTION</name><argument_list>(<argument><expr><name>prev</name> <operator>^</operator> <name><name>node</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>SIZE_OP_SET_OPTION_PUSH</name> <operator>+</operator> <name>SIZE_OP_SET_OPTION</name> <operator>+</operator> <name>SIZE_OP_FAIL</name>
<operator>+</operator> <name>tlen</name> <operator>+</operator> <name>SIZE_OP_SET_OPTION</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>tlen</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_option_node</name><parameter_list>(<parameter><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>prev</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_DYNAMIC_OPTION</name><argument_list>(<argument><expr><name>prev</name> <operator>^</operator> <name><name>node</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_option</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_SET_OPTION_PUSH</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_option</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_SET_OPTION</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_DYNAMIC_OPTION</name><argument_list>(<argument><expr><name>prev</name> <operator>^</operator> <name><name>node</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_option</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_SET_OPTION</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_enclose_node</name><parameter_list>(<parameter><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENCLOSE_OPTION</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>compile_length_option_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_CALLED</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_MEMORY_START_PUSH</name> <operator>+</operator> <name>tlen</name>
<operator>+</operator> <name>SIZE_OP_CALL</name> <operator>+</operator> <name>SIZE_OP_JUMP</name> <operator>+</operator> <name>SIZE_OP_RETURN</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>SIZE_OP_MEMORY_END_PUSH_REC</name></expr> </then><else>: <expr><name>SIZE_OP_MEMORY_END_PUSH</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>SIZE_OP_MEMORY_END_REC</name></expr> </then><else>: <expr><name>SIZE_OP_MEMORY_END</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_MEMORY_START_PUSH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>SIZE_OP_MEMORY_END_PUSH_REC</name></expr> </then><else>: <expr><name>SIZE_OP_MEMORY_END_REC</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_start</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_MEMORY_START_PUSH</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_MEMORY_START</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>SIZE_OP_MEMORY_END_PUSH</name></expr> </then><else>: <expr><name>SIZE_OP_MEMORY_END</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_STOP_BT_SIMPLE_REPEAT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>tlen</name> <operator>*</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name>
<operator>+</operator> <name>SIZE_OP_PUSH</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <name>SIZE_OP_POP</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_PUSH_STOP_BT</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <name>SIZE_OP_POP_STOP_BT</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_CONDITION</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_ALT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>x</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>tlen</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>tlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_CONDITION_PATTERN</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_PUSH_ABSENT_POS</name> <operator>+</operator> <name>SIZE_OP_ABSENT</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <name>SIZE_OP_ABSENT_END</name></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_TYPE_BUG</name></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_char_length_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_enclose_node</name><parameter_list>(<parameter><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENCLOSE_OPTION</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>compile_option_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_CALLED</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>call_addr</name></name> <operator>=</operator> <call><name>BBUF_GET_OFFSET_POS</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>SIZE_ABSADDR</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>NST_ADDR_FIXED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_abs_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>call_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>SIZE_OP_MEMORY_START_PUSH</name> <operator>+</operator> <name>SIZE_OP_RETURN</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>SIZE_OP_MEMORY_END_PUSH_REC</name></expr> </then><else>: <expr><name>SIZE_OP_MEMORY_END_PUSH</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>SIZE_OP_MEMORY_END_REC</name></expr> </then><else>: <expr><name>SIZE_OP_MEMORY_END</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_start</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_MEMORY_START_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_MEMORY_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_CALLED</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>OP_MEMORY_END_PUSH_REC</name></expr> </then><else>: <expr><name>OP_MEMORY_END_PUSH</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>OP_MEMORY_END_REC</name></expr> </then><else>: <expr><name>OP_MEMORY_END</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_MEMORY_END_PUSH_REC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_MEMORY_END_REC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_MEMORY_END_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_MEMORY_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_STOP_BT_SIMPLE_REPEAT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree_n_times</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>SIZE_OP_POP</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_POP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>,
<argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_PUSH</name> <operator>+</operator> <name>len</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_POP</name> <operator>+</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>SIZE_OP_JUMP</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH_STOP_BT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_POP_STOP_BT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_CONDITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_ALT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>x</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len2</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_CONDITION_PATTERN</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH_ABSENT_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ABSENT</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>SIZE_OP_ABSENT_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ABSENT_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_TYPE_BUG</name></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_anchor_node</name><parameter_list>(<parameter><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tlen</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_PUSH_POS</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <name>SIZE_OP_POP_POS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_PUSH_POS_NOT</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <name>SIZE_OP_FAIL_POS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_LOOK_BEHIND</name> <operator>+</operator> <name>tlen</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OP_PUSH_LOOK_BEHIND_NOT</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <name>SIZE_OP_FAIL_LOOK_BEHIND_NOT</name></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SIZE_OPCODE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_anchor_node</name><parameter_list>(<parameter><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_BEGIN_BUF</name></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BEGIN_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_END_BUF</name></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_END_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_BEGIN_LINE</name></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BEGIN_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_END_LINE</name></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_END_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_SEMI_END_BUF</name></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_SEMI_END_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_BEGIN_POSITION</name></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BEGIN_POSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ANCHOR_WORD_BOUND</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ascii_range</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ASCII_WORD_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_WORD_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>ANCHOR_NOT_WORD_BOUND</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ascii_range</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_NOT_ASCII_WORD_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_NOT_WORD_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_WORD_BEGIN_END</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>ANCHOR_WORD_BEGIN</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ascii_range</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ASCII_WORD_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_WORD_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>ANCHOR_WORD_END</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ascii_range</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ASCII_WORD_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_WORD_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>ANCHOR_KEEP</name></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_KEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_POP_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH_POS_NOT</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>SIZE_OP_FAIL_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_FAIL_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_LOOK_BEHIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>char_len</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_LOOK_BEHIND_PATTERN</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>char_len</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH_LOOK_BEHIND_NOT</name></expr></argument>,
<argument><expr><name>len</name> <operator>+</operator> <name>SIZE_OP_FAIL_LOOK_BEHIND_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>char_len</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_LOOK_BEHIND_PATTERN</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>char_len</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_FAIL_LOOK_BEHIND_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_TYPE_BUG</name></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_length_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>(</operator><name>SIZE_OP_PUSH</name> <operator>+</operator> <name>SIZE_OP_JUMP</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>n</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NSTRING_IS_RAW</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_length_string_raw_node</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_length_string_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_length_cclass_node</name><argument_list>(<argument><expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<case>case <expr><name>NT_CANY</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>SIZE_OPCODE</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>BRefNode</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_BACKREF_NEST_LEVEL</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>SIZE_OPCODE</name> <operator>+</operator> <name>SIZE_OPTION</name> <operator>+</operator> <name>SIZE_LENGTH</name> <operator>+</operator>
<name>SIZE_LENGTH</name> <operator>+</operator> <operator>(</operator><name>SIZE_MEMNUM</name> <operator>*</operator> <name><name>br</name><operator>-&gt;</operator><name>back_num</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
if <condition>(<expr><name><name>br</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>!</operator><call><name>IS_IGNORECASE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>br</name><operator>-&gt;</operator><name>back_static</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">2</literal><operator>)</operator></expr>
?</condition><then> <expr><name>SIZE_OPCODE</name></expr> </then><else>: <expr><operator>(</operator><name>SIZE_OPCODE</name> <operator>+</operator> <name>SIZE_MEMNUM</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>SIZE_OPCODE</name> <operator>+</operator> <name>SIZE_LENGTH</name> <operator>+</operator> <operator>(</operator><name>SIZE_MEMNUM</name> <operator>*</operator> <name><name>br</name><operator>-&gt;</operator><name>back_num</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>SIZE_OP_CALL</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_length_quantifier_node</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_length_enclose_node</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_length_anchor_node</name><argument_list>(<argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<return>return <expr><name>ONIGERR_TYPE_BUG</name></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>x</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SIZE_OP_PUSH</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>x</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>used</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt> 

<do>do <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compile_length_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_PUSH</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>SIZE_OP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>pos</name> <operator>-</operator> <operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>used</name></name> <operator>+</operator> <name>SIZE_OP_JUMP</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode_rel_addr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_JUMP</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NSTRING_IS_RAW</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_string_raw_node</name><argument_list>(<argument><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_string_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_cclass_node</name><argument_list>(<argument><expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ONIGENC_CTYPE_WORD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_NOT_ASCII_WORD</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_ASCII_WORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_NOT_WORD</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_WORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><name>ONIGERR_TYPE_BUG</name></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CANY</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_MULTILINE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ANYCHAR_ML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_ANYCHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>BRefNode</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_BACKREF_NEST_LEVEL</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_option</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ONIG_OPTION_IGNORECASE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>br</name><operator>-&gt;</operator><name>nest_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<goto>goto <name>add_bacref_mems</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
if <condition>(<expr><name><name>br</name><operator>-&gt;</operator><name>back_num</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>br</name><operator>-&gt;</operator><name>back_static</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_IGNORECASE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BACKREFN_IC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BACKREF1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BACKREF2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BACKREFN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_IGNORECASE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BACKREF_MULTI_IC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_BACKREF_MULTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>add_bacref_mems</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_length</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>br</name><operator>-&gt;</operator><name>back_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>BACKREFS_P</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>br</name><operator>-&gt;</operator><name>back_num</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_mem_num</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_call</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_quantifier_node</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_enclose_node</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_anchor_node</name><argument_list>(<argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"compile_tree: undefined node type %d\n"</literal></expr></argument>, <argument><expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>noname_disable_map</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>plink</name></decl></parameter>, <parameter><decl><type><name>GroupNumRemap</name><modifier>*</modifier></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>counter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><operator>*</operator><name>plink</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>noname_disable_map</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>ptarget</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>old</name> <init>= <expr><operator>*</operator><name>ptarget</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>noname_disable_map</name><argument_list>(<argument><expr><name>ptarget</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptarget</name> <operator>!=</operator> <name>old</name> <operator>&amp;&amp;</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><operator>*</operator><name>ptarget</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_QTFR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_reduce_nested_quantifier</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>*</operator><name>ptarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENCLOSE_MEMORY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_NAMED_GROUP</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>counter</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>map</name><index>[<expr><name><name>en</name><operator>-&gt;</operator><name>regnum</name></name></expr>]</index></name><operator>.</operator><name>new_val</name> <operator>=</operator> <operator>*</operator><name>counter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>en</name><operator>-&gt;</operator><name>regnum</name></name> <operator>=</operator> <operator>*</operator><name>counter</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>regnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>plink</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>noname_disable_map</name><argument_list>(<argument><expr><name>plink</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>noname_disable_map</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>en</name><operator>-&gt;</operator><name>target</name></name><operator>)</operator></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>noname_disable_map</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name><operator>)</operator></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>renumber_node_backref</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>GroupNumRemap</name><modifier>*</modifier></type> <name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>old_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>backs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BRefNode</name><modifier>*</modifier></type> <name>bn</name> <init>= <expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_BACKREF_NAME_REF</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>old_num</name> <operator>=</operator> <name><name>bn</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>bn</name><operator>-&gt;</operator><name>back_dynamic</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>backs</name> <operator>=</operator> <name><name>bn</name><operator>-&gt;</operator><name>back_static</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>backs</name> <operator>=</operator> <name><name>bn</name><operator>-&gt;</operator><name>back_dynamic</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>map</name><index>[<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>new_val</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>backs</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>back_num</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>renumber_by_map</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>GroupNumRemap</name><modifier>*</modifier></type> <name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>renumber_by_map</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>
<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>renumber_by_map</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENCLOSE_CONDITION</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>en</name><operator>-&gt;</operator><name>regnum</name></name> <operator>=</operator> <name><name>map</name><index>[<expr><name><name>en</name><operator>-&gt;</operator><name>regnum</name></name></expr>]</index></name><operator>.</operator><name>new_val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>renumber_by_map</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>renumber_node_backref</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>renumber_by_map</name><argument_list>(<argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>numbered_ref_check</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>numbered_ref_check</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>
<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>numbered_ref_check</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>numbered_ref_check</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_BACKREF_NAME_REF</name><argument_list>(<argument><expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>numbered_ref_check</name><argument_list>(<argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>disable_noname_group_capture</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>root</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>, <decl><type ref="prev"/><name>counter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitStatusType</name></type> <name>loc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GroupNumRemap</name><modifier>*</modifier></type> <name>map</name></decl>;</decl_stmt>

<expr_stmt><expr><name>map</name> <operator>=</operator> <operator>(</operator><name>GroupNumRemap</name><operator>*</operator> <operator>)</operator><call><name>xalloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GroupNumRemap</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>new_val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>counter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>noname_disable_map</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>renumber_by_map</name><argument_list>(<argument><expr><operator>*</operator><name>root</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>new_val</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><index>[<expr><name>pos</name></expr>]</index> <operator>=</operator> <call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>capture_history</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIT_STATUS_CLEAR</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>capture_history</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>ONIG_MAX_CAPTURE_HISTORY_GROUP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIT_STATUS_ON_AT_SIMPLE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>capture_history</name></name></expr></argument>, <argument><expr><name><name>map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_named</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_named</name></name></expr>;</expr_stmt>

<return>return <expr><call><name>onig_renumber_name_table</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unset_addr_list_fix</name><parameter_list>(<parameter><decl><type><name>UnsetAddrList</name><modifier>*</modifier></type> <name>uslist</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AbsAddrType</name></type> <name>addr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>uslist</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>en</name> <operator>=</operator> <call><name>NENCLOSE</name><argument_list>(<argument><expr><name><name>uslist</name><operator>-&gt;</operator><name>us</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_ENCLOSE_ADDR_FIXED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_PARSER_BUG</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>call_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>uslist</name><operator>-&gt;</operator><name>us</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BBUF_WRITE</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>SIZE_ABSADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>quantifiers_memory_node_info</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>quantifiers_memory_node_info</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_CALL_RECURSION</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NQ_TARGET_IS_EMPTY_REC</name></expr>;</return> 
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>quantifiers_memory_node_info</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>quantifiers_memory_node_info</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<return>return <expr><name>NQ_TARGET_IS_EMPTY_MEM</name></expr>;</return>
<break>break;</break>

<case>case <expr><name>ENCLOSE_OPTION</name></expr>:</case>
<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>quantifiers_memory_node_info</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<case>case <expr><name>NT_STR</name></expr>:</case>
<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<case>case <expr><name>NT_CANY</name></expr>:</case>
<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_min_match_length</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>tmin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_BREF</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>backs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name> <init>= <expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BRefNode</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>br</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>NST_RECURSION</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>backs</name> <operator>=</operator> <call><name>BACKREFS_P</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>backs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>backs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>br</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmin</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>min</name> <operator>&gt;</operator> <name>tmin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name>tmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_CALL_RECURSION</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MIN_FIXED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>min_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_LIST</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmin</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>min</name> <operator>+=</operator> <name>tmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>NCAR</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmin</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name>tmin</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>min</name> <operator>&gt;</operator> <name>tmin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name>tmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>y</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<case>case <expr><name>NT_CANY</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <call><name>distance_multiply</name><argument_list>(<argument><expr><operator>*</operator><name>min</name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MIN_FIXED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>min_len</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MARK1</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>en</name><operator>-&gt;</operator><name>min_len</name></name> <operator>=</operator> <operator>*</operator><name>min</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MIN_FIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_OPTION</name></expr>:</case>
<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_max_match_length</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>tmax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmax</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>distance_add</name><argument_list>(<argument><expr><operator>*</operator><name>max</name></expr></argument>, <argument><expr><name>tmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmax</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>max</name> <operator>&lt;</operator> <name>tmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>tmax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>ONIGENC_MBC_MAXLEN_DIST</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<case>case <expr><name>NT_CANY</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>ONIGENC_MBC_MAXLEN_DIST</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>backs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name> <init>= <expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BRefNode</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>br</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>NST_RECURSION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>backs</name> <operator>=</operator> <call><name>BACKREFS_P</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>br</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmax</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>max</name> <operator>&lt;</operator> <name>tmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>tmax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_CALL_RECURSION</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>max</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>distance_multiply</name><argument_list>(<argument><expr><operator>*</operator><name>max</name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MAX_FIXED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>max_len</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MARK1</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>en</name><operator>-&gt;</operator><name>max_len</name></name> <operator>=</operator> <operator>*</operator><name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MAX_FIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_OPTION</name></expr>:</case>
<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_CHAR_LEN_VARLEN</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_CHAR_LEN_TOP_ALT_VARLEN</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_char_length_tree1</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree1</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlen</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><call><name>distance_add</name><argument_list>(<argument><expr><operator>*</operator><name>len</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tlen2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>varlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree1</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlen</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree1</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlen2</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>!=</operator> <name>tlen2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>varlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>varlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>GET_CHAR_LEN_TOP_ALT_VARLEN</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>GET_CHAR_LEN_VARLEN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>tlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>len</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree1</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlen</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><call><name>distance_multiply</name><argument_list>(<argument><expr><name>tlen</name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>GET_CHAR_LEN_VARLEN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_CALL_RECURSION</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree1</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>GET_CHAR_LEN_VARLEN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<case>case <expr><name>NT_CANY</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_CLEN_FIXED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>char_len</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree1</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>en</name><operator>-&gt;</operator><name>char_len</name></name> <operator>=</operator> <operator>*</operator><name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_CLEN_FIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>ENCLOSE_OPTION</name></expr>:</case>
<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree1</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>GET_CHAR_LEN_VARLEN</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_char_length_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>get_char_length_tree1</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_not_included</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ytype</name></decl>;</decl_stmt>

<label><name>retry</name>:</label>
<expr_stmt><expr><name>ytype</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<block>{<block_content>
<switch>switch <condition>(<expr><name>ytype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctype</name> <operator>==</operator> <call><name>NCTYPE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctype</name> <operator>&amp;&amp;</operator>
<call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name> <operator>!=</operator> <call><name>NCTYPE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name> <operator>&amp;&amp;</operator>
<call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name> <operator>==</operator> <call><name>NCTYPE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<label><name>swap</name>:</label>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt> <expr_stmt><expr><name>y</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<goto>goto <name>retry</name>;</goto>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<goto>goto <name>swap</name>;</goto>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>xc</name> <init>= <expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>ytype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<switch>switch <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ONIGENC_CTYPE_WORD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>xc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>xc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BITSET_AT</name><argument_list>(<argument><expr><name><name>xc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_CODE_SB_WORD</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_WORD</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>xc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>is_word</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>is_word</name> <operator>=</operator> <call><name>IS_CODE_SB_WORD</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>is_word</name> <operator>=</operator> <call><name>ONIGENC_IS_CODE_WORD</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>is_word</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>xc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BITSET_AT</name><argument_list>(<argument><expr><name><name>xc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>BITSET_AT</name><argument_list>(<argument><expr><name><name>xc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>yc</name> <init>= <expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>BITSET_AT</name><argument_list>(<argument><expr><name><name>xc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>v</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>xc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>v</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>xc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>BITSET_AT</name><argument_list>(<argument><expr><name><name>yc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>v</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>yc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>v</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>yc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>xc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>xc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>yc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>yc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<goto>goto <name>swap</name>;</goto>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>xs</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NSTRING_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>ytype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<switch>switch <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ONIGENC_CTYPE_WORD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_MBC_ASCII_WORD</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><operator>(</operator><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_MBC_WORD</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><operator>(</operator><call><name>NCTYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name> <init>= <expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>ONIGENC_MBC_TO_CODE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>s</name></name></expr></argument>,
<argument><expr><name><name>xs</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <call><name>ONIGENC_MBC_MAXLEN</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>onig_is_code_in_cc</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>ys</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NSTRING_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <call><name>NSTRING_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NSTRING_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NSTRING_IS_AMBIG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NSTRING_IS_AMBIG</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name><name>ys</name><operator>-&gt;</operator><name>s</name></name></expr><operator>,</operator> <expr><name>q</name> <operator>=</operator> <name><name>xs</name><operator>-&gt;</operator><name>s</name></name></expr>;</init> <condition><expr><operator>(</operator><name>OnigDistance</name> <operator>)</operator><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>q</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <operator>*</operator><name>q</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>get_head_value_node</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exact</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>n</name> <init>= <expr><name>NULL_NODE</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_BREF</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<case>case <expr><name>NT_CANY</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>exact</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_LIST</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_head_value_node</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exact</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>&lt;=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exact</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>NSTRING_IS_RAW</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_IGNORECASE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_OP_PUSH_OR_JUMP_EXACT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>qn</name><operator>-&gt;</operator><name>head_exact</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_head_value_node</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>exact</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_OPTION</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>options</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_head_value_node</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>exact</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_head_value_node</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>exact</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>ANCHOR_PREC_READ</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_head_value_node</name><argument_list>(<argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>exact</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_type_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type_mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>enclose_mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>anchor_mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>NTYPE2BIT</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>type_mask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_type_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type_mask</name></expr></argument>, <argument><expr><name>enclose_mask</name></expr></argument>,
<argument><expr><name>anchor_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_type_tree</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>type_mask</name></expr></argument>, <argument><expr><name>enclose_mask</name></expr></argument>,
<argument><expr><name>anchor_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>en</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>enclose_mask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_type_tree</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>type_mask</name></expr></argument>, <argument><expr><name>enclose_mask</name></expr></argument>, <argument><expr><name>anchor_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>anchor_mask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_type_tree</name><argument_list>(<argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>,
<argument><expr><name>type_mask</name></expr></argument>, <argument><expr><name>enclose_mask</name></expr></argument>, <argument><expr><name>anchor_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECURSION_EXIST</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECURSION_INFINITE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>subexp_inf_recursive_check</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>min</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>subexp_inf_recursive_check</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>ret</name> <operator>==</operator> <name>RECURSION_INFINITE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>|=</operator> <name>ret</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>head</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>min</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>head</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>x</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>RECURSION_EXIST</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>subexp_inf_recursive_check</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>ret</name> <operator>==</operator> <name>RECURSION_INFINITE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>RECURSION_EXIST</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lower</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>an</name> <init>= <expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>an</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CALL</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MARK2</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_ENCLOSE_MARK1</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>head</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>RECURSION_EXIST</name></expr> </then><else>: <expr><name>RECURSION_INFINITE</name></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>subexp_inf_recursive_check_trav</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check_trav</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check_trav</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>an</name> <init>= <expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>an</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check_trav</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_NEVER_ENDING_RECURSION</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CLEAR_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check_trav</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>subexp_recursive_check</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>|=</operator> <call><name>subexp_recursive_check</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>an</name> <init>= <expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>an</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CALL</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_CALL_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MARK2</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>IS_ENCLOSE_MARK1</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if> 
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>subexp_recursive_check_trav</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUND_CALLED_NODE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>subexp_recursive_check_trav</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>FOUND_CALLED_NODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <name>FOUND_CALLED_NODE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check_trav</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>upper</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FOUND_CALLED_NODE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>is_referred</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>an</name> <init>= <expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>an</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check_trav</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_CALLED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_RECURSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CLEAR_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_MARK1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check_trav</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_CALLED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>|=</operator> <name>FOUND_CALLED_NODE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_subexp_call</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_subexp_call</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_subexp_call</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_subexp_call</name><argument_list>(<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_subexp_call</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_CALL</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>CallNode</name><modifier>*</modifier></type> <name>cn</name> <init>= <expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name> <init>= <expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cn</name><operator>-&gt;</operator><name>group_num</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>gnum</name> <init>= <expr><name><name>cn</name><operator>-&gt;</operator><name>group_num</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>num_named</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ONIG_IS_OPTION_ON</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><name>ONIG_OPTION_CAPTURE_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>gnum</name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>,
<argument><expr><name>ONIGERR_UNDEFINED_GROUP_REFERENCE</name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_UNDEFINED_GROUP_REFERENCE</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>set_call_attr</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>cn</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name><name>cn</name><operator>-&gt;</operator><name>group_num</name></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>,
<argument><expr><name>ONIGERR_UNDEFINED_NAME_REFERENCE</name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_UNDEFINED_NAME_REFERENCE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>NST_CALLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIT_STATUS_ON_AT</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>bt_mem_start</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>group_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cn</name><operator>-&gt;</operator><name>unset_addr_list</name></name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>unset_addr_list</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PERL_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name><name>cn</name><operator>-&gt;</operator><name>name_end</name></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>set_call_attr</name>;</goto>
</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>refs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>onig_name_to_group_numbers</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name_end</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>refs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>,
<argument><expr><name>ONIGERR_UNDEFINED_NAME_REFERENCE</name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_UNDEFINED_NAME_REFERENCE</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>!</operator> <call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME_CALL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_scan_env_set_error_string</name><argument_list>(<argument><expr><name>env</name></expr></argument>,
<argument><expr><name>ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL</name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>cn</name><operator>-&gt;</operator><name>group_num</name></name> <operator>=</operator> <name><name>refs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<goto>goto <name>set_call_attr</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>an</name> <init>= <expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>an</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_subexp_call</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>divide_look_behind_alternatives</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>head</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>np</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>insert_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>an</name> <init>= <expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>anc_type</name> <init>= <expr><name><name>an</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>NCAR</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>swap_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>

<expr_stmt><expr><name>np</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>np</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL_NODE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>insert_node</name> <operator>=</operator> <call><name>onig_node_new_anchor</name><argument_list>(<argument><expr><name>anc_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>insert_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>insert_node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <call><name>NCAR</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>insert_node</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>anc_type</name> <operator>==</operator> <name>ANCHOR_LOOK_BEHIND_NOT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>np</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><call><name>SET_NTYPE</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>NT_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>np</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL_NODE</name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_look_behind</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>an</name> <init>= <expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_char_length_tree</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>an</name><operator>-&gt;</operator><name>char_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <name>GET_CHAR_LEN_VARLEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_LOOK_BEHIND_PATTERN</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <name>GET_CHAR_LEN_TOP_ALT_VARLEN</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>divide_look_behind_alternatives</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_INVALID_LOOK_BEHIND_PATTERN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>next_setup</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>next_node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

<label><name>retry</name>:</label>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NT_QTFR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_QTFR_PEEK_NEXT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>n</name> <init>= <expr><call><name>get_head_value_node</name><argument_list>(<argument><expr><name>next_node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>next_head_exact</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ttype</name> <init>= <expr><call><name>NTYPE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NODE_TYPE_SIMPLE</name><argument_list>(<argument><expr><name>ttype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>get_head_value_node</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>get_head_value_node</name><argument_list>(<argument><expr><name>next_node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_not_included</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>onig_node_new_enclose</name><argument_list>(<argument><expr><name>ENCLOSE_STOP_BACKTRACK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>en</name></expr></argument>, <argument><expr><name>NST_STOP_BT_SIMPLE_REPEAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>swap_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name> <operator>=</operator> <name>en</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>NT_ENCLOSE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENCLOSE_MEMORY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
<goto>goto <name>retry</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>update_string_node_case_fold</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><name>ONIGENC_MBC_CASE_FOLD_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>sbuf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ebuf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>sbuf_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sbuf_size</name> <operator>=</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sbuf</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name>sbuf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ebuf</name> <operator>=</operator> <name>sbuf</name> <operator>+</operator> <name>sbuf_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>sbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ONIGENC_MBC_CASE_FOLD</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&gt;=</operator> <name>ebuf</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>xrealloc</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>sbuf_size</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sbuf</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>sbuf</name> <operator>+</operator> <name>sbuf_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sbuf_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ebuf</name> <operator>=</operator> <name>sbuf</name> <operator>+</operator> <name>sbuf_size</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>sp</name><operator>++</operator> <operator>=</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></while>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_node_str_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>expand_case_fold_make_rem_string</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>UChar</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>UChar</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>onig_node_new_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>update_string_node_case_fold</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NSTRING_SET_AMBIG</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NSTRING_SET_DONT_GET_OPT_INFO</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>rnode</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_case_fold_variable_len</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>item_num</name></decl></parameter>, <parameter><decl><type><name>OnigCaseFoldCodeItem</name></type> <name><name>items</name><index>[]</index></name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>item_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>byte_len</name> <operator>!=</operator> <name>slen</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>code_len</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>expand_case_fold_string_alt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>item_num</name></decl></parameter>, <parameter><decl><type><name>OnigCaseFoldCodeItem</name></type> <name><name>items</name><index>[]</index></name></decl></parameter>,
<parameter><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>UChar</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>varlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>anode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>var_anode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>snode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xnode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>an</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>rnode</name> <operator>=</operator> <name>var_anode</name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>varlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>item_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>byte_len</name> <operator>!=</operator> <name>slen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>varlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>varlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rnode</name> <operator>=</operator> <name>var_anode</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>NULL_NODE</name></expr></argument>, <argument><expr><name>NULL_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>var_anode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>xnode</name> <operator>=</operator> <call><name>onig_node_new_list</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>xnode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>mem_err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>var_anode</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>xnode</name></expr>;</expr_stmt>

<expr_stmt><expr><name>anode</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>NULL_NODE</name></expr></argument>, <argument><expr><name>NULL_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>anode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>mem_err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>xnode</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>anode</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rnode</name> <operator>=</operator> <name>anode</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>NULL_NODE</name></expr></argument>, <argument><expr><name>NULL_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>anode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>snode</name> <operator>=</operator> <call><name>onig_node_new_str</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>mem_err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>anode</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>snode</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>item_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>snode</name> <operator>=</operator> <call><name>onig_node_new_str</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>mem_err</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>code_len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>code</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<goto>goto <name>mem_err2</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_node_str_cat</name><argument_list>(<argument><expr><name>snode</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>mem_err2</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>an</name> <operator>=</operator> <call><name>onig_node_new_alt</name><argument_list>(<argument><expr><name>NULL_NODE</name></expr></argument>, <argument><expr><name>NULL_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>an</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>mem_err2</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>byte_len</name> <operator>!=</operator> <name>slen</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>p</name> <operator>+</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>byte_len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>expand_case_fold_make_rem_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rem</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>an</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err2</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>xnode</name> <operator>=</operator> <call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>NULL_NODE</name></expr></argument>, <argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>xnode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>an</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err2</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>xnode</name></expr></argument>, <argument><expr><name>rem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>an</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>xnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>an</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>xnode</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>an</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>snode</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>var_anode</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>an</name></expr>;</expr_stmt>
<expr_stmt><expr><name>var_anode</name> <operator>=</operator> <name>an</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>an</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>snode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NCDR</name><argument_list>(<argument><expr><name>anode</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>an</name></expr>;</expr_stmt>
<expr_stmt><expr><name>anode</name> <operator>=</operator> <name>an</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>varlen</name></expr>;</return>

<label><name>mem_err2</name>:</label>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>mem_err</name>:</label>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><operator>*</operator><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>expand_case_fold_string</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>alt_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>varlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>top_root</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>root</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>snode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCaseFoldCodeItem</name></type> <name><name>items</name><index>[<expr><name>ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NSTRING_IS_AMBIG</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>top_root</name> <operator>=</operator> <name>root</name> <operator>=</operator> <name>prev_node</name> <operator>=</operator> <name>snode</name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>alt_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ONIGENC_GET_CASE_FOLD_CODES_BY_STR</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>varlen</name> <operator>=</operator> <call><name>is_case_fold_variable_len</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>varlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>top_root</name> <operator>=</operator> <name>root</name> <operator>=</operator> <call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>NULL_NODE</name></expr></argument>, <argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prev_node</name> <operator>=</operator> <name>snode</name> <operator>=</operator> <call><name>onig_node_new_str</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>mem_err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_node_str_cat</name><argument_list>(<argument><expr><name>snode</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>alt_num</name> <operator>*=</operator> <operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>alt_num</name> <operator>&gt;</operator> <name>THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>update_string_node_case_fold</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NSTRING_SET_AMBIG</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>top_root</name> <operator>=</operator> <name>root</name> <operator>=</operator> <call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>NULL_NODE</name></expr></argument>, <argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>expand_case_fold_string_alt</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>mem_err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>top_root</name> <operator>=</operator> <name>prev_node</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>NCAR</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>snode</name> <operator>=</operator> <name>NULL_NODE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>update_string_node_case_fold</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NSTRING_SET_AMBIG</name><argument_list>(<argument><expr><name>snode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>srem</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>expand_case_fold_make_rem_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srem</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>mem_err</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>top_root</name> <operator>=</operator> <name>root</name> <operator>=</operator> <call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>NULL_NODE</name></expr></argument>, <argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>srem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>prev_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev_node</name> <operator>=</operator> <name>srem</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>srem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>srem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>mem_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>top_root</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>top_root</name></expr> </then><else>: <expr><name>prev_node</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>swap_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>top_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>mem_err</name>:</label>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_MEMORY</name></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CEC_THRES_NUM_BIG_REPEAT</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CEC_INFINITE_NUM</name></cpp:macro> <cpp:value>0x7fffffff</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CEC_IN_INFINITE_REPEAT</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CEC_IN_FINITE_REPEAT</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CEC_CONT_BIG_REPEAT</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_comb_exp_check</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><name>state</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>prev</name> <init>= <expr><name>NULL_NODE</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_comb_exp_check</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>setup_comb_exp_check</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>|=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>child_state</name> <init>= <expr><name>state</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>add_state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>target</name> <init>= <expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>var_num</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>child_state</name> <operator>|=</operator> <name>CEC_IN_FINITE_REPEAT</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>backrefed_mem</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_ENCLOSE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENCLOSE_MEMORY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_QTFR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>q</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>q</name><operator>-&gt;</operator><name>greedy</name></name> <operator>==</operator> <name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>child_state</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>&amp;</operator> <name>CEC_IN_FINITE_REPEAT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>comb_exp_check_num</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>var_num</name> <operator>=</operator> <name>CEC_INFINITE_NUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>child_state</name> <operator>|=</operator> <name>CEC_IN_INFINITE_REPEAT</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>var_num</name> <operator>=</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>-</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>var_num</name> <operator>&gt;=</operator> <name>CEC_THRES_NUM_BIG_REPEAT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>add_state</name> <operator>|=</operator> <name>CEC_CONT_BIG_REPEAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>CEC_IN_INFINITE_REPEAT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>var_num</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>CEC_CONT_BIG_REPEAT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>var_num</name> <operator>&gt;=</operator> <name>CEC_THRES_NUM_BIG_REPEAT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>comb_exp_check_num</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>num_comb_exp_check</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>comb_exp_check_num</name></name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>num_comb_exp_check</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>curr_max_regnum</name></name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>comb_exp_max_regnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>comb_exp_max_regnum</name></name> <operator>=</operator> <name><name>env</name><operator>-&gt;</operator><name>curr_max_regnum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_comb_exp_check</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>child_state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>|=</operator> <name>add_state</name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>curr_max_regnum</name></name> <operator>&lt;</operator> <name><name>en</name><operator>-&gt;</operator><name>regnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>curr_max_regnum</name></name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>regnum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_comb_exp_check</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_comb_exp_check</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_CALL_RECURSION</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>has_recursion</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_comb_exp_check</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_ALT</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_NOT</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_REPEAT</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_VAR_REPEAT</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_CALL</name></cpp:macro> <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_RECCALL</name></cpp:macro> <cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define>









<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<label><name>restart</name>:</label>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>prev</name> <init>= <expr><name>NULL_NODE</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>next_setup</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name>state</name> <operator>|</operator> <name>IN_ALT</name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_IGNORECASE</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NSTRING_IS_RAW</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>expand_case_fold_string</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<case>case <expr><name>NT_CANY</name></expr>:</case>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name> <init>= <expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BRefNode</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>BACKREFS_P</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>br</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>BIT_STATUS_ON_AT</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>backrefed_mem</name></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIT_STATUS_ON_AT</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>bt_mem_start</name></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_BACKREF_WITH_LEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IS_BACKREF_NEST_LEVEL</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIT_STATUS_ON_AT</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>NST_MEM_BACKREFED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>target</name> <init>= <expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>IN_REPEAT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>NST_IN_REPEAT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>target_empty_info</name></name> <operator>=</operator> <name>NQ_TARGET_IS_EMPTY</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>quantifiers_memory_node_info</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>target_empty_info</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
r = get_max_match_length(target, &amp;d, env);
if (r == 0 &amp;&amp; d == 0) {

qn-&gt;upper = 1;
if (qn-&gt;lower &gt; 1) qn-&gt;lower = 1;
if (NTYPE(target) == NT_STR) {
qn-&gt;upper = qn-&gt;lower = 0; 
}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>state</name> <operator>|=</operator> <name>IN_REPEAT</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>!=</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>|=</operator> <name>IN_VAR_REPEAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPAND_STRING_MAX_LENGTH</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_STR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>len</name> <init>= <expr><call><name>NSTRING_LEN</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>np</name></decl>;</decl_stmt>

<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>onig_node_new_str</name><argument_list>(<argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NSTR</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flag</name> <operator>=</operator> <name><name>sn</name><operator>-&gt;</operator><name>flag</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>len</name> <operator>&lt;=</operator> <name>EXPAND_STRING_MAX_LENGTH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_node_str_cat</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>||</operator> <call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>np1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>np2</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>np1</name> <operator>=</operator> <call><name>onig_node_new_list</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>np1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>swap_node</name><argument_list>(<argument><expr><name>np1</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>np2</name> <operator>=</operator> <call><name>onig_node_list_add</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>np1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>np2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>np1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>swap_node</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_OP_PUSH_OR_JUMP_EXACT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>qn</name><operator>-&gt;</operator><name>target_empty_info</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_QTFR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>tqn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>tqn</name><operator>-&gt;</operator><name>head_exact</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>head_exact</name></name> <operator>=</operator> <name><name>tqn</name><operator>-&gt;</operator><name>head_exact</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tqn</name><operator>-&gt;</operator><name>head_exact</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>qn</name><operator>-&gt;</operator><name>head_exact</name></name> <operator>=</operator> <call><name>get_head_value_node</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_OPTION</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>options</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <operator>(</operator><name>IN_ALT</name> <operator>|</operator> <name>IN_NOT</name> <operator>|</operator> <name>IN_VAR_REPEAT</name> <operator>|</operator> <name>IN_CALL</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIT_STATUS_ON_AT</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>bt_mem_start</name></name></expr></argument>, <argument><expr><name><name>en</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_CALLED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>|=</operator> <name>IN_CALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_RECURSION</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>|=</operator> <name>IN_RECCALL</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>IN_RECCALL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SET_CALL_RECURSION</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>target</name> <init>= <expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_QTFR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>tqn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>tqn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>tqn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<name><name>tqn</name><operator>-&gt;</operator><name>greedy</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name>qtype</name> <init>= <expr><call><name>NTYPE</name><argument_list>(<argument><expr><name><name>tqn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NODE_TYPE_SIMPLE</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SET_ENCLOSE_STATUS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NST_STOP_BT_SIMPLE_REPEAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>IS_ENCLOSE_NAME_REF</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>env</name><operator>-&gt;</operator><name>num_named</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ONIG_IS_OPTION_ON</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><name>ONIG_OPTION_CAPTURE_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>num_mem</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_BACKREF</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>AnchorNode</name><modifier>*</modifier></type> <name>an</name> <init>= <expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>an</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name>state</name> <operator>|</operator> <name>IN_NOT</name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOWED_TYPE_IN_LB</name></cpp:macro> <cpp:value>( BIT_NT_LIST | BIT_NT_ALT | BIT_NT_STR | BIT_NT_CCLASS | BIT_NT_CTYPE | BIT_NT_CANY | BIT_NT_ANCHOR | BIT_NT_ENCLOSE | BIT_NT_QTFR | BIT_NT_CALL )</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOWED_ENCLOSE_IN_LB</name></cpp:macro> <cpp:value>( ENCLOSE_MEMORY | ENCLOSE_OPTION )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOWED_ENCLOSE_IN_LB_NOT</name></cpp:macro> <cpp:value>ENCLOSE_OPTION</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOWED_ANCHOR_IN_LB</name></cpp:macro> <cpp:value>( ANCHOR_LOOK_BEHIND | ANCHOR_LOOK_BEHIND_NOT | ANCHOR_BEGIN_LINE | ANCHOR_END_LINE | ANCHOR_BEGIN_BUF | ANCHOR_BEGIN_POSITION | ANCHOR_KEEP | ANCHOR_WORD_BOUND | ANCHOR_NOT_WORD_BOUND | ANCHOR_WORD_BEGIN | ANCHOR_WORD_END )</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOWED_ANCHOR_IN_LB_NOT</name></cpp:macro> <cpp:value>( ANCHOR_LOOK_BEHIND | ANCHOR_LOOK_BEHIND_NOT | ANCHOR_BEGIN_LINE | ANCHOR_END_LINE | ANCHOR_BEGIN_BUF | ANCHOR_BEGIN_POSITION | ANCHOR_KEEP | ANCHOR_WORD_BOUND | ANCHOR_NOT_WORD_BOUND | ANCHOR_WORD_BEGIN | ANCHOR_WORD_END )</cpp:value></cpp:define>





<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_type_tree</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>ALLOWED_TYPE_IN_LB</name></expr></argument>,
<argument><expr><name>ALLOWED_ENCLOSE_IN_LB</name></expr></argument>, <argument><expr><name>ALLOWED_ANCHOR_IN_LB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_LOOK_BEHIND_PATTERN</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NT_ANCHOR</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>restart</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_look_behind</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_type_tree</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>ALLOWED_TYPE_IN_LB</name></expr></argument>,
<argument><expr><name>ALLOWED_ENCLOSE_IN_LB_NOT</name></expr></argument>, <argument><expr><name>ALLOWED_ANCHOR_IN_LB_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_INVALID_LOOK_BEHIND_PATTERN</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NT_ANCHOR</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>restart</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><name><name>an</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name>state</name> <operator>|</operator> <name>IN_NOT</name><operator>)</operator></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_look_behind</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUNDAY_QUICK_SEARCH</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_bm_skip</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>,
<parameter><decl><type><name>UChar</name></type> <name><name>skip</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier><modifier>*</modifier></type> <name>int_skip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_case</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>, <decl><type ref="prev"/><name>flen</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><name>ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM</name></expr>]</index><index>[<expr><name>ONIGENC_MBC_CASE_FOLD_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCaseFoldCodeItem</name></type> <name><name>items</name><index>[<expr><name>ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>skip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><name>len</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>clen</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ONIGENC_GET_CASE_FOLD_CODES_BY_STR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <name>clen</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clen</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>code_len</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>byte_len</name> <operator>!=</operator> <name>clen</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>!=</operator> <name>clen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>skip</name><index>[<expr><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>skip</name><index>[<expr><name><name>buf</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXACT_MAXLEN</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr></cpp:if>

<return>return <expr><name>ONIGERR_TYPE_BUG</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>int_skip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>int_skip</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>int_skip</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>int_skip</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><name>len</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>clen</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ONIGENC_GET_CASE_FOLD_CODES_BY_STR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <name>clen</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clen</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>code_len</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>byte_len</name> <operator>!=</operator> <name>clen</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>!=</operator> <name>clen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>int_skip</name><operator>)</operator><index>[<expr><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>]</index> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>int_skip</name><operator>)</operator><index>[<expr><name><name>buf</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>]</index> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 


<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_bm_skip</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>,
<parameter><decl><type><name>UChar</name></type> <name><name>skip</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier><modifier>*</modifier></type> <name>int_skip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_case</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>, <decl><type ref="prev"/><name>flen</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><name>ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM</name></expr>]</index><index>[<expr><name>ONIGENC_MBC_CASE_FOLD_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCaseFoldCodeItem</name></type> <name><name>items</name><index>[<expr><name>ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>skip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>clen</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ONIGENC_GET_CASE_FOLD_CODES_BY_STR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <name>clen</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clen</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>code_len</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>byte_len</name> <operator>!=</operator> <name>clen</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>!=</operator> <name>clen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>skip</name><index>[<expr><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <name>i</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>skip</name><index>[<expr><name><name>buf</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <name>i</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXACT_MAXLEN</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr></cpp:if>

<return>return <expr><name>ONIGERR_TYPE_BUG</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>int_skip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>int_skip</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>int_skip</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>int_skip</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>clen</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ONIGENC_GET_CASE_FOLD_CODES_BY_STR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <name>clen</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clen</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>code_len</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>byte_len</name> <operator>!=</operator> <name>clen</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>!=</operator> <name>clen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>int_skip</name><operator>)</operator><index>[<expr><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>]</index> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <name>i</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>int_skip</name><operator>)</operator><index>[<expr><name><name>buf</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>]</index> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <name>i</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>min</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>max</name></decl>;</decl_stmt> 
}</block></struct></type> <name>MinMaxLen</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>MinMaxLen</name></type> <name>mmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>options</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>case_fold_flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>scan_env</name></decl>;</decl_stmt>
}</block></struct></type> <name>OptEnv</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>left_anchor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>right_anchor</name></decl>;</decl_stmt>
}</block></struct></type> <name>OptAncInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>MinMaxLen</name></type> <name>mmd</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>OptAncInfo</name></type> <name>anc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>reach_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_case</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>s</name><index>[<expr><name>OPT_EXACT_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>OptExactInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>MinMaxLen</name></type> <name>mmd</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>OptAncInfo</name></type> <name>anc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>UChar</name></type> <name><name>map</name><index>[<expr><name>ONIG_CHAR_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>OptMapInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>MinMaxLen</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OptAncInfo</name></type> <name>anc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OptExactInfo</name></type> <name>exb</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>OptExactInfo</name></type> <name>exm</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>OptExactInfo</name></type> <name>expr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>OptMapInfo</name></type> <name>map</name></decl>;</decl_stmt> 
}</block></struct></type> <name>NodeOptInfo</name>;</typedef>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>map_position_value</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>short</name> <name>int</name></type> <name><name>ByteValTable</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="number">5</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">12</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>,
<expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>,
<expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>,
<expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>,
<expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>,
<expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">1</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>ByteValTable</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">20</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>int</name> <operator>)</operator><name><name>ByteValTable</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">4</literal></expr>;</return></block_content></block></else></if_stmt> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>distance_value</name><parameter_list>(<parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>short</name> <name>int</name></type> <name><name>dist_vals</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="number">1000</literal></expr>, <expr><literal type="number">500</literal></expr>, <expr><literal type="number">333</literal></expr>, <expr><literal type="number">250</literal></expr>, <expr><literal type="number">200</literal></expr>, <expr><literal type="number">167</literal></expr>, <expr><literal type="number">143</literal></expr>, <expr><literal type="number">125</literal></expr>, <expr><literal type="number">111</literal></expr>, <expr><literal type="number">100</literal></expr>,
<expr><literal type="number">91</literal></expr>, <expr><literal type="number">83</literal></expr>, <expr><literal type="number">77</literal></expr>, <expr><literal type="number">71</literal></expr>, <expr><literal type="number">67</literal></expr>, <expr><literal type="number">63</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">50</literal></expr>,
<expr><literal type="number">48</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">43</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">33</literal></expr>,
<expr><literal type="number">32</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">25</literal></expr>,
<expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">20</literal></expr>,
<expr><literal type="number">20</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">17</literal></expr>,
<expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>,
<expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>,
<expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>,
<expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigDistance</name></type> <name>d</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mm</name><operator>-&gt;</operator><name>max</name></name> <operator>==</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>mm</name><operator>-&gt;</operator><name>max</name></name> <operator>-</operator> <name><name>mm</name><operator>-&gt;</operator><name>min</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>dist_vals</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>int</name> <operator>)</operator><name><name>dist_vals</name><index>[<expr><name>d</name></expr>]</index></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>comp_distance_value</name><parameter_list>(<parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>d1</name></decl></parameter>, <parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>d2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>v2</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>v1</name> <operator>*=</operator> <call><name>distance_value</name><argument_list>(<argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>*=</operator> <call><name>distance_value</name><argument_list>(<argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v2</name> <operator>&gt;</operator> <name>v1</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>v2</name> <operator>&lt;</operator> <name>v1</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>d2</name><operator>-&gt;</operator><name>min</name></name> <operator>&lt;</operator> <name><name>d1</name><operator>-&gt;</operator><name>min</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d2</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <name><name>d1</name><operator>-&gt;</operator><name>min</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_equal_mml</name><parameter_list>(<parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>min</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>min</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>max</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>max</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_mml</name><parameter_list>(<parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>mml</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>mml</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mml</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_mml</name><parameter_list>(<parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>mml</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>mml</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>mml</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_mml</name><parameter_list>(<parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>min</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>max</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_mml</name><parameter_list>(<parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <call><name>distance_add</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <call><name>distance_add</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>max</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void
add_len_mml(MinMaxLen* to, OnigDistance len)
{
to-&gt;min = distance_add(to-&gt;min, len);
to-&gt;max = distance_add(to-&gt;max, len);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alt_merge_mml</name><parameter_list>(<parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <name><name>from</name><operator>-&gt;</operator><name>min</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>min</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>max</name></name> <operator>&lt;</operator> <name><name>from</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>max</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_opt_env</name><parameter_list>(<parameter><decl><type><name>OptEnv</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptEnv</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_opt_anc_info</name><parameter_list>(<parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>anc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>anc</name><operator>-&gt;</operator><name>left_anchor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>anc</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_opt_anc_info</name><parameter_list>(<parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>concat_opt_anc_info</name><parameter_list>(<parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>right</name></decl></parameter>,
<parameter><decl><type><name>OnigDistance</name></type> <name>left_len</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>right_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>clear_opt_anc_info</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>left_anchor</name></name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>left_anchor</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>left_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>left_anchor</name></name> <operator>|=</operator> <name><name>right</name><operator>-&gt;</operator><name>left_anchor</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>=</operator> <name><name>right</name><operator>-&gt;</operator><name>right_anchor</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>right_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>|=</operator> <name><name>left</name><operator>-&gt;</operator><name>right_anchor</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>|=</operator> <operator>(</operator><name><name>left</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>&amp;</operator> <name>ANCHOR_PREC_READ_NOT</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_left_anchor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>anc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>anc</name> <operator>==</operator> <name>ANCHOR_END_BUF</name> <operator>||</operator> <name>anc</name> <operator>==</operator> <name>ANCHOR_SEMI_END_BUF</name> <operator>||</operator>
<name>anc</name> <operator>==</operator> <name>ANCHOR_END_LINE</name> <operator>||</operator> <name>anc</name> <operator>==</operator> <name>ANCHOR_PREC_READ</name> <operator>||</operator>
<name>anc</name> <operator>==</operator> <name>ANCHOR_PREC_READ_NOT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_set_opt_anc_info</name><parameter_list>(<parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>anc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>to</name><operator>-&gt;</operator><name>left_anchor</name></name> <operator>&amp;</operator> <name>anc</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>to</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>&amp;</operator> <name>anc</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_opt_anc_info</name><parameter_list>(<parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>anc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_left_anchor</name><argument_list>(<argument><expr><name>anc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>left_anchor</name></name> <operator>|=</operator> <name>anc</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>|=</operator> <name>anc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_opt_anc_info</name><parameter_list>(<parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>anc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_left_anchor</name><argument_list>(<argument><expr><name>anc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>left_anchor</name></name> <operator>&amp;=</operator> <operator>~</operator><name>anc</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>&amp;=</operator> <operator>~</operator><name>anc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alt_merge_opt_anc_info</name><parameter_list>(<parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>add</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>left_anchor</name></name> <operator>&amp;=</operator> <name><name>add</name><operator>-&gt;</operator><name>left_anchor</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>&amp;=</operator> <name><name>add</name><operator>-&gt;</operator><name>right_anchor</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_full_opt_exact_info</name><parameter_list>(<parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>ex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>ex</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <name>OPT_EXACT_MAXLEN</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_opt_exact_info</name><parameter_list>(<parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>ex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>clear_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ex</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ex</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ex</name><operator>-&gt;</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ex</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>ex</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ex</name><operator>-&gt;</operator><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_opt_exact_info</name><parameter_list>(<parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>concat_opt_exact_info</name><parameter_list>(<parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>add</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OptAncInfo</name></type> <name>tanc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>!=</operator> <name><name>add</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return ;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>add</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>len</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>OPT_EXACT_MAXLEN</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>reach_end</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>p</name> <operator>==</operator> <name>end</name></expr> ?</condition><then> <expr><name><name>add</name><operator>-&gt;</operator><name>reach_end</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>concat_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tanc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>to</name><operator>-&gt;</operator><name>reach_end</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>tanc</name><operator>.</operator><name>right_anchor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>copy_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tanc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>concat_opt_exact_info_str</name><parameter_list>(<parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>int</name> <name>raw</name></type> <name>ARG_UNUSED</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>len</name></name></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>OPT_EXACT_MAXLEN</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>OPT_EXACT_MAXLEN</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alt_merge_opt_exact_info</name><parameter_list>(<parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>add</name></decl></parameter>, <parameter><decl><type><name>OptEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>to</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>clear_opt_exact_info</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return ;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>is_equal_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>clear_opt_exact_info</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return ;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>add</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>add</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <name><name>to</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>add</name><operator>-&gt;</operator><name>s</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>add</name><operator>-&gt;</operator><name>reach_end</name></name> <operator>||</operator> <name>i</name> <operator>&lt;</operator> <name><name>add</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name>i</name> <operator>&lt;</operator> <name><name>to</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>=</operator> <name><name>add</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>|=</operator> <name><name>add</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alt_merge_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>to</name><operator>-&gt;</operator><name>reach_end</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>anc</name><operator>.</operator><name>right_anchor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>select_opt_exact_info</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>alt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v1</name></decl>, <decl><type ref="prev"/><name>v2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v1</name> <operator>=</operator> <name><name>now</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>=</operator> <name><name>alt</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return ;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>v1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_opt_exact_info</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return ;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>v1</name> <operator>&lt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>v2</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>map_position_value</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>now</name><operator>-&gt;</operator><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>map_position_value</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>alt</name><operator>-&gt;</operator><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>now</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v1</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>alt</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v2</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>now</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v1</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>alt</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v2</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>comp_distance_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>now</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alt</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_opt_exact_info</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_opt_map_info</name><parameter_list>(<parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>OptMapInfo</name></type> <name>clean_info</name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>,
<expr><block>{
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xmemcpy</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clean_info</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OptMapInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_opt_map_info</name><parameter_list>(<parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_char_opt_map_info</name><parameter_list>(<parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>UChar</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>c</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>value</name></name> <operator>+=</operator> <call><name>map_position_value</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_char_amb_opt_map_info</name><parameter_list>(<parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>OnigCaseFoldType</name></type> <name>case_fold_flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigCaseFoldCodeItem</name></type> <name><name>items</name><index>[<expr><name>ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>add_char_opt_map_info</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>case_fold_flag</name> <operator>=</operator> <call><name>DISABLE_CASE_FOLD_MULTI_CHAR</name><argument_list>(<argument><expr><name>case_fold_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ONIGENC_GET_CASE_FOLD_CODES_BY_STR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>case_fold_flag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>n</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ONIGENC_CODE_TO_MBC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_char_opt_map_info</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>select_opt_map_info</name><parameter_list>(<parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>alt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>z</name> <init>= <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">15</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>v1</name></decl>, <decl><type ref="prev"/><name>v2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>alt</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>now</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_opt_map_info</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return ;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>v1</name> <operator>=</operator> <name>z</name> <operator>/</operator> <name><name>now</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>=</operator> <name>z</name> <operator>/</operator> <name><name>alt</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>comp_distance_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>now</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alt</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_opt_map_info</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>comp_opt_exact_or_map_info</name><parameter_list>(<parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_EM_BASE</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>ve</name></decl>, <decl><type ref="prev"/><name>vm</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>value</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ve</name> <operator>=</operator> <name>COMP_EM_BASE</name> <operator>*</operator> <name><name>e</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>vm</name> <operator>=</operator> <name>COMP_EM_BASE</name> <operator>*</operator> <literal type="number">5</literal> <operator>*</operator> <literal type="number">2</literal> <operator>/</operator> <name><name>m</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>comp_distance_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>, <argument><expr><name>ve</name></expr></argument>, <argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alt_merge_opt_map_info</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>add</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>to</name><operator>-&gt;</operator><name>mmd</name><operator>.</operator><name>max</name></name> <operator>&lt;</operator> <name><name>add</name><operator>-&gt;</operator><name>mmd</name><operator>.</operator><name>min</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>clear_opt_map_info</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return ;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>alt_merge_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>map_position_value</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>alt_merge_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_bound_node_opt_info</name><parameter_list>(<parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>opt</name></decl></parameter>, <parameter><decl><type><name>MinMaxLen</name><modifier>*</modifier></type> <name>mmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>copy_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>mmd</name></name><operator>)</operator></expr></argument>, <argument><expr><name>mmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>expr</name><operator>.</operator><name>mmd</name></name><operator>)</operator></expr></argument>, <argument><expr><name>mmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>map</name><operator>.</operator><name>mmd</name></name><operator>)</operator></expr></argument>, <argument><expr><name>mmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_node_opt_info</name><parameter_list>(<parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>clear_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>exm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_opt_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_node_opt_info</name><parameter_list>(<parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>concat_left_node_opt_info</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>add</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>exb_reach</name></decl>, <decl><type ref="prev"/><name>exm_reach</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OptAncInfo</name></type> <name>tanc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>concat_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tanc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name></expr></argument>, <argument><expr><name><name>add</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tanc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>to</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>concat_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tanc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>anc</name></name></expr></argument>,
<argument><expr><name><name>to</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name></expr></argument>, <argument><expr><name><name>add</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tanc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>map</name><operator>.</operator><name>value</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>to</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>map</name><operator>.</operator><name>mmd</name><operator>.</operator><name>max</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>add</name><operator>-&gt;</operator><name>map</name><operator>.</operator><name>anc</name><operator>.</operator><name>left_anchor</name></name> <operator>|=</operator> <name><name>to</name><operator>-&gt;</operator><name>anc</name><operator>.</operator><name>left_anchor</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>exb_reach</name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>reach_end</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>exm_reach</name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>exm</name><operator>.</operator><name>reach_end</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>reach_end</name></name> <operator>=</operator> <name><name>to</name><operator>-&gt;</operator><name>exm</name><operator>.</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>exb_reach</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>concat_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>exm_reach</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>concat_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>exm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>select_opt_exact_info</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>exm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>select_opt_exact_info</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>exm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>expr</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>expr</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <operator>(</operator><name>int</name> <operator>)</operator><name><name>add</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>expr</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><name><name>add</name><operator>-&gt;</operator><name>len</name><operator>.</operator><name>max</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>expr</name><operator>.</operator><name>mmd</name><operator>.</operator><name>max</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>select_opt_exact_info</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>select_opt_exact_info</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>exm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>add</name><operator>-&gt;</operator><name>expr</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>select_opt_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alt_merge_node_opt_info</name><parameter_list>(<parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>add</name></decl></parameter>, <parameter><decl><type><name>OptEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>alt_merge_opt_anc_info</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alt_merge_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alt_merge_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>exm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>exm</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alt_merge_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alt_merge_opt_map_info</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>alt_merge_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>add</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NODE_OPT_INFO_REF_COUNT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>optimize_node_left</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>NodeOptInfo</name><modifier>*</modifier></type> <name>opt</name></decl></parameter>, <parameter><decl><type><name>OptEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>clear_node_opt_info</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_bound_node_opt_info</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>mmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OptEnv</name></type> <name>nenv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NodeOptInfo</name></type> <name>nopt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>nd</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>copy_opt_env</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nenv</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>nd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nopt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nenv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nenv</name><operator>.</operator><name>mmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nopt</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>concat_left_node_opt_info</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>nd</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>nd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ALT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>NodeOptInfo</name></type> <name>nopt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>nd</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>nd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nopt</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nd</name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>copy_node_opt_info</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>alt_merge_node_opt_info</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nopt</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>r</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>nd</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>nd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>StrNode</name><modifier>*</modifier></type> <name>sn</name> <init>= <expr><call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>slen</name> <init>= <expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_raw</name> <init>= <expr><call><name>NSTRING_IS_RAW</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>NSTRING_IS_AMBIG</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>concat_opt_exact_info_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>,
<argument><expr><name>is_raw</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>ignore_case</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_char_opt_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name><name>sn</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>max</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NSTRING_IS_DONT_GET_OPT_INFO</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>onigenc_strlen</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>ONIGENC_MBC_MAXLEN_DIST</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>concat_opt_exact_info_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>,
<argument><expr><name>is_raw</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>ignore_case</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_char_amb_opt_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sn</name><operator>-&gt;</operator><name>end</name></name></expr></argument>,
<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <name>slen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>OnigDistance</name> <operator>)</operator><name><name>opt</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name> <init>= <expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>min</name> <init>= <expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>max</name> <init>= <expr><call><name>ONIGENC_MBC_MAXLEN_DIST</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>BITSET_AT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>z</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>z</name> <operator>&amp;&amp;</operator> <call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_char_opt_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name> <operator>)</operator><name>i</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maxcode</name></decl>;</decl_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>ONIGENC_MBC_MAXLEN_DIST</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>max</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>maxcode</name> <operator>=</operator> <ternary><condition><expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ascii_range</name></expr> ?</condition><then> <expr><literal type="number">0x80</literal></expr> </then><else>: <expr><name>SINGLE_BYTE_SIZE</name></expr></else></ternary></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ONIGENC_CTYPE_WORD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SINGLE_BYTE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ONIGENC_IS_CODE_WORD</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name>maxcode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_char_opt_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name> <operator>)</operator><name>i</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxcode</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_CODE_WORD</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_char_opt_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name> <operator>)</operator><name>i</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_CANY</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>min</name> <init>= <expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>max</name> <init>= <expr><call><name>ONIGENC_MBC_MAXLEN_DIST</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<switch>switch <condition>(<expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_BEGIN_BUF</name></expr>:</case>
<case>case <expr><name>ANCHOR_BEGIN_POSITION</name></expr>:</case>
<case>case <expr><name>ANCHOR_BEGIN_LINE</name></expr>:</case>
<case>case <expr><name>ANCHOR_END_BUF</name></expr>:</case>
<case>case <expr><name>ANCHOR_SEMI_END_BUF</name></expr>:</case>
<case>case <expr><name>ANCHOR_END_LINE</name></expr>:</case>
<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case> 
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case> 
<expr_stmt><expr><call><name>add_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>NodeOptInfo</name></type> <name>nopt</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nopt</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nopt</name><operator>.</operator><name>exb</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nopt</name><operator>.</operator><name>exb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>nopt</name><operator>.</operator><name>exm</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nopt</name><operator>.</operator><name>exm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>expr</name><operator>.</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nopt</name><operator>.</operator><name>map</name><operator>.</operator><name>value</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_opt_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nopt</name><operator>.</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>backs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>, <decl><type ref="prev"/><name>tmin</name></decl>, <decl><type ref="prev"/><name>tmax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name> <init>= <expr><call><name>SCANENV_MEM_NODES</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>scan_env</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BRefNode</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>br</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>NST_RECURSION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ONIG_INFINITE_DISTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>backs</name> <operator>=</operator> <call><name>BACKREFS_P</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>backs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>min</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>scan_env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>backs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>scan_env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>br</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_min_match_length</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmin</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>scan_env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_max_match_length</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name><name>backs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmax</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>scan_env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name>tmin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min</name> <operator>=</operator> <name>tmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name>tmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name>tmax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_CALL_RECURSION</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ONIG_INFINITE_DISTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>save</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>NENCLOSE</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>save</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NodeOptInfo</name></type> <name>nopt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QtfrNode</name><modifier>*</modifier></type> <name>qn</name> <init>= <expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nopt</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>mmd</name><operator>.</operator><name>max</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>NTYPE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_CANY</name> <operator>&amp;&amp;</operator> <name><name>qn</name><operator>-&gt;</operator><name>greedy</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_MULTILINE</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><name>ANCHOR_ANYCHAR_STAR_ML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><name>ANCHOR_ANYCHAR_STAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_node_opt_info</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nopt</name><operator>.</operator><name>exb</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nopt</name><operator>.</operator><name>exb</name><operator>.</operator><name>reach_end</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator> <call><name>is_full_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>concat_opt_exact_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>exb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nopt</name><operator>.</operator><name>exb</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>!=</operator> <name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>exb</name><operator>.</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>exm</name><operator>.</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>exm</name><operator>.</operator><name>reach_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>distance_multiply</name><argument_list>(<argument><expr><name><name>nopt</name><operator>.</operator><name>len</name><operator>.</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_REPEAT_INFINITE</name><argument_list>(<argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>nopt</name><operator>.</operator><name>len</name><operator>.</operator><name>max</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ONIG_INFINITE_DISTANCE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>distance_multiply</name><argument_list>(<argument><expr><name><name>nopt</name><operator>.</operator><name>len</name><operator>.</operator><name>max</name></name></expr></argument>, <argument><expr><name><name>qn</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>EncloseNode</name><modifier>*</modifier></type> <name>en</name> <init>= <expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_OPTION</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>save</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>option</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>save</name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>en</name><operator>-&gt;</operator><name>opt_count</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>opt_count</name></name> <operator>&gt;</operator> <name>MAX_NODE_OPT_INFO_REF_COUNT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MIN_FIXED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>min_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_ENCLOSE_MAX_FIXED</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>max_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_set_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><name>ANCHOR_ANYCHAR_STAR_MASK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>scan_env</name><operator>-&gt;</operator><name>backrefed_mem</name></name></expr></argument>, <argument><expr><name><name>en</name><operator>-&gt;</operator><name>regnum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_opt_anc_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>anc</name></name></expr></argument>, <argument><expr><name>ANCHOR_ANYCHAR_STAR_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<expr_stmt><expr><call><name>set_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ONIG_INFINITE_DISTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>

<default>default:</default>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"optimize_node_left: undefined node type %d\n"</literal></expr></argument>,
<argument><expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>ONIGERR_TYPE_BUG</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_optimize_exact_info</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>OptExactInfo</name><modifier>*</modifier></type> <name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>allow_reverse</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_NULL_RETURN_MEMERR</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xmemcpy</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>exact</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>allow_reverse</name> <operator>=</operator>
<call><name>ONIGENC_IS_ALLOWED_REVERSE_MATCH</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>||</operator> <operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>allow_reverse</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>set_bm_skip</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>,
<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>int_map</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>allow_reverse</name> <operator>!=</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><name>ONIG_OPTIMIZE_EXACT_BM_IC</name></expr> </then><else>: <expr><name>ONIG_OPTIMIZE_EXACT_BM_NOT_REV_IC</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>=</operator> <name>ONIG_OPTIMIZE_EXACT_IC</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>=</operator> <name>ONIG_OPTIMIZE_EXACT_IC</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>||</operator> <operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>allow_reverse</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>set_bm_skip</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>,
<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>int_map</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>allow_reverse</name> <operator>!=</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><name>ONIG_OPTIMIZE_EXACT_BM</name></expr> </then><else>: <expr><name>ONIG_OPTIMIZE_EXACT_BM_NOT_REV</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>=</operator> <name>ONIG_OPTIMIZE_EXACT</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>=</operator> <name>ONIG_OPTIMIZE_EXACT</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>dmin</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>mmd</name><operator>.</operator><name>min</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>dmax</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>mmd</name><operator>.</operator><name>max</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>dmin</name></name> <operator>!=</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>threshold_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>dmin</name></name> <operator>+</operator> <operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name> <operator>-</operator> <name><name>reg</name><operator>-&gt;</operator><name>exact</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_optimize_map_info</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>OptMapInfo</name><modifier>*</modifier></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>=</operator> <name>ONIG_OPTIMIZE_MAP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>dmin</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>mmd</name><operator>.</operator><name>min</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>dmax</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>mmd</name><operator>.</operator><name>max</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>dmin</name></name> <operator>!=</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>threshold_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>)</operator><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>dmin</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_sub_anchor</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>OptAncInfo</name><modifier>*</modifier></type> <name>anc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>sub_anchor</name></name> <operator>|=</operator> <name><name>anc</name><operator>-&gt;</operator><name>left_anchor</name></name> <operator>&amp;</operator> <name>ANCHOR_BEGIN_LINE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>sub_anchor</name></name> <operator>|=</operator> <name><name>anc</name><operator>-&gt;</operator><name>right_anchor</name></name> <operator>&amp;</operator> <name>ANCHOR_END_LINE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_COMPILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_MATCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_optimize_info</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_optimize_info_from_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>scan_env</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NodeOptInfo</name></type> <name>opt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OptEnv</name></type> <name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>env</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>.</operator><name>options</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>.</operator><name>case_fold_flag</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>case_fold_flag</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>env</name><operator>.</operator><name>scan_env</name></name> <operator>=</operator> <name>scan_env</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_mml</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>.</operator><name>mmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>optimize_node_left</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor</name></name> <operator>=</operator> <name><name>opt</name><operator>.</operator><name>anc</name><operator>.</operator><name>left_anchor</name></name> <operator>&amp;</operator> <operator>(</operator><name>ANCHOR_BEGIN_BUF</name> <operator>|</operator>
<name>ANCHOR_BEGIN_POSITION</name> <operator>|</operator> <name>ANCHOR_ANYCHAR_STAR</name> <operator>|</operator> <name>ANCHOR_ANYCHAR_STAR_ML</name> <operator>|</operator>
<name>ANCHOR_LOOK_BEHIND</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>opt</name><operator>.</operator><name>anc</name><operator>.</operator><name>left_anchor</name></name> <operator>&amp;</operator> <operator>(</operator><name>ANCHOR_LOOK_BEHIND</name> <operator>|</operator> <name>ANCHOR_PREC_READ_NOT</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ANCHOR_ANYCHAR_STAR_ML</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor</name></name> <operator>|=</operator> <name><name>opt</name><operator>.</operator><name>anc</name><operator>.</operator><name>right_anchor</name></name> <operator>&amp;</operator> <operator>(</operator><name>ANCHOR_END_BUF</name> <operator>|</operator> <name>ANCHOR_SEMI_END_BUF</name> <operator>|</operator>
<name>ANCHOR_PREC_READ_NOT</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>anchor</name></name> <operator>&amp;</operator> <operator>(</operator><name>ANCHOR_END_BUF</name> <operator>|</operator> <name>ANCHOR_SEMI_END_BUF</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor_dmin</name></name> <operator>=</operator> <name><name>opt</name><operator>.</operator><name>len</name><operator>.</operator><name>min</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor_dmax</name></name> <operator>=</operator> <name><name>opt</name><operator>.</operator><name>len</name><operator>.</operator><name>max</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>.</operator><name>exb</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>opt</name><operator>.</operator><name>exm</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>select_opt_exact_info</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>exb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>exm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>.</operator><name>map</name><operator>.</operator><name>value</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>comp_opt_exact_or_map_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>exb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>map</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>set_map</name>;</goto>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>set_optimize_exact_info</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>exb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_sub_anchor</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>exb</name><operator>.</operator><name>anc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>.</operator><name>map</name><operator>.</operator><name>value</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<label><name>set_map</name>:</label>
<expr_stmt><expr><call><name>set_optimize_map_info</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_sub_anchor</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>map</name><operator>.</operator><name>anc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>sub_anchor</name></name> <operator>|=</operator> <name><name>opt</name><operator>.</operator><name>anc</name><operator>.</operator><name>left_anchor</name></name> <operator>&amp;</operator> <name>ANCHOR_BEGIN_LINE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>.</operator><name>len</name><operator>.</operator><name>max</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>sub_anchor</name></name> <operator>|=</operator> <name><name>opt</name><operator>.</operator><name>anc</name><operator>.</operator><name>right_anchor</name></name> <operator>&amp;</operator> <name>ANCHOR_END_LINE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_COMPILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_MATCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>print_optimize_info</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_optimize_info</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>=</operator> <name>ONIG_OPTIMIZE_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor_dmin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor_dmax</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>sub_anchor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>threshold_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_enc_string</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\nPATTERN: /"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>ONIGENC_MBC_TO_CODE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>code</name> <operator>&gt;=</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" 0x%04x "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>(</operator><name>int</name> <operator>)</operator><name>code</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else <block>{<block_content>
<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/ (%s)\n"</literal></expr></argument>, <argument><expr><name><name>enc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_COMPILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_MATCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_distance_range</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>OnigDistance</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"inf"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"(%"</literal><name>PRIuPTR</name><literal type="string">")"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>ONIG_INFINITE_DISTANCE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"inf"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"(%"</literal><name>PRIuPTR</name><literal type="string">")"</literal></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_anchor</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>anchor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>q</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&amp;</operator> <name>ANCHOR_BEGIN_BUF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"begin-buf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&amp;</operator> <name>ANCHOR_BEGIN_LINE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"begin-line"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&amp;</operator> <name>ANCHOR_BEGIN_POSITION</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"begin-pos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&amp;</operator> <name>ANCHOR_END_BUF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"end-buf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&amp;</operator> <name>ANCHOR_SEMI_END_BUF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"semi-end-buf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&amp;</operator> <name>ANCHOR_END_LINE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"end-line"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&amp;</operator> <name>ANCHOR_ANYCHAR_STAR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"anychar-star"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>anchor</name> <operator>&amp;</operator> <name>ANCHOR_ANYCHAR_STAR_ML</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"anychar-star-ml"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_optimize_info</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>on</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"NONE"</literal></expr>, <expr><literal type="string">"EXACT"</literal></expr>, <expr><literal type="string">"EXACT_BM"</literal></expr>, <expr><literal type="string">"EXACT_BM_NOT_REV"</literal></expr>,
<expr><literal type="string">"EXACT_IC"</literal></expr>, <expr><literal type="string">"MAP"</literal></expr>,
<expr><literal type="string">"EXACT_BM_IC"</literal></expr>, <expr><literal type="string">"EXACT_BM_NOT_REV_IC"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"optimize: %s\n"</literal></expr></argument>, <argument><expr><name><name>on</name><index>[<expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" anchor: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>print_anchor</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>anchor</name></name> <operator>&amp;</operator> <name>ANCHOR_END_BUF_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_distance_range</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor_dmin</name></name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>anchor_dmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" sub anchor: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>print_anchor</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>sub_anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"exact: ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"]: length: %"</literal><name>PRIdPTR</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name> <operator>-</operator> <name><name>reg</name><operator>-&gt;</operator><name>exact</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>optimize</name></name> <operator>&amp;</operator> <name>ONIG_OPTIMIZE_MAP</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"map: n=%d\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'['</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MAXLEN</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<call><name>ONIGENC_IS_CODE_PRINT</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>OnigCodePoint</name> <operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 


<function><type><specifier>extern</specifier> <name>void</name></type>
<name>onig_free_body</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>int_map</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>int_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>int_map_backward</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>int_map_backward</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>onig_names_free</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>onig_free</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onig_free_body</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>size_t</name></type>
<name>onig_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>regex_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>reg</name><operator>-&gt;</operator><name>alloc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>reg</name><operator>-&gt;</operator><name>exact_end</name></name> <operator>-</operator> <name><name>reg</name><operator>-&gt;</operator><name>exact</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>int_map</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>int_map_backward</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ONIG_CHAR_TABLE_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>reg</name><operator>-&gt;</operator><name>repeat_range_alloc</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OnigRepeatRange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>onig_memsize</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>onig_region_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OnigRegion</name> <modifier>*</modifier></type><name>regs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regs</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>regs</name><operator>-&gt;</operator><name>allocated</name></name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>regs</name><operator>-&gt;</operator><name>beg</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>regs</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGEX_TRANSFER</name><parameter_list>(<parameter><type><name>to</name></type></parameter>,<parameter><type><name>from</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {onig_free_body(to);xmemcpy(to, from, sizeof(regex_t));xfree(from);} while (0)</cpp:value></cpp:define>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
extern void
onig_transfer(regex_t* to, regex_t* from)
{
REGEX_TRANSFER(to, from);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_COMPILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_compiled_byte_code_list</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_PARSE_TREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_tree</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_compile</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern_end</name></decl></parameter>,
<parameter><decl><type><name>OnigErrorInfo</name><modifier>*</modifier></type> <name>einfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>onig_compile_ruby</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_end</name></expr></argument>, <argument><expr><name>einfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_compile_ruby</name><argument_list>(<argument><expr><name>regex_t</name><operator>*</operator> <name>reg</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>UChar</name><operator>*</operator> <name>pattern</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>UChar</name><operator>*</operator> <name>pattern_end</name></expr></argument>,
<argument><expr><name>OnigErrorInfo</name><operator>*</operator> <name>einfo</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>sourcefile</name></expr></argument>, <argument><expr><name>int</name> <name>sourceline</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
extern <name>int</name>
<name>onig_compile</name><argument_list>(<argument><expr><name>regex_t</name><operator>*</operator> <name>reg</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>UChar</name><operator>*</operator> <name>pattern</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>UChar</name><operator>*</operator> <name>pattern_end</name></expr></argument>,
<argument><expr><name>OnigErrorInfo</name><operator>*</operator> <name>einfo</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_INIT_SIZE</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>init_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ScanEnv</name></type> <name>scan_env</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UnsetAddrList</name></type> <name>uslist</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>einfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>einfo</name><operator>-&gt;</operator><name>par</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>scan_env</name><operator>.</operator><name>sourcefile</name></name> <operator>=</operator> <name>sourcefile</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>scan_env</name><operator>.</operator><name>sourceline</name></name> <operator>=</operator> <name>sourceline</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>print_enc_string</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>alloc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>init_size</name> <operator>=</operator> <operator>(</operator><name>pattern_end</name> <operator>-</operator> <name>pattern</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>init_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>init_size</name> <operator>=</operator> <name>COMPILE_INIT_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>BBUF_INIT</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>init_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_mem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_repeat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_null_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range_alloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>repeat_range</name></name> <operator>=</operator> <operator>(</operator><name>OnigRepeatRange</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_comb_exp_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_parse_make_tree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>root</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_end</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_PARSE_TREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
fprintf(stderr, "ORIGINAL PARSE TREE:\n");
print_tree(stderr, root);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>num_named</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_SYNTAX_BV</name><argument_list>(<argument><expr><name><name>scan_env</name><operator>.</operator><name>syntax</name></name></expr></argument>, <argument><expr><name>ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ONIG_IS_OPTION_ON</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>ONIG_OPTION_CAPTURE_GROUP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>num_named</name></name> <operator>!=</operator> <name><name>scan_env</name><operator>.</operator><name>num_mem</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>disable_noname_group_capture</name><argument_list>(<argument><expr><operator>&amp;</operator><name>root</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>numbered_ref_check</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>num_call</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>unset_addr_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uslist</name></expr></argument>, <argument><expr><name><name>scan_env</name><operator>.</operator><name>num_call</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>scan_env</name><operator>.</operator><name>unset_addr_list</name></name> <operator>=</operator> <operator>&amp;</operator><name>uslist</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_subexp_call</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_unset</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_recursive_check_trav</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_unset</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>subexp_inf_recursive_check_trav</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_unset</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_call</name></name> <operator>=</operator> <name><name>scan_env</name><operator>.</operator><name>num_call</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_call</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>setup_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_unset</name>;</goto></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_PARSE_TREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>print_tree</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>capture_history</name></name> <operator>=</operator> <name><name>scan_env</name><operator>.</operator><name>capture_history</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_start</name></name> <operator>=</operator> <name><name>scan_env</name><operator>.</operator><name>bt_mem_start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_start</name></name> <operator>|=</operator> <name><name>reg</name><operator>-&gt;</operator><name>capture_history</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_FIND_CONDITION</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BIT_STATUS_ON_ALL</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name> <operator>=</operator> <name><name>scan_env</name><operator>.</operator><name>bt_mem_end</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name> <operator>|=</operator> <name><name>reg</name><operator>-&gt;</operator><name>capture_history</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>backrefed_mem</name></name> <operator>==</operator> <literal type="number">0</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <name><name>scan_env</name><operator>.</operator><name>num_call</name></name> <operator>==</operator> <literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setup_comb_exp_check</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>has_recursion</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>scan_env</name><operator>.</operator><name>num_comb_exp_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>comb_exp_max_regnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>scan_env</name><operator>.</operator><name>comb_exp_max_regnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_STATUS_AT</name><argument_list>(<argument><expr><name><name>scan_env</name><operator>.</operator><name>backrefed_mem</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>scan_env</name><operator>.</operator><name>num_comb_exp_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>num_comb_exp_check</name></name> <operator>=</operator> <name><name>scan_env</name><operator>.</operator><name>num_comb_exp_check</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>clear_optimize_info</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DONT_OPTIMIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>set_optimize_info_from_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_unset</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>scan_env</name><operator>.</operator><name>mem_nodes_dynamic</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>scan_env</name><operator>.</operator><name>mem_nodes_dynamic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>scan_env</name><operator>.</operator><name>mem_nodes_dynamic</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_opcode</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>num_call</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>unset_addr_list_fix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uslist</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unset_addr_list_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>num_repeat</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_end</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>stack_pop_level</name></name> <operator>=</operator> <name>STACK_POP_LEVEL_ALL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>bt_mem_start</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>stack_pop_level</name></name> <operator>=</operator> <name>STACK_POP_LEVEL_MEM_START</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reg</name><operator>-&gt;</operator><name>stack_pop_level</name></name> <operator>=</operator> <name>STACK_POP_LEVEL_FREE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>num_call</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unset_addr_list_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_COMPILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>onig_print_names</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>print_compiled_byte_code_list</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>end</name>:</label>
<return>return <expr><name>r</name></expr>;</return>

<label><name>err_unset</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>scan_env</name><operator>.</operator><name>num_call</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unset_addr_list_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>err</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>scan_env</name><operator>.</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>einfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>einfo</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name><name>scan_env</name><operator>.</operator><name>enc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>einfo</name><operator>-&gt;</operator><name>par</name></name> <operator>=</operator> <name><name>scan_env</name><operator>.</operator><name>error</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>einfo</name><operator>-&gt;</operator><name>par_end</name></name> <operator>=</operator> <name><name>scan_env</name><operator>.</operator><name>error_end</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>onig_node_free</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name><name>scan_env</name><operator>.</operator><name>mem_nodes_dynamic</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>scan_env</name><operator>.</operator><name>mem_nodes_dynamic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>onig_inited</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_reg_init</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>OnigOptionType</name></type> <name>option</name></decl></parameter>,
<parameter><decl><type><name>OnigCaseFoldType</name></type> <name>case_fold_flag</name></decl></parameter>,
<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syntax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>onig_inited</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>onig_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_INVALID_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_IS_UNDEF</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ONIGERR_DEFAULT_ENCODING_IS_NOT_SET</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>option</name> <operator>&amp;</operator> <operator>(</operator><name>ONIG_OPTION_DONT_CAPTURE_GROUP</name><operator>|</operator><name>ONIG_OPTION_CAPTURE_GROUP</name><operator>)</operator><operator>)</operator>
<operator>==</operator> <operator>(</operator><name>ONIG_OPTION_DONT_CAPTURE_GROUP</name><operator>|</operator><name>ONIG_OPTION_CAPTURE_GROUP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ONIGERR_INVALID_COMBINATION_OF_OPTIONS</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>option</name> <operator>&amp;</operator> <name>ONIG_OPTION_NEGATE_SINGLELINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>option</name> <operator>|=</operator> <name><name>syntax</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>option</name> <operator>&amp;=</operator> <operator>~</operator><name>ONIG_OPTION_SINGLELINE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>option</name> <operator>|=</operator> <name><name>syntax</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>enc</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>options</name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>syntax</name> <operator>=</operator> <name>syntax</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>optimize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>exact</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>int_map</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>int_map_backward</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>chain</name> <operator>=</operator> <operator>(</operator><name>regex_t</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>alloc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>used</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>name_table</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator> <operator>)</operator><name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>reg</name><operator>)</operator><operator>-&gt;</operator><name>case_fold_flag</name> <operator>=</operator> <name>case_fold_flag</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_new_without_alloc</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern_end</name></decl></parameter>, <parameter><decl><type><name>OnigOptionType</name></type> <name>option</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syntax</name></decl></parameter>, <parameter><decl><type><name>OnigErrorInfo</name><modifier>*</modifier></type> <name>einfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_reg_init</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIGENC_CASE_FOLD_DEFAULT</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>syntax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_compile</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_end</name></expr></argument>, <argument><expr><name>einfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_new</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern_end</name></decl></parameter>,
<parameter><decl><type><name>OnigOptionType</name></type> <name>option</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syntax</name></decl></parameter>,
<parameter><decl><type><name>OnigErrorInfo</name><modifier>*</modifier></type> <name>einfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>reg</name> <operator>=</operator> <operator>(</operator><name>regex_t</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regex_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_reg_init</name><argument_list>(<argument><expr><operator>*</operator><name>reg</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIGENC_CASE_FOLD_DEFAULT</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>syntax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_compile</name><argument_list>(<argument><expr><operator>*</operator><name>reg</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_end</name></expr></argument>, <argument><expr><name>einfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><operator>*</operator><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>reg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_initialize</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name> <name><name>encodings</name><index>[]</index></name></type> <name>ARG_UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>n</name></type> <name>ARG_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>onig_init</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>onig_inited</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>onig_inited</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_MEMLEAK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_CrtSetDbgFlag</name><argument_list>(<argument><expr><name>_CRTDBG_ALLOC_MEM_DF</name> <operator>|</operator> <name>_CRTDBG_LEAK_CHECK_DF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>onigenc_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_STATISTICS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>onig_statistics_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>OnigEndCallListItemType</name><modifier>*</modifier></type> <name>EndCallTop</name></decl>;</decl_stmt>

<function><type><specifier>extern</specifier> <name>void</name></type> <name>onig_add_end_call</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigEndCallListItemType</name><modifier>*</modifier></type> <name>item</name></decl>;</decl_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>OnigEndCallListItemType</name><operator>*</operator> <operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return ;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>EndCallTop</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name>EndCallTop</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_end_call_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigEndCallListItemType</name><modifier>*</modifier></type> <name>prev</name></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<while>while <condition>(<expr><name>EndCallTop</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name><name>EndCallTop</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>EndCallTop</name></expr>;</expr_stmt>
<expr_stmt><expr><name>EndCallTop</name> <operator>=</operator> <name><name>EndCallTop</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_end</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>exec_end_call_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_STATISTICS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>onig_print_statistics</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_MEMLEAK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_CrtDumpMemoryLeaks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>onig_inited</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_is_in_code_range</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>high</name> <operator>=</operator> <name>n</name></expr>;</init> <condition><expr><name>low</name> <operator>&lt;</operator> <name>high</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>low</name> <operator>+</operator> <name>high</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>code</name> <operator>&gt;</operator> <name><name>data</name><index>[<expr><name>x</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>low</name> <operator>=</operator> <name>x</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>low</name> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator> <name>code</name> <operator>&gt;=</operator> <name><name>data</name><index>[<expr><name>low</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_is_code_in_cc_len</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elen</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>found</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>code</name> <operator>&gt;=</operator> <name>SINGLE_BYTE_SIZE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>onig_is_in_code_range</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>mbuf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>BITSET_AT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>bs</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><name>found</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>found</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>
<name>onig_is_code_in_cc</name><parameter_list>(<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>CClassNode</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ONIGENC_MBC_MINLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ONIGENC_CODE_TO_MBCLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name>onig_is_code_in_cc_len</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_SPECIAL</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_NON</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_RELADDR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_ABSADDR</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_LENGTH</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_MEMNUM</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_OPTION</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_STATE_CHECK</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<decl_stmt><decl><type><name>OnigOpInfoType</name></type> <name><name>OnigOpInfo</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>OP_FINISH</name></expr>, <expr><literal type="string">"finish"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_END</name></expr>, <expr><literal type="string">"end"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACT1</name></expr>, <expr><literal type="string">"exact1"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACT2</name></expr>, <expr><literal type="string">"exact2"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACT3</name></expr>, <expr><literal type="string">"exact3"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACT4</name></expr>, <expr><literal type="string">"exact4"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACT5</name></expr>, <expr><literal type="string">"exact5"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACTN</name></expr>, <expr><literal type="string">"exactn"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACTMB2N1</name></expr>, <expr><literal type="string">"exactmb2-n1"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACTMB2N2</name></expr>, <expr><literal type="string">"exactmb2-n2"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACTMB2N3</name></expr>, <expr><literal type="string">"exactmb2-n3"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACTMB2N</name></expr>, <expr><literal type="string">"exactmb2-n"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACTMB3N</name></expr>, <expr><literal type="string">"exactmb3n"</literal></expr> , <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACTMBN</name></expr>, <expr><literal type="string">"exactmbn"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACT1_IC</name></expr>, <expr><literal type="string">"exact1-ic"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_EXACTN_IC</name></expr>, <expr><literal type="string">"exactn-ic"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_CCLASS</name></expr>, <expr><literal type="string">"cclass"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_CCLASS_MB</name></expr>, <expr><literal type="string">"cclass-mb"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_CCLASS_MIX</name></expr>, <expr><literal type="string">"cclass-mix"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_CCLASS_NOT</name></expr>, <expr><literal type="string">"cclass-not"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_CCLASS_MB_NOT</name></expr>, <expr><literal type="string">"cclass-mb-not"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_CCLASS_MIX_NOT</name></expr>, <expr><literal type="string">"cclass-mix-not"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ANYCHAR</name></expr>, <expr><literal type="string">"anychar"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ANYCHAR_ML</name></expr>, <expr><literal type="string">"anychar-ml"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ANYCHAR_STAR</name></expr>, <expr><literal type="string">"anychar*"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ANYCHAR_ML_STAR</name></expr>, <expr><literal type="string">"anychar-ml*"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ANYCHAR_STAR_PEEK_NEXT</name></expr>, <expr><literal type="string">"anychar*-peek-next"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ANYCHAR_ML_STAR_PEEK_NEXT</name></expr>, <expr><literal type="string">"anychar-ml*-peek-next"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_WORD</name></expr>, <expr><literal type="string">"word"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_NOT_WORD</name></expr>, <expr><literal type="string">"not-word"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_WORD_BOUND</name></expr>, <expr><literal type="string">"word-bound"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_NOT_WORD_BOUND</name></expr>, <expr><literal type="string">"not-word-bound"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_WORD_BEGIN</name></expr>, <expr><literal type="string">"word-begin"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_WORD_END</name></expr>, <expr><literal type="string">"word-end"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ASCII_WORD</name></expr>, <expr><literal type="string">"ascii-word"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_NOT_ASCII_WORD</name></expr>, <expr><literal type="string">"not-ascii-word"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ASCII_WORD_BOUND</name></expr>, <expr><literal type="string">"ascii-word-bound"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_NOT_ASCII_WORD_BOUND</name></expr>,<expr><literal type="string">"not-ascii-word-bound"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ASCII_WORD_BEGIN</name></expr>, <expr><literal type="string">"ascii-word-begin"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ASCII_WORD_END</name></expr>, <expr><literal type="string">"ascii-word-end"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BEGIN_BUF</name></expr>, <expr><literal type="string">"begin-buf"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_END_BUF</name></expr>, <expr><literal type="string">"end-buf"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BEGIN_LINE</name></expr>, <expr><literal type="string">"begin-line"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_END_LINE</name></expr>, <expr><literal type="string">"end-line"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_SEMI_END_BUF</name></expr>, <expr><literal type="string">"semi-end-buf"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BEGIN_POSITION</name></expr>, <expr><literal type="string">"begin-position"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BACKREF1</name></expr>, <expr><literal type="string">"backref1"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BACKREF2</name></expr>, <expr><literal type="string">"backref2"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BACKREFN</name></expr>, <expr><literal type="string">"backrefn"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BACKREFN_IC</name></expr>, <expr><literal type="string">"backrefn-ic"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BACKREF_MULTI</name></expr>, <expr><literal type="string">"backref_multi"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BACKREF_MULTI_IC</name></expr>, <expr><literal type="string">"backref_multi-ic"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_BACKREF_WITH_LEVEL</name></expr>, <expr><literal type="string">"backref_at_level"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_MEMORY_START_PUSH</name></expr>, <expr><literal type="string">"mem-start-push"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_MEMORY_START</name></expr>, <expr><literal type="string">"mem-start"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_MEMORY_END_PUSH</name></expr>, <expr><literal type="string">"mem-end-push"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_MEMORY_END_PUSH_REC</name></expr>, <expr><literal type="string">"mem-end-push-rec"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_MEMORY_END</name></expr>, <expr><literal type="string">"mem-end"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_MEMORY_END_REC</name></expr>, <expr><literal type="string">"mem-end-rec"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_SET_OPTION_PUSH</name></expr>, <expr><literal type="string">"set-option-push"</literal></expr>, <expr><name>ARG_OPTION</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_SET_OPTION</name></expr>, <expr><literal type="string">"set-option"</literal></expr>, <expr><name>ARG_OPTION</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_KEEP</name></expr>, <expr><literal type="string">"keep"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_FAIL</name></expr>, <expr><literal type="string">"fail"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_JUMP</name></expr>, <expr><literal type="string">"jump"</literal></expr>, <expr><name>ARG_RELADDR</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_PUSH</name></expr>, <expr><literal type="string">"push"</literal></expr>, <expr><name>ARG_RELADDR</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_POP</name></expr>, <expr><literal type="string">"pop"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_PUSH_OR_JUMP_EXACT1</name></expr>, <expr><literal type="string">"push-or-jump-e1"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_PUSH_IF_PEEK_NEXT</name></expr>, <expr><literal type="string">"push-if-peek-next"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_REPEAT</name></expr>, <expr><literal type="string">"repeat"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_REPEAT_NG</name></expr>, <expr><literal type="string">"repeat-ng"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_REPEAT_INC</name></expr>, <expr><literal type="string">"repeat-inc"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_REPEAT_INC_NG</name></expr>, <expr><literal type="string">"repeat-inc-ng"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_REPEAT_INC_SG</name></expr>, <expr><literal type="string">"repeat-inc-sg"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_REPEAT_INC_NG_SG</name></expr>, <expr><literal type="string">"repeat-inc-ng-sg"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_NULL_CHECK_START</name></expr>, <expr><literal type="string">"null-check-start"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_NULL_CHECK_END</name></expr>, <expr><literal type="string">"null-check-end"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_NULL_CHECK_END_MEMST</name></expr>,<expr><literal type="string">"null-check-end-memst"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_NULL_CHECK_END_MEMST_PUSH</name></expr>,<expr><literal type="string">"null-check-end-memst-push"</literal></expr>, <expr><name>ARG_MEMNUM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_PUSH_POS</name></expr>, <expr><literal type="string">"push-pos"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_POP_POS</name></expr>, <expr><literal type="string">"pop-pos"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_PUSH_POS_NOT</name></expr>, <expr><literal type="string">"push-pos-not"</literal></expr>, <expr><name>ARG_RELADDR</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_FAIL_POS</name></expr>, <expr><literal type="string">"fail-pos"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_PUSH_STOP_BT</name></expr>, <expr><literal type="string">"push-stop-bt"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_POP_STOP_BT</name></expr>, <expr><literal type="string">"pop-stop-bt"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_LOOK_BEHIND</name></expr>, <expr><literal type="string">"look-behind"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_PUSH_LOOK_BEHIND_NOT</name></expr>, <expr><literal type="string">"push-look-behind-not"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_FAIL_LOOK_BEHIND_NOT</name></expr>, <expr><literal type="string">"fail-look-behind-not"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_PUSH_ABSENT_POS</name></expr>, <expr><literal type="string">"push-absent-pos"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ABSENT</name></expr>, <expr><literal type="string">"absent"</literal></expr>, <expr><name>ARG_RELADDR</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_ABSENT_END</name></expr>, <expr><literal type="string">"absent-end"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_CALL</name></expr>, <expr><literal type="string">"call"</literal></expr>, <expr><name>ARG_ABSADDR</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_RETURN</name></expr>, <expr><literal type="string">"return"</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_CONDITION</name></expr>, <expr><literal type="string">"condition"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_STATE_CHECK_PUSH</name></expr>, <expr><literal type="string">"state-check-push"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_STATE_CHECK_PUSH_OR_JUMP</name></expr>, <expr><literal type="string">"state-check-push-or-jump"</literal></expr>, <expr><name>ARG_SPECIAL</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_STATE_CHECK</name></expr>, <expr><literal type="string">"state-check"</literal></expr>, <expr><name>ARG_STATE_CHECK</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_STATE_CHECK_ANYCHAR_STAR</name></expr>, <expr><literal type="string">"state-check-anychar*"</literal></expr>, <expr><name>ARG_STATE_CHECK</name></expr> }</block></expr>,
<expr><block>{ <expr><name>OP_STATE_CHECK_ANYCHAR_ML_STAR</name></expr>,
<expr><literal type="string">"state-check-anychar-ml*"</literal></expr>, <expr><name>ARG_STATE_CHECK</name></expr> }</block></expr>,
<expr><block>{ <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><name>ARG_NON</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>op2name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>OnigOpInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name><name>OnigOpInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>OnigOpInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>op2arg_type</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>opcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>OnigOpInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name><name>OnigOpInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>OnigOpInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>arg_type</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>ARG_SPECIAL</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_PARSE_TREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Indent</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indent</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name></type>
<name>p_string</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>p_len_string</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>LengthType</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mb_len</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name>len</name> <operator>*</operator> <name>mb_len</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d:"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>x</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>onig_print_compiled_byte_code</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>bp</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>bpend</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>nextp</name></decl></parameter>,
<parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>arg_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RelAddrType</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LengthType</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemNumType</name></type> <name>mem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StateCheckNumType</name></type> <name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"[%s"</literal></expr></argument>, <argument><expr><call><name>op2name</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arg_type</name> <operator>=</operator> <call><name>op2arg_type</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arg_type</name> <operator>!=</operator> <name>ARG_SPECIAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bp</name><operator>++</operator></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>arg_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ARG_NON</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ARG_RELADDR</name></expr>:</case>
<expr_stmt><expr><call><name>GET_RELADDR_INC</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":(%s%d)"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>addr</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ARG_ABSADDR</name></expr>:</case>
<expr_stmt><expr><call><name>GET_ABSADDR_INC</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":(%d)"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ARG_LENGTH</name></expr>:</case>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ARG_MEMNUM</name></expr>:</case>
<expr_stmt><expr><name>mem</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>MemNumType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_MEMNUM</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ARG_OPTION</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>option</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>OnigOptionType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_OPTION</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>ARG_STATE_CHECK</name></expr>:</case>
<expr_stmt><expr><name>scn</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>StateCheckNumType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_STATE_CHECK_NUM</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>scn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>bp</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OP_EXACT1</name></expr>:</case>
<case>case <expr><name>OP_ANYCHAR_STAR_PEEK_NEXT</name></expr>:</case>
<case>case <expr><name>OP_ANYCHAR_ML_STAR_PEEK_NEXT</name></expr>:</case>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>OP_EXACT2</name></expr>:</case>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>OP_EXACT3</name></expr>:</case>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>OP_EXACT4</name></expr>:</case>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>OP_EXACT5</name></expr>:</case>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>OP_EXACTN</name></expr>:</case>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_len_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_EXACTMB2N1</name></expr>:</case>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>OP_EXACTMB2N2</name></expr>:</case>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>OP_EXACTMB2N3</name></expr>:</case>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>OP_EXACTMB2N</name></expr>:</case>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_len_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>len</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>OP_EXACTMB3N</name></expr>:</case>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_len_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>len</name> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>OP_EXACTMBN</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mb_len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>mb_len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d:%d:"</literal></expr></argument>, <argument><expr><name>mb_len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>len</name> <operator>*</operator> <name>mb_len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name><operator>++</operator></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></while>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>OP_EXACT1_IC</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>enclen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>bpend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>OP_EXACTN_IC</name></expr>:</case>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_len_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_CCLASS</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bitset_on_num</name><argument_list>(<argument><expr><operator>(</operator><name>BitSetRef</name> <operator>)</operator><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_BITSET</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_CCLASS_NOT</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bitset_on_num</name><argument_list>(<argument><expr><operator>(</operator><name>BitSetRef</name> <operator>)</operator><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_BITSET</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_CCLASS_MB</name></expr>:</case>
<case>case <expr><name>OP_CCLASS_MB_NOT</name></expr>:</case>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PLATFORM_UNALIGNED_WORD_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ALIGNMENT_RIGHT</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d:%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><name>code</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_CCLASS_MIX</name></expr>:</case>
<case>case <expr><name>OP_CCLASS_MIX_NOT</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bitset_on_num</name><argument_list>(<argument><expr><operator>(</operator><name>BitSetRef</name> <operator>)</operator><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_BITSET</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PLATFORM_UNALIGNED_WORD_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ALIGNMENT_RIGHT</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>GET_CODE_POINT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d:%d:%d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><name>code</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_BACKREFN_IC</name></expr>:</case>
<expr_stmt><expr><name>mem</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>MemNumType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_MEMNUM</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_BACKREF_MULTI_IC</name></expr>:</case>
<case>case <expr><name>OP_BACKREF_MULTI</name></expr>:</case>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>GET_MEMNUM_INC</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>

<case>case <expr><name>OP_BACKREF_WITH_LEVEL</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LengthType</name></type> <name>level</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GET_OPTION_INC</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>GET_MEMNUM_INC</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>OP_REPEAT</name></expr>:</case>
<case>case <expr><name>OP_REPEAT_NG</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>mem</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>MemNumType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_MEMNUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>RelAddrType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_RELADDR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d:%d"</literal></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>OP_PUSH_OR_JUMP_EXACT1</name></expr>:</case>
<case>case <expr><name>OP_PUSH_IF_PEEK_NEXT</name></expr>:</case>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>RelAddrType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_RELADDR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":(%s%d)"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>addr</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_LOOK_BEHIND</name></expr>:</case>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_PUSH_LOOK_BEHIND_NOT</name></expr>:</case>
<expr_stmt><expr><call><name>GET_RELADDR_INC</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LENGTH_INC</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d:(%s%d)"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>addr</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_STATE_CHECK_PUSH</name></expr>:</case>
<case>case <expr><name>OP_STATE_CHECK_PUSH_OR_JUMP</name></expr>:</case>
<expr_stmt><expr><name>scn</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>StateCheckNumType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_STATE_CHECK_NUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>RelAddrType</name><operator>*</operator> <operator>)</operator><name>bp</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>SIZE_RELADDR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d:(%s%d)"</literal></expr></argument>, <argument><expr><name>scn</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>addr</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OP_CONDITION</name></expr>:</case>
<expr_stmt><expr><call><name>GET_MEMNUM_INC</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_RELADDR_INC</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%d:(%s%d)"</literal></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>addr</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"onig_print_compiled_byte_code: undefined code %d\n"</literal></expr></argument>,
<argument><expr><name><name>bp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nextp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>nextp</name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_COMPILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_compiled_byte_code_list</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ncode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>bp</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name> <init>= <expr><name><name>reg</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <name><name>reg</name><operator>-&gt;</operator><name>used</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"code length: %d"</literal></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ncode</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>bp</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ncode</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ncode</name> <operator>%</operator> <literal type="number">5</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n%ld:"</literal></expr></argument>, <argument><expr><name>bp</name> <operator>-</operator> <name><name>reg</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %ld:"</literal></expr></argument>, <argument><expr><name>bp</name> <operator>-</operator> <name><name>reg</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>onig_print_compiled_byte_code</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bp</name></expr></argument>, <argument><expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG_PARSE_TREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_indent_tree</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>container_p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>add</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Indent</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"ERROR: null node!!!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_LIST</name></expr>:</case>
<case>case <expr><name>NT_ALT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NT_LIST</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;list:%"</literal><name>PRIxPTR</name><literal type="string">"&gt;\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;alt:%"</literal><name>PRIxPTR</name><literal type="string">"&gt;\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>print_indent_tree</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indent</name> <operator>+</operator> <name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>IS_NOT_NULL</name><argument_list>(<argument><expr><name>node</name> <operator>=</operator> <call><name>NCDR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"ERROR: list/alt right is not a cons. %d\n"</literal></expr></argument>, <argument><expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>print_indent_tree</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>NCAR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indent</name> <operator>+</operator> <name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<break>break;</break>

<case>case <expr><name>NT_STR</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;string%s:%"</literal><name>PRIxPTR</name><literal type="string">"&gt;"</literal></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><call><name>NSTRING_IS_RAW</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"-raw"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>s</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <call><name>NSTR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;</operator> <literal type="number">0x7f</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" 0x%02x"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<break>break;</break>

<case>case <expr><name>NT_CCLASS</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;cclass:%"</literal><name>PRIxPTR</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NCCLASS_NOT</name><argument_list>(<argument><expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"not "</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mbuf</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BBuf</name><modifier>*</modifier></type> <name>bbuf</name> <init>= <expr><call><name>NCCLASS</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mbuf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name><modifier>*</modifier></type> <name>data</name> <init>= <expr><operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCodePoint</name><modifier>*</modifier></type> <name>end</name> <init>= <expr><operator>(</operator><name>OnigCodePoint</name><operator>*</operator> <operator>)</operator><operator>(</operator><name><name>bbuf</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <name><name>bbuf</name><operator>-&gt;</operator><name>used</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>*</operator><name>data</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>data</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>data</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%04x-%04x"</literal></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>NT_CTYPE</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;ctype:%"</literal><name>PRIxPTR</name><literal type="string">"&gt; "</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ONIGENC_CTYPE_WORD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>NCTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>not</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"not word"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"word"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"ERROR: undefined ctype.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<break>break;</break>

<case>case <expr><name>NT_CANY</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;anychar:%"</literal><name>PRIxPTR</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ANCHOR</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;anchor:%"</literal><name>PRIxPTR</name><literal type="string">"&gt; "</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ANCHOR_BEGIN_BUF</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"begin buf"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_END_BUF</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"end buf"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_BEGIN_LINE</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"begin line"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_END_LINE</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"end line"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_SEMI_END_BUF</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"semi end buf"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_BEGIN_POSITION</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"begin position"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ANCHOR_WORD_BOUND</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"word bound"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_NOT_WORD_BOUND</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"not word bound"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_WORD_BEGIN_END</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>ANCHOR_WORD_BEGIN</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"word begin"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_WORD_END</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"word end"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>ANCHOR_PREC_READ</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"prec read"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>container_p</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_PREC_READ_NOT</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"prec read not"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>container_p</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_LOOK_BEHIND</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"look_behind"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>container_p</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_LOOK_BEHIND_NOT</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"look_behind_not"</literal></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>container_p</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>ANCHOR_KEEP</name></expr>:</case> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"keep"</literal></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"ERROR: undefined anchor type.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>

<case>case <expr><name>NT_BREF</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BRefNode</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><call><name>NBREF</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>BACKREFS_P</name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;backref:%"</literal><name>PRIxPTR</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>br</name><operator>-&gt;</operator><name>back_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>NT_CALL</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>CallNode</name><modifier>*</modifier></type> <name>cn</name> <init>= <expr><call><name>NCALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;call:%"</literal><name>PRIxPTR</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_string</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name_end</name></name> <operator>-</operator> <name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_QTFR</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;quantifier:%"</literal><name>PRIxPTR</name><literal type="string">"&gt;{%d,%d}%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>,
<argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lower</name></expr></argument>, <argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>upper</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>greedy</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"?"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_indent_tree</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>NQTFR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>indent</name> <operator>+</operator> <name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NT_ENCLOSE</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&lt;enclose:%"</literal><name>PRIxPTR</name><literal type="string">"&gt; "</literal></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name> <operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCLOSE_OPTION</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"option:%d"</literal></expr></argument>, <argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCLOSE_MEMORY</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"memory:%d"</literal></expr></argument>, <argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCLOSE_STOP_BACKTRACK</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"stop-bt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCLOSE_CONDITION</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"condition:%d"</literal></expr></argument>, <argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCLOSE_ABSENT</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"absent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_indent_tree</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>NENCLOSE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>indent</name> <operator>+</operator> <name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"print_indent_tree: undefined node type %d\n"</literal></expr></argument>, <argument><expr><call><name>NTYPE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>NT_LIST</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>NT_ALT</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>NT_QTFR</name> <operator>&amp;&amp;</operator>
<name>type</name> <operator>!=</operator> <name>NT_ENCLOSE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>container_p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>print_indent_tree</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>NANCHOR</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>target</name></expr></argument>, <argument><expr><name>indent</name> <operator>+</operator> <name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_tree</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>print_indent_tree</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
