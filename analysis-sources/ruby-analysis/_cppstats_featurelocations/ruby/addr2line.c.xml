<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\addr2line.c">









<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>clang</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wgnu-empty-initializer"</cpp:literal></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>clang</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wgcc-compat"</cpp:literal></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/defines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/missing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"addr2line.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBPROC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libproc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/stdbool.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ELF</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MACH_O_LOADER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>alloca</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>alloca</name></cpp:macro> <cpp:value>__builtin_alloca</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ALLOCA_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>alloca</name></cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>alloca</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>alloca</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DLADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MACH_O_LOADER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crt_externs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/fat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/loader.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/nlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/stab.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ELF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;elf_abi.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;elf.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ElfW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOIDP</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ElfW</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Elf64##_##x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ElfW</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Elf32##_##x</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ELF_ST_TYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOIDP</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_ST_TYPE</name></cpp:macro> <cpp:value>ELF64_ST_TYPE</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_ST_TYPE</name></cpp:macro> <cpp:value>ELF32_ST_TYPE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SHF_COMPRESSED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELFCOMPRESS_ZLIB</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBZ</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_COMPRESSED_DEBUG_LINE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHF_COMPRESSED</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_MAX</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_copy</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_advance_pc</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_advance_line</name></cpp:macro> <cpp:value>0x03</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_set_file</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_set_column</name></cpp:macro> <cpp:value>0x05</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_negate_stmt</name></cpp:macro> <cpp:value>0x06</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_set_basic_block</name></cpp:macro> <cpp:value>0x07</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_const_add_pc</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_fixed_advance_pc</name></cpp:macro> <cpp:value>0x09</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_set_prologue_end</name></cpp:macro> <cpp:value>0x0a</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_set_epilogue_begin</name></cpp:macro> <cpp:value>0x0b</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNS_set_isa</name></cpp:macro> <cpp:value>0x0c</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNE_end_sequence</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNE_set_address</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNE_define_file</name></cpp:macro> <cpp:value>0x03</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LNE_set_discriminator</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 

<macro><name>PRINTF_ARGS</name><argument_list>(<argument>static int kprintf(const char *fmt, ...)</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<typedef>typedef <type><struct>struct <name>line_info</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uintptr_t</name></type> <name>base_addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>saddr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>line_info</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>line_info_t</name>;</typedef>

<struct>struct <name>dwarf_section</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>flags</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>obj_info</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mapped</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>mapped_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>uncompressed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>base_addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>vmaddr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name></type> <name>debug_abbrev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name></type> <name>debug_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name></type> <name>debug_line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name></type> <name>debug_ranges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name></type> <name>debug_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>obj_info</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>obj_info_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DWARF_SECTION_COUNT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>dwarf_section</name></name> <modifier>*</modifier></type>
<name>obj_dwarf_section_at</name><parameter_list>(<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name> <modifier>*</modifier></type><name><name>ary</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>debug_abbrev</name></name></expr>,
<expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>debug_info</name></name></expr>,
<expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>debug_line</name></name></expr>,
<expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>debug_ranges</name></name></expr>,
<expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>debug_str</name></name></expr>
}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>DWARF_SECTION_COUNT</name> <operator>&lt;=</operator> <name>n</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>ary</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>debug_section_definition</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name> <modifier>*</modifier></type><name>dwarf</name></decl>;</decl_stmt>
}</block>;</struct>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>binary_filename</name><index>[<expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>uleb128</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>b</name> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>sleb128</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&amp;</operator> <literal type="number">0x40</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>-=</operator> <operator>(</operator><literal type="number">0x80</literal> <operator>-</operator> <name>b</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_nth_dirname</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>dir</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"Unexpected directory number %lu in %s\n"</literal></expr></argument>,
<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_filename</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>include_directories</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filenames</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>filenames</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>dir</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>file</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"Unexpected file number %d in %s at %tx\n"</literal></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>filenames</name> <operator>-</operator> <name><name>obj</name><operator>-&gt;</operator><name>mapped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>file</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>dirname</name></name> <operator>=</operator> <call><name>get_nth_dirname</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>include_directories</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_line</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>include_directories</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filenames</name></decl></parameter>,
<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>-</operator> <name><name>obj</name><operator>-&gt;</operator><name>vmaddr</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_traces</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>a</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>traces</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&lt;</operator> <name>a</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>&lt;</operator> <name>addr</name> <operator>+</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fill_filename</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>include_directories</name></expr></argument>, <argument><expr><name>filenames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<struct>struct <name>LineNumberProgramHeader</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>unit_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>format</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint64_t</name></type> <name>header_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>minimum_instruction_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>maximum_operations_per_instruction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>default_is_stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name></type> <name>line_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>line_range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>opcode_base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>include_directories</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filenames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cu_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cu_end</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_debug_line_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>LineNumberProgramHeader</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>unit_length</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>unit_length</name></name> <operator>==</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>unit_length</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>cu_end</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>unit_length</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>header_length</name></name> <operator>=</operator> <ternary><condition><expr><name><name>header</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr> </then><else>: <expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>p</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>header</name><operator>-&gt;</operator><name>format</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>cu_start</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>header_length</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>minimum_instruction_length</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>default_is_stmt</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>line_base</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>line_range</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>opcode_base</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>header</name><operator>-&gt;</operator><name>opcode_base</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>include_directories</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name><name>header</name><operator>-&gt;</operator><name>cu_end</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>cu_end</name></name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>filenames</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>cu_start</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_debug_line_cu</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>debug_line</name></decl></parameter>,
<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>debug_line</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LineNumberProgramHeader</name></name></type> <name>header</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>file</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>line</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_stmt</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><call><name>parse_debug_line_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>is_stmt</name> <operator>=</operator> <name><name>header</name><operator>.</operator><name>default_is_stmt</name></name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILL_LINE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { fill_line(num_traces, traces, addr, file, line, (char *)header.include_directories, (char *)header.filenames, obj, lines, offset); } while (0)</cpp:value></cpp:define>








<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name><name>header</name><operator>.</operator><name>cu_end</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>op</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_LNS_copy</name></expr>:</case>
<expr_stmt><expr><call><name>FILL_LINE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_advance_pc</name></expr>:</case>
<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>uleb128</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_advance_line</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>a</name> <init>= <expr><call><name>sleb128</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>line</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>DW_LNS_set_file</name></expr>:</case>
<expr_stmt><expr><name>file</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>uleb128</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_column</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>uleb128</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_negate_stmt</name></expr>:</case>
<expr_stmt><expr><name>is_stmt</name> <operator>=</operator> <operator>!</operator><name>is_stmt</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_basic_block</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>DW_LNS_const_add_pc</name></expr>:</case>
<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">255UL</literal> <operator>-</operator> <name><name>header</name><operator>.</operator><name>opcode_base</name></name><operator>)</operator> <operator>/</operator> <name><name>header</name><operator>.</operator><name>line_range</name></name><operator>)</operator> <operator>*</operator>
<name><name>header</name><operator>.</operator><name>minimum_instruction_length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_fixed_advance_pc</name></expr>:</case>
<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_prologue_end</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>DW_LNS_set_epilogue_begin</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>DW_LNS_set_isa</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>uleb128</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>op</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_LNE_end_sequence</name></expr>:</case>

<expr_stmt><expr><call><name>FILL_LINE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>file</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>is_stmt</name> <operator>=</operator> <name><name>header</name><operator>.</operator><name>default_is_stmt</name></name></expr>;</expr_stmt>


<break>break;</break>
<case>case <expr><name>DW_LNE_set_address</name></expr>:</case>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>long</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> sizeof<operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNE_define_file</name></expr>:</case>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"Unsupported operation in %s\n"</literal></expr></argument>,
<argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNE_set_discriminator</name></expr>:</case>

<expr_stmt><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"Unknown extended opcode: %d in %s\n"</literal></expr></argument>,
<argument><expr><name>op</name></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<break>break;</break>
<default>default:</default> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>adjusted_opcode</name> <init>= <expr><name>op</name> <operator>-</operator> <name><name>header</name><operator>.</operator><name>opcode_base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>operation_advance</name> <init>= <expr><name>adjusted_opcode</name> <operator>/</operator> <name><name>header</name><operator>.</operator><name>line_range</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>operation_advance</name> <operator>*</operator> <name><name>header</name><operator>.</operator><name>minimum_instruction_length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>+=</operator> <name><name>header</name><operator>.</operator><name>line_base</name></name> <operator>+</operator> <operator>(</operator><name>adjusted_opcode</name> <operator>%</operator> <name><name>header</name><operator>.</operator><name>line_range</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FILL_LINE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>debug_line</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_debug_line</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>debug_line</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>debug_line_end</name> <init>= <expr><name>debug_line</name> <operator>+</operator> <name>size</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>debug_line</name> <operator>&lt;</operator> <name>debug_line_end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>parse_debug_line_cu</name><argument_list>(<argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>debug_line</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>debug_line</name> <operator>!=</operator> <name>debug_line_end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"Unexpected size of .debug_line in %s\n"</literal></expr></argument>,
<argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>uintptr_t</name></type>
<name>fill_lines</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check_debuglink</name></decl></parameter>,
<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>objp</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_obj</name><parameter_list>(<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>objp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>newobj</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>obj_info_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>objp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>objp</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newobj</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>objp</name> <operator>=</operator> <name>newobj</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ELF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>follow_debuglink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>debuglink</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>,
<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>objp</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>global_debug_dir</name><index>[]</index></name> <init>= <expr><literal type="string">"/usr/lib/debug"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>global_debug_dir_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>global_debug_dir</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>o1</name> <init>= <expr><operator>*</operator><name>objp</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>o2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>PATH_MAX</name> <operator>-</operator> <name>global_debug_dir_len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>PATH_MAX</name> <operator>-</operator> <name>global_debug_dir_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>binary_filename</name> <operator>+</operator> <name>global_debug_dir_len</name></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>global_debug_dir</name></expr></argument>, <argument><expr><name>global_debug_dir_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>global_debug_dir_len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>binary_filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>debuglink</name></expr></argument>, <argument><expr><name>PATH_MAX</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_obj</name><argument_list>(<argument><expr><name>objp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o2</name> <operator>=</operator> <operator>*</operator><name>objp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o2</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>=</operator> <name><name>o1</name><operator>-&gt;</operator><name>base_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o2</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>o1</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_lines</name><argument_list>(<argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>objp</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum
<block>{
<decl><name>DW_TAG_compile_unit</name> <init>= <expr><literal type="number">0x11</literal></expr></init></decl>,
<decl><name>DW_TAG_inlined_subroutine</name> <init>= <expr><literal type="number">0x1d</literal></expr></init></decl>,
<decl><name>DW_TAG_subprogram</name> <init>= <expr><literal type="number">0x2e</literal></expr></init></decl>,
}</block>;</enum>


<enum>enum
<block>{
<decl><name>DW_AT_sibling</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
<decl><name>DW_AT_location</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,
<decl><name>DW_AT_name</name> <init>= <expr><literal type="number">0x03</literal></expr></init></decl>,





<decl><name>DW_AT_ordering</name> <init>= <expr><literal type="number">0x09</literal></expr></init></decl>,

<decl><name>DW_AT_byte_size</name> <init>= <expr><literal type="number">0x0b</literal></expr></init></decl>,

<decl><name>DW_AT_bit_size</name> <init>= <expr><literal type="number">0x0d</literal></expr></init></decl>,


<decl><name>DW_AT_stmt_list</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>DW_AT_low_pc</name> <init>= <expr><literal type="number">0x11</literal></expr></init></decl>,
<decl><name>DW_AT_high_pc</name> <init>= <expr><literal type="number">0x12</literal></expr></init></decl>,
<decl><name>DW_AT_language</name> <init>= <expr><literal type="number">0x13</literal></expr></init></decl>,

<decl><name>DW_AT_discr</name> <init>= <expr><literal type="number">0x15</literal></expr></init></decl>,
<decl><name>DW_AT_discr_value</name> <init>= <expr><literal type="number">0x16</literal></expr></init></decl>,
<decl><name>DW_AT_visibility</name> <init>= <expr><literal type="number">0x17</literal></expr></init></decl>,
<decl><name>DW_AT_import</name> <init>= <expr><literal type="number">0x18</literal></expr></init></decl>,
<decl><name>DW_AT_string_length</name> <init>= <expr><literal type="number">0x19</literal></expr></init></decl>,
<decl><name>DW_AT_common_reference</name> <init>= <expr><literal type="number">0x1a</literal></expr></init></decl>,
<decl><name>DW_AT_comp_dir</name> <init>= <expr><literal type="number">0x1b</literal></expr></init></decl>,
<decl><name>DW_AT_const_value</name> <init>= <expr><literal type="number">0x1c</literal></expr></init></decl>,
<decl><name>DW_AT_containing_type</name> <init>= <expr><literal type="number">0x1d</literal></expr></init></decl>,
<decl><name>DW_AT_default_value</name> <init>= <expr><literal type="number">0x1e</literal></expr></init></decl>,

<decl><name>DW_AT_inline</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,
<decl><name>DW_AT_is_optional</name> <init>= <expr><literal type="number">0x21</literal></expr></init></decl>,
<decl><name>DW_AT_lower_bound</name> <init>= <expr><literal type="number">0x22</literal></expr></init></decl>,


<decl><name>DW_AT_producer</name> <init>= <expr><literal type="number">0x25</literal></expr></init></decl>,

<decl><name>DW_AT_prototyped</name> <init>= <expr><literal type="number">0x27</literal></expr></init></decl>,


<decl><name>DW_AT_return_addr</name> <init>= <expr><literal type="number">0x2a</literal></expr></init></decl>,

<decl><name>DW_AT_start_scope</name> <init>= <expr><literal type="number">0x2c</literal></expr></init></decl>,

<decl><name>DW_AT_bit_stride</name> <init>= <expr><literal type="number">0x2e</literal></expr></init></decl>,
<decl><name>DW_AT_upper_bound</name> <init>= <expr><literal type="number">0x2f</literal></expr></init></decl>,

<decl><name>DW_AT_abstract_origin</name> <init>= <expr><literal type="number">0x31</literal></expr></init></decl>,
<decl><name>DW_AT_accessibility</name> <init>= <expr><literal type="number">0x32</literal></expr></init></decl>,
<decl><name>DW_AT_address_class</name> <init>= <expr><literal type="number">0x33</literal></expr></init></decl>,
<decl><name>DW_AT_artificial</name> <init>= <expr><literal type="number">0x34</literal></expr></init></decl>,
<decl><name>DW_AT_base_types</name> <init>= <expr><literal type="number">0x35</literal></expr></init></decl>,
<decl><name>DW_AT_calling_convention</name> <init>= <expr><literal type="number">0x36</literal></expr></init></decl>,
<decl><name>DW_AT_count</name> <init>= <expr><literal type="number">0x37</literal></expr></init></decl>,
<decl><name>DW_AT_data_member_location</name> <init>= <expr><literal type="number">0x38</literal></expr></init></decl>,
<decl><name>DW_AT_decl_column</name> <init>= <expr><literal type="number">0x39</literal></expr></init></decl>,
<decl><name>DW_AT_decl_file</name> <init>= <expr><literal type="number">0x3a</literal></expr></init></decl>,
<decl><name>DW_AT_decl_line</name> <init>= <expr><literal type="number">0x3b</literal></expr></init></decl>,
<decl><name>DW_AT_declaration</name> <init>= <expr><literal type="number">0x3c</literal></expr></init></decl>,
<decl><name>DW_AT_discr_list</name> <init>= <expr><literal type="number">0x3d</literal></expr></init></decl>,
<decl><name>DW_AT_encoding</name> <init>= <expr><literal type="number">0x3e</literal></expr></init></decl>,
<decl><name>DW_AT_external</name> <init>= <expr><literal type="number">0x3f</literal></expr></init></decl>,
<decl><name>DW_AT_frame_base</name> <init>= <expr><literal type="number">0x40</literal></expr></init></decl>,
<decl><name>DW_AT_friend</name> <init>= <expr><literal type="number">0x41</literal></expr></init></decl>,
<decl><name>DW_AT_identifier_case</name> <init>= <expr><literal type="number">0x42</literal></expr></init></decl>,

<decl><name>DW_AT_namelist_item</name> <init>= <expr><literal type="number">0x44</literal></expr></init></decl>,
<decl><name>DW_AT_priority</name> <init>= <expr><literal type="number">0x45</literal></expr></init></decl>,
<decl><name>DW_AT_segment</name> <init>= <expr><literal type="number">0x46</literal></expr></init></decl>,
<decl><name>DW_AT_specification</name> <init>= <expr><literal type="number">0x47</literal></expr></init></decl>,
<decl><name>DW_AT_static_link</name> <init>= <expr><literal type="number">0x48</literal></expr></init></decl>,
<decl><name>DW_AT_type</name> <init>= <expr><literal type="number">0x49</literal></expr></init></decl>,
<decl><name>DW_AT_use_location</name> <init>= <expr><literal type="number">0x4a</literal></expr></init></decl>,
<decl><name>DW_AT_variable_parameter</name> <init>= <expr><literal type="number">0x4b</literal></expr></init></decl>,
<decl><name>DW_AT_virtuality</name> <init>= <expr><literal type="number">0x4c</literal></expr></init></decl>,
<decl><name>DW_AT_vtable_elem_location</name> <init>= <expr><literal type="number">0x4d</literal></expr></init></decl>,
<decl><name>DW_AT_allocated</name> <init>= <expr><literal type="number">0x4e</literal></expr></init></decl>,
<decl><name>DW_AT_associated</name> <init>= <expr><literal type="number">0x4f</literal></expr></init></decl>,
<decl><name>DW_AT_data_location</name> <init>= <expr><literal type="number">0x50</literal></expr></init></decl>,
<decl><name>DW_AT_byte_stride</name> <init>= <expr><literal type="number">0x51</literal></expr></init></decl>,
<decl><name>DW_AT_entry_pc</name> <init>= <expr><literal type="number">0x52</literal></expr></init></decl>,
<decl><name>DW_AT_use_UTF8</name> <init>= <expr><literal type="number">0x53</literal></expr></init></decl>,
<decl><name>DW_AT_extension</name> <init>= <expr><literal type="number">0x54</literal></expr></init></decl>,
<decl><name>DW_AT_ranges</name> <init>= <expr><literal type="number">0x55</literal></expr></init></decl>,
<decl><name>DW_AT_trampoline</name> <init>= <expr><literal type="number">0x56</literal></expr></init></decl>,
<decl><name>DW_AT_call_column</name> <init>= <expr><literal type="number">0x57</literal></expr></init></decl>,
<decl><name>DW_AT_call_file</name> <init>= <expr><literal type="number">0x58</literal></expr></init></decl>,
<decl><name>DW_AT_call_line</name> <init>= <expr><literal type="number">0x59</literal></expr></init></decl>,
<decl><name>DW_AT_description</name> <init>= <expr><literal type="number">0x5a</literal></expr></init></decl>,
<decl><name>DW_AT_binary_scale</name> <init>= <expr><literal type="number">0x5b</literal></expr></init></decl>,
<decl><name>DW_AT_decimal_scale</name> <init>= <expr><literal type="number">0x5c</literal></expr></init></decl>,
<decl><name>DW_AT_small</name> <init>= <expr><literal type="number">0x5d</literal></expr></init></decl>,
<decl><name>DW_AT_decimal_sign</name> <init>= <expr><literal type="number">0x5e</literal></expr></init></decl>,
<decl><name>DW_AT_digit_count</name> <init>= <expr><literal type="number">0x5f</literal></expr></init></decl>,
<decl><name>DW_AT_picture_string</name> <init>= <expr><literal type="number">0x60</literal></expr></init></decl>,
<decl><name>DW_AT_mutable</name> <init>= <expr><literal type="number">0x61</literal></expr></init></decl>,
<decl><name>DW_AT_threads_scaled</name> <init>= <expr><literal type="number">0x62</literal></expr></init></decl>,
<decl><name>DW_AT_explicit</name> <init>= <expr><literal type="number">0x63</literal></expr></init></decl>,
<decl><name>DW_AT_object_pointer</name> <init>= <expr><literal type="number">0x64</literal></expr></init></decl>,
<decl><name>DW_AT_endianity</name> <init>= <expr><literal type="number">0x65</literal></expr></init></decl>,
<decl><name>DW_AT_elemental</name> <init>= <expr><literal type="number">0x66</literal></expr></init></decl>,
<decl><name>DW_AT_pure</name> <init>= <expr><literal type="number">0x67</literal></expr></init></decl>,
<decl><name>DW_AT_recursive</name> <init>= <expr><literal type="number">0x68</literal></expr></init></decl>,
<decl><name>DW_AT_signature</name> <init>= <expr><literal type="number">0x69</literal></expr></init></decl>,
<decl><name>DW_AT_main_subprogram</name> <init>= <expr><literal type="number">0x6a</literal></expr></init></decl>,
<decl><name>DW_AT_data_bit_offset</name> <init>= <expr><literal type="number">0x6b</literal></expr></init></decl>,
<decl><name>DW_AT_const_expr</name> <init>= <expr><literal type="number">0x6c</literal></expr></init></decl>,
<decl><name>DW_AT_enum_class</name> <init>= <expr><literal type="number">0x6d</literal></expr></init></decl>,
<decl><name>DW_AT_linkage_name</name> <init>= <expr><literal type="number">0x6e</literal></expr></init></decl>,
<decl><name>DW_AT_string_length_bit_size</name> <init>= <expr><literal type="number">0x6f</literal></expr></init></decl>,
<decl><name>DW_AT_string_length_byte_size</name> <init>= <expr><literal type="number">0x70</literal></expr></init></decl>,
<decl><name>DW_AT_rank</name> <init>= <expr><literal type="number">0x71</literal></expr></init></decl>,
<decl><name>DW_AT_str_offsets_base</name> <init>= <expr><literal type="number">0x72</literal></expr></init></decl>,
<decl><name>DW_AT_addr_base</name> <init>= <expr><literal type="number">0x73</literal></expr></init></decl>,
<decl><name>DW_AT_rnglists_base</name> <init>= <expr><literal type="number">0x74</literal></expr></init></decl>,

<decl><name>DW_AT_dwo_name</name> <init>= <expr><literal type="number">0x76</literal></expr></init></decl>,
<decl><name>DW_AT_reference</name> <init>= <expr><literal type="number">0x77</literal></expr></init></decl>,
<decl><name>DW_AT_rvalue_reference</name> <init>= <expr><literal type="number">0x78</literal></expr></init></decl>,
<decl><name>DW_AT_macros</name> <init>= <expr><literal type="number">0x79</literal></expr></init></decl>,
<decl><name>DW_AT_call_all_calls</name> <init>= <expr><literal type="number">0x7a</literal></expr></init></decl>,
<decl><name>DW_AT_call_all_source_calls</name> <init>= <expr><literal type="number">0x7b</literal></expr></init></decl>,
<decl><name>DW_AT_call_all_tail_calls</name> <init>= <expr><literal type="number">0x7c</literal></expr></init></decl>,
<decl><name>DW_AT_call_return_pc</name> <init>= <expr><literal type="number">0x7d</literal></expr></init></decl>,
<decl><name>DW_AT_call_value</name> <init>= <expr><literal type="number">0x7e</literal></expr></init></decl>,
<decl><name>DW_AT_call_origin</name> <init>= <expr><literal type="number">0x7f</literal></expr></init></decl>,
<decl><name>DW_AT_call_parameter</name> <init>= <expr><literal type="number">0x80</literal></expr></init></decl>,
<decl><name>DW_AT_call_pc</name> <init>= <expr><literal type="number">0x81</literal></expr></init></decl>,
<decl><name>DW_AT_call_tail_call</name> <init>= <expr><literal type="number">0x82</literal></expr></init></decl>,
<decl><name>DW_AT_call_target</name> <init>= <expr><literal type="number">0x83</literal></expr></init></decl>,
<decl><name>DW_AT_call_target_clobbered</name> <init>= <expr><literal type="number">0x84</literal></expr></init></decl>,
<decl><name>DW_AT_call_data_location</name> <init>= <expr><literal type="number">0x85</literal></expr></init></decl>,
<decl><name>DW_AT_call_data_value</name> <init>= <expr><literal type="number">0x86</literal></expr></init></decl>,
<decl><name>DW_AT_noreturn</name> <init>= <expr><literal type="number">0x87</literal></expr></init></decl>,
<decl><name>DW_AT_alignment</name> <init>= <expr><literal type="number">0x88</literal></expr></init></decl>,
<decl><name>DW_AT_export_symbols</name> <init>= <expr><literal type="number">0x89</literal></expr></init></decl>,
<decl><name>DW_AT_deleted</name> <init>= <expr><literal type="number">0x8a</literal></expr></init></decl>,
<decl><name>DW_AT_defaulted</name> <init>= <expr><literal type="number">0x8b</literal></expr></init></decl>,
<decl><name>DW_AT_loclists_base</name> <init>= <expr><literal type="number">0x8c</literal></expr></init></decl>,
<decl><name>DW_AT_lo_user</name> <init>= <expr><literal type="number">0x2000</literal></expr></init></decl>,
<decl><name>DW_AT_hi_user</name> <init>= <expr><literal type="number">0x3fff</literal></expr></init></decl>
}</block>;</enum>


<enum>enum
<block>{
<decl><name>DW_FORM_addr</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,

<decl><name>DW_FORM_block2</name> <init>= <expr><literal type="number">0x03</literal></expr></init></decl>,
<decl><name>DW_FORM_block4</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>,
<decl><name>DW_FORM_data2</name> <init>= <expr><literal type="number">0x05</literal></expr></init></decl>,
<decl><name>DW_FORM_data4</name> <init>= <expr><literal type="number">0x06</literal></expr></init></decl>,
<decl><name>DW_FORM_data8</name> <init>= <expr><literal type="number">0x07</literal></expr></init></decl>,
<decl><name>DW_FORM_string</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>,
<decl><name>DW_FORM_block</name> <init>= <expr><literal type="number">0x09</literal></expr></init></decl>,
<decl><name>DW_FORM_block1</name> <init>= <expr><literal type="number">0x0a</literal></expr></init></decl>,
<decl><name>DW_FORM_data1</name> <init>= <expr><literal type="number">0x0b</literal></expr></init></decl>,
<decl><name>DW_FORM_flag</name> <init>= <expr><literal type="number">0x0c</literal></expr></init></decl>,
<decl><name>DW_FORM_sdata</name> <init>= <expr><literal type="number">0x0d</literal></expr></init></decl>,
<decl><name>DW_FORM_strp</name> <init>= <expr><literal type="number">0x0e</literal></expr></init></decl>,
<decl><name>DW_FORM_udata</name> <init>= <expr><literal type="number">0x0f</literal></expr></init></decl>,
<decl><name>DW_FORM_ref_addr</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>DW_FORM_ref1</name> <init>= <expr><literal type="number">0x11</literal></expr></init></decl>,
<decl><name>DW_FORM_ref2</name> <init>= <expr><literal type="number">0x12</literal></expr></init></decl>,
<decl><name>DW_FORM_ref4</name> <init>= <expr><literal type="number">0x13</literal></expr></init></decl>,
<decl><name>DW_FORM_ref8</name> <init>= <expr><literal type="number">0x14</literal></expr></init></decl>,
<decl><name>DW_FORM_ref_udata</name> <init>= <expr><literal type="number">0x15</literal></expr></init></decl>,
<decl><name>DW_FORM_indirect</name> <init>= <expr><literal type="number">0x16</literal></expr></init></decl>,
<decl><name>DW_FORM_sec_offset</name> <init>= <expr><literal type="number">0x17</literal></expr></init></decl>,
<decl><name>DW_FORM_exprloc</name> <init>= <expr><literal type="number">0x18</literal></expr></init></decl>,
<decl><name>DW_FORM_flag_present</name> <init>= <expr><literal type="number">0x19</literal></expr></init></decl>,
<decl><name>DW_FORM_strx</name> <init>= <expr><literal type="number">0x1a</literal></expr></init></decl>,
<decl><name>DW_FORM_addrx</name> <init>= <expr><literal type="number">0x1b</literal></expr></init></decl>,
<decl><name>DW_FORM_ref_sup4</name> <init>= <expr><literal type="number">0x1c</literal></expr></init></decl>,
<decl><name>DW_FORM_strp_sup</name> <init>= <expr><literal type="number">0x1d</literal></expr></init></decl>,
<decl><name>DW_FORM_data16</name> <init>= <expr><literal type="number">0x1e</literal></expr></init></decl>,
<decl><name>DW_FORM_line_strp</name> <init>= <expr><literal type="number">0x1f</literal></expr></init></decl>,
<decl><name>DW_FORM_ref_sig8</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,
<decl><name>DW_FORM_implicit_const</name> <init>= <expr><literal type="number">0x21</literal></expr></init></decl>,
<decl><name>DW_FORM_loclistx</name> <init>= <expr><literal type="number">0x22</literal></expr></init></decl>,
<decl><name>DW_FORM_rnglistx</name> <init>= <expr><literal type="number">0x23</literal></expr></init></decl>,
<decl><name>DW_FORM_ref_sup8</name> <init>= <expr><literal type="number">0x24</literal></expr></init></decl>,
<decl><name>DW_FORM_strx1</name> <init>= <expr><literal type="number">0x25</literal></expr></init></decl>,
<decl><name>DW_FORM_strx2</name> <init>= <expr><literal type="number">0x26</literal></expr></init></decl>,
<decl><name>DW_FORM_strx3</name> <init>= <expr><literal type="number">0x27</literal></expr></init></decl>,
<decl><name>DW_FORM_strx4</name> <init>= <expr><literal type="number">0x28</literal></expr></init></decl>,
<decl><name>DW_FORM_addrx1</name> <init>= <expr><literal type="number">0x29</literal></expr></init></decl>,
<decl><name>DW_FORM_addrx2</name> <init>= <expr><literal type="number">0x2a</literal></expr></init></decl>,
<decl><name>DW_FORM_addrx3</name> <init>= <expr><literal type="number">0x2b</literal></expr></init></decl>,
<decl><name>DW_FORM_addrx4</name> <init>= <expr><literal type="number">0x2c</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <block>{
<decl><name>VAL_none</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>VAL_cstr</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>VAL_data</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>VAL_uint</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
<decl><name>VAL_int</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABBREV_TABLE_SIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>current_cu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>current_low_pc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>debug_line_cu_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>debug_line_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>debug_line_directories</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cu_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>format</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>address_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>abbrev_table</name><index>[<expr><name>ABBREV_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>DebugInfoReader</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_children</name></decl>;</decl_stmt>
}</block></struct></type> <name>DIE</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<union>union <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>uint64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>int64</name></decl>;</decl_stmt>
}</block> <decl><name>as</name></decl>;</union>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>form</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>DebugInfoValue</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MERGE_2INTS</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((uint64_t)(b)&lt;&lt;sz)|(a))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>uint16_t</name></type>
<name>get_uint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>uint16_t</name><operator>)</operator><call><name>MERGE_2INTS</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>get_uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>MERGE_2INTS</name><argument_list>(<argument><expr><call><name>get_uint16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>get_uint16</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>get_uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>MERGE_2INTS</name><argument_list>(<argument><expr><call><name>get_uint32</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>get_uint32</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8_t</name></type>
<name>read_uint8</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint16_t</name></type>
<name>read_uint16</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><call><name>get_uint16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>read_uint24</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <call><name>get_uint16</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>read_uint32</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><call><name>get_uint32</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>read_uint64</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><call><name>get_uint64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uintptr_t</name></type>
<name>read_uintptr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <name>SIZEOF_VOIDP</name><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOIDP</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<return>return <expr><call><name>get_uint64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>get_uint32</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>read_uint</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content> 
<return>return <expr><call><name>read_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>read_uleb128</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64_t</name></type>
<name>read_sleb128</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>sleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>debug_info_reader_init</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>mapped</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>debug_info</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>pend</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>debug_info</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <name><name>obj</name><operator>-&gt;</operator><name>debug_info</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>debug_line_cu_end</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>debug_line</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>di_read_debug_abbrev_cu</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>reader</name><operator>-&gt;</operator><name>q0</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>abbrev_number</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>abbrev_number</name> <operator>&lt;=</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>abbrev_number</name> <operator>&lt;</operator> <name>ABBREV_TABLE_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>abbrev_table</name><index>[<expr><name>abbrev_number</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>abbrev_number</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>at</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>form</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>at</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>form</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>di_read_debug_line_cu</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LineNumberProgramHeader</name></name></type> <name>header</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>reader</name><operator>-&gt;</operator><name>debug_line_cu_end</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_debug_line_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>debug_line_cu_end</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>header</name><operator>.</operator><name>cu_end</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>debug_line_directories</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>header</name><operator>.</operator><name>include_directories</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>debug_line_files</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>header</name><operator>.</operator><name>filenames</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_uint_value</name><parameter_list>(<parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>uint64</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>VAL_uint</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_int_value</name><parameter_list>(<parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>int64</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>VAL_int</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_cstr_value</name><parameter_list>(<parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>VAL_cstr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_cstrp_value</name><parameter_list>(<parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>VAL_cstr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_data_value</name><parameter_list>(<parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>VAL_data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_cstr_value</name><parameter_list>(<parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <name><name>v</name><operator>-&gt;</operator><name>off</name></name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>debug_info_reader_read_value</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>form</name></decl></parameter>, <parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>form</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_FORM_addr</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>address_size</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>address_size</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"unknown address_size:%d"</literal></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>address_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_block2</name></expr>:</case>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>read_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_data_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_block4</name></expr>:</case>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_data_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_data2</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_data4</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_data8</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_string</name></expr>:</case>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_cstr_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_block</name></expr>:</case>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_data_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_block1</name></expr>:</case>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_data_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_data1</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_flag</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_sdata</name></expr>:</case>
<expr_stmt><expr><call><name>set_int_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_sleb128</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_strp</name></expr>:</case>
<expr_stmt><expr><call><name>set_cstrp_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>debug_str</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><call><name>read_uint</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_udata</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uleb128</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_ref_addr</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>address_size</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>address_size</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"unknown address_size:%d"</literal></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>address_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_ref1</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_ref2</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_ref4</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_ref8</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_ref_udata</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_indirect</name></expr>:</case>

<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_sec_offset</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 








<break>break;</break>
<case>case <expr><name>DW_FORM_exprloc</name></expr>:</case>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>read_uleb128</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_data_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_flag_present</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_strx</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_addrx</name></expr>:</case>

<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_ref_sup4</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_strp_sup</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><name>DW_FORM_data16</name></expr>:</case>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_data_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_line_strp</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><name>DW_FORM_ref_sig8</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_implicit_const</name></expr>:</case>
<expr_stmt><expr><call><name>set_int_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_loclistx</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uleb128</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_rnglistx</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uleb128</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_ref_sup8</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_strx1</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_strx2</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_strx3</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint24</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_strx4</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_addrx1</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_addrx2</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_addrx3</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint24</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_FORM_addrx4</name></expr>:</case>
<expr_stmt><expr><call><name>set_uint_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<goto>goto <name>fail</name>;</goto>
<break>break;</break>
</block_content>}</block></switch>
<return>return;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d: unsupported form: %#"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>di_find_abbrev</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>abbrev_number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>abbrev_number</name> <operator>&lt;</operator> <name>ABBREV_TABLE_SIZE</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>reader</name><operator>-&gt;</operator><name>abbrev_table</name><index>[<expr><name>abbrev_number</name></expr>]</index></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>reader</name><operator>-&gt;</operator><name>abbrev_table</name><index>[<expr><name>ABBREV_TABLE_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>at</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>form</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>at</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>form</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><decl><type><name>uint64_t</name></type> <name>n</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>abbrev_number</name> <operator>!=</operator> <name>n</name></expr>;</condition> <incr><expr><name>n</name> <operator>=</operator> <call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%d: Abbrev Number %"</literal><name>PRId64</name><literal type="string">" not found\n"</literal></expr></argument>,<argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>abbrev_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>at</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>form</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>at</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>form</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void
hexdump0(const unsigned char *p, size_t n)
{
size_t i;
fprintf(stderr, " 0 1 2 3 4 5 6 7 8 9 A B C D E F\n");
for (i=0; i &lt; n; i++){
switch (i &amp; 15) {
case 0:
fprintf(stderr, "%02zd: %02X ", i/16, p[i]);
break;
case 15:
fprintf(stderr, "%02X\n", p[i]);
break;
default:
fprintf(stderr, "%02X ", p[i]);
break;
}
}
if ((i &amp; 15) != 15) {
fprintf(stderr, "\n");
}
}
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hexdump</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>hexdump0((const unsigned char *)p, n)</cpp:value></cpp:define>

static void
div_inspect(DebugInfoValue *v)
{
switch (v-&gt;type) {
case VAL_uint:
fprintf(stderr,"%d: type:%d size:%zx v:%lx\n",__LINE__,v-&gt;type,v-&gt;size,v-&gt;as.uint64);
break;
case VAL_int:
fprintf(stderr,"%d: type:%d size:%zx v:%ld\n",__LINE__,v-&gt;type,v-&gt;size,(int64_t)v-&gt;as.uint64);
break;
case VAL_cstr:
fprintf(stderr,"%d: type:%d size:%zx v:'%s'\n",__LINE__,v-&gt;type,v-&gt;size,v-&gt;as.ptr);
break;
case VAL_data:
fprintf(stderr,"%d: type:%d size:%zx v:\n",__LINE__,v-&gt;type,v-&gt;size);
hexdump(v-&gt;as.ptr, 16);
break;
}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>DIE</name> <modifier>*</modifier></type>
<name>di_read_die</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>DIE</name> <modifier>*</modifier></type><name>die</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>abbrev_number</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>abbrev_number</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>level</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>q</name></name> <operator>=</operator> <call><name>di_find_abbrev</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>abbrev_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>die</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>debug_info</name><operator>.</operator><name>ptr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>die</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>die</name><operator>-&gt;</operator><name>has_children</name></name> <operator>=</operator> <operator>*</operator><name><name>reader</name><operator>-&gt;</operator><name>q</name></name><operator>++</operator></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>die</name><operator>-&gt;</operator><name>has_children</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>level</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>die</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DebugInfoValue</name> <modifier>*</modifier></type>
<name>di_read_record</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>vp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>at</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>form</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>at</name> <operator>||</operator> <operator>!</operator><name>form</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>vp</name><operator>-&gt;</operator><name>at</name></name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vp</name><operator>-&gt;</operator><name>form</name></name> <operator>=</operator> <name>form</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug_info_reader_read_value</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>form</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>vp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>di_skip_records</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DebugInfoValue</name></type> <name>v</name> <init>= <expr><block>{<expr><block>{}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>at</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>form</name> <init>= <expr><call><name>uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>at</name> <operator>||</operator> <operator>!</operator><name>form</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>debug_info_reader_read_value</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>form</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>low_pc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>high_pc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ranges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>low_pc_set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>high_pc_set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ranges_set</name></decl>;</decl_stmt>
}</block></struct></type> <name>ranges_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ranges_set</name><parameter_list>(<parameter><decl><type><name>ranges_t</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>DebugInfoValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>at</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_AT_low_pc</name></expr>:</case>
<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>low_pc</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>uint64</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>low_pc_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_AT_high_pc</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>form</name></name> <operator>==</operator> <name>DW_FORM_addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>high_pc</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>uint64</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>high_pc</name></name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>low_pc</name></name> <operator>+</operator> <name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>uint64</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>high_pc_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_AT_ranges</name></expr>:</case>
<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>ranges</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>uint64</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>ranges_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uintptr_t</name></type>
<name>ranges_include</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>ranges_t</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>high_pc_set</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>ranges_set</name></name> <operator>||</operator> <operator>!</operator><name><name>ptr</name><operator>-&gt;</operator><name>low_pc_set</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>low_pc</name></name> <operator>&lt;=</operator> <name>addr</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>high_pc</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>ptr</name><operator>-&gt;</operator><name>low_pc</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>ranges_set</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>debug_ranges</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <name><name>ptr</name><operator>-&gt;</operator><name>ranges</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>base</name> <init>= <expr><ternary><condition><expr><name><name>ptr</name><operator>-&gt;</operator><name>low_pc_set</name></name></expr> ?</condition><then> <expr><name><name>ptr</name><operator>-&gt;</operator><name>low_pc</name></name></expr> </then><else>: <expr><name><name>reader</name><operator>-&gt;</operator><name>current_low_pc</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>from</name> <init>= <expr><call><name>read_uintptr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>to</name> <init>= <expr><call><name>read_uintptr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>to</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>UINTPTR_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>base</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>+</operator> <name>from</name> <operator>&lt;=</operator> <name>addr</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name>base</name> <operator>+</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>from</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>low_pc_set</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>low_pc</name></name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>ptr</name><operator>-&gt;</operator><name>low_pc</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void
ranges_inspect(DebugInfoReader *reader, ranges_t *ptr)
{
if (ptr-&gt;high_pc_set) {
if (ptr-&gt;ranges_set || !ptr-&gt;low_pc_set) {
fprintf(stderr,"low_pc_set:%d high_pc_set:%d ranges_set:%d\n",ptr-&gt;low_pc_set,ptr-&gt;high_pc_set,ptr-&gt;ranges_set);
exit(1);
}
fprintf(stderr,"low_pc:%"PRIx64" high_pc:%"PRIx64"\n",ptr-&gt;low_pc,ptr-&gt;high_pc);
}
else if (ptr-&gt;ranges_set) {
char *p = reader-&gt;obj-&gt;debug_ranges.ptr + ptr-&gt;ranges;
fprintf(stderr,"low_pc:%"PRIx64" ranges:%"PRIx64" %lx ",ptr-&gt;low_pc,ptr-&gt;ranges, p-reader-&gt;obj-&gt;mapped);
for (;;) {
uintptr_t from = read_uintptr(&amp;p);
uintptr_t to = read_uintptr(&amp;p);
if (!from &amp;&amp; !to) break;
fprintf(stderr,"%"PRIx64"-%"PRIx64" ",ptr-&gt;low_pc+from,ptr-&gt;low_pc+to);
}
fprintf(stderr,"\n");
}
else if (ptr-&gt;low_pc_set) {
fprintf(stderr,"low_pc:%"PRIx64"\n",ptr-&gt;low_pc);
}
else {
fprintf(stderr,"empty\n");
}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>di_read_cu</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>unit_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>debug_abbrev_offset</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>current_cu</name></name> <operator>=</operator> <name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>unit_length</name> <operator>=</operator> <call><name>read_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>unit_length</name> <operator>==</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>unit_length</name> <operator>=</operator> <call><name>read_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>cu_end</name></name> <operator>=</operator> <name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <name>unit_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>read_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>version</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>version</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>address_size</name></name> <operator>=</operator> <call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>debug_abbrev_offset</name> <operator>=</operator> <call><name>read_uint</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>debug_abbrev_offset</name> <operator>=</operator> <call><name>read_uint</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>address_size</name></name> <operator>=</operator> <call><name>read_uint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>q0</name></name> <operator>=</operator> <name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>debug_abbrev</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <name>debug_abbrev_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>di_read_debug_abbrev_cu</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>di_read_debug_line_cu</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER_BUILD_DATE</name></expr></argument>)</argument_list></call></expr></cpp:if>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>DIE</name></type> <name>die</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>di_read_die</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>die</name><operator>.</operator><name>tag</name></name> <operator>!=</operator> <name>DW_TAG_compile_unit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>di_skip_records</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DebugInfoValue</name></type> <name>v</name> <init>= <expr><block>{<expr><block>{}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>di_read_record</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>v</name><operator>.</operator><name>at</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_AT_low_pc</name></expr>:</case>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>current_low_pc</name></name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>as</name><operator>.</operator><name>uint64</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_abstract_origin</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>abstract_origin</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name><name>reader</name><operator>-&gt;</operator><name>q</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><name><name>reader</name><operator>-&gt;</operator><name>level</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DIE</name></type> <name>die</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>reader</name><operator>-&gt;</operator><name>current_cu</name></name> <operator>+</operator> <name>abstract_origin</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>di_read_die</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>finish</name>;</goto></block_content></block></if></if_stmt>


<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DebugInfoValue</name></type> <name>v</name> <init>= <expr><block>{<expr><block>{}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>di_read_record</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>v</name><operator>.</operator><name>at</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_AT_name</name></expr>:</case>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>sname</name></name> <operator>=</operator> <call><name>get_cstr_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<label><name>finish</name>:</label>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>q</name></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>debug_info_read</name><parameter_list>(<parameter><decl><type><name>DebugInfoReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>,
<parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>p</name></name> <operator>&lt;</operator> <name><name>reader</name><operator>-&gt;</operator><name>cu_end</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DIE</name></type> <name>die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ranges_t</name></type> <name>ranges</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>line_info_t</name></type> <name>line</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>di_read_die</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>die</name><operator>.</operator><name>tag</name></name> <operator>!=</operator> <name>DW_TAG_subprogram</name> <operator>&amp;&amp;</operator> <name><name>die</name><operator>.</operator><name>tag</name></name> <operator>!=</operator> <name>DW_TAG_inlined_subroutine</name></expr>)</condition> <block>{<block_content>
<label><name>skip_die</name>:</label>
<expr_stmt><expr><call><name>di_skip_records</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DebugInfoValue</name></type> <name>v</name> <init>= <expr><block>{<expr><block>{}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>di_read_record</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>


<switch>switch <condition>(<expr><name><name>v</name><operator>.</operator><name>at</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_AT_name</name></expr>:</case>
<expr_stmt><expr><name><name>line</name><operator>.</operator><name>sname</name></name> <operator>=</operator> <call><name>get_cstr_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_AT_call_file</name></expr>:</case>
<expr_stmt><expr><call><name>fill_filename</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>v</name><operator>.</operator><name>as</name><operator>.</operator><name>uint64</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>debug_line_directories</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>debug_line_files</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_AT_call_line</name></expr>:</case>
<expr_stmt><expr><name><name>line</name><operator>.</operator><name>line</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>v</name><operator>.</operator><name>as</name><operator>.</operator><name>uint64</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_AT_low_pc</name></expr>:</case>
<case>case <expr><name>DW_AT_high_pc</name></expr>:</case>
<case>case <expr><name>DW_AT_ranges</name></expr>:</case>
<expr_stmt><expr><call><name>ranges_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ranges</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_AT_declaration</name></expr>:</case>
<goto>goto <name>skip_die</name>;</goto>
<case>case <expr><name>DW_AT_inline</name></expr>:</case>

<break>break;</break> 
<case>case <expr><name>DW_AT_abstract_origin</name></expr>:</case>
<expr_stmt><expr><call><name>read_abstract_origin</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>as</name><operator>.</operator><name>uint64</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break> 
</block_content>}</block></switch>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><name>offset</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_traces</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>addr</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>traces</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>offset</name> <init>= <expr><name>addr</name> <operator>-</operator> <name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>+</operator> <name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>vmaddr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>saddr</name> <init>= <expr><call><name>ranges_include</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ranges</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>saddr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line_info_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line_info_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>dirname</name></name> <operator>=</operator> <name><name>line</name><operator>.</operator><name>dirname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name><name>line</name><operator>.</operator><name>filename</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>line</name><operator>.</operator><name>line</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>saddr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base_addr</name> <operator>=</operator> <name><name>line</name><operator>.</operator><name>base_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name> <operator>=</operator> <name><name>line</name><operator>.</operator><name>sname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>saddr</name> <operator>=</operator> <name>saddr</name> <operator>+</operator> <name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>-</operator> <name><name>reader</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>vmaddr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ELF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>uncompress_debug_section</name><argument_list>(<argument><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>shdr</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>file</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator><name>ptr</name></expr></argument>)</argument_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_COMPRESSED_DEBUG_LINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Chdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>chdr</name> <operator>=</operator> <operator>(</operator><call><name>ElfW</name><argument_list>(<argument><expr><name>Chdr</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><operator>(</operator><name>file</name> <operator>+</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>destsize</name> <init>= <expr><name><name>chdr</name><operator>-&gt;</operator><name>ch_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>chdr</name><operator>-&gt;</operator><name>ch_type</name></name> <operator>!=</operator> <name>ELFCOMPRESS_ZLIB</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>destsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>uncompress</name><argument_list>(<argument><expr><operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destsize</name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>Bytef</name><operator>*</operator><operator>)</operator><name>chdr</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Chdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Chdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<return>return <expr><name>destsize</name></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><specifier>static</specifier> <name>uintptr_t</name></type>
<name>fill_lines</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check_debuglink</name></decl></parameter>,
<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>objp</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shstr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Ehdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>ehdr</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>shdr</name></expr><operator>,</operator> <expr><operator>*</operator><name>shstr_shdr</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>gnu_debuglink_shdr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>filesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>symtab_shdr</name> <operator>=</operator> <name>NULL</name></expr><operator>,</operator> <expr><operator>*</operator><name>strtab_shdr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>dynsym_shdr</name> <operator>=</operator> <name>NULL</name></expr><operator>,</operator> <expr><operator>*</operator><name>dynstr_shdr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><operator>*</operator><name>objp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>dladdr_fbase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>filesize</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>filesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"lseek: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_OFF_T</name> <operator>&gt;</operator> <name>SIZEOF_SIZE_T</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>filesize</name> <operator>&gt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator><name>SIZE_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"Too large file %s\n"</literal></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>filesize</name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"mmap: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ehdr</name> <operator>=</operator> <operator>(</operator><call><name>ElfW</name><argument_list>(<argument><expr><name>Ehdr</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><name>file</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>ehdr</name><operator>-&gt;</operator><name>e_ident</name></name></expr></argument>, <argument><expr><literal type="string">"\177ELF"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>mapped</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>mapped_size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>filesize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>shdr</name> <operator>=</operator> <operator>(</operator><call><name>ElfW</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><operator>(</operator><name>file</name> <operator>+</operator> <name><name>ehdr</name><operator>-&gt;</operator><name>e_shoff</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>shstr_shdr</name> <operator>=</operator> <name>shdr</name> <operator>+</operator> <name><name>ehdr</name><operator>-&gt;</operator><name>e_shstrndx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>shstr</name> <operator>=</operator> <name>file</name> <operator>+</operator> <name><name>shstr_shdr</name><operator>-&gt;</operator><name>sh_offset</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ehdr</name><operator>-&gt;</operator><name>e_shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>section_name</name> <init>= <expr><name>shstr</name> <operator>+</operator> <name><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_name</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_STRTAB</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">".strtab"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>strtab_shdr</name> <operator>=</operator> <name>shdr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">".dynstr"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dynstr_shdr</name> <operator>=</operator> <name>shdr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>SHT_SYMTAB</name></expr>:</case>

<expr_stmt><expr><name>symtab_shdr</name> <operator>=</operator> <name>shdr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHT_DYNSYM</name></expr>:</case>

<expr_stmt><expr><name>dynsym_shdr</name> <operator>=</operator> <name>shdr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHT_PROGBITS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">".gnu_debuglink"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gnu_debuglink_shdr</name> <operator>=</operator> <name>shdr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>debug_section_names</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">".debug_abbrev"</literal></expr>,
<expr><literal type="string">".debug_info"</literal></expr>,
<expr><literal type="string">".debug_line"</literal></expr>,
<expr><literal type="string">".debug_ranges"</literal></expr>,
<expr><literal type="string">".debug_str"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>DWARF_SECTION_COUNT</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>obj_dwarf_section_at</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><name><name>debug_section_names</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>file</name> <operator>+</operator> <name><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_flags</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SHF_COMPRESSED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>uncompress_debug_section</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dynsym_shdr</name> <operator>&amp;&amp;</operator> <name>dynstr_shdr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strtab</name> <init>= <expr><name>file</name> <operator>+</operator> <name><name>dynstr_shdr</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>symtab</name> <operator>=</operator> <operator>(</operator><call><name>ElfW</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><operator>(</operator><name>file</name> <operator>+</operator> <name><name>dynsym_shdr</name><operator>-&gt;</operator><name>sh_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symtab_count</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>dynsym_shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><call><name>dlopen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RTLD_NOW</name><operator>|</operator><name>RTLD_LOCAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>handle</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>symtab_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name> <operator>=</operator> <operator>&amp;</operator><name><name>symtab</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Dl_info</name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STT_FUNC</name> <operator>||</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>dlsym</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>strtab</name> <operator>+</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&amp;&amp;</operator> <call><name>dladdr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>=</operator> <name>dladdr_fbase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dladdr_fbase</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>info</name><operator>.</operator><name>dli_fbase</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ehdr</name><operator>-&gt;</operator><name>e_type</name></name> <operator>==</operator> <name>ET_EXEC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>=</operator> <name>dladdr_fbase</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>debug_info</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>debug_abbrev</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DebugInfoReader</name></type> <name>reader</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>debug_info_reader_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>reader</name><operator>.</operator><name>p</name></name> <operator>&lt;</operator> <name><name>reader</name><operator>.</operator><name>pend</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>di_read_cu</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>use_symtab</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>debug_info_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else <block>{<block_content>

<label><name>use_symtab</name>:</label>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>symtab_shdr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>symtab_shdr</name> <operator>=</operator> <name>dynsym_shdr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>strtab_shdr</name> <operator>=</operator> <name>dynstr_shdr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>symtab_shdr</name> <operator>&amp;&amp;</operator> <name>strtab_shdr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strtab</name> <init>= <expr><name>file</name> <operator>+</operator> <name><name>strtab_shdr</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>symtab</name> <operator>=</operator> <operator>(</operator><call><name>ElfW</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><operator>(</operator><name>file</name> <operator>+</operator> <name><name>symtab_shdr</name><operator>-&gt;</operator><name>sh_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symtab_count</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>symtab_shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>symtab_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ElfW</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name> <operator>=</operator> <operator>&amp;</operator><name><name>symtab</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>saddr</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>+</operator> <name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STT_FUNC</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_traces</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>d</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>traces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>saddr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>d</name> <operator>&gt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name> <operator>=</operator> <name>strtab</name> <operator>+</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>saddr</name> <operator>=</operator> <name>saddr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base_addr</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>debug_line</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>gnu_debuglink_shdr</name> <operator>&amp;&amp;</operator> <name>check_debuglink</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>follow_debuglink</name><argument_list>(<argument><expr><name>file</name> <operator>+</operator> <name><name>gnu_debuglink_shdr</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>,
<argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>,
<argument><expr><name>objp</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>finish</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_debug_line</name><argument_list>(<argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>,
<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>debug_line</name><operator>.</operator><name>ptr</name></name></expr></argument>,
<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>debug_line</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<label><name>finish</name>:</label>
<return>return <expr><name>dladdr_fbase</name></expr>;</return>
<label><name>fail</name>:</label>
<return>return <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><specifier>static</specifier> <name>uintptr_t</name></type>
<name>fill_lines</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check_debuglink</name></decl></parameter>,
<parameter><decl><type><name>obj_info_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>objp</name></decl></parameter>, <parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__LP64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x##_64</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>filesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><operator>*</operator><name>objp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LP</name></name></type><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list> <modifier>*</modifier><name>header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>dladdr_fbase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>binary_filename</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>max</name> <init>= <expr><name>PATH_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>basesize</name> <init>= <expr><name>size</name> <operator>-</operator> <operator>(</operator><name>base</name> <operator>-</operator> <name>binary_filename</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">".dSYM/Contents/Resources/DWARF/"</literal></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;=</operator> <name>basesize</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>basesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>basesize</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><name>filesize</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>filesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"lseek: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_OFF_T</name> <operator>&gt;</operator> <name>SIZEOF_SIZE_T</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>filesize</name> <operator>&gt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator><name>SIZE_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"Too large file %s\n"</literal></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>filesize</name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"mmap: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>mapped</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>mapped_size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>filesize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator>struct <call><name>LP</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><name>file</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <call><name>LP</name><argument_list>(<argument><expr><name>MH_MAGIC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>FAT_CIGAM</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>LP</name></name></type><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list> <modifier>*</modifier><name>mhp</name> <init>= <expr><call><name>_NSGetMachExecuteHeader</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>fat_header</name></name> <modifier>*</modifier></type><name>fat</name> <init>= <expr><operator>(</operator>struct <name>fat_header</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>file</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>fat</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nfat_arch</name> <init>= <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name><name>fat</name><operator>-&gt;</operator><name>nfat_arch</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfat_arch</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>fat_arch</name></name> <modifier>*</modifier></type><name>arch</name> <init>= <expr><operator>(</operator>struct <name>fat_arch</name> <operator>*</operator><operator>)</operator><name>q</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cpu_type_t</name></type> <name>cputype</name> <init>= <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name><name>arch</name><operator>-&gt;</operator><name>cputype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cpu_subtype_t</name></type> <name>cpusubtype</name> <init>= <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name><name>arch</name><operator>-&gt;</operator><name>cpusubtype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>offset</name> <init>= <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name><name>arch</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mhp</name><operator>-&gt;</operator><name>cputype</name></name> <operator>==</operator> <name>cputype</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>cpu_subtype_t</name><operator>)</operator><operator>(</operator><name><name>mhp</name><operator>-&gt;</operator><name>cpusubtype</name></name> <operator>&amp;</operator> <operator>~</operator><name>CPU_SUBTYPE_MASK</name><operator>)</operator> <operator>==</operator> <name>cpusubtype</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>file</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>file</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator>struct <call><name>LP</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <call><name>LP</name><argument_list>(<argument><expr><name>MH_MAGIC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>found_mach_header</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>q</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>arch</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"'%s' is not a Mach-O universal binary file!\n"</literal></expr></argument>,<argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"'%s' is not a "</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__LP64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<literal type="string">"64"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<literal type="string">"32"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<literal type="string">"-bit Mach-O file!\n"</literal></expr></argument>,<argument><expr><name>binary_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></else></if_stmt>
<label><name>found_mach_header</name>:</label>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>header</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>header</name><operator>-&gt;</operator><name>ncmds</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>load_command</name></name> <modifier>*</modifier></type><name>lcmd</name> <init>= <expr><operator>(</operator>struct <name>load_command</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>lcmd</name><operator>-&gt;</operator><name>cmd</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><call><name>LP</name><argument_list>(<argument><expr><name>LC_SEGMENT</name></expr></argument>)</argument_list></call></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>debug_section_names</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"__debug_abbrev"</literal></expr>,
<expr><literal type="string">"__debug_info"</literal></expr>,
<expr><literal type="string">"__debug_line"</literal></expr>,
<expr><literal type="string">"__debug_ranges"</literal></expr>,
<expr><literal type="string">"__debug_str"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LP</name></name></type><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list> <modifier>*</modifier><name>scmd</name> <init>= <expr><operator>(</operator>struct <call><name>LP</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><name>lcmd</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>scmd</name><operator>-&gt;</operator><name>segname</name></name></expr></argument>, <argument><expr><literal type="string">"__TEXT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>vmaddr</name></name> <operator>=</operator> <name><name>scmd</name><operator>-&gt;</operator><name>vmaddr</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>scmd</name><operator>-&gt;</operator><name>segname</name></name></expr></argument>, <argument><expr><literal type="string">"__DWARF"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <call><name>LP</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>uint64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scmd</name><operator>-&gt;</operator><name>nsects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>LP</name></name></type><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list> <modifier>*</modifier><name>sect</name> <init>= <expr><operator>(</operator>struct <call><name>LP</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <call><name>LP</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>DWARF_SECTION_COUNT</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>obj_dwarf_section_at</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sect</name><operator>-&gt;</operator><name>sectname</name></name></expr></argument>, <argument><expr><name><name>debug_section_names</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>file</name> <operator>+</operator> <name><name>sect</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>sect</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>sect</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SHF_COMPRESSED</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<case>case <expr><name>LC_SYMTAB</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>symtab_command</name></name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator>struct <name>symtab_command</name> <operator>*</operator><operator>)</operator><name>lcmd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LP</name></name></type><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list> <modifier>*</modifier><name>nl</name> <init>= <expr><operator>(</operator>struct <call><name>LP</name><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><operator>(</operator><name>file</name> <operator>+</operator> <name><name>cmd</name><operator>-&gt;</operator><name>symoff</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strtab</name> <init>= <expr><name>file</name> <operator>+</operator> <name><name>cmd</name><operator>-&gt;</operator><name>stroff</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>saddr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>nsyms</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>symsize</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LP</name></name></type><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list> <modifier>*</modifier><name>e</name> <init>= <expr><operator>&amp;</operator><name><name>nl</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>n_type</name></name> <operator>!=</operator> <name>N_FUN</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>n_sect</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>saddr</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>n_value</name></name> <operator>+</operator> <name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>-</operator> <name><name>obj</name><operator>-&gt;</operator><name>vmaddr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sname</name> <operator>=</operator> <name>strtab</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_strx</name></name></expr>;</expr_stmt>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name>offset</name></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>num_traces</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>traces</name><index>[<expr><name>k</name></expr>]</index></name> <operator>-</operator> <name>saddr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>symsize</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>n_value</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>d</name> <operator>&gt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>symsize</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lines</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>sname</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>lines</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>sname</name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>saddr</name> <operator>=</operator> <name>saddr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>base_addr</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>lcmd</name><operator>-&gt;</operator><name>cmdsize</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>debug_info</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>debug_abbrev</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DebugInfoReader</name></type> <name>reader</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>debug_info_reader_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>reader</name><operator>.</operator><name>p</name></name> <operator>&lt;</operator> <name><name>reader</name><operator>.</operator><name>pend</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>di_read_cu</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>debug_info_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_debug_line</name><argument_list>(<argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>,
<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>debug_line</name><operator>.</operator><name>ptr</name></name></expr></argument>,
<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>debug_line</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<return>return <expr><name>dladdr_fbase</name></expr>;</return>
<label><name>fail</name>:</label>
<return>return <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MAIN_EXE_PATH</name></cpp:macro></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>main_exe_path</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROC_SELF_EXE</name></cpp:macro> <cpp:value>"/proc/self/exe"</cpp:value></cpp:define>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name> <init>= <expr><call><name>readlink</name><argument_list>(<argument><expr><name>PROC_SELF_EXE</name></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>binary_filename</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>main_exe_path</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>CTL_KERN</name></expr>, <expr><name>KERN_PROC</name></expr>, <expr><name>KERN_PROC_PATHNAME</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>PATH_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>sysctl</name><argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"Can't get the path of ruby"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt> 
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBPROC_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>main_exe_path</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>proc_pidpath</name><argument_list>(<argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>binary_filename</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_MAIN_EXE_PATH</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_line0</name><parameter_list>(<parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>addr</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>address</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>d</name> <init>= <expr><name>addr</name> <operator>-</operator> <name><name>line</name><operator>-&gt;</operator><name>saddr</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>address</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>line</name><operator>-&gt;</operator><name>dirname</name></name> <operator>&amp;&amp;</operator> <name><name>line</name><operator>-&gt;</operator><name>dirname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"%s(%s) %s/%s:%d\n"</literal></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>dirname</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"%s(%s) %s:%d\n"</literal></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>path</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"[0x%"</literal><name>PRIxPTR</name><literal type="string">"]\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>saddr</name></name> <operator>||</operator> <operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>sname</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"%s(0x%"</literal><name>PRIxPTR</name><literal type="string">") [0x%"</literal><name>PRIxPTR</name><literal type="string">"]\n"</literal></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>addr</name><operator>-</operator><name><name>line</name><operator>-&gt;</operator><name>base_addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>line</name><operator>-&gt;</operator><name>line</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"%s(%s+0x%"</literal><name>PRIxPTR</name><literal type="string">") [0x%"</literal><name>PRIxPTR</name><literal type="string">"]\n"</literal></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>,
<argument><expr><name>d</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"%s(%s+0x%"</literal><name>PRIxPTR</name><literal type="string">") [0x%"</literal><name>PRIxPTR</name><literal type="string">"] ???:%d\n"</literal></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>,
<argument><expr><name>d</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>line</name><operator>-&gt;</operator><name>dirname</name></name> <operator>&amp;&amp;</operator> <name><name>line</name><operator>-&gt;</operator><name>dirname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"%s(%s+0x%"</literal><name>PRIxPTR</name><literal type="string">") [0x%"</literal><name>PRIxPTR</name><literal type="string">"] %s/%s:%d\n"</literal></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>,
<argument><expr><name>d</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>dirname</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>kprintf</name><argument_list>(<argument><expr><literal type="string">"%s(%s+0x%"</literal><name>PRIxPTR</name><literal type="string">") [0x%"</literal><name>PRIxPTR</name><literal type="string">"] %s:%d\n"</literal></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>,
<argument><expr><name>d</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_line</name><parameter_list>(<parameter><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>print_line0</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>line</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_dump_backtrace_with_lines</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_traces</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>traces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>lines</name> <init>= <expr><operator>(</operator><name>line_info_t</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>num_traces</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line_info_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>dladdr_fbases</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><name>num_traces</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MAIN_EXE_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>main_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>main_exe_path</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>main_path</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>alloca</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>main_path</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>addr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>main_path</name></expr></argument>, <argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>append_obj</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name>main_path</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>fill_lines</name><argument_list>(<argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dladdr_fbases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_traces</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Dl_info</name></type> <name>info</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dladdr</name><argument_list>(<argument><expr><name><name>traces</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>p</name><operator>=</operator><name>dladdr_fbases</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name><name>info</name><operator>.</operator><name>dli_fbase</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>dli_fname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>dli_sname</name></name></expr>;</expr_stmt>
<goto>goto <name>next_line</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>dli_fbase</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_obj</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>base_addr</name></name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>info</name><operator>.</operator><name>dli_fbase</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>dli_fname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>dli_sname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>saddr</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>info</name><operator>.</operator><name>dli_saddr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>binary_filename</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fill_lines</name><argument_list>(<argument><expr><name>num_traces</name></expr></argument>, <argument><expr><name>traces</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>next_line</name>:</label>
<continue>continue;</continue>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_traces</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>traces</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>


<while>while <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>obj_info_t</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name>obj</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DWARF_SECTION_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dwarf_section</name></name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>obj_dwarf_section_at</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SHF_COMPRESSED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>mapped_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>mapped</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>mapped_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_traces</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>next</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>line</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>line_info_t</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>line</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dladdr_fbases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXNBUF</name></cpp:macro> <cpp:value>(sizeof(intmax_t) * CHAR_BIT + 1)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>toupper</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><ternary><condition><expr><operator>(</operator><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x5f</literal><operator>)</operator></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</return> </block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hex2ascii</name><parameter_list>(<parameter><type><name>hex</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(hex2ascii_data[hex])</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>hex2ascii_data</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789abcdefghijklmnopqrstuvwxyz"</literal></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>imax</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><ternary><condition><expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>kvprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>radix</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>putce</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ret</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>kprintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>kvprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>putce</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ksprintn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nbuf</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lenp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>upper</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>nbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>hex2ascii</name><argument_list>(<argument><expr><name>num</name> <operator>%</operator> <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>++</operator><name>p</name> <operator>=</operator> <ternary><condition><expr><name>upper</name></expr> ?</condition><then> <expr><call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>num</name> <operator>/=</operator> <name>base</name></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>lenp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>lenp</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>nbuf</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>



























<function><type><specifier>static</specifier> <name>int</name></type>
<name>kvprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>radix</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHAR</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{int cc=(c); if (func) (*func)(cc); else *d++ = cc; retval++; }</cpp:value></cpp:define>
<decl_stmt><decl><type><name>char</name></type> <name><name>nbuf</name><index>[<expr><name>MAXNBUF</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>percent</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>up</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>, <decl><type ref="prev"/><name>lflag</name></decl>, <decl><type ref="prev"/><name>qflag</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>, <decl><type ref="prev"/><name>width</name></decl>, <decl><type ref="prev"/><name>ladjust</name></decl>, <decl><type ref="prev"/><name>sharpflag</name></decl>, <decl><type ref="prev"/><name>neg</name></decl>, <decl><type ref="prev"/><name>sign</name></decl>, <decl><type ref="prev"/><name>dot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cflag</name></decl>, <decl><type ref="prev"/><name>hflag</name></decl>, <decl><type ref="prev"/><name>jflag</name></decl>, <decl><type ref="prev"/><name>tflag</name></decl>, <decl><type ref="prev"/><name>zflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dwidth</name></decl>, <decl><type ref="prev"/><name>upper</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>padc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>func</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <literal type="string">"(fmt null)\n"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>radix</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>radix</name></expr></argument> &gt;</argument_list></name> <literal type="number">36</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>radix</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>padc</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>fmt</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'%'</literal> <operator>||</operator> <name>stop</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>retval</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>percent</name> <operator>=</operator> <name>fmt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>qflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>lflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>ladjust</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>sharpflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>dot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>dwidth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>upper</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>hflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>jflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>tflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>zflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>reswitch</name>:</label> <switch>switch <condition>(<expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>fmt</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>
<expr_stmt><expr><name>dot</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'#'</literal></expr>:</case>
<expr_stmt><expr><name>sharpflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<expr_stmt><expr><name>ladjust</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'%'</literal></expr>:</case>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dot</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>width</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ladjust</name> <operator>=</operator> <operator>!</operator><name>ladjust</name></expr>;</expr_stmt>
<expr_stmt><expr><name>width</name> <operator>=</operator> <operator>-</operator><name>width</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>dwidth</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'0'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dot</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>padc</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
</block_content>}</block></if></if_stmt>
<case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case>
<case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><operator>++</operator><name>fmt</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name>ch</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>fmt</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ch</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <name>ch</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>dot</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dwidth</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>width</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <call><name>ksprintn</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><operator>*</operator><name>q</name></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><operator>*</operator><name>q</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>n</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><ternary><condition><expr><name>tmp</name></expr> ?</condition><then> <expr><literal type="char">','</literal></expr> </then><else>: <expr><literal type="char">'&lt;'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>n</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>&gt;</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>&gt;</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for></block_content></block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<expr_stmt><expr><name>up</name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned char *</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>width</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while<condition>(<expr><name>width</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><call><name>hex2ascii</name><argument_list>(<argument><expr><operator>*</operator><name>up</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><call><name>hex2ascii</name><argument_list>(<argument><expr><operator>*</operator><name>up</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>up</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>width</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>q</name><operator>=</operator><name>p</name></expr>;</init><condition><expr><operator>*</operator><name>q</name></expr>;</condition><incr><expr><name>q</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></while>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<case>case <expr><literal type="char">'i'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>handle_sign</name>;</goto>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>hflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>hflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><name>jflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>lflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>qflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>lflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>jflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>intmax_t</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>retval</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>qflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int64_t</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>retval</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>lflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>long</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>retval</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>zflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>size_t</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>retval</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>hflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>short</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>retval</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>cflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>retval</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>retval</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<goto>goto <name>handle_nosign</name>;</goto>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sharpflag</name> <operator>=</operator> <operator>(</operator><name>width</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>number</name>;</goto>
<case>case <expr><literal type="char">'q'</literal></expr>:</case>
<expr_stmt><expr><name>qflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <name>radix</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>handle_sign</name>;</goto></block_content></block></if></if_stmt>
<goto>goto <name>handle_nosign</name>;</goto>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="string">"(null)"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dot</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>dwidth</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for></block_content></block></else></if_stmt>

<expr_stmt><expr><name>width</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ladjust</name> <operator>&amp;&amp;</operator> <name>width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><name>width</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><name>padc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>n</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>ladjust</name> <operator>&amp;&amp;</operator> <name>width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><name>width</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><name>padc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><name>tflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<goto>goto <name>handle_nosign</name>;</goto>
<case>case <expr><literal type="char">'X'</literal></expr>:</case>
<expr_stmt><expr><name>upper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<goto>goto <name>handle_nosign</name>;</goto>
<case>case <expr><literal type="char">'y'</literal></expr>:</case>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>handle_sign</name>;</goto>
<case>case <expr><literal type="char">'z'</literal></expr>:</case>
<expr_stmt><expr><name>zflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>reswitch</name>;</goto>
<label><name>handle_nosign</name>:</label>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>jflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>uintmax_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>qflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>tflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>ptrdiff_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>lflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned long</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>zflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>hflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>cflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned int</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>number</name>;</goto>
<label><name>handle_sign</name>:</label>
<if_stmt><if>if <condition>(<expr><name>jflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>intmax_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>qflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>tflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>ptrdiff_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>lflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>zflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>hflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>cflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<label><name>number</name>:</label>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>intmax_t</name><operator>)</operator><name>num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ksprintn</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sharpflag</name> <operator>&amp;&amp;</operator> <name>num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ladjust</name> <operator>&amp;&amp;</operator> <name>padc</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dwidth</name> <operator>=</operator> <name>width</name> <operator>-</operator> <name>tmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>width</name> <operator>-=</operator> <name>tmp</name> <operator>+</operator> <call><name>imax</name><argument_list>(<argument><expr><name>dwidth</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dwidth</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ladjust</name></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><name>width</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sharpflag</name> <operator>&amp;&amp;</operator> <name>num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><literal type="char">'x'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>dwidth</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>ladjust</name></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><name>width</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>

<break>break;</break>
<default>default:</default>
<while>while <condition>(<expr><name>percent</name> <operator>&lt;</operator> <name>fmt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PCHAR</name><argument_list>(<argument><expr><operator>*</operator><name>percent</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>






<expr_stmt><expr><name>stop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PCHAR</name></cpp:undef>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
<cpp:error>#<cpp:directive>error</cpp:directive> not supported</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
