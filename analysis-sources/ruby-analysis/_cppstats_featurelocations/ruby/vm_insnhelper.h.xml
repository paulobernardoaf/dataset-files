<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\vm_insnhelper.h">










<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_INSNHELPER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_INSNHELPER_H</name></cpp:macro></cpp:define>

<decl_stmt><decl><type><name>RUBY_SYMBOL_EXPORT_BEGIN</name>

<name>RUBY_EXTERN</name> <name>VALUE</name></type> <name>ruby_vm_const_missing_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>rb_serial_t</name></type> <name>ruby_vm_global_method_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>rb_serial_t</name></type> <name>ruby_vm_global_constant_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>rb_serial_t</name></type> <name>ruby_vm_class_serial</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RUBY_SYMBOL_EXPORT_END</name>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_COLLECT_USAGE_DETAILS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_USAGE_INSN</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vm_collect_usage_insn(insn)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_USAGE_OPERAND</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>op</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vm_collect_usage_operand((insn), (n), ((VALUE)(op)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_USAGE_REGISTER</name><parameter_list>(<parameter><type><name>reg</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vm_collect_usage_register((reg), (s))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_USAGE_INSN</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_USAGE_OPERAND</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>op</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_USAGE_REGISTER</name><parameter_list>(<parameter><type><name>reg</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SET_SV(x), INC_SP(1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOPN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(GET_SP()-(n)-1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(DEC_SP(n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(DEC_SP(1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_ADDR_FROM_TOP</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(GET_SP()-(n))</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_REG_CFP</name></cpp:macro> <cpp:value>(reg_cfp)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_REG_PC</name></cpp:macro> <cpp:value>(VM_REG_CFP-&gt;pc)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_REG_SP</name></cpp:macro> <cpp:value>(VM_REG_CFP-&gt;sp)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_REG_EP</name></cpp:macro> <cpp:value>(VM_REG_CFP-&gt;ep)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_REGS</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { VM_REG_CFP = ec-&gt;cfp; } while (0)</cpp:value></cpp:define>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_COLLECT_USAGE_DETAILS</name></expr></cpp:if>
<name><name>enum</name> <name>vm_regan_regtype</name></name></type> <block>{<block_content>
<expr_stmt><expr><name>VM_REGAN_PC</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator>
<expr><name>VM_REGAN_SP</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator>
<expr><name>VM_REGAN_EP</name> <operator>=</operator> <literal type="number">2</literal></expr><operator>,</operator>
<expr><name>VM_REGAN_CFP</name> <operator>=</operator> <literal type="number">3</literal></expr><operator>,</operator>
<expr><name>VM_REGAN_SELF</name> <operator>=</operator> <literal type="number">4</literal></expr><operator>,</operator>
<expr><name>VM_REGAN_ISEQ</name> <operator>=</operator> <literal type="number">5</literal></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <name>vm_regan_acttype</name> <block>{
<decl><name>VM_REGAN_ACT_GET</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>VM_REGAN_ACT_SET</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_USAGE_REGISTER_HELPER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(COLLECT_USAGE_REGISTER((VM_REGAN_##a), (VM_REGAN_ACT_##b)), (v))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLECT_USAGE_REGISTER_HELPER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_PC</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(COLLECT_USAGE_REGISTER_HELPER(PC, GET, VM_REG_PC))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_PC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VM_REG_PC = (COLLECT_USAGE_REGISTER_HELPER(PC, SET, (x))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_CURRENT_INSN</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(*GET_PC())</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_OPERAND</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(GET_PC()[(n)])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_PC</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SET_PC(VM_REG_PC + (n)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMP</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SET_PC(VM_REG_PC + (dst)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_CFP</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(COLLECT_USAGE_REGISTER_HELPER(CFP, GET, VM_REG_CFP))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_EP</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(COLLECT_USAGE_REGISTER_HELPER(EP, GET, VM_REG_EP))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_EP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VM_REG_EP = (COLLECT_USAGE_REGISTER_HELPER(EP, SET, (x))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LEP</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(VM_EP_LEP(GET_EP()))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_SP</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(COLLECT_USAGE_REGISTER_HELPER(SP, GET, VM_REG_SP))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_SP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VM_REG_SP = (COLLECT_USAGE_REGISTER_HELPER(SP, SET, (x))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INC_SP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VM_REG_SP += (COLLECT_USAGE_REGISTER_HELPER(SP, SET, (x))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEC_SP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VM_REG_SP -= (COLLECT_USAGE_REGISTER_HELPER(SP, SET, (x))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_SV</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*GET_SP() = (x))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ISEQ</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(GET_CFP()-&gt;iseq)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_PREV_EP</name><parameter_list>(<parameter><type><name>ep</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((VALUE *)((ep)[VM_ENV_DATA_INDEX_SPECVAL] &amp; ~0x03))</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_SELF</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(COLLECT_USAGE_REGISTER_HELPER(SELF, GET, GET_CFP()-&gt;self))</cpp:value></cpp:define>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CC_SET_FASTPATH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>vm_call_handler</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>enabled</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name>enabled</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vm_cc_call_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_BLOCK_HANDLER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(GET_LEP()[VM_ENV_DATA_INDEX_SPECVAL])</cpp:value></cpp:define>










<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETUP_CANARY</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>VALUE *canary; if (leaf) { canary = GET_SP(); SET_SV(vm_stack_canary); } else {SET_SV(Qfalse); }</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_CANARY</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>if (leaf) { if (*canary == vm_stack_canary) { *canary = Qfalse; } else { vm_canary_is_found_dead(INSN_ATTR(bin), *canary); } }</cpp:value></cpp:define>








<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETUP_CANARY</name><parameter_list>()</parameter_list></cpp:macro></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_CANARY</name><parameter_list>()</parameter_list></cpp:macro></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_SIMPLE_METHOD</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { rb_snum_t x = leaf ? INSN_ATTR(width) : 0; rb_snum_t y = attr_width_opt_send_without_block(0); rb_snum_t z = x - y; ADD_PC(z); DISPATCH_ORIGINAL_INSN(opt_send_without_block); } while (0)</cpp:value></cpp:define>






<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREV_CLASS_SERIAL</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(ruby_vm_class_serial)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_CLASS_SERIAL</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(++ruby_vm_class_serial)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_GLOBAL_METHOD_STATE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(ruby_vm_global_method_state)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INC_GLOBAL_METHOD_STATE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(++ruby_vm_global_method_state)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_GLOBAL_CONSTANT_STATE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(ruby_vm_global_constant_state)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INC_GLOBAL_CONSTANT_STATE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(++ruby_vm_global_constant_state)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type>
<name>THROW_DATA_NEW</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><operator>(</operator>struct <name>vm_throw_data</name> <operator>*</operator><operator>)</operator><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_throw_data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>throw_state</name></name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>
<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>
<name>THROW_DATA_VAL</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>throw_obj</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>
<name>THROW_DATA_CATCH_FRAME</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>catch_frame</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>THROW_DATA_STATE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>throw_state</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>THROW_DATA_CONSUMED_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>THROW_DATA_CONSUMED</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>THROW_DATA_CATCH_FRAME_SET</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>catch_frame</name></name> <operator>=</operator> <name>cfp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>THROW_DATA_STATE_SET</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>throw_state</name></name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>THROW_DATA_CONSUMED_SET</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>THROW_DATA_STATE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TAG_BREAK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>THROW_DATA_CONSUMED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ARGS_SPLAT</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(vm_ci_flag(ci) &amp; VM_CALL_ARGS_SPLAT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ARGS_KEYWORD</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(vm_ci_flag(ci) &amp; VM_CALL_KWARG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ARGS_KW_SPLAT</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(vm_ci_flag(ci) &amp; VM_CALL_KW_SPLAT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ARGS_KW_OR_KW_SPLAT</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(vm_ci_flag(ci) &amp; (VM_CALL_KWARG | VM_CALL_KW_SPLAT))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ARGS_KW_SPLAT_MUT</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(vm_ci_flag(ci) &amp; VM_CALL_KW_SPLAT_MUT)</cpp:value></cpp:define>



<function><type><specifier>static</specifier> <name>bool</name></type>
<name>vm_call_iseq_optimizable_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>!</operator><call><name>IS_ARGS_SPLAT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_ARGS_KEYWORD</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PROTECTED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
