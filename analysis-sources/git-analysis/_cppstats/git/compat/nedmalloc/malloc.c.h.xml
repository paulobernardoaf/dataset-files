<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\compat\nedmalloc\malloc.c.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_GNU_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKS_FCNTL_H</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WINNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_WIN32_WINNT</name></cpp:macro> <cpp:value>0x403</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MMAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MORECORE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKS_UNISTD_H</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKS_SYS_PARAM_H</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKS_SYS_MMAN_H</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKS_STRING_H</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKS_STRINGS_H</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKS_SYS_TYPES_H</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKS_ERRNO_H</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MALLOC_FAILURE_ACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_FAILURE_ACTION</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_CLEARS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_CLEARS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DARWIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_DARWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MORECORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MORECORE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MMAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MALLOC_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ALIGNMENT</name></cpp:macro> <cpp:value>((size_t)16U)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_SYS_TYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SIZE_T</name></cpp:macro> <cpp:value>(~(size_t)0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ONLY_MSPACES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONLY_MSPACES</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONLY_MSPACES</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSPACES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ONLY_MSPACES</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSPACES</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSPACES</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MALLOC_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ALIGNMENT</name></cpp:macro> <cpp:value>((size_t)8U)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FOOTERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOOTERS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ABORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABORT</name></cpp:macro> <cpp:value>abort()</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ABORT_ON_ASSERT_FAILURE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABORT_ON_ASSERT_FAILURE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PROCEED_ON_ERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROCEED_ON_ERROR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LOCKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_LOCKS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_SPIN_LOCKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1310</literal><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_SPIN_LOCKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_SPIN_LOCKS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>INSECURE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSECURE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MMAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MMAP_CLEARS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_CLEARS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MREMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MREMAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MREMAP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MALLOC_FAILURE_ACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_FAILURE_ACTION</name></cpp:macro> <cpp:value>errno = ENOMEM;</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MORECORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ONLY_MSPACES</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MORECORE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MORECORE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_MORECORE</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MORECORE_CONTIGUOUS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MORECORE_DEFAULT</name></cpp:macro> <cpp:value>sbrk</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MORECORE_CONTIGUOUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MORECORE_CONTIGUOUS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DEFAULT_GRANULARITY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>MORECORE_CONTIGUOUS</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_GRANULARITY</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_GRANULARITY</name></cpp:macro> <cpp:value>((size_t)64U * (size_t)1024U)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DEFAULT_TRIM_THRESHOLD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MORECORE_CANNOT_TRIM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TRIM_THRESHOLD</name></cpp:macro> <cpp:value>((size_t)2U * (size_t)1024U * (size_t)1024U)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TRIM_THRESHOLD</name></cpp:macro> <cpp:value>MAX_SIZE_T</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DEFAULT_MMAP_THRESHOLD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MMAP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MMAP_THRESHOLD</name></cpp:macro> <cpp:value>((size_t)256U * (size_t)1024U)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MMAP_THRESHOLD</name></cpp:macro> <cpp:value>MAX_SIZE_T</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAX_RELEASE_CHECK_RATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MMAP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_RELEASE_CHECK_RATE</name></cpp:macro> <cpp:value>4095</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_RELEASE_CHECK_RATE</name></cpp:macro> <cpp:value>MAX_SIZE_T</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_BUILTIN_FFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_BUILTIN_FFS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_DEV_RANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_DEV_RANDOM</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_MALLINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_MALLINFO</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MALLINFO_FIELD_TYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLINFO_FIELD_TYPE</name></cpp:macro> <cpp:value>size_t</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_SEGMENT_TRAVERSAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SEGMENT_TRAVERSAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_TRIM_THRESHOLD</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_GRANULARITY</name></cpp:macro> <cpp:value>(-2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_MMAP_THRESHOLD</name></cpp:macro> <cpp:value>(-3)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>NO_MALLINFO</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USR_INCLUDE_MALLOC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"/usr/include/malloc.h"</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>STRUCT_MALLINFO_DECLARED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRUCT_MALLINFO_DECLARED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<struct>struct <name>mallinfo</name> <block>{

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>arena</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>ordblks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>smblks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>hblks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>hblkhd</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>usmblks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>fsmblks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>uordblks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>fordblks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MALLINFO_FIELD_TYPE</name></type> <name>keepcost</name></decl>;</decl_stmt> 

}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW64_VERSION_MAJOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FORCEINLINE</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FORCEINLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCEINLINE</name></cpp:macro> <cpp:value>__inline __attribute__ ((always_inline))</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCEINLINE</name></cpp:macro> <cpp:value>__forceinline</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NOINLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOINLINE</name></cpp:macro> <cpp:value>__attribute__ ((noinline))</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOINLINE</name></cpp:macro> <cpp:value>__declspec(noinline)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOINLINE</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FORCEINLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCEINLINE</name></cpp:macro> <cpp:value>inline</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FORCEINLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCEINLINE</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>ONLY_MSPACES</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_DL_PREFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlcalloc</name></cpp:macro> <cpp:value>calloc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlfree</name></cpp:macro> <cpp:value>free</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmalloc</name></cpp:macro> <cpp:value>malloc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmemalign</name></cpp:macro> <cpp:value>memalign</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlrealloc</name></cpp:macro> <cpp:value>realloc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlvalloc</name></cpp:macro> <cpp:value>valloc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlpvalloc</name></cpp:macro> <cpp:value>pvalloc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmallinfo</name></cpp:macro> <cpp:value>mallinfo</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmallopt</name></cpp:macro> <cpp:value>mallopt</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmalloc_trim</name></cpp:macro> <cpp:value>malloc_trim</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmalloc_stats</name></cpp:macro> <cpp:value>malloc_stats</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmalloc_usable_size</name></cpp:macro> <cpp:value>malloc_usable_size</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmalloc_footprint</name></cpp:macro> <cpp:value>malloc_footprint</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlmalloc_max_footprint</name></cpp:macro> <cpp:value>malloc_max_footprint</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlindependent_calloc</name></cpp:macro> <cpp:value>independent_calloc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dlindependent_comalloc</name></cpp:macro> <cpp:value>independent_comalloc</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>dlmalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>dlfree</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>dlcalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>dlrealloc</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>dlmemalign</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>dlvalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>dlmallopt</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>dlmalloc_footprint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>dlmalloc_max_footprint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>NO_MALLINFO</name></expr></cpp:if>

<function_decl><type><name><name>struct</name> <name>mallinfo</name></name></type> <name>dlmallinfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function_decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>dlindependent_calloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>dlindependent_comalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>dlpvalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>dlmalloc_trim</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>dlmalloc_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function_decl><type><name>size_t</name></type> <name>dlmalloc_usable_size</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MSPACES</name></expr></cpp:if>

<typedef>typedef <type><name>void</name><modifier>*</modifier></type> <name>mspace</name>;</typedef>

<function_decl><type><name>mspace</name></type> <name>create_mspace</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>capacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locked</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>destroy_mspace</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>mspace</name></type> <name>create_mspace_with_base</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>capacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locked</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>mspace_mmap_large_chunks</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>enable</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>mspace_malloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>mspace_free</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>mspace_realloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newsize</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>mspace_calloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elem_size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier></type> <name>mspace_memalign</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>mspace_independent_calloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>elem_size</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name><name>chunks</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>mspace_independent_comalloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name><name>sizes</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name><name>chunks</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>mspace_footprint</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>mspace_max_footprint</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>NO_MALLINFO</name></expr></cpp:if>

<function_decl><type><name><name>struct</name> <name>mallinfo</name></name></type> <name>mspace_mallinfo</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function_decl><type><name>size_t</name></type> <name>mspace_usable_size</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>mspace_malloc_stats</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>mspace_trim</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>mspace_mallopt</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern><empty_stmt>;</empty_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name> <name>disable</name> <name>:</name> <name>4146</name> <name>)</name></cpp:pragma> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_ERRNO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FOOTERS</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_STDLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ABORT_ON_ASSERT_FAILURE</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assert</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if(!(x)) ABORT</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>assert</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assert</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_STRING_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_BUILTIN_FFS</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_STRINGS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MMAP</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_SYS_MMAN_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>extern</specifier> <name>void</name><modifier>*</modifier></type> <name>sbrk</name><parameter_list>(<parameter><decl><type><name>ptrdiff_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__SVR4</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;thread.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_M_AMD64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>LONG</name> <name>__cdecl</name></type> <name>_InterlockedCompareExchange</name><parameter_list>(<parameter><decl><type><name>LONG</name> <specifier>volatile</specifier> <modifier>*</modifier></type><name>Dest</name></decl></parameter>, <parameter><decl><type><name>LONG</name></type> <name>Exchange</name></decl></parameter>, <parameter><decl><type><name>LONG</name></type> <name>Comp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>LONG</name> <name>__cdecl</name></type> <name>_InterlockedExchange</name><parameter_list>(<parameter><decl><type><name>LONG</name> <specifier>volatile</specifier> <modifier>*</modifier></type><name>Target</name></decl></parameter>, <parameter><decl><type><name>LONG</name></type> <name>Value</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name> <name>(</name><name>_InterlockedCompareExchange</name><name>)</name></cpp:pragma>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name> <name>(</name><name>_InterlockedExchange</name><name>)</name></cpp:pragma>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>__GNUC__</name> <operator>*</operator> <literal type="number">10000</literal> <operator>+</operator> <name>__GNUC_MINOR__</name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <name>__GNUC_PATCHLEVEL__</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">40100</literal></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_ReadWriteBarrier</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_ReadWriteBarrier</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>__sync_synchronize()</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>static</specifier> <name>__inline__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>always_inline</name><operator>)</operator></expr></argument>)</argument_list> <name>long</name> <name>__sync_lock_test_and_set</name><argument_list>(<argument><expr><specifier>volatile</specifier> <name>long</name> <operator>*</operator> <specifier>const</specifier> <name>Target</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>long</name> <name>Value</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>res</name></decl>;</decl_stmt>

<asm>__asm__ <specifier>__volatile__</specifier>("xchg%z0 %2, %0" : "=g" (*(Target)), "=r" (res) : "1" (Value));</asm>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>__inline__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>always_inline</name><operator>)</operator></expr></argument>)</argument_list> <name>_MemoryBarrier</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>

<block>{<block_content>

<asm>__asm__ <specifier>__volatile__</specifier>("" : : : "memory");</asm>

</block_content>}</block></decl></decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_ReadWriteBarrier</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>_MemoryBarrier()</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>__inline__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>always_inline</name><operator>)</operator></expr></argument>)</argument_list> <name>long</name> <name>_InterlockedExchange</name><argument_list>(<argument><expr><specifier>volatile</specifier> <name>long</name> <operator>*</operator> <specifier>const</specifier> <name>Target</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>long</name> <name>Value</name></expr></argument>)</argument_list>

<block>{<block_content>

<expr_stmt><expr><call><name>_ReadWriteBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>__sync_lock_test_and_set</name><argument_list>(<argument><expr><name>Target</name></expr></argument>, <argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>interlockedcompareexchange</name></cpp:macro> <cpp:value>_InterlockedCompareExchange</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>interlockedexchange</name></cpp:macro> <cpp:value>_InterlockedExchange</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BitScanForward</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function_decl><type><name>unsigned</name> <name>char</name></type> <name>_BitScanForward</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>unsigned</name> <name>char</name></type> <name>_BitScanReverse</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BitScanForward</name></cpp:macro> <cpp:value>_BitScanForward</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BitScanReverse</name></cpp:macro> <cpp:value>_BitScanReverse</cpp:value></cpp:define>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_BitScanForward</name><name>)</name></cpp:pragma>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_BitScanReverse</name><name>)</name></cpp:pragma>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>malloc_getpagesize</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SC_PAGE_SIZE</name></cpp:macro> <cpp:value>_SC_PAGESIZE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SC_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>sysconf(_SC_PAGE_SIZE)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BSD</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>DGUX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPAGESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>extern</specifier> <name>size_t</name></type> <name>getpagesize</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>getpagesize()</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>getpagesize()</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LACKS_SYS_PARAM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXEC_PAGESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>EXEC_PAGESIZE</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NBPG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CLSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>NBPG</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>(NBPG * CLSIZE)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NBPC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>NBPC</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PAGESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>PAGESIZE</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_getpagesize</name></cpp:macro> <cpp:value>((size_t)4096U)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_SIZE</name></cpp:macro> <cpp:value>(sizeof(size_t))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_BITSIZE</name></cpp:macro> <cpp:value>(sizeof(size_t) &lt;&lt; 3)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_ZERO</name></cpp:macro> <cpp:value>((size_t)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_ONE</name></cpp:macro> <cpp:value>((size_t)1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_TWO</name></cpp:macro> <cpp:value>((size_t)2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_FOUR</name></cpp:macro> <cpp:value>((size_t)4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWO_SIZE_T_SIZES</name></cpp:macro> <cpp:value>(SIZE_T_SIZE&lt;&lt;1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUR_SIZE_T_SIZES</name></cpp:macro> <cpp:value>(SIZE_T_SIZE&lt;&lt;2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIX_SIZE_T_SIZES</name></cpp:macro> <cpp:value>(FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HALF_MAX_SIZE_T</name></cpp:macro> <cpp:value>(MAX_SIZE_T / 2U)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_ALIGN_MASK</name></cpp:macro> <cpp:value>(MALLOC_ALIGNMENT - SIZE_T_ONE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_aligned</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((size_t)((A)) &amp; (CHUNK_ALIGN_MASK)) == 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>align_offset</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((((size_t)(A) &amp; CHUNK_ALIGN_MASK) == 0)? 0 :((MALLOC_ALIGNMENT - ((size_t)(A) &amp; CHUNK_ALIGN_MASK)) &amp; CHUNK_ALIGN_MASK))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MFAIL</name></cpp:macro> <cpp:value>((void*)(MAX_SIZE_T))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMFAIL</name></cpp:macro> <cpp:value>((char*)(MFAIL))</cpp:value></cpp:define> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MMAP</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNMAP_DEFAULT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>munmap((a), (s))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_PROT</name></cpp:macro> <cpp:value>(PROT_READ|PROT_WRITE)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANON</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_ANONYMOUS</name></cpp:macro> <cpp:value>MAP_ANON</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_FLAGS</name></cpp:macro> <cpp:value>(MAP_PRIVATE|MAP_ANONYMOUS)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_DEFAULT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_FLAGS</name></cpp:macro> <cpp:value>(MAP_PRIVATE)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dev_zero_fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_DEFAULT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((dev_zero_fd &lt; 0) ? (dev_zero_fd = open("/dev/zero", O_RDWR), mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_MMAP_DEFAULT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MMAP_DEFAULT(s)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>void</name><modifier>*</modifier></type> <name>win32mmap</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><call><name>VirtualAlloc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MEM_RESERVE</name><operator>|</operator><name>MEM_COMMIT</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>ptr</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>ptr</name></expr></then><else>: <expr><name>MFAIL</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>void</name><modifier>*</modifier></type> <name>win32direct_mmap</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><call><name>VirtualAlloc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MEM_RESERVE</name><operator>|</operator><name>MEM_COMMIT</name><operator>|</operator><name>MEM_TOP_DOWN</name></expr></argument>,

<argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>ptr</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>ptr</name></expr></then><else>: <expr><name>MFAIL</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>int</name></type> <name>win32munmap</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>MEMORY_BASIC_INFORMATION</name></type> <name>minfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>cptr</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VirtualQuery</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>minfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>minfo</name><operator>.</operator><name>BaseAddress</name></name> <operator>!=</operator> <name>cptr</name> <operator>||</operator> <name><name>minfo</name><operator>.</operator><name>AllocationBase</name></name> <operator>!=</operator> <name>cptr</name> <operator>||</operator>

<name><name>minfo</name><operator>.</operator><name>State</name></name> <operator>!=</operator> <name>MEM_COMMIT</name> <operator>||</operator> <name><name>minfo</name><operator>.</operator><name>RegionSize</name></name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VirtualFree</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MEM_RELEASE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cptr</name> <operator>+=</operator> <name><name>minfo</name><operator>.</operator><name>RegionSize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <name><name>minfo</name><operator>.</operator><name>RegionSize</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_DEFAULT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>win32mmap(s)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNMAP_DEFAULT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>win32munmap((a), (s))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_MMAP_DEFAULT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>win32direct_mmap(s)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MREMAP</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MREMAP_DEFAULT</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>osz</name></type></parameter>, <parameter><type><name>nsz</name></type></parameter>, <parameter><type><name>mv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mremap((addr), (osz), (nsz), (mv))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MORECORE</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MORECORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MORECORE</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MORECORE(S)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MORECORE</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MORECORE_DEFAULT(S)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MORECORE</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MFAIL</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MMAP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_MMAPPED_BIT</name></cpp:macro> <cpp:value>(SIZE_T_ONE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_MMAP_BIT</name></cpp:macro> <cpp:value>(SIZE_T_ONE)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MMAP(s)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MMAP_DEFAULT(s)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MUNMAP</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MUNMAP((a), (s))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MUNMAP</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MUNMAP_DEFAULT((a), (s))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DIRECT_MMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_DIRECT_MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DIRECT_MMAP(s)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_DIRECT_MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DIRECT_MMAP_DEFAULT(s)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_MMAPPED_BIT</name></cpp:macro> <cpp:value>(SIZE_T_ZERO)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_MMAP_BIT</name></cpp:macro> <cpp:value>(SIZE_T_ZERO)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MFAIL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNMAP</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MFAIL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_DIRECT_MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DIRECT_MMAP(s)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MMAP(s)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MUNMAP</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MUNMAP((a), (s))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MMAP</name> <operator>&amp;&amp;</operator> <name>HAVE_MREMAP</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MREMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>osz</name></type></parameter>, <parameter><type><name>nsz</name></type></parameter>, <parameter><type><name>mv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MREMAP((addr), (osz), (nsz), (mv))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>osz</name></type></parameter>, <parameter><type><name>nsz</name></type></parameter>, <parameter><type><name>mv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MREMAP_DEFAULT((addr), (osz), (nsz), (mv))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>osz</name></type></parameter>, <parameter><type><name>nsz</name></type></parameter>, <parameter><type><name>mv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MFAIL</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NONCONTIGUOUS_BIT</name></cpp:macro> <cpp:value>(4U)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERN_BIT</name></cpp:macro> <cpp:value>(8U)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_SPIN_LOCKS</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>pthread_mlock_t</name> <block>{

<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>int</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>pthread_t</name></type> <name>threadid</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLOCK_T</name></cpp:macro> <cpp:value>struct pthread_mlock_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURRENT_THREAD</name></cpp:macro> <cpp:value>pthread_self()</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(memset(sl, 0, sizeof(MLOCK_T)), 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_acquire_lock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_release_lock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_try_lock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPINS_PER_YIELD</name></cpp:macro> <cpp:value>63</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>MLOCK_T</name></type> <name>malloc_global_mutex</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>int</name></type> <name>pthread_acquire_lock</name> <parameter_list>(<parameter><decl><type><name>MLOCK_T</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>spins</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>int</name><modifier>*</modifier></type> <name>lp</name> <init>= <expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>l</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>lp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>==</operator> <name>CURRENT_THREAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>sl</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<asm>__asm__ <specifier>__volatile__</specifier> ("lock; cmpxchgl %1, %2"

: "=a" (ret)

: "r" (val), "m" (*(lp)), "0"(cmp)

: "memory", "cc");</asm>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>=</operator> <name>CURRENT_THREAD</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>++</operator><name>spins</name> <operator>&amp;</operator> <name>SPINS_PER_YIELD</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__SVR4</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if> 

<expr_stmt><expr><call><name>thr_yield</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>sched_yield</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>void</name></type> <name>pthread_release_lock</name> <parameter_list>(<parameter><decl><type><name>MLOCK_T</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>l</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>==</operator> <name>CURRENT_THREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>sl</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>int</name><modifier>*</modifier></type> <name>lp</name> <init>= <expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>l</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<asm>__asm__ <specifier>__volatile__</specifier> ("lock; xchgl %0, %1"

: "=r" (ret)

: "m" (*(lp)), "0"(prev)

: "memory");</asm>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>int</name></type> <name>pthread_try_lock</name> <parameter_list>(<parameter><decl><type><name>MLOCK_T</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>int</name><modifier>*</modifier></type> <name>lp</name> <init>= <expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>l</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>lp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>==</operator> <name>CURRENT_THREAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>sl</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<asm>__asm__ <specifier>__volatile__</specifier> ("lock; cmpxchgl %1, %2"

: "=a" (ret)

: "r" (val), "m" (*(lp)), "0"(cmp)

: "memory", "cc");</asm>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>=</operator> <name>CURRENT_THREAD</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<struct>struct <name>win32_mlock_t</name>

<block>{

<decl_stmt><decl><type><specifier>volatile</specifier> <name>long</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>long</name></type> <name>threadid</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>return_0</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLOCK_T</name></cpp:macro> <cpp:value>struct win32_mlock_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURRENT_THREAD</name></cpp:macro> <cpp:value>win32_getcurrentthreadid()</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(memset(sl, 0, sizeof(MLOCK_T)), return_0(0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>win32_acquire_lock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>win32_release_lock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>win32_try_lock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPINS_PER_YIELD</name></cpp:macro> <cpp:value>63</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>MLOCK_T</name></type> <name>malloc_global_mutex</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>long</name></type> <name>win32_getcurrentthreadid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>long</name> <modifier>*</modifier></type><name>threadstruct</name><init>=<expr><operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><call><name>__readfsdword</name><argument_list>(<argument><expr><literal type="number">0x18</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>threadid</name><init>=<expr><name><name>threadstruct</name><index>[<expr><literal type="number">0x24</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></init></decl>;</decl_stmt>

<return>return <expr><name>threadid</name></expr>;</return>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<return>return <expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>int</name></type> <name>win32_acquire_lock</name> <parameter_list>(<parameter><decl><type><name>MLOCK_T</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>spins</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>l</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>==</operator> <name>CURRENT_THREAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>sl</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>interlockedexchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>l</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>c</name></name><operator>=</operator><name>CURRENT_THREAD</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>=</operator> <name>CURRENT_THREAD</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>++</operator><name>spins</name> <operator>&amp;</operator> <name>SPINS_PER_YIELD</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>SleepEx</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>void</name></type> <name>win32_release_lock</name> <parameter_list>(<parameter><decl><type><name>MLOCK_T</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>==</operator> <name>CURRENT_THREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>l</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>sl</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>interlockedexchange</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>l</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCEINLINE</name> <name>int</name></type> <name>win32_try_lock</name> <parameter_list>(<parameter><decl><type><name>MLOCK_T</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>l</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>==</operator> <name>CURRENT_THREAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>sl</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>interlockedexchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>l</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>threadid</name></name> <operator>=</operator> <name>CURRENT_THREAD</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLOCK_T</name></cpp:macro> <cpp:value>pthread_mutex_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURRENT_THREAD</name></cpp:macro> <cpp:value>pthread_self()</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_init_lock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_mutex_lock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_mutex_unlock(sl)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_LOCK</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!pthread_mutex_trylock(sl))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>MLOCK_T</name></type> <name>malloc_global_mutex</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PTHREAD_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name> <name>pthread_mutexattr_setkind_np</name></type> <name>__P</name> <argument_list>(<argument><expr><operator>(</operator><name>pthread_mutexattr_t</name> <operator>*</operator><name>__attr</name><operator>,</operator>

<name>int</name> <name>__kind</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTHREAD_MUTEX_RECURSIVE</name></cpp:macro> <cpp:value>PTHREAD_MUTEX_RECURSIVE_NP</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_mutexattr_settype</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_mutexattr_setkind_np(x,y)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pthread_init_lock</name> <parameter_list>(<parameter><decl><type><name>MLOCK_T</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>attr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_mutexattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_mutexattr_settype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>PTHREAD_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><name>sl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_mutexattr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLOCK_T</name></cpp:macro> <cpp:value>CRITICAL_SECTION</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURRENT_THREAD</name></cpp:macro> <cpp:value>GetCurrentThreadId()</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_LOCK</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!InitializeCriticalSectionAndSpinCount((s), 0x80000000|4000))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_LOCK</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(EnterCriticalSection(s), 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_LOCK</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LeaveCriticalSection(s)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_LOCK</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TryEnterCriticalSection(s)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_GLOBAL_LOCK_INIT</name></cpp:macro></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>MLOCK_T</name></type> <name>malloc_global_mutex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>long</name></type> <name>malloc_global_mutex_status</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_malloc_global_mutex</name><parameter_list>()</parameter_list> <block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>stat</name> <init>= <expr><name>malloc_global_mutex_status</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stat</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>stat</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>interlockedcompareexchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>malloc_global_mutex_status</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>malloc_global_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>interlockedexchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>malloc_global_mutex_status</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SleepEx</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></cpp:if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_LOCK_BIT</name></cpp:macro> <cpp:value>(2U)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_LOCK_BIT</name></cpp:macro> <cpp:value>(0U)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_LOCK</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_MALLOC_GLOBAL_LOCK</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>ACQUIRE_LOCK(&amp;malloc_global_mutex);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_MALLOC_GLOBAL_LOCK</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>RELEASE_LOCK(&amp;malloc_global_mutex);</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_MALLOC_GLOBAL_LOCK</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_MALLOC_GLOBAL_LOCK</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<struct>struct <name>malloc_chunk</name> <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>prev_foot</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>head</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_chunk</name></name><modifier>*</modifier></type> <name>fd</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_chunk</name></name><modifier>*</modifier></type> <name>bk</name></decl>;</decl_stmt>

}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>malloc_chunk</name></name></type> <name>mchunk</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>malloc_chunk</name></name><modifier>*</modifier></type> <name>mchunkptr</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>malloc_chunk</name></name><modifier>*</modifier></type> <name>sbinptr</name>;</typedef> 

<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>bindex_t</name>;</typedef> 

<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>binmap_t</name>;</typedef> 

<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>flag_t</name>;</typedef> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCHUNK_SIZE</name></cpp:macro> <cpp:value>(sizeof(mchunk))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FOOTERS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_OVERHEAD</name></cpp:macro> <cpp:value>(TWO_SIZE_T_SIZES)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_OVERHEAD</name></cpp:macro> <cpp:value>(SIZE_T_SIZE)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_CHUNK_OVERHEAD</name></cpp:macro> <cpp:value>(TWO_SIZE_T_SIZES)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_FOOT_PAD</name></cpp:macro> <cpp:value>(FOUR_SIZE_T_SIZES)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_CHUNK_SIZE</name><parameter_list>(</parameter_list></cpp:macro>(MCHUNK_SIZE + CHUNK_ALIGN_MASK) &amp; ~CHUNK_ALIGN_MASK)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunk2mem</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void*)((char*)(p) + TWO_SIZE_T_SIZES))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mem2chunk</name><parameter_list>(<parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>align_as_chunk</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(mchunkptr)((A) + align_offset(chunk2mem(A)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REQUEST</name></cpp:macro> <cpp:value>((-MIN_CHUNK_SIZE) &lt;&lt; 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_REQUEST</name></cpp:macro> <cpp:value>(MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pad_request</name><parameter_list>(<parameter><type><name>req</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) &amp; ~CHUNK_ALIGN_MASK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>request2size</name><parameter_list>(<parameter><type><name>req</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((req) &lt; MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PINUSE_BIT</name></cpp:macro> <cpp:value>(SIZE_T_ONE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CINUSE_BIT</name></cpp:macro> <cpp:value>(SIZE_T_TWO)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG4_BIT</name></cpp:macro> <cpp:value>(SIZE_T_FOUR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INUSE_BITS</name></cpp:macro> <cpp:value>(PINUSE_BIT|CINUSE_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG_BITS</name></cpp:macro> <cpp:value>(PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FENCEPOST_HEAD</name></cpp:macro> <cpp:value>(INUSE_BITS|SIZE_T_SIZE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)-&gt;head &amp; CINUSE_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)-&gt;head &amp; PINUSE_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunksize</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)-&gt;head &amp; ~(FLAG_BITS))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)-&gt;head &amp;= ~PINUSE_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_cinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)-&gt;head &amp;= ~CINUSE_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunk_plus_offset</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((mchunkptr)(((char*)(p)) + (s)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunk_minus_offset</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((mchunkptr)(((char*)(p)) - (s)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_chunk</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((mchunkptr)( ((char*)(p)) + ((p)-&gt;head &amp; ~FLAG_BITS)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>prev_chunk</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_foot) ))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((next_chunk(p)-&gt;head) &amp; PINUSE_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_foot</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((mchunkptr)((char*)(p) + (s)))-&gt;prev_foot)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_foot</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((mchunkptr)((char*)(p) + (s)))-&gt;prev_foot = (s))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_size_and_pinuse_of_free_chunk</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((p)-&gt;head = (s|PINUSE_BIT), set_foot(p, s))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_free_with_pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_mmapped</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(!((p)-&gt;head &amp; PINUSE_BIT) &amp;&amp; ((p)-&gt;prev_foot &amp; IS_MMAPPED_BIT))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>overhead_for</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MMAP_CLEARS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>calloc_must_clear</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!is_mmapped(p))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>calloc_must_clear</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<struct>struct <name>malloc_tree_chunk</name> <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>prev_foot</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>head</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_tree_chunk</name></name><modifier>*</modifier></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_tree_chunk</name></name><modifier>*</modifier></type> <name>bk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_tree_chunk</name></name><modifier>*</modifier></type> <name><name>child</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_tree_chunk</name></name><modifier>*</modifier></type> <name>parent</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>index</name></decl>;</decl_stmt>

}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>malloc_tree_chunk</name></name></type> <name>tchunk</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>malloc_tree_chunk</name></name><modifier>*</modifier></type> <name>tchunkptr</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>malloc_tree_chunk</name></name><modifier>*</modifier></type> <name>tbinptr</name>;</typedef> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>leftmost_child</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t)-&gt;child[0] != 0? (t)-&gt;child[0] : (t)-&gt;child[1])</cpp:value></cpp:define>

<struct>struct <name>malloc_segment</name> <block>{

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>base</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_segment</name></name><modifier>*</modifier></type> <name>next</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>flag_t</name></type> <name>sflags</name></decl>;</decl_stmt> 

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_mmapped_segment</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((S)-&gt;sflags &amp; IS_MMAPPED_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_extern_segment</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((S)-&gt;sflags &amp; EXTERN_BIT)</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>malloc_segment</name></name></type> <name>msegment</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>malloc_segment</name></name><modifier>*</modifier></type> <name>msegmentptr</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSMALLBINS</name></cpp:macro> <cpp:value>(32U)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTREEBINS</name></cpp:macro> <cpp:value>(32U)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLBIN_SHIFT</name></cpp:macro> <cpp:value>(3U)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLBIN_WIDTH</name></cpp:macro> <cpp:value>(SIZE_T_ONE &lt;&lt; SMALLBIN_SHIFT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREEBIN_SHIFT</name></cpp:macro> <cpp:value>(8U)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_LARGE_SIZE</name></cpp:macro> <cpp:value>(SIZE_T_ONE &lt;&lt; TREEBIN_SHIFT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SMALL_SIZE</name></cpp:macro> <cpp:value>(MIN_LARGE_SIZE - SIZE_T_ONE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SMALL_REQUEST</name></cpp:macro> <cpp:value>(MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)</cpp:value></cpp:define>

<struct>struct <name>malloc_state</name> <block>{

<decl_stmt><decl><type><name>binmap_t</name></type> <name>smallmap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>treemap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>dvsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>topsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>least_addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>dv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>top</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>trim_check</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>release_checks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>magic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name><name>smallbins</name><index>[<expr><operator>(</operator><name>NSMALLBINS</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tbinptr</name></type> <name><name>treebins</name><index>[<expr><name>NTREEBINS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>footprint</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>max_footprint</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>flag_t</name></type> <name>mflags</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name></expr></cpp:if>

<decl_stmt><decl><type><name>MLOCK_T</name></type> <name>mutex</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<decl_stmt><decl><type><name>msegment</name></type> <name>seg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>extp</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>exts</name></decl>;</decl_stmt>

}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>malloc_state</name></name><modifier>*</modifier></type> <name>mstate</name>;</typedef>

<struct>struct <name>malloc_params</name> <block>{

<decl_stmt><decl><type><specifier>volatile</specifier> <name>size_t</name></type> <name>magic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>page_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>granularity</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>mmap_threshold</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>trim_threshold</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>flag_t</name></type> <name>default_mflags</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>malloc_params</name></name></type> <name>mparams</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ensure_initialization</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((void)(mparams.magic != 0 || init_mparams()))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>ONLY_MSPACES</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>malloc_state</name></name></type> <name>_gm_</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gm</name></cpp:macro> <cpp:value>(&amp;_gm_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_global</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M) == &amp;_gm_)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_initialized</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;top != 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>use_lock</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;mflags &amp; USE_LOCK_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>enable_lock</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;mflags |= USE_LOCK_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>disable_lock</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;mflags &amp;= ~USE_LOCK_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>use_mmap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;mflags &amp; USE_MMAP_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>enable_mmap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;mflags |= USE_MMAP_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>disable_mmap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;mflags &amp;= ~USE_MMAP_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>use_noncontiguous</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;mflags &amp; USE_NONCONTIGUOUS_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>disable_contiguous</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;mflags |= USE_NONCONTIGUOUS_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_lock</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((M)-&gt;mflags = (L)?((M)-&gt;mflags | USE_LOCK_BIT) :((M)-&gt;mflags &amp; ~USE_LOCK_BIT))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>page_align</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(((S) + (mparams.page_size - SIZE_T_ONE)) &amp; ~(mparams.page_size - SIZE_T_ONE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>granularity_align</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(((S) + (mparams.granularity - SIZE_T_ONE))&amp; ~(mparams.granularity - SIZE_T_ONE))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mmap_align</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>granularity_align(S)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mmap_align</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>page_align(S)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYS_ALLOC_PADDING</name></cpp:macro> <cpp:value>(TOP_FOOT_SIZE + MALLOC_ALIGNMENT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_page_aligned</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(((size_t)(S) &amp; (mparams.page_size - SIZE_T_ONE)) == 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_granularity_aligned</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(((size_t)(S) &amp; (mparams.granularity - SIZE_T_ONE)) == 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>segment_holds</name><parameter_list>(<parameter><type><name>S</name></type></parameter>, <parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((char*)(A) &gt;= S-&gt;base &amp;&amp; (char*)(A) &lt; S-&gt;base + S-&gt;size)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>msegmentptr</name></type> <name>segment_holding</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>sp</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>has_segment_link</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>msegmentptr</name></type> <name>ss</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>sp</name> <operator>&gt;=</operator> <name><name>ss</name><operator>-&gt;</operator><name>base</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>sp</name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>ss</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MORECORE_CANNOT_TRIM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>should_trim</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((s) &gt; (M)-&gt;trim_check)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>should_trim</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOP_FOOT_SIZE</name><parameter_list>(<parameter><type><name>align_offset</name></type></parameter></parameter_list></cpp:macro>(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREACTION</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((use_lock(M))? ACQUIRE_LOCK(&amp;(M)-&gt;mutex) : 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSTACTION</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (use_lock(M)) RELEASE_LOCK(&amp;(M)-&gt;mutex); }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PREACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREACTION</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>POSTACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSTACTION</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PROCEED_ON_ERROR</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>malloc_corruption_error_count</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reset_on_error</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CORRUPTION_ERROR_ACTION</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>reset_on_error(m)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_ERROR_ACTION</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CORRUPTION_ERROR_ACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CORRUPTION_ERROR_ACTION</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ABORT</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USAGE_ERROR_ACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_ERROR_ACTION</name><parameter_list>(<parameter><type><name>m</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ABORT</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>DEBUG</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_free_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_inuse_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_malloced_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>,<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_mmapped_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_malloc_state</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_top_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_free_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do_check_free_chunk(M,P)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_inuse_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do_check_inuse_chunk(M,P)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_top_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do_check_top_chunk(M,P)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_malloced_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>,<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do_check_malloced_chunk(M,P,N)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_mmapped_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do_check_mmapped_chunk(M,P)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_malloc_state</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do_check_malloc_state(M)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_any_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_top_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_mmapped_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_inuse_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_free_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_malloced_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_tree</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>tchunkptr</name></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_treebin</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>bindex_t</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_smallbin</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>bindex_t</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_check_malloc_state</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>bin_find</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>traverse_and_check</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_small</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((s) &gt;&gt; SMALLBIN_SHIFT) &lt; NSMALLBINS)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>small_index</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((s) &gt;&gt; SMALLBIN_SHIFT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>small_index2size</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((i) &lt;&lt; SMALLBIN_SHIFT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_SMALL_INDEX</name></cpp:macro> <cpp:value>(small_index(MIN_CHUNK_SIZE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>smallbin_at</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sbinptr)((char*)&amp;((M)-&gt;smallbins[(i)&lt;&lt;1])))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>treebin_at</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((M)-&gt;treebins[i]))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_tree_index</name><parameter_list>(<parameter><type><name>S</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{unsigned int X = S &gt;&gt; TREEBIN_SHIFT;if (X == 0)I = 0;else if (X &gt; 0xFFFF)I = NTREEBINS-1;else {unsigned int K;__asm__("bsrl\t%1, %0\n\t" : "=r" (K) : "rm" (X));I = (bindex_t)((K &lt;&lt; 1) + ((S &gt;&gt; (K + (TREEBIN_SHIFT-1)) &amp; 1)));}}</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_tree_index</name><parameter_list>(<parameter><type><name>S</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{size_t X = S &gt;&gt; TREEBIN_SHIFT;if (X == 0)I = 0;else if (X &gt; 0xFFFF)I = NTREEBINS-1;else {unsigned int K = _bit_scan_reverse (X); I = (bindex_t)((K &lt;&lt; 1) + ((S &gt;&gt; (K + (TREEBIN_SHIFT-1)) &amp; 1)));}}</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_tree_index</name><parameter_list>(<parameter><type><name>S</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{size_t X = S &gt;&gt; TREEBIN_SHIFT;if (X == 0)I = 0;else if (X &gt; 0xFFFF)I = NTREEBINS-1;else {unsigned int K;_BitScanReverse((DWORD *) &amp;K, X);I = (bindex_t)((K &lt;&lt; 1) + ((S &gt;&gt; (K + (TREEBIN_SHIFT-1)) &amp; 1)));}}</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_tree_index</name><parameter_list>(<parameter><type><name>S</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{size_t X = S &gt;&gt; TREEBIN_SHIFT;if (X == 0)I = 0;else if (X &gt; 0xFFFF)I = NTREEBINS-1;else {unsigned int Y = (unsigned int)X;unsigned int N = ((Y - 0x100) &gt;&gt; 16) &amp; 8;unsigned int K = (((Y &lt;&lt;= N) - 0x1000) &gt;&gt; 16) &amp; 4;N += K;N += K = (((Y &lt;&lt;= K) - 0x4000) &gt;&gt; 16) &amp; 2;K = 14 - N + ((Y &lt;&lt;= K) &gt;&gt; 15);I = (K &lt;&lt; 1) + ((S &gt;&gt; (K + (TREEBIN_SHIFT-1)) &amp; 1));}}</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bit_for_tree_index</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>leftshift_for_tree_index</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((i == NTREEBINS-1)? 0 : ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 2)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>minsize_for_tree_index</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((SIZE_T_ONE &lt;&lt; (((i) &gt;&gt; 1) + TREEBIN_SHIFT)) | (((size_t)((i) &amp; SIZE_T_ONE)) &lt;&lt; (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 1)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>idx2bit</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((binmap_t)(1) &lt;&lt; (i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mark_smallmap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;smallmap |= idx2bit(i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_smallmap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;smallmap &amp;= ~idx2bit(i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>smallmap_is_marked</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;smallmap &amp; idx2bit(i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mark_treemap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;treemap |= idx2bit(i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_treemap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;treemap &amp;= ~idx2bit(i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>treemap_is_marked</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;treemap &amp; idx2bit(i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>least_bit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &amp; -(x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>left_bits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x&lt;&lt;1) | -(x&lt;&lt;1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>same_or_left_bits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) | -(x))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_bit2idx</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{unsigned int J;__asm__("bsfl\t%1, %0\n\t" : "=r" (J) : "rm" (X));I = (bindex_t)J;}</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_bit2idx</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{unsigned int J;J = _bit_scan_forward (X); I = (bindex_t)J;}</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_bit2idx</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{unsigned int J;_BitScanForward((DWORD *) &amp;J, X);I = (bindex_t)J;}</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>USE_BUILTIN_FFS</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_bit2idx</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>I = ffs(X)-1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_bit2idx</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{unsigned int Y = X - 1;unsigned int K = Y &gt;&gt; (16-4) &amp; 16;unsigned int N = K; Y &gt;&gt;= K;N += K = Y &gt;&gt; (8-3) &amp; 8; Y &gt;&gt;= K;N += K = Y &gt;&gt; (4-2) &amp; 4; Y &gt;&gt;= K;N += K = Y &gt;&gt; (2-1) &amp; 2; Y &gt;&gt;= K;N += K = Y &gt;&gt; (1-0) &amp; 1; Y &gt;&gt;= K;I = (bindex_t)(N + Y);}</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>INSECURE</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_address</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char*)(a) &gt;= (M)-&gt;least_addr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_next</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char*)(p) &lt; (char*)(n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_cinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cinuse(p)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pinuse(p)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_address</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_next</name><parameter_list>(<parameter><type><name>b</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_cinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>FOOTERS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>INSECURE</name><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_magic</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((M)-&gt;magic == mparams.magic)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ok_magic</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>INSECURE</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTCHECK</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_expect(e, 1)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTCHECK</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(e)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTCHECK</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>FOOTERS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mark_inuse_foot</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_inuse</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((p)-&gt;head = (((p)-&gt;head &amp; PINUSE_BIT)|s|CINUSE_BIT),((mchunkptr)(((char*)(p)) + (s)))-&gt;head |= PINUSE_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_inuse_and_pinuse</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT),((mchunkptr)(((char*)(p)) + (s)))-&gt;head |= PINUSE_BIT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_size_and_pinuse_of_inuse_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mark_inuse_foot</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(((mchunkptr)((char*)(p) + (s)))-&gt;prev_foot = ((size_t)(M) ^ mparams.magic))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_mstate_for</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((mstate)(((mchunkptr)((char*)(p) +(chunksize(p))))-&gt;prev_foot ^ mparams.magic))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_inuse</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((p)-&gt;head = (((p)-&gt;head &amp; PINUSE_BIT)|s|CINUSE_BIT),(((mchunkptr)(((char*)(p)) + (s)))-&gt;head |= PINUSE_BIT), mark_inuse_foot(M,p,s))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_inuse_and_pinuse</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT),(((mchunkptr)(((char*)(p)) + (s)))-&gt;head |= PINUSE_BIT),mark_inuse_foot(M,p,s))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_size_and_pinuse_of_inuse_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT),mark_inuse_foot(M, p, s))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>int</name></type> <name>init_mparams</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_GLOBAL_LOCK_INIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>malloc_global_mutex_status</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>init_malloc_global_mutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>ACQUIRE_MALLOC_GLOBAL_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mparams</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>magic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>gsize</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>psize</name> <operator>=</operator> <name>malloc_getpagesize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>gsize</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>DEFAULT_GRANULARITY</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>DEFAULT_GRANULARITY</name></expr> </then><else>: <expr><name>psize</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<block>{<block_content>

<decl_stmt><decl><type><name>SYSTEM_INFO</name></type> <name>system_info</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetSystemInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>system_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>psize</name> <operator>=</operator> <name><name>system_info</name><operator>.</operator><name>dwPageSize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>gsize</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>DEFAULT_GRANULARITY</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>

<expr><name>DEFAULT_GRANULARITY</name></expr> </then><else>: <expr><name><name>system_info</name><operator>.</operator><name>dwAllocationGranularity</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>MAX_SIZE_T</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name><operator>)</operator> <operator>||</operator>

<operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>MALLOC_ALIGNMENT</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">8U</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>MALLOC_ALIGNMENT</name> <operator>&amp;</operator> <operator>(</operator><name>MALLOC_ALIGNMENT</name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>MCHUNK_SIZE</name> <operator>&amp;</operator> <operator>(</operator><name>MCHUNK_SIZE</name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>gsize</name> <operator>&amp;</operator> <operator>(</operator><name>gsize</name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>psize</name> <operator>&amp;</operator> <operator>(</operator><name>psize</name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ABORT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>granularity</name></name> <operator>=</operator> <name>gsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>page_size</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>mmap_threshold</name></name> <operator>=</operator> <name>DEFAULT_MMAP_THRESHOLD</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>trim_threshold</name></name> <operator>=</operator> <name>DEFAULT_TRIM_THRESHOLD</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORECORE_CONTIGUOUS</name></expr></cpp:if>

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>default_mflags</name></name> <operator>=</operator> <name>USE_LOCK_BIT</name><operator>|</operator><name>USE_MMAP_BIT</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>default_mflags</name></name> <operator>=</operator> <name>USE_LOCK_BIT</name><operator>|</operator><name>USE_MMAP_BIT</name><operator>|</operator><name>USE_NONCONTIGUOUS_BIT</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>ONLY_MSPACES</name></expr></cpp:if>

<expr_stmt><expr><name><name>gm</name><operator>-&gt;</operator><name>mflags</name></name> <operator>=</operator> <name><name>mparams</name><operator>.</operator><name>default_mflags</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>INITIAL_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gm</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>FOOTERS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>INSECURE</name><operator>)</operator></expr></cpp:if>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_DEV_RANDOM</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><literal type="string">"/dev/urandom"</literal></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>magic</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>magic</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><call><name>GetTickCount</name><argument_list>()</argument_list></call> <operator>^</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0x55555555U</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>magic</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>^</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0x55555555U</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>magic</name> <operator>|=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">8U</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>magic</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">7U</literal></expr>;</expr_stmt> 

</block_content>}</block>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<expr_stmt><expr><name>magic</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0x58585858U</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>magic</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RELEASE_MALLOC_GLOBAL_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>change_mparam</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>param_number</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>val</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then> <expr><name>MAX_SIZE_T</name></expr> </then><else>: <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>value</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>param_number</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>M_TRIM_THRESHOLD</name></expr>:</case>

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>trim_threshold</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

<case>case <expr><name>M_GRANULARITY</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;=</operator> <name><name>mparams</name><operator>.</operator><name>page_size</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>val</name> <operator>&amp;</operator> <operator>(</operator><name>val</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>granularity</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>

<case>case <expr><name>M_MMAP_THRESHOLD</name></expr>:</case>

<expr_stmt><expr><name><name>mparams</name><operator>.</operator><name>mmap_threshold</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

<default>default:</default>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUG</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_any_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>is_aligned</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>FENCEPOST_HEAD</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_top_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><call><name>segment_holding</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;</operator> <operator>~</operator><name>INUSE_BITS</name></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>is_aligned</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>FENCEPOST_HEAD</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator> <operator>-</operator> <name>TOP_FOOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>pinuse</name><argument_list>(<argument><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_mmapped_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>sz</name> <operator>+</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prev_foot</name></name> <operator>&amp;</operator> <operator>~</operator><name>IS_MMAPPED_BIT</name><operator>)</operator> <operator>+</operator> <name>MMAP_FOOT_PAD</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_mmapped</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>use_mmap</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>is_aligned</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>FENCEPOST_HEAD</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>is_small</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>&amp;</operator> <operator>(</operator><name><name>mparams</name><operator>.</operator><name>page_size</name></name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>==</operator> <name>FENCEPOST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name><operator>+</operator><name>SIZE_T_SIZE</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_inuse_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>do_check_any_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>cinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>next_pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_mmapped</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>next_chunk</name><argument_list>(<argument><expr><call><name>prev_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_mmapped</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_check_mmapped_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_free_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>next</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>do_check_any_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>next_pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>!</operator><call><name>is_mmapped</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name><name>m</name><operator>-&gt;</operator><name>dv</name></name> <operator>&amp;&amp;</operator> <name>p</name> <operator>!=</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>sz</name> <operator>&amp;</operator> <name>CHUNK_ALIGN_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_aligned</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>prev_foot</name></name> <operator>==</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>next</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>||</operator> <call><name>cinuse</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name><operator>-&gt;</operator><name>bk</name></name> <operator>==</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>bk</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <name>SIZE_T_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_malloced_chunk</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>PINUSE_BIT</name><operator>|</operator><name>CINUSE_BIT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>do_check_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>sz</name> <operator>&amp;</operator> <name>CHUNK_ALIGN_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>&gt;=</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_mmapped</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>sz</name> <operator>&lt;</operator> <operator>(</operator><name>s</name> <operator>+</operator> <name>MIN_CHUNK_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_tree</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>tchunkptr</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>u</name> <init>= <expr><name>t</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>tindex</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>compute_tree_index</name><argument_list>(<argument><expr><name>tsize</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tindex</name> <operator>==</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tsize</name> <operator>&gt;=</operator> <name>MIN_LARGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tsize</name> <operator>&gt;=</operator> <call><name>minsize_for_tree_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>idx</name> <operator>==</operator> <name>NTREEBINS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tsize</name> <operator>&lt;</operator> <call><name>minsize_for_tree_index</name><argument_list>(<argument><expr><operator>(</operator><name>idx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content> 

<expr_stmt><expr><call><name>do_check_any_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>u</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <name>tindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>next_pinuse</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>fd</name><operator>-&gt;</operator><name>bk</name></name> <operator>==</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>bk</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>u</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>head</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>head</name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>u</name> <operator>||</operator>

<name><name>u</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>u</name> <operator>||</operator>

<operator>*</operator><operator>(</operator><operator>(</operator><name>tbinptr</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>u</name><operator>-&gt;</operator><name>parent</name></name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>parent</name> <operator>==</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_check_tree</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>parent</name> <operator>==</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_check_tree</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>u</name> <operator>=</operator> <name><name>u</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>u</name> <operator>!=</operator> <name>t</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>head</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_treebin</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>bindex_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>tbinptr</name><modifier>*</modifier></type> <name>tb</name> <init>= <expr><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>t</name> <init>= <expr><operator>*</operator><name>tb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>empty</name> <init>= <expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>treemap</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>empty</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_check_tree</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_smallbin</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>bindex_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>sbinptr</name></type> <name>b</name> <init>= <expr><call><name>smallbin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>bk</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>empty</name> <init>= <expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>smallmap</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>empty</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>b</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>bk</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>q</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>do_check_free_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>small_index</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>bk</name></name> <operator>==</operator> <name>b</name> <operator>||</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>bk</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>next_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>FENCEPOST_HEAD</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_check_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bin_find</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_small</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>sidx</name> <init>= <expr><call><name>small_index</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>sbinptr</name></type> <name>b</name> <init>= <expr><call><name>smallbin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>sidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>smallmap_is_marked</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>sidx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>fd</name></name><operator>)</operator> <operator>!=</operator> <name>b</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>tidx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>compute_tree_index</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>tidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>treemap_is_marked</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tidx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>t</name> <init>= <expr><operator>*</operator><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sizebits</name> <init>= <expr><name>size</name> <operator>&lt;&lt;</operator> <call><name>leftshift_for_tree_index</name><argument_list>(<argument><expr><name>tidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>t</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>child</name><index>[<expr><operator>(</operator><name>sizebits</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>SIZE_T_BITSIZE</name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>sizebits</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>u</name> <init>= <expr><name>t</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>u</name> <operator>==</operator> <operator>(</operator><name>tchunkptr</name><operator>)</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>u</name> <operator>=</operator> <name><name>u</name><operator>-&gt;</operator><name>fd</name></name><operator>)</operator> <operator>!=</operator> <name>t</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>traverse_and_check</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_initialized</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>s</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+</operator> <name>TOP_FOOT_SIZE</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>q</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>lastq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>pinuse</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>segment_holds</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>q</name> <operator>!=</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>FENCEPOST_HEAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>cinuse</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bin_find</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_check_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>q</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>dv</name></name> <operator>||</operator> <call><name>bin_find</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lastq</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>cinuse</name><argument_list>(<argument><expr><name>lastq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>do_check_free_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>lastq</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>next_chunk</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>sum</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_check_malloc_state</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSMALLBINS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_check_smallbin</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NTREEBINS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_check_treebin</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>do_check_any_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>dv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>==</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>dv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>bin_find</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>dv</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>do_check_top_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>bin_find</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>total</name> <operator>=</operator> <call><name>traverse_and_check</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>total</name> <operator>&lt;=</operator> <name><name>m</name><operator>-&gt;</operator><name>footprint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>&lt;=</operator> <name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>NO_MALLINFO</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>mallinfo</name></name></type> <name>internal_mallinfo</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>mallinfo</name></name></type> <name>nm</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_malloc_state</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_initialized</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nfree</name> <init>= <expr><name>SIZE_T_ONE</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>mfree</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+</operator> <name>TOP_FOOT_SIZE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sum</name> <init>= <expr><name>mfree</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>s</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>q</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>segment_holds</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>q</name> <operator>!=</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>FENCEPOST_HEAD</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mfree</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>nfree</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>next_chunk</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>nm</name><operator>.</operator><name>arena</name></name> <operator>=</operator> <name>sum</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nm</name><operator>.</operator><name>ordblks</name></name> <operator>=</operator> <name>nfree</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nm</name><operator>.</operator><name>hblkhd</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>-</operator> <name>sum</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nm</name><operator>.</operator><name>usmblks</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nm</name><operator>.</operator><name>uordblks</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>-</operator> <name>mfree</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nm</name><operator>.</operator><name>fordblks</name></name> <operator>=</operator> <name>mfree</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nm</name><operator>.</operator><name>keepcost</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>nm</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name></type> <name>internal_malloc_stats</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>maxfp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>fp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>check_malloc_state</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_initialized</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>s</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>maxfp</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>fp</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>footprint</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>used</name> <operator>=</operator> <name>fp</name> <operator>-</operator> <operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+</operator> <name>TOP_FOOT_SIZE</name><operator>)</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>q</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>segment_holds</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>q</name> <operator>!=</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>FENCEPOST_HEAD</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>used</name> <operator>-=</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>next_chunk</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"max system bytes = %10lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><name>maxfp</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"system bytes = %10lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><name>fp</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"in use bytes = %10lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><name>used</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>insert_small_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{bindex_t I = small_index(S);mchunkptr B = smallbin_at(M, I);mchunkptr F = B;assert(S &gt;= MIN_CHUNK_SIZE);if (!smallmap_is_marked(M, I))mark_smallmap(M, I);else if (RTCHECK(ok_address(M, B-&gt;fd)))F = B-&gt;fd;else {CORRUPTION_ERROR_ACTION(M);}B-&gt;fd = P;F-&gt;bk = P;P-&gt;fd = F;P-&gt;bk = B;}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink_small_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{mchunkptr F = P-&gt;fd;mchunkptr B = P-&gt;bk;bindex_t I = small_index(S);assert(P != B);assert(P != F);assert(chunksize(P) == small_index2size(I));if (F == B)clear_smallmap(M, I);else if (RTCHECK((F == smallbin_at(M,I) || ok_address(M, F)) &amp;&amp;(B == smallbin_at(M,I) || ok_address(M, B)))) {F-&gt;bk = B;B-&gt;fd = F;}else {CORRUPTION_ERROR_ACTION(M);}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink_first_small_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>B</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{mchunkptr F = P-&gt;fd;assert(P != B);assert(P != F);assert(chunksize(P) == small_index2size(I));if (B == F)clear_smallmap(M, I);else if (RTCHECK(ok_address(M, F))) {B-&gt;fd = F;F-&gt;bk = B;}else {CORRUPTION_ERROR_ACTION(M);}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>replace_dv</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{size_t DVS = M-&gt;dvsize;if (DVS != 0) {mchunkptr DV = M-&gt;dv;assert(is_small(DVS));insert_small_chunk(M, DV, DVS);}M-&gt;dvsize = S;M-&gt;dv = P;}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>insert_large_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>X</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{tbinptr* H;bindex_t I;compute_tree_index(S, I);H = treebin_at(M, I);X-&gt;index = I;X-&gt;child[0] = X-&gt;child[1] = 0;if (!treemap_is_marked(M, I)) {mark_treemap(M, I);*H = X;X-&gt;parent = (tchunkptr)H;X-&gt;fd = X-&gt;bk = X;}else {tchunkptr T = *H;size_t K = S &lt;&lt; leftshift_for_tree_index(I);for (;;) {if (chunksize(T) != S) {tchunkptr* C = &amp;(T-&gt;child[(K &gt;&gt; (SIZE_T_BITSIZE-SIZE_T_ONE)) &amp; 1]);K &lt;&lt;= 1;if (*C != 0)T = *C;else if (RTCHECK(ok_address(M, C))) {*C = X;X-&gt;parent = T;X-&gt;fd = X-&gt;bk = X;break;}else {CORRUPTION_ERROR_ACTION(M);break;}}else {tchunkptr F = T-&gt;fd;if (RTCHECK(ok_address(M, T) &amp;&amp; ok_address(M, F))) {T-&gt;fd = F-&gt;bk = X;X-&gt;fd = F;X-&gt;bk = T;X-&gt;parent = 0;break;}else {CORRUPTION_ERROR_ACTION(M);break;}}}}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink_large_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{tchunkptr XP = X-&gt;parent;tchunkptr R;if (X-&gt;bk != X) {tchunkptr F = X-&gt;fd;R = X-&gt;bk;if (RTCHECK(ok_address(M, F))) {F-&gt;bk = R;R-&gt;fd = F;}else {CORRUPTION_ERROR_ACTION(M);}}else {tchunkptr* RP;if (((R = *(RP = &amp;(X-&gt;child[1]))) != 0) ||((R = *(RP = &amp;(X-&gt;child[0]))) != 0)) {tchunkptr* CP;while ((*(CP = &amp;(R-&gt;child[1])) != 0) ||(*(CP = &amp;(R-&gt;child[0])) != 0)) {R = *(RP = CP);}if (RTCHECK(ok_address(M, RP)))*RP = 0;else {CORRUPTION_ERROR_ACTION(M);}}}if (XP != 0) {tbinptr* H = treebin_at(M, X-&gt;index);if (X == *H) {if ((*H = R) == 0) clear_treemap(M, X-&gt;index);}else if (RTCHECK(ok_address(M, XP))) {if (XP-&gt;child[0] == X) XP-&gt;child[0] = R;else XP-&gt;child[1] = R;}elseCORRUPTION_ERROR_ACTION(M);if (R != 0) {if (RTCHECK(ok_address(M, R))) {tchunkptr C0, C1;R-&gt;parent = XP;if ((C0 = X-&gt;child[0]) != 0) {if (RTCHECK(ok_address(M, C0))) {R-&gt;child[0] = C0;C0-&gt;parent = R;}elseCORRUPTION_ERROR_ACTION(M);}if ((C1 = X-&gt;child[1]) != 0) {if (RTCHECK(ok_address(M, C1))) {R-&gt;child[1] = C1;C1-&gt;parent = R;}elseCORRUPTION_ERROR_ACTION(M);}}elseCORRUPTION_ERROR_ACTION(M);}}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>insert_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if (is_small(S)) insert_small_chunk(M, P, S)else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if (is_small(S)) unlink_small_chunk(M, P, S)else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ONLY_MSPACES</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>internal_malloc</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mspace_malloc(m, b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>internal_free</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mspace_free(m,mem);</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MSPACES</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>internal_malloc</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(m == gm)? dlmalloc(b) : mspace_malloc(m, b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>internal_free</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if (m == gm) dlfree(mem); else mspace_free(m,mem);</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>internal_malloc</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>dlmalloc(b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>internal_free</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>dlfree(mem)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>mmap_alloc</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>mmsize</name> <init>= <expr><call><name>mmap_align</name><argument_list>(<argument><expr><name>nb</name> <operator>+</operator> <name>SIX_SIZE_T_SIZES</name> <operator>+</operator> <name>CHUNK_ALIGN_MASK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mmsize</name> <operator>&gt;</operator> <name>nb</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>mm</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_DIRECT_MMAP</name><argument_list>(<argument><expr><name>mmsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mm</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name>align_offset</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><name>mmsize</name> <operator>-</operator> <name>offset</name> <operator>-</operator> <name>MMAP_FOOT_PAD</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><operator>(</operator><name>mm</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>prev_foot</name></name> <operator>=</operator> <name>offset</name> <operator>|</operator> <name>IS_MMAPPED_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>p</name><operator>)</operator><operator>-&gt;</operator><name>head</name> <operator>=</operator> <operator>(</operator><name>psize</name><operator>|</operator><name>CINUSE_BIT</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_inuse_foot</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <name>FENCEPOST_HEAD</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name><operator>+</operator><name>SIZE_T_SIZE</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mm</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>least_addr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>least_addr</name></name> <operator>=</operator> <name>mm</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>+=</operator> <name>mmsize</name><operator>)</operator> <operator>&gt;</operator> <name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>footprint</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_aligned</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_mmapped_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mchunkptr</name></type> <name>mmap_resize</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>oldsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_small</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>oldsize</name> <operator>&gt;=</operator> <name>nb</name> <operator>+</operator> <name>SIZE_T_SIZE</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>oldsize</name> <operator>-</operator> <name>nb</name><operator>)</operator> <operator>&lt;=</operator> <operator>(</operator><name><name>mparams</name><operator>.</operator><name>granularity</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>oldp</name></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><name><name>oldp</name><operator>-&gt;</operator><name>prev_foot</name></name> <operator>&amp;</operator> <operator>~</operator><name>IS_MMAPPED_BIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>oldmmsize</name> <init>= <expr><name>oldsize</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <name>MMAP_FOOT_PAD</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>newmmsize</name> <init>= <expr><call><name>mmap_align</name><argument_list>(<argument><expr><name>nb</name> <operator>+</operator> <name>SIX_SIZE_T_SIZES</name> <operator>+</operator> <name>CHUNK_ALIGN_MASK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>cp</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>CALL_MREMAP</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>oldp</name> <operator>-</operator> <name>offset</name></expr></argument>,

<argument><expr><name>oldmmsize</name></expr></argument>, <argument><expr><name>newmmsize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>newp</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><operator>(</operator><name>cp</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><name>newmmsize</name> <operator>-</operator> <name>offset</name> <operator>-</operator> <name>MMAP_FOOT_PAD</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>newp</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name>psize</name><operator>|</operator><name>CINUSE_BIT</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_inuse_foot</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <name>FENCEPOST_HEAD</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>psize</name><operator>+</operator><name>SIZE_T_SIZE</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>least_addr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>least_addr</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>+=</operator> <name>newmmsize</name> <operator>-</operator> <name>oldmmsize</name><operator>)</operator> <operator>&gt;</operator> <name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>footprint</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>check_mmapped_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>newp</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_top</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name>align_offset</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>mchunkptr</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>psize</name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>psize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <name>TOP_FOOT_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>trim_check</name></name> <operator>=</operator> <name><name>mparams</name><operator>.</operator><name>trim_threshold</name></name></expr>;</expr_stmt> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_bins</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSMALLBINS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>sbinptr</name></type> <name>bin</name> <init>= <expr><call><name>smallbin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>bk</name></name> <operator>=</operator> <name>bin</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PROCEED_ON_ERROR</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type> <name>reset_on_error</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>++</operator><name>malloc_corruption_error_count</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>smallbins</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>treebins</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>base</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NTREEBINS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>init_bins</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>prepend_alloc</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>newbase</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>oldbase</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name>newbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>oldfirst</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name>oldbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>oldfirst</name> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>q</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>qsize</name> <init>= <expr><name>psize</name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>oldfirst</name> <operator>&gt;</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>pinuse</name><argument_list>(<argument><expr><name>oldfirst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>qsize</name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oldfirst</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+=</operator> <name>qsize</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>tsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_top_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>oldfirst</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>+=</operator> <name>qsize</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>oldfirst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>oldfirst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>unlink_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldfirst</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldfirst</name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>oldfirst</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qsize</name> <operator>+=</operator> <name>nsize</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qsize</name></expr></argument>, <argument><expr><name>oldfirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>insert_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>qsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_free_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_segment</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>tbase</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tsize</name></decl></parameter>, <parameter><decl><type><name>flag_t</name></type> <name>mmapped</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>old_top</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>oldsp</name> <init>= <expr><call><name>segment_holding</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>old_end</name> <init>= <expr><name><name>oldsp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>oldsp</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ssize</name> <init>= <expr><call><name>pad_request</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>rawsp</name> <init>= <expr><name>old_end</name> <operator>-</operator> <operator>(</operator><name>ssize</name> <operator>+</operator> <name>FOUR_SIZE_T_SIZES</name> <operator>+</operator> <name>CHUNK_ALIGN_MASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name>align_offset</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>rawsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>asp</name> <init>= <expr><name>rawsp</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>csp</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>asp</name> <operator>&lt;</operator> <operator>(</operator><name>old_top</name> <operator>+</operator> <name>MIN_CHUNK_SIZE</name><operator>)</operator><operator>)</operator></expr>?</condition><then> <expr><name>old_top</name></expr> </then><else>: <expr><name>asp</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>sp</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>csp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>ss</name> <init>= <expr><operator>(</operator><name>msegmentptr</name><operator>)</operator><operator>(</operator><call><name>chunk2mem</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>tnext</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name>tnext</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nfences</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>tbase</name></expr></argument>, <argument><expr><name>tsize</name> <operator>-</operator> <name>TOP_FOOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_aligned</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ss</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name>tbase</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>tsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>sflags</name></name> <operator>=</operator> <name>mmapped</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>nextp</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SIZE_T_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>FENCEPOST_HEAD</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>nfences</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>nextp</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator><operator>)</operator> <operator>&lt;</operator> <name>old_end</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<break>break;</break></block_content></block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nfences</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>csp</name> <operator>!=</operator> <name>old_top</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>q</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>old_top</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><name>csp</name> <operator>-</operator> <name>old_top</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>tn</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>insert_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>check_top_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>sys_alloc</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>tbase</name> <init>= <expr><name>CMFAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>flag_t</name></type> <name>mmap_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>use_mmap</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nb</name> <operator>&gt;=</operator> <name><name>mparams</name><operator>.</operator><name>mmap_threshold</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name> <init>= <expr><call><name>mmap_alloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>mem</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>MORECORE_CONTIGUOUS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>use_noncontiguous</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><name>CMFAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>ss</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>segment_holding</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>asize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ACQUIRE_MALLOC_GLOBAL_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>base</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>base</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>asize</name> <operator>=</operator> <call><name>granularity_align</name><argument_list>(<argument><expr><name>nb</name> <operator>+</operator> <name>SYS_ALLOC_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_page_aligned</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>asize</name> <operator>+=</operator> <operator>(</operator><call><name>page_align</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>base</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>base</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&lt;</operator> <name>HALF_MAX_SIZE_T</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>br</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><name>asize</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>==</operator> <name>base</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tbase</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>asize</name> <operator>=</operator> <call><name>granularity_align</name><argument_list>(<argument><expr><name>nb</name> <operator>-</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+</operator> <name>SYS_ALLOC_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&lt;</operator> <name>HALF_MAX_SIZE_T</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>br</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><name>asize</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>==</operator> <name><name>ss</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name><name>ss</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tbase</name> <operator>=</operator> <name>br</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tbase</name> <operator>==</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name>br</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&lt;</operator> <name>HALF_MAX_SIZE_T</name> <operator>&amp;&amp;</operator>

<name>asize</name> <operator>&lt;</operator> <name>nb</name> <operator>+</operator> <name>SYS_ALLOC_PADDING</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>esize</name> <init>= <expr><call><name>granularity_align</name><argument_list>(<argument><expr><name>nb</name> <operator>+</operator> <name>SYS_ALLOC_PADDING</name> <operator>-</operator> <name>asize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>esize</name> <operator>&lt;</operator> <name>HALF_MAX_SIZE_T</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>end</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><name>esize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>asize</name> <operator>+=</operator> <name>esize</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CALL_MORECORE</name><argument_list>(<argument><expr><operator>-</operator><name>asize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>br</name> <operator>=</operator> <name>CMFAIL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>br</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>tbase</name> <operator>=</operator> <name>br</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>disable_contiguous</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RELEASE_MALLOC_GLOBAL_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>HAVE_MMAP</name> <operator>&amp;&amp;</operator> <name>tbase</name> <operator>==</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><call><name>granularity_align</name><argument_list>(<argument><expr><name>nb</name> <operator>+</operator> <name>SYS_ALLOC_PADDING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&gt;</operator> <name>nb</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>mp</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MMAP</name><argument_list>(<argument><expr><name>rsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mp</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tbase</name> <operator>=</operator> <name>mp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name>rsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mmap_flag</name> <operator>=</operator> <name>IS_MMAPPED_BIT</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>HAVE_MORECORE</name> <operator>&amp;&amp;</operator> <name>tbase</name> <operator>==</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>asize</name> <init>= <expr><call><name>granularity_align</name><argument_list>(<argument><expr><name>nb</name> <operator>+</operator> <name>SYS_ALLOC_PADDING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>asize</name> <operator>&lt;</operator> <name>HALF_MAX_SIZE_T</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><name>CMFAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>end</name> <init>= <expr><name>CMFAIL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ACQUIRE_MALLOC_GLOBAL_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>br</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><name>asize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RELEASE_MALLOC_GLOBAL_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>br</name> <operator>!=</operator> <name>CMFAIL</name> <operator>&amp;&amp;</operator> <name>end</name> <operator>!=</operator> <name>CMFAIL</name> <operator>&amp;&amp;</operator> <name>br</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>ssize</name> <init>= <expr><name>end</name> <operator>-</operator> <name>br</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ssize</name> <operator>&gt;</operator> <name>nb</name> <operator>+</operator> <name>TOP_FOOT_SIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tbase</name> <operator>=</operator> <name>br</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name>ssize</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tbase</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>+=</operator> <name>tsize</name><operator>)</operator> <operator>&gt;</operator> <name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>footprint</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_initialized</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>least_addr</name></name> <operator>=</operator> <name>tbase</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>tsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>sflags</name></name> <operator>=</operator> <name>mmap_flag</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name><name>mparams</name><operator>.</operator><name>magic</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>release_checks</name></name> <operator>=</operator> <name>MAX_RELEASE_CHECK_RATE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_bins</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>ONLY_MSPACES</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>is_global</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>tbase</name></expr></argument>, <argument><expr><name>tsize</name> <operator>-</operator> <name>TOP_FOOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>mn</name> <init>= <expr><call><name>next_chunk</name><argument_list>(<argument><expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>mn</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>tbase</name> <operator>+</operator> <name>tsize</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>mn</name><operator>)</operator> <operator>-</operator><name>TOP_FOOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tbase</name> <operator>!=</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>NO_SEGMENT_TRAVERSAL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>is_extern_segment</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>sflags</name></name> <operator>&amp;</operator> <name>IS_MMAPPED_BIT</name><operator>)</operator> <operator>==</operator> <name>mmap_flag</name> <operator>&amp;&amp;</operator>

<call><name>segment_holds</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>+=</operator> <name>tsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+</operator> <name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>tbase</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>least_addr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>least_addr</name></name> <operator>=</operator> <name>tbase</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>!=</operator> <name>tbase</name> <operator>+</operator> <name>tsize</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>NO_SEGMENT_TRAVERSAL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>is_extern_segment</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>sflags</name></name> <operator>&amp;</operator> <name>IS_MMAPPED_BIT</name><operator>)</operator> <operator>==</operator> <name>mmap_flag</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>oldbase</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>tbase</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>+=</operator> <name>tsize</name></expr>;</expr_stmt>

<return>return <expr><call><name>prepend_alloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tbase</name></expr></argument>, <argument><expr><name>oldbase</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_segment</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tbase</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>, <argument><expr><name>mmap_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nb</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-=</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>rsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_top_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>MALLOC_FAILURE_ACTION</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>release_unused_segments</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>released</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nsegs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>pred</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><name><name>pred</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>base</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>next</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>++</operator><name>nsegs</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_mmapped_segment</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_extern_segment</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>psize</name> <operator>&gt;=</operator> <name>base</name> <operator>+</operator> <name>size</name> <operator>-</operator> <name>TOP_FOOT_SIZE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>tp</name> <init>= <expr><operator>(</operator><name>tchunkptr</name><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>segment_holds</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>sp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>unlink_large_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>released</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>pred</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>insert_large_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>NO_SEGMENT_TRAVERSAL</name></expr>)</condition><block type="pseudo"><block_content> 

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pred</name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>release_checks</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>nsegs</name> <operator>&gt;</operator> <name>MAX_RELEASE_CHECK_RATE</name><operator>)</operator></expr>?</condition><then>

<expr><name>nsegs</name></expr> </then><else>: <expr><name>MAX_RELEASE_CHECK_RATE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>released</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sys_trim</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>released</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pad</name> <operator>&lt;</operator> <name>MAX_REQUEST</name> <operator>&amp;&amp;</operator> <call><name>is_initialized</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pad</name> <operator>+=</operator> <name>TOP_FOOT_SIZE</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>&gt;</operator> <name>pad</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>unit</name> <init>= <expr><name><name>mparams</name><operator>.</operator><name>granularity</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>extra</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-</operator> <name>pad</name> <operator>+</operator> <operator>(</operator><name>unit</name> <operator>-</operator> <name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>/</operator> <name>unit</name> <operator>-</operator>

<name>SIZE_T_ONE</name><operator>)</operator> <operator>*</operator> <name>unit</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><call><name>segment_holding</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_extern_segment</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_mmapped_segment</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>HAVE_MMAP</name> <operator>&amp;&amp;</operator>

<name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <name>extra</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>has_segment_link</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>extra</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>CALL_MREMAP</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MFAIL</name><operator>)</operator> <operator>||</operator>

<operator>(</operator><call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>newsize</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>released</name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>HAVE_MORECORE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&gt;=</operator> <name>HALF_MAX_SIZE_T</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>extra</name> <operator>=</operator> <operator>(</operator><name>HALF_MAX_SIZE_T</name><operator>)</operator> <operator>+</operator> <name>SIZE_T_ONE</name> <operator>-</operator> <name>unit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ACQUIRE_MALLOC_GLOBAL_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>old_br</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>old_br</name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>rel_br</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><operator>-</operator><name>extra</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>new_br</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MORECORE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rel_br</name> <operator>!=</operator> <name>CMFAIL</name> <operator>&amp;&amp;</operator> <name>new_br</name> <operator>&lt;</operator> <name>old_br</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>released</name> <operator>=</operator> <name>old_br</name> <operator>-</operator> <name>new_br</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>RELEASE_MALLOC_GLOBAL_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>released</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>-=</operator> <name>released</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>-=</operator> <name>released</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-</operator> <name>released</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_top_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>HAVE_MMAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>released</name> <operator>+=</operator> <call><name>release_unused_segments</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>released</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>&gt;</operator> <name><name>m</name><operator>-&gt;</operator><name>trim_check</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>trim_check</name></name> <operator>=</operator> <name>MAX_SIZE_T</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>released</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>tmalloc_large</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><operator>-</operator><name>nb</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>compute_tree_index</name><argument_list>(<argument><expr><name>nb</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <operator>*</operator><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sizebits</name> <init>= <expr><name>nb</name> <operator>&lt;&lt;</operator> <call><name>leftshift_for_tree_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>rst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>rt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>trem</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>trem</name> <operator>&lt;</operator> <name>rsize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rsize</name> <operator>=</operator> <name>trem</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rt</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>child</name><index>[<expr><operator>(</operator><name>sizebits</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>SIZE_T_BITSIZE</name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rt</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rt</name> <operator>!=</operator> <name>t</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>rst</name> <operator>=</operator> <name>rt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>rst</name></expr>;</expr_stmt> 

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sizebits</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>binmap_t</name></type> <name>leftbits</name> <init>= <expr><call><name>left_bits</name><argument_list>(<argument><expr><call><name>idx2bit</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name><name>m</name><operator>-&gt;</operator><name>treemap</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>leftbits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>leastbit</name> <init>= <expr><call><name>least_bit</name><argument_list>(<argument><expr><name>leftbits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>compute_bit2idx</name><argument_list>(<argument><expr><name>leastbit</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>*</operator><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>t</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>trem</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>trem</name> <operator>&lt;</operator> <name>rsize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rsize</name> <operator>=</operator> <name>trem</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>leftmost_child</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rsize</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>-</operator> <name>nb</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rsize</name> <operator>+</operator> <name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_next</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>unlink_large_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>rsize</name> <operator>+</operator> <name>nb</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>insert_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CORRUPTION_ERROR_ACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>tmalloc_small</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>t</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>leastbit</name> <init>= <expr><call><name>least_bit</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>treemap</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>compute_bit2idx</name><argument_list>(<argument><expr><name>leastbit</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name>t</name> <operator>=</operator> <operator>*</operator><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rsize</name> <operator>=</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name>leftmost_child</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>trem</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>trem</name> <operator>&lt;</operator> <name>rsize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rsize</name> <operator>=</operator> <name>trem</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rsize</name> <operator>+</operator> <name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_next</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>unlink_large_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>rsize</name> <operator>+</operator> <name>nb</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>replace_dv</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CORRUPTION_ERROR_ACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>internal_realloc</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>oldmem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&gt;=</operator> <name>MAX_REQUEST</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>MALLOC_FAILURE_ACTION</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>oldp</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>oldmem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>oldsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>next</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>newp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>extra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ok_cinuse</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>ok_next</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ok_pinuse</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nb</name> <init>= <expr><call><name>request2size</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_mmapped</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>newp</name> <operator>=</operator> <call><name>mmap_resize</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>oldsize</name> <operator>&gt;=</operator> <name>nb</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name>oldsize</name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>newp</name> <operator>=</operator> <name>oldp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>remainder</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>next</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <name>oldsize</name> <operator>+</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>&gt;</operator> <name>nb</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr><name>oldsize</name> <operator>+</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>newtopsize</name> <init>= <expr><name>newsize</name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>newtop</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>newtop</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>newtopsize</name> <operator>|</operator><name>PINUSE_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>newtop</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>=</operator> <name>newtopsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>newp</name> <operator>=</operator> <name>oldp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>internal_free</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>check_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>newp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>newmem</name> <init>= <expr><call><name>internal_malloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>newmem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>oc</name> <init>= <expr><name>oldsize</name> <operator>-</operator> <call><name>overhead_for</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newmem</name></expr></argument>, <argument><expr><name>oldmem</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>oc</name> <operator>&lt;</operator> <name>bytes</name><operator>)</operator></expr>?</condition><then> <expr><name>oc</name></expr> </then><else>: <expr><name>bytes</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>internal_free</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>newmem</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>internal_memalign</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>alignment</name> <operator>&lt;=</operator> <name>MALLOC_ALIGNMENT</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><call><name>internal_malloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>alignment</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>alignment</name> <operator>=</operator> <name>MIN_CHUNK_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>alignment</name> <operator>&amp;</operator> <operator>(</operator><name>alignment</name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>a</name> <init>= <expr><name>MALLOC_ALIGNMENT</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>alignment</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>alignment</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&gt;=</operator> <name>MAX_REQUEST</name> <operator>-</operator> <name>alignment</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>MALLOC_FAILURE_ACTION</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nb</name> <init>= <expr><call><name>request2size</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>req</name> <init>= <expr><name>nb</name> <operator>+</operator> <name>alignment</name> <operator>+</operator> <name>MIN_CHUNK_SIZE</name> <operator>-</operator> <name>CHUNK_OVERHEAD</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>mem</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>internal_malloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>leader</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>trailer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>PREACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>mem</name><operator>)</operator><operator>)</operator> <operator>%</operator> <name>alignment</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>br</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>mem2chunk</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>mem</name> <operator>+</operator>

<name>alignment</name> <operator>-</operator>

<name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator>

<operator>-</operator><name>alignment</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>pos</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>br</name> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>p</name><operator>)</operator><operator>)</operator> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name><operator>)</operator></expr>?</condition><then>

<expr><name>br</name></expr> </then><else>: <expr><name>br</name><operator>+</operator><name>alignment</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>newp</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>pos</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>leadsize</name> <init>= <expr><name>pos</name> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>leadsize</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_mmapped</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>newp</name><operator>-&gt;</operator><name>prev_foot</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>prev_foot</name></name> <operator>+</operator> <name>leadsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>newp</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name>newsize</name><operator>|</operator><name>CINUSE_BIT</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>leadsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>leader</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>newp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_mmapped</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>nb</name> <operator>+</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>remainder_size</name> <init>= <expr><name>size</name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>remainder</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>remainder_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>trailer</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>%</operator> <name>alignment</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>leader</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>internal_free</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>leader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>trailer</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>internal_free</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>trailer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>ialloc</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>,

<parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>sizes</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>,

<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name><name>chunks</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>element_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>contents_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>array_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>remainder_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>marray</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>array_chunk</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>flag_t</name></type> <name>was_enabled</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>chunks</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>n_elements</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>chunks</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>marray</name> <operator>=</operator> <name>chunks</name></expr>;</expr_stmt>

<expr_stmt><expr><name>array_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>n_elements</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>internal_malloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>marray</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>array_size</name> <operator>=</operator> <call><name>request2size</name><argument_list>(<argument><expr><name>n_elements</name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <literal type="number">0x1</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>element_size</name> <operator>=</operator> <call><name>request2size</name><argument_list>(<argument><expr><operator>*</operator><name>sizes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>contents_size</name> <operator>=</operator> <name>n_elements</name> <operator>*</operator> <name>element_size</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><name>element_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>contents_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>n_elements</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>contents_size</name> <operator>+=</operator> <call><name>request2size</name><argument_list>(<argument><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>contents_size</name> <operator>+</operator> <name>array_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>was_enabled</name> <operator>=</operator> <call><name>use_mmap</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>disable_mmap</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>internal_malloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>CHUNK_OVERHEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>was_enabled</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>enable_mmap</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>PREACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>remainder_size</name> <operator>=</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>is_mmapped</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <literal type="number">0x2</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator><name>mem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>remainder_size</name> <operator>-</operator> <name>SIZE_T_SIZE</name> <operator>-</operator> <name>array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>marray</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>array_chunk_size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>array_chunk</name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>contents_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>array_chunk_size</name> <operator>=</operator> <name>remainder_size</name> <operator>-</operator> <name>contents_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>marray</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><call><name>chunk2mem</name><argument_list>(<argument><expr><name>array_chunk</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>array_chunk</name></expr></argument>, <argument><expr><name>array_chunk_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>remainder_size</name> <operator>=</operator> <name>contents_size</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>marray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>n_elements</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>element_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>element_size</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>request2size</name><argument_list>(<argument><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>remainder_size</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>remainder_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUG</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>marray</name> <operator>!=</operator> <name>chunks</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>element_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>remainder_size</name> <operator>==</operator> <name>element_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>remainder_size</name> <operator>==</operator> <call><name>request2size</name><argument_list>(<argument><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>check_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>marray</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>n_elements</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>check_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name><name>marray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>marray</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>ONLY_MSPACES</name></expr></cpp:if>

<function><type><name>void</name><modifier>*</modifier></type> <name>dlmalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LOCKS</name></expr></cpp:if>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>gm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>nb</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&lt;=</operator> <name>MAX_SMALL_REQUEST</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>smallbits</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nb</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bytes</name> <operator>&lt;</operator> <name>MIN_REQUEST</name><operator>)</operator></expr>?</condition><then> <expr><name>MIN_CHUNK_SIZE</name></expr> </then><else>: <expr><call><name>pad_request</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>small_index</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>smallbits</name> <operator>=</operator> <name><name>gm</name><operator>-&gt;</operator><name>smallmap</name></name> <operator>&gt;&gt;</operator> <name>idx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>smallbits</name> <operator>&amp;</operator> <literal type="number">0x3U</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <operator>~</operator><name>smallbits</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>smallbin_at</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>small_index2size</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unlink_first_small_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>small_index2size</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>nb</name> <operator>&gt;</operator> <name><name>gm</name><operator>-&gt;</operator><name>dvsize</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>smallbits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>p</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>leftbits</name> <init>= <expr><operator>(</operator><name>smallbits</name> <operator>&lt;&lt;</operator> <name>idx</name><operator>)</operator> <operator>&amp;</operator> <call><name>left_bits</name><argument_list>(<argument><expr><call><name>idx2bit</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>leastbit</name> <init>= <expr><call><name>least_bit</name><argument_list>(<argument><expr><name>leftbits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>compute_bit2idx</name><argument_list>(<argument><expr><name>leastbit</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>smallbin_at</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>small_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unlink_first_small_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rsize</name> <operator>=</operator> <call><name>small_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>SIZE_T_SIZE</name> <operator>!=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>rsize</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>small_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>replace_dv</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>treemap</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mem</name> <operator>=</operator> <call><name>tmalloc_small</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>bytes</name> <operator>&gt;=</operator> <name>MAX_REQUEST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>nb</name> <operator>=</operator> <name>MAX_SIZE_T</name></expr>;</expr_stmt></block_content></block></if> 

<else>else <block>{<block_content>

<expr_stmt><expr><name>nb</name> <operator>=</operator> <call><name>pad_request</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>treemap</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mem</name> <operator>=</operator> <call><name>tmalloc_large</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nb</name> <operator>&lt;=</operator> <name><name>gm</name><operator>-&gt;</operator><name>dvsize</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name><name>gm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>gm</name><operator>-&gt;</operator><name>dv</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><name><name>gm</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>gm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>rsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>dvs</name> <init>= <expr><name><name>gm</name><operator>-&gt;</operator><name>dvsize</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>gm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gm</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>dvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>nb</name> <operator>&lt;</operator> <name><name>gm</name><operator>-&gt;</operator><name>topsize</name></name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name><name>gm</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-=</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>gm</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><name><name>gm</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>rsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_top_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>sys_alloc</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>postaction</name>:</label>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>gm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>mem</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>dlfree</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FOOTERS</name></expr></cpp:if>

<decl_stmt><decl><type><name>mstate</name></type> <name>fm</name> <init>= <expr><call><name>get_mstate_for</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fm</name></cpp:macro> <cpp:value>gm</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_inuse_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ok_cinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>next</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>prevsize</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>prev_foot</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prevsize</name> <operator>&amp;</operator> <name>IS_MMAPPED_BIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prevsize</name> <operator>&amp;=</operator> <operator>~</operator><name>IS_MMAPPED_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>prevsize</name> <operator>+</operator> <name>MMAP_FOOT_PAD</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>-</operator> <name>prevsize</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>footprint</name></name> <operator>-=</operator> <name>psize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>prev</name> <init>= <expr><call><name>chunk_minus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>prevsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>unlink_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>next</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;</operator> <name>INUSE_BITS</name><operator>)</operator> <operator>==</operator> <name>INUSE_BITS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<goto>goto <name>erroraction</name>;</goto></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_next</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ok_pinuse</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+=</operator> <name>psize</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>tsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>should_trim</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sys_trim</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>next</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>+=</operator> <name>psize</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>nsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unlink_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_small</name><argument_list>(<argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>insert_small_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_free_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>tp</name> <init>= <expr><operator>(</operator><name>tchunkptr</name><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>insert_large_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_free_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>fm</name><operator>-&gt;</operator><name>release_checks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>release_unused_segments</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>erroraction</name>:</label>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>postaction</name>:</label>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>FOOTERS</name></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fm</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>dlcalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elem_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>req</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n_elements</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>req</name> <operator>=</operator> <name>n_elements</name> <operator>*</operator> <name>elem_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>n_elements</name> <operator>|</operator> <name>elem_size</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0xffff</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name>req</name> <operator>/</operator> <name>n_elements</name> <operator>!=</operator> <name>elem_size</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>req</name> <operator>=</operator> <name>MAX_SIZE_T</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>dlmalloc</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>calloc_must_clear</name><argument_list>(<argument><expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>mem</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>dlrealloc</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>oldmem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>oldmem</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>dlmalloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REALLOC_ZERO_BYTES_FREES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dlfree</name><argument_list>(<argument><expr><name>oldmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>FOOTERS</name></expr></cpp:if>

<decl_stmt><decl><type><name>mstate</name></type> <name>m</name> <init>= <expr><name>gm</name></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<decl_stmt><decl><type><name>mstate</name></type> <name>m</name> <init>= <expr><call><name>get_mstate_for</name><argument_list>(<argument><expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>oldmem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<return>return <expr><call><name>internal_realloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldmem</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>dlmemalign</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>internal_memalign</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>dlindependent_calloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elem_size</name></decl></parameter>,

<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name><name>chunks</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name>elem_size</name></expr></init></decl>;</decl_stmt> 

<return>return <expr><call><name>ialloc</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>n_elements</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>dlindependent_comalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>sizes</name><index>[]</index></name></decl></parameter>,

<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name><name>chunks</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>ialloc</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>n_elements</name></expr></argument>, <argument><expr><name>sizes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>dlvalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>pagesz</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pagesz</name> <operator>=</operator> <name><name>mparams</name><operator>.</operator><name>page_size</name></name></expr>;</expr_stmt>

<return>return <expr><call><name>dlmemalign</name><argument_list>(<argument><expr><name>pagesz</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>dlpvalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>pagesz</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pagesz</name> <operator>=</operator> <name><name>mparams</name><operator>.</operator><name>page_size</name></name></expr>;</expr_stmt>

<return>return <expr><call><name>dlmemalign</name><argument_list>(<argument><expr><name>pagesz</name></expr></argument>, <argument><expr><operator>(</operator><name>bytes</name> <operator>+</operator> <name>pagesz</name> <operator>-</operator> <name>SIZE_T_ONE</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>pagesz</name> <operator>-</operator> <name>SIZE_T_ONE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>dlmalloc_trim</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>gm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sys_trim</name><argument_list>(<argument><expr><name>gm</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>gm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>dlmalloc_footprint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>gm</name><operator>-&gt;</operator><name>footprint</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>dlmalloc_max_footprint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>gm</name><operator>-&gt;</operator><name>max_footprint</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>NO_MALLINFO</name></expr></cpp:if>

<function><type><name><name>struct</name> <name>mallinfo</name></name></type> <name>dlmallinfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>internal_mallinfo</name><argument_list>(<argument><expr><name>gm</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>void</name></type> <name>dlmalloc_stats</name><parameter_list>()</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>internal_malloc_stats</name><argument_list>(<argument><expr><name>gm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>dlmallopt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>param_number</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>change_mparam</name><argument_list>(<argument><expr><name>param_number</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>size_t</name></type> <name>dlmalloc_usable_size</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>cinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>overhead_for</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MSPACES</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>mstate</name></type> <name>init_user_mstate</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>tbase</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tsize</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>msize</name> <init>= <expr><call><name>pad_request</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>mn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>msp</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name>tbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mstate</name></type> <name>m</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><operator>(</operator><call><name>chunk2mem</name><argument_list>(<argument><expr><name>msp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>INITIAL_LOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name>msize</name><operator>|</operator><name>PINUSE_BIT</name><operator>|</operator><name>CINUSE_BIT</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>least_addr</name></name> <operator>=</operator> <name>tbase</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>footprint</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>max_footprint</name></name> <operator>=</operator> <name>tsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name><name>mparams</name><operator>.</operator><name>magic</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>release_checks</name></name> <operator>=</operator> <name>MAX_RELEASE_CHECK_RATE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>mflags</name></name> <operator>=</operator> <name><name>mparams</name><operator>.</operator><name>default_mflags</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>extp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>exts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>disable_contiguous</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_bins</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mn</name> <operator>=</operator> <call><name>next_chunk</name><argument_list>(<argument><expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>mn</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>tbase</name> <operator>+</operator> <name>tsize</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>mn</name><operator>)</operator> <operator>-</operator> <name>TOP_FOOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_top_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>m</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>mspace</name></type> <name>create_mspace</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>capacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locked</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mstate</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>msize</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>msize</name> <operator>=</operator> <call><name>pad_request</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>capacity</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>-</operator><operator>(</operator><name>msize</name> <operator>+</operator> <name>TOP_FOOT_SIZE</name> <operator>+</operator> <name><name>mparams</name><operator>.</operator><name>page_size</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>rs</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>capacity</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>mparams</name><operator>.</operator><name>granularity</name></name></expr> </then><else>:

<expr><operator>(</operator><name>capacity</name> <operator>+</operator> <name>TOP_FOOT_SIZE</name> <operator>+</operator> <name>msize</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><call><name>granularity_align</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>tbase</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MMAP</name><argument_list>(<argument><expr><name>tsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tbase</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>init_user_mstate</name><argument_list>(<argument><expr><name>tbase</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>sflags</name></name> <operator>=</operator> <name>IS_MMAPPED_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_lock</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>locked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>mspace</name><operator>)</operator><name>m</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>mspace</name></type> <name>create_mspace_with_base</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>capacity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locked</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mstate</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>msize</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ensure_initialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>msize</name> <operator>=</operator> <call><name>pad_request</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>capacity</name> <operator>&gt;</operator> <name>msize</name> <operator>+</operator> <name>TOP_FOOT_SIZE</name> <operator>&amp;&amp;</operator>

<name>capacity</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>-</operator><operator>(</operator><name>msize</name> <operator>+</operator> <name>TOP_FOOT_SIZE</name> <operator>+</operator> <name><name>mparams</name><operator>.</operator><name>page_size</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>init_user_mstate</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>base</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>sflags</name></name> <operator>=</operator> <name>EXTERN_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_lock</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>locked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>mspace</name><operator>)</operator><name>m</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>mspace_mmap_large_chunks</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>enable</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>use_mmap</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enable</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>enable_mmap</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>disable_mmap</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>destroy_mspace</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>freed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>base</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>flag_t</name></type> <name>flag</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>sflags</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>IS_MMAPPED_BIT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>EXTERN_BIT</name><operator>)</operator> <operator>&amp;&amp;</operator>

<call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>freed</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>freed</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>mspace_malloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>nb</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&lt;=</operator> <name>MAX_SMALL_REQUEST</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>smallbits</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nb</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bytes</name> <operator>&lt;</operator> <name>MIN_REQUEST</name><operator>)</operator></expr>?</condition><then> <expr><name>MIN_CHUNK_SIZE</name></expr> </then><else>: <expr><call><name>pad_request</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>small_index</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>smallbits</name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>smallmap</name></name> <operator>&gt;&gt;</operator> <name>idx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>smallbits</name> <operator>&amp;</operator> <literal type="number">0x3U</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <operator>~</operator><name>smallbits</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>smallbin_at</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>small_index2size</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unlink_first_small_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>small_index2size</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>nb</name> <operator>&gt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>smallbits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>p</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>leftbits</name> <init>= <expr><operator>(</operator><name>smallbits</name> <operator>&lt;&lt;</operator> <name>idx</name><operator>)</operator> <operator>&amp;</operator> <call><name>left_bits</name><argument_list>(<argument><expr><call><name>idx2bit</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>binmap_t</name></type> <name>leastbit</name> <init>= <expr><call><name>least_bit</name><argument_list>(<argument><expr><name>leftbits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>compute_bit2idx</name><argument_list>(<argument><expr><name>leastbit</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>smallbin_at</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>small_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unlink_first_small_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rsize</name> <operator>=</operator> <call><name>small_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>SIZE_T_SIZE</name> <operator>!=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>rsize</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>small_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>replace_dv</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>treemap</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mem</name> <operator>=</operator> <call><name>tmalloc_small</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>bytes</name> <operator>&gt;=</operator> <name>MAX_REQUEST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>nb</name> <operator>=</operator> <name>MAX_SIZE_T</name></expr>;</expr_stmt></block_content></block></if> 

<else>else <block>{<block_content>

<expr_stmt><expr><name>nb</name> <operator>=</operator> <call><name>pad_request</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>treemap</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mem</name> <operator>=</operator> <call><name>tmalloc_large</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nb</name> <operator>&lt;=</operator> <name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dv</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>rsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>dvs</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>dvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>nb</name> <operator>&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>topsize</name></name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-=</operator> <name>nb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>rsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_top_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_malloced_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>sys_alloc</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>postaction</name>:</label>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>mem</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>mspace_free</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FOOTERS</name></expr></cpp:if>

<decl_stmt><decl><type><name>mstate</name></type> <name>fm</name> <init>= <expr><call><name>get_mstate_for</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<decl_stmt><decl><type><name>mstate</name></type> <name>fm</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_inuse_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ok_cinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>next</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>prevsize</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>prev_foot</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prevsize</name> <operator>&amp;</operator> <name>IS_MMAPPED_BIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prevsize</name> <operator>&amp;=</operator> <operator>~</operator><name>IS_MMAPPED_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>prevsize</name> <operator>+</operator> <name>MMAP_FOOT_PAD</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>-</operator> <name>prevsize</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>footprint</name></name> <operator>-=</operator> <name>psize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>prev</name> <init>= <expr><call><name>chunk_minus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>prevsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_address</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>unlink_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>next</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;</operator> <name>INUSE_BITS</name><operator>)</operator> <operator>==</operator> <name>INUSE_BITS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<goto>goto <name>erroraction</name>;</goto></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTCHECK</name><argument_list>(<argument><expr><call><name>ok_next</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ok_pinuse</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+=</operator> <name>psize</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>tsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>should_trim</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sys_trim</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>next</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>+=</operator> <name>psize</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>nsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unlink_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_small</name><argument_list>(<argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>insert_small_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_free_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>tchunkptr</name></type> <name>tp</name> <init>= <expr><operator>(</operator><name>tchunkptr</name><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>insert_large_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_free_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>fm</name><operator>-&gt;</operator><name>release_checks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>release_unused_segments</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<goto>goto <name>postaction</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>erroraction</name>:</label>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>postaction</name>:</label>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>mspace_calloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elem_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>req</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n_elements</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>req</name> <operator>=</operator> <name>n_elements</name> <operator>*</operator> <name>elem_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>n_elements</name> <operator>|</operator> <name>elem_size</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0xffff</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name>req</name> <operator>/</operator> <name>n_elements</name> <operator>!=</operator> <name>elem_size</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>req</name> <operator>=</operator> <name>MAX_SIZE_T</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>internal_malloc</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>calloc_must_clear</name><argument_list>(<argument><expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>mem</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>mspace_realloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>oldmem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>oldmem</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>mspace_malloc</name><argument_list>(<argument><expr><name>msp</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REALLOC_ZERO_BYTES_FREES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mspace_free</name><argument_list>(<argument><expr><name>msp</name></expr></argument>, <argument><expr><name>oldmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FOOTERS</name></expr></cpp:if>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>oldmem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><call><name>get_mstate_for</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>internal_realloc</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>oldmem</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>mspace_memalign</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>internal_memalign</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>mspace_independent_calloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>elem_size</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name><name>chunks</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name>elem_size</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ialloc</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>n_elements</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>mspace_independent_comalloc</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_elements</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name><name>sizes</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name><name>chunks</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ialloc</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>n_elements</name></expr></argument>, <argument><expr><name>sizes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>mspace_trim</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PREACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sys_trim</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POSTACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>mspace_malloc_stats</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>internal_malloc_stats</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>mspace_footprint</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>footprint</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>mspace_max_footprint</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>max_footprint</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>NO_MALLINFO</name></expr></cpp:if>

<function><type><name><name>struct</name> <name>mallinfo</name></name></type> <name>mspace_mallinfo</name><parameter_list>(<parameter><decl><type><name>mspace</name></type> <name>msp</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ok_magic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USAGE_ERROR_ACTION</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>internal_mallinfo</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>size_t</name></type> <name>mspace_usable_size</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>cinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>overhead_for</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>mspace_mallopt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>param_number</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>change_mparam</name><argument_list>(<argument><expr><name>param_number</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
