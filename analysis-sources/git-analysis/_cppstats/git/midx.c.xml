<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\midx.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"csum-file.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lockfile.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"packfile.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sha1-lookup.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"midx.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"progress.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trace2.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_SIGNATURE</name></cpp:macro> <cpp:value>0x4d494458</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_VERSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_BYTE_FILE_VERSION</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_BYTE_HASH_VERSION</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_BYTE_NUM_CHUNKS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_BYTE_NUM_PACKS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_HASH_VERSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_HEADER_SIZE</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_MIN_SIZE</name></cpp:macro> <cpp:value>(MIDX_HEADER_SIZE + the_hash_algo-&gt;rawsz)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_MAX_CHUNKS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNK_ALIGNMENT</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNKID_PACKNAMES</name></cpp:macro> <cpp:value>0x504e414d</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNKID_OIDFANOUT</name></cpp:macro> <cpp:value>0x4f494446</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNKID_OIDLOOKUP</name></cpp:macro> <cpp:value>0x4f49444c</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNKID_OBJECTOFFSETS</name></cpp:macro> <cpp:value>0x4f4f4646</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNKID_LARGEOFFSETS</name></cpp:macro> <cpp:value>0x4c4f4646</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNKLOOKUP_WIDTH</name></cpp:macro> <cpp:value>(sizeof(uint32_t) + sizeof(uint64_t))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNK_FANOUT_SIZE</name></cpp:macro> <cpp:value>(sizeof(uint32_t) * 256)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNK_OFFSET_WIDTH</name></cpp:macro> <cpp:value>(2 * sizeof(uint32_t))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_CHUNK_LARGE_OFFSET_WIDTH</name></cpp:macro> <cpp:value>(sizeof(uint64_t))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIDX_LARGE_OFFSET_NEEDED</name></cpp:macro> <cpp:value>0x80000000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_EXPIRED</name></cpp:macro> <cpp:value>UINT_MAX</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_midx_filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%s/pack/multi-pack-index"</literal></expr></argument>, <argument><expr><name>object_dir</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>load_multi_pack_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>midx_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>midx_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>hash_version</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>midx_name</name> <init>= <expr><call><name>get_midx_filename</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_pack_name</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>git_open</name><argument_list>(<argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>cleanup_fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to read %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>cleanup_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>midx_size</name> <operator>=</operator> <call><name>xsize_t</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>midx_size</name> <operator>&lt;</operator> <name>MIDX_MIN_SIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index file %s is too small"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>cleanup_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>midx_map</name> <operator>=</operator> <call><name>xmmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>midx_size</name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_PRIVATE</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FLEX_ALLOC_STR</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>object_dir</name></expr></argument>, <argument><expr><name>object_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>midx_map</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>data_len</name></name> <operator>=</operator> <name>midx_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>local</name></name> <operator>=</operator> <name>local</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>signature</name></name> <operator>!=</operator> <name>MIDX_SIGNATURE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index signature 0x%08x does not match signature 0x%08x"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>signature</name></name></expr></argument>, <argument><expr><name>MIDX_SIGNATURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>MIDX_BYTE_FILE_VERSION</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>version</name></name> <operator>!=</operator> <name>MIDX_VERSION</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index version %d not recognized"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hash_version</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>MIDX_BYTE_HASH_VERSION</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hash_version</name> <operator>!=</operator> <name>MIDX_HASH_VERSION</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"hash version %u does not match"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hash_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>hash_len</name></name> <operator>=</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>num_chunks</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>MIDX_BYTE_NUM_CHUNKS</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>MIDX_BYTE_NUM_PACKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>chunk_id</name> <init>= <expr><call><name>get_be32</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>MIDX_HEADER_SIZE</name> <operator>+</operator>

<name>MIDX_CHUNKLOOKUP_WIDTH</name> <operator>*</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>chunk_offset</name> <init>= <expr><call><name>get_be64</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>MIDX_HEADER_SIZE</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator>

<name>MIDX_CHUNKLOOKUP_WIDTH</name> <operator>*</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>chunk_offset</name> <operator>&gt;=</operator> <name><name>m</name><operator>-&gt;</operator><name>data_len</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid chunk offset (too large)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>chunk_id</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MIDX_CHUNKID_PACKNAMES</name></expr>:</case>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_pack_names</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>chunk_offset</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIDX_CHUNKID_OIDFANOUT</name></expr>:</case>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_fanout</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>chunk_offset</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIDX_CHUNKID_OIDLOOKUP</name></expr>:</case>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_lookup</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>chunk_offset</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIDX_CHUNKID_OBJECTOFFSETS</name></expr>:</case>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_object_offsets</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>chunk_offset</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIDX_CHUNKID_LARGEOFFSETS</name></expr>:</case>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_large_offsets</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>chunk_offset</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"terminating multi-pack-index chunk id appears earlier than expected"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>m</name><operator>-&gt;</operator><name>chunk_pack_names</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index missing required pack-name chunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_fanout</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index missing required OID fanout chunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_lookup</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index missing required OID lookup chunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>m</name><operator>-&gt;</operator><name>chunk_object_offsets</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index missing required object offsets chunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_fanout</name><index>[<expr><literal type="number">255</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>m</name><operator>-&gt;</operator><name>pack_names</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>packs</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>m</name><operator>-&gt;</operator><name>packs</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_pack_name</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>m</name><operator>-&gt;</operator><name>chunk_pack_names</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cur_pack_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_pack_name</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cur_pack_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index pack names out of order: '%s' before '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>trace2_data_intmax</name><argument_list>(<argument><expr><literal type="string">"midx"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"load/num_packs"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace2_data_intmax</name><argument_list>(<argument><expr><literal type="string">"midx"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"load/num_objects"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>m</name></expr>;</return>

<label><name>cleanup_fail</name>:</label>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>midx_map</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name>midx_map</name></expr></argument>, <argument><expr><name>midx_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>fd</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>close_midx</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>m</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>multi_pack_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>packs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>prepare_midx_pack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>pack_int_id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>pack_name</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pack_int_id</name> <operator>&gt;=</operator> <name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad pack-int-id: %u (%u total packs)"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>pack_int_id</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>pack_int_id</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pack_name</name></expr></argument>, <argument><expr><literal type="string">"%s/pack/%s"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>object_dir</name></name></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>pack_int_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>add_packed_git</name><argument_list>(<argument><expr><name><name>pack_name</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>pack_name</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pack_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>multi_pack_index</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>pack_int_id</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>install_packed_git</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_add_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>mru</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>packed_git_mru</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>bsearch_midx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>bsearch_hash</name><argument_list>(<argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_fanout</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_lookup</name></name></expr></argument>,

<argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>nth_midxed_object_oid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_lookup</name></name> <operator>+</operator> <name><name>m</name><operator>-&gt;</operator><name>hash_len</name></name> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>oid</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>off_t</name></type> <name>nth_midxed_offset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>offset_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>offset32</name></decl>;</decl_stmt>

<expr_stmt><expr><name>offset_data</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>chunk_object_offsets</name></name> <operator>+</operator> <name>pos</name> <operator>*</operator> <name>MIDX_CHUNK_OFFSET_WIDTH</name></expr>;</expr_stmt>

<expr_stmt><expr><name>offset32</name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name>offset_data</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>chunk_large_offsets</name></name> <operator>&amp;&amp;</operator> <name>offset32</name> <operator>&amp;</operator> <name>MIDX_LARGE_OFFSET_NEEDED</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>off_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multi-pack-index stores a 64-bit offset, but off_t is too small"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>offset32</name> <operator>^=</operator> <name>MIDX_LARGE_OFFSET_NEEDED</name></expr>;</expr_stmt>

<return>return <expr><call><name>get_be64</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_large_offsets</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>offset32</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>offset32</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>nth_midxed_pack_int_id</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>get_be32</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_object_offsets</name></name> <operator>+</operator> <name>pos</name> <operator>*</operator> <name>MIDX_CHUNK_OFFSET_WIDTH</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>nth_midxed_pack_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pack_int_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pack_int_id</name> <operator>=</operator> <call><name>nth_midxed_pack_int_id</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prepare_midx_pack</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>pack_int_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"error preparing packfile from multi-pack-index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>pack_int_id</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_pack_valid</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>num_bad_objects</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>num_bad_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>hasheq</name><argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>,

<argument><expr><name><name>p</name><operator>-&gt;</operator><name>bad_object_sha1</name></name> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name> <operator>*</operator> <name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>nth_midxed_offset</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>fill_midx_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type> <name>r</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bsearch_midx</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>nth_midxed_pack_entry</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_idx_or_pack_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idx_or_pack_name</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idx_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>idx_name</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>idx_name</name> <operator>==</operator> <operator>*</operator><name>idx_or_pack_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>idx_name</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>idx_or_pack_name</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>idx_name</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>idx_or_pack_name</name></expr></argument>, <argument><expr><literal type="string">"pack"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>idx_or_pack_name</name></expr></argument>, <argument><expr><name>idx_name</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>midx_contains_pack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idx_or_pack_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>last</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>first</name> <operator>&lt;</operator> <name>last</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>mid</name> <init>= <expr><name>first</name> <operator>+</operator> <operator>(</operator><name>last</name> <operator>-</operator> <name>first</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>mid</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>cmp_idx_or_pack_name</name><argument_list>(<argument><expr><name>idx_or_pack_name</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>first</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>prepare_multi_pack_index_one</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m_search</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>config_value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>env_value</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>env_value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>env_value</name> <operator>=</operator> <call><name>git_env_bool</name><argument_list>(<argument><expr><name>GIT_TEST_MULTI_PACK_INDEX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>env_value</name> <operator>&amp;&amp;</operator>

<operator>(</operator><call><name>repo_config_get_bool</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"core.multipackindex"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>config_value</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><name>config_value</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>m_search</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>multi_pack_index</name></name></expr>;</init> <condition><expr><name>m_search</name></expr>;</condition> <incr><expr><name>m_search</name> <operator>=</operator> <name><name>m_search</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><name><name>m_search</name><operator>-&gt;</operator><name>object_dir</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>load_multi_pack_index</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>multi_pack_index</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>multi_pack_index</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>write_midx_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>num_chunks</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>num_packs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>byte_values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>MIDX_SIGNATURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>byte_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MIDX_VERSION</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>byte_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MIDX_HASH_VERSION</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>byte_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>num_chunks</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>byte_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>byte_values</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>byte_values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>num_packs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>MIDX_HEADER_SIZE</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>pack_info</name> <block>{

<decl_stmt><decl><type><name>uint32_t</name></type> <name>orig_pack_int_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pack_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>expired</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pack_info_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_info</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>pack_info</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_info</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator>struct <name>pack_info</name> <operator>*</operator><operator>)</operator><name>_b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>pack_list</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>pack_info</name></name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>progress</name></name> <modifier>*</modifier></type><name>progress</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>pack_paths_checked</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_pack_to_midx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>full_path</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>full_path_len</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file_name</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_list</name></name> <modifier>*</modifier></type><name>packs</name> <init>= <expr><operator>(</operator>struct <name>pack_list</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ends_with</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><literal type="string">".idx"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name><name>packs</name><operator>-&gt;</operator><name>progress</name></name></expr></argument>, <argument><expr><operator>++</operator><name><name>packs</name><operator>-&gt;</operator><name>pack_paths_checked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>packs</name><operator>-&gt;</operator><name>m</name></name> <operator>&amp;&amp;</operator> <call><name>midx_contains_pack</name><argument_list>(<argument><expr><name><name>packs</name><operator>-&gt;</operator><name>m</name></name></expr></argument>, <argument><expr><name>file_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>packs</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>packs</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>-&gt;</operator><name>info</name><index>[<expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>p</name> <operator>=</operator> <call><name>add_packed_git</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>,

<argument><expr><name>full_path_len</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>packs</name><operator>-&gt;</operator><name>info</name><index>[<expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to add packfile '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>full_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>open_pack_index</name><argument_list>(<argument><expr><name><name>packs</name><operator>-&gt;</operator><name>info</name><index>[<expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to open pack-index '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>full_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close_pack</name><argument_list>(<argument><expr><name><name>packs</name><operator>-&gt;</operator><name>info</name><index>[<expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>packs</name><operator>-&gt;</operator><name>info</name><index>[<expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>packs</name><operator>-&gt;</operator><name>info</name><index>[<expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>pack_name</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>-&gt;</operator><name>info</name><index>[<expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>orig_pack_int_id</name> <operator>=</operator> <name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>-&gt;</operator><name>info</name><index>[<expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>expired</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>pack_midx_entry</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pack_int_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>time_t</name></type> <name>pack_mtime</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>offset</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>midx_oid_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>pack_midx_entry</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>pack_midx_entry</name> <operator>*</operator><operator>)</operator><name>_b</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>oidcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>pack_mtime</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>pack_mtime</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>pack_mtime</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>pack_mtime</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>pack_int_id</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>pack_int_id</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>nth_midxed_pack_midx_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_int_id</name></name> <operator>=</operator> <call><name>nth_midxed_pack_int_id</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>nth_midxed_offset</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_mtime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_pack_entry</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>pack_int_id</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>cur_object</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>cur_object</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to locate object %d in packfile"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cur_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pack_int_id</name></name> <operator>=</operator> <name>pack_int_id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pack_mtime</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mtime</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>nth_packed_object_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cur_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>get_sorted_entries</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_info</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>nr_packs</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>nr_objects</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>cur_fanout</name></decl>, <decl><type ref="prev"/><name>cur_pack</name></decl>, <decl><type ref="prev"/><name>cur_object</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>alloc_fanout</name></decl>, <decl><type ref="prev"/><name>alloc_objects</name></decl>, <decl><type ref="prev"/><name>total_objects</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>entries_by_fanout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>deduplicated_entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>start_pack</name> <init>= <expr><ternary><condition><expr><name>m</name></expr> ?</condition><then> <expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>cur_pack</name> <operator>=</operator> <name>start_pack</name></expr>;</init> <condition><expr><name>cur_pack</name> <operator>&lt;</operator> <name>nr_packs</name></expr>;</condition> <incr><expr><name>cur_pack</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>total_objects</name> <operator>+=</operator> <name><name>info</name><index>[<expr><name>cur_pack</name></expr>]</index></name><operator>.</operator><name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>alloc_objects</name> <operator>=</operator> <name>alloc_fanout</name> <operator>=</operator> <ternary><condition><expr><name>total_objects</name> <operator>&gt;</operator> <literal type="number">3200</literal></expr> ?</condition><then> <expr><name>total_objects</name> <operator>/</operator> <literal type="number">200</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>entries_by_fanout</name></expr></argument>, <argument><expr><name>alloc_fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>deduplicated_entries</name></expr></argument>, <argument><expr><name>alloc_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nr_objects</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cur_fanout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cur_fanout</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>cur_fanout</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>nr_fanout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_fanout</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_fanout</name><index>[<expr><name>cur_fanout</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_fanout</name><index>[<expr><name>cur_fanout</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cur_object</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>cur_object</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>cur_object</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name>entries_by_fanout</name></expr></argument>, <argument><expr><name>nr_fanout</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>alloc_fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>nth_midxed_pack_midx_entry</name><argument_list>(<argument><expr><name>m</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>entries_by_fanout</name><index>[<expr><name>nr_fanout</name></expr>]</index></name></expr></argument>,

<argument><expr><name>cur_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nr_fanout</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>cur_pack</name> <operator>=</operator> <name>start_pack</name></expr>;</init> <condition><expr><name>cur_pack</name> <operator>&lt;</operator> <name>nr_packs</name></expr>;</condition> <incr><expr><name>cur_pack</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_fanout</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>get_pack_fanout</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>cur_pack</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>cur_fanout</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>get_pack_fanout</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>cur_pack</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>cur_fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cur_object</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>cur_object</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>cur_object</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name>entries_by_fanout</name></expr></argument>, <argument><expr><name>nr_fanout</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>alloc_fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_pack_entry</name><argument_list>(<argument><expr><name>cur_pack</name></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>cur_pack</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>, <argument><expr><name>cur_object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entries_by_fanout</name><index>[<expr><name>nr_fanout</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nr_fanout</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name>entries_by_fanout</name></expr></argument>, <argument><expr><name>nr_fanout</name></expr></argument>, <argument><expr><name>midx_oid_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cur_object</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cur_object</name> <operator>&lt;</operator> <name>nr_fanout</name></expr>;</condition> <incr><expr><name>cur_object</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cur_object</name> <operator>&amp;&amp;</operator> <call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entries_by_fanout</name><index>[<expr><name>cur_object</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>entries_by_fanout</name><index>[<expr><name>cur_object</name></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name>deduplicated_entries</name></expr></argument>, <argument><expr><operator>*</operator><name>nr_objects</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>alloc_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>deduplicated_entries</name><index>[<expr><operator>*</operator><name>nr_objects</name></expr>]</index></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>entries_by_fanout</name><index>[<expr><name>cur_object</name></expr>]</index></name></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pack_midx_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>nr_objects</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entries_by_fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>deduplicated_entries</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>write_midx_pack_names</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_info</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>num_packs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>padding</name><index>[<expr><name>MIDX_CHUNK_ALIGNMENT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_packs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>writelen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expired</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"incorrect pack-file order: %s before %s"</literal></expr></argument>,

<argument><expr><name><name>info</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>,

<argument><expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>writelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>, <argument><expr><name>writelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>writelen</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>MIDX_CHUNK_ALIGNMENT</name> <operator>-</operator> <operator>(</operator><name>written</name> <operator>%</operator> <name>MIDX_CHUNK_ALIGNMENT</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>MIDX_CHUNK_ALIGNMENT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>padding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>padding</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>written</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>write_midx_oid_fanout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>objects</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>nr_objects</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>objects</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>objects</name> <operator>+</operator> <name>nr_objects</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>list</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>next</name> <operator>&lt;</operator> <name>last</name> <operator>&amp;&amp;</operator> <name><name>next</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>MIDX_CHUNK_FANOUT_SIZE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>write_midx_oid_lookup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>hash_len</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>objects</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>nr_objects</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>objects</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr_objects</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name>list</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nr_objects</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>list</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oidcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>next</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"OIDs not in order: %s &gt;= %s"</literal></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>hash_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>hash_len</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>written</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>write_midx_object_offsets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>large_offset_needed</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>perm</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>objects</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>nr_objects</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>objects</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nr_large_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr_objects</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name>list</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>perm</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>pack_int_id</name></name></expr>]</index></name> <operator>==</operator> <name>PACK_EXPIRED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"object %s is in an expired pack with int-id %d"</literal></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>pack_int_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>perm</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>pack_int_id</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>large_offset_needed</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>MIDX_LARGE_OFFSET_NEEDED</name> <operator>|</operator> <name>nr_large_offset</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>large_offset_needed</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"object %s requires a large offset (%"</literal><name>PRIx64</name><literal type="string">") but the MIDX is not writing large offsets!"</literal></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>obj</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>MIDX_CHUNK_OFFSET_WIDTH</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>written</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>write_midx_large_offsets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>nr_large_offset</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>objects</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>nr_objects</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>objects</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>objects</name> <operator>+</operator> <name>nr_objects</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>nr_large_offset</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"too many large-offset objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <name>list</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>offset</name> <operator>&amp;</operator> <literal type="number">0xffffffffUL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>nr_large_offset</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>written</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>write_midx_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_dir</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>packs_to_drop</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cur_chunk</name></decl>, <decl><type ref="prev"/><name>num_chunks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>midx_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>lock_file</name></name></type> <name>lk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_list</name></name></type> <name>packs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pack_perm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>chunk_ids</name><index>[<expr><name>MIDX_MAX_CHUNKS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>chunk_offsets</name><index>[<expr><name>MIDX_MAX_CHUNKS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>nr_entries</name></decl>, <decl><type ref="prev"/><name>num_large_offsets</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_midx_entry</name></name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>progress</name></name> <modifier>*</modifier></type><name>progress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>large_offsets_needed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pack_name_concat_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dropped_packs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>midx_name</name> <operator>=</operator> <call><name>get_midx_filename</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>safe_create_leading_directories</name><argument_list>(<argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UNLEAK</name><argument_list>(<argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to create leading directories of %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>m</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>m</name></name> <operator>=</operator> <call><name>load_multi_pack_index</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>alloc</name></name> <operator>=</operator> <ternary><condition><expr><name><name>packs</name><operator>.</operator><name>m</name></name></expr> ?</condition><then> <expr><name><name>packs</name><operator>.</operator><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>packs</name><operator>.</operator><name>m</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>packs</name><operator>.</operator><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name><name>packs</name><operator>.</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>orig_pack_int_id</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name><name>packs</name><operator>.</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>pack_name</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name><name>packs</name><operator>.</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name><name>packs</name><operator>.</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>expired</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>nr</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>pack_paths_checked</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>progress</name></name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Adding packfiles to multi-pack-index"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>progress</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>for_each_file_in_pack_dir</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><name>add_pack_to_midx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>packs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>packs</name><operator>.</operator><name>progress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>packs</name><operator>.</operator><name>m</name></name> <operator>&amp;&amp;</operator> <name><name>packs</name><operator>.</operator><name>nr</name></name> <operator>==</operator> <name><name>packs</name><operator>.</operator><name>m</name><operator>-&gt;</operator><name>num_packs</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>packs_to_drop</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>get_sorted_entries</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>m</name></name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>nr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nr_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr_entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>&gt;</operator> <literal type="number">0x7fffffff</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>num_large_offsets</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>&gt;</operator> <literal type="number">0xffffffff</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>large_offsets_needed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>nr</name></name></expr></argument>, <argument><expr><name>pack_info_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>packs_to_drop</name> <operator>&amp;&amp;</operator> <name><name>packs_to_drop</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>drop_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>missing_drops</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>packs</name><operator>.</operator><name>nr</name></name> <operator>&amp;&amp;</operator> <name>drop_index</name> <operator>&lt;</operator> <name><name>packs_to_drop</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>,

<argument><expr><name><name>packs_to_drop</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>drop_index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>drop_index</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expired</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"did not see pack-file %s to drop"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>packs_to_drop</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>drop_index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>drop_index</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>missing_drops</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expired</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>missing_drops</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>pack_perm</name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>packs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expired</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dropped_packs</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_perm</name><index>[<expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>orig_pack_int_id</name></expr>]</index></name> <operator>=</operator> <name>PACK_EXPIRED</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>pack_perm</name><index>[<expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>orig_pack_int_id</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>dropped_packs</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>packs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expired</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pack_name_concat_len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>pack_name_concat_len</name> <operator>%</operator> <name>MIDX_CHUNK_ALIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pack_name_concat_len</name> <operator>+=</operator> <name>MIDX_CHUNK_ALIGNMENT</name> <operator>-</operator>

<operator>(</operator><name>pack_name_concat_len</name> <operator>%</operator> <name>MIDX_CHUNK_ALIGNMENT</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hold_lock_file_for_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lk</name></expr></argument>, <argument><expr><name>midx_name</name></expr></argument>, <argument><expr><name>LOCK_DIE_ON_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>hashfd</name><argument_list>(<argument><expr><name><name>lk</name><operator>.</operator><name>tempfile</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>lk</name><operator>.</operator><name>tempfile</name><operator>-&gt;</operator><name>filename</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>packs</name><operator>.</operator><name>m</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_midx</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>m</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cur_chunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>num_chunks</name> <operator>=</operator> <ternary><condition><expr><name>large_offsets_needed</name></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>write_midx_header</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>num_chunks</name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>nr</name></name> <operator>-</operator> <name>dropped_packs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_ids</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name>MIDX_CHUNKID_PACKNAMES</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name>written</name> <operator>+</operator> <operator>(</operator><name>num_chunks</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>MIDX_CHUNKLOOKUP_WIDTH</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_chunk</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_ids</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name>MIDX_CHUNKID_OIDFANOUT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>pack_name_concat_len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_chunk</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_ids</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name>MIDX_CHUNKID_OIDLOOKUP</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>MIDX_CHUNK_FANOUT_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_chunk</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_ids</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name>MIDX_CHUNKID_OBJECTOFFSETS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>nr_entries</name> <operator>*</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_chunk</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>nr_entries</name> <operator>*</operator> <name>MIDX_CHUNK_OFFSET_WIDTH</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>large_offsets_needed</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>chunk_ids</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name>MIDX_CHUNKID_LARGEOFFSETS</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_chunk</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <name><name>chunk_offsets</name><index>[<expr><name>cur_chunk</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator>

<name>num_large_offsets</name> <operator>*</operator> <name>MIDX_CHUNK_LARGE_OFFSET_WIDTH</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>chunk_ids</name><index>[<expr><name>cur_chunk</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_chunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&amp;&amp;</operator> <name><name>chunk_offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>chunk_offsets</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"incorrect chunk offsets: %"</literal><name>PRIu64</name><literal type="string">" before %"</literal><name>PRIu64</name></expr></argument>,

<argument><expr><name><name>chunk_offsets</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><name><name>chunk_offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>chunk_offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>%</operator> <name>MIDX_CHUNK_ALIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"chunk offset %"</literal><name>PRIu64</name><literal type="string">" is not properly aligned"</literal></expr></argument>,

<argument><expr><name><name>chunk_offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>chunk_ids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>chunk_offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashwrite_be32</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>chunk_offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>MIDX_CHUNKLOOKUP_WIDTH</name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Writing chunks to multi-pack-index"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>num_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_chunks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <name><name>chunk_offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"incorrect chunk offset (%"</literal><name>PRIu64</name><literal type="string">" != %"</literal><name>PRIu64</name><literal type="string">") for chunk id %"</literal><name>PRIx32</name></expr></argument>,

<argument><expr><name><name>chunk_offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,

<argument><expr><name>written</name></expr></argument>,

<argument><expr><name><name>chunk_ids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>chunk_ids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MIDX_CHUNKID_PACKNAMES</name></expr>:</case>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <call><name>write_midx_pack_names</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>packs</name><operator>.</operator><name>nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIDX_CHUNKID_OIDFANOUT</name></expr>:</case>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <call><name>write_midx_oid_fanout</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>, <argument><expr><name>nr_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIDX_CHUNKID_OIDLOOKUP</name></expr>:</case>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <call><name>write_midx_oid_lookup</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>, <argument><expr><name>entries</name></expr></argument>, <argument><expr><name>nr_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIDX_CHUNKID_OBJECTOFFSETS</name></expr>:</case>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <call><name>write_midx_object_offsets</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>large_offsets_needed</name></expr></argument>, <argument><expr><name>pack_perm</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>, <argument><expr><name>nr_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIDX_CHUNKID_LARGEOFFSETS</name></expr>:</case>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <call><name>write_midx_large_offsets</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>num_large_offsets</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>, <argument><expr><name>nr_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"trying to write unknown chunk id %"</literal><name>PRIx32</name></expr></argument>,

<argument><expr><name><name>chunk_ids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <name><name>chunk_offsets</name><index>[<expr><name>num_chunks</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"incorrect final offset %"</literal><name>PRIu64</name><literal type="string">" != %"</literal><name>PRIu64</name></expr></argument>,

<argument><expr><name>written</name></expr></argument>,

<argument><expr><name><name>chunk_offsets</name><index>[<expr><name>num_chunks</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>finalize_hashfile</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CSUM_FSYNC</name> <operator>|</operator> <name>CSUM_HASH_IN_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>commit_lock_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>packs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>close_pack</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>packs</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pack_perm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>midx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>write_midx_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_dir</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>write_midx_internal</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>clear_midx_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>midx</name> <init>= <expr><call><name>get_midx_filename</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>odb</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>objects</name></name> <operator>&amp;&amp;</operator> <name><name>r</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>multi_pack_index</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>close_midx</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>multi_pack_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>multi_pack_index</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>remove_path</name><argument_list>(<argument><expr><name>midx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UNLEAK</name><argument_list>(<argument><expr><name>midx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to clear multi-pack-index at %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>midx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>midx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>verify_midx_error</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>midx_report</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><name>verify_midx_error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>pair_pos_vs_id</name>

<block>{

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pack_int_id</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_pair_pos_vs_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pair_pos_vs_id</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>pair_pos_vs_id</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pair_pos_vs_id</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator>struct <name>pair_pos_vs_id</name> <operator>*</operator><operator>)</operator><name>_b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>b</name><operator>-&gt;</operator><name>pack_int_id</name></name> <operator>-</operator> <name><name>a</name><operator>-&gt;</operator><name>pack_int_id</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPARSE_PROGRESS_INTERVAL</name></cpp:macro> <cpp:value>(1 &lt;&lt; 12)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>midx_display_sparse_progress</name><parameter_list>(<parameter><type><name>progress</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { uint64_t _n = (n); if ((_n &amp; (SPARSE_PROGRESS_INTERVAL - 1)) == 0) display_progress(progress, _n); } while (0)</cpp:value></cpp:define>

<function><type><name>int</name></type> <name>verify_midx_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_dir</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pair_pos_vs_id</name></name> <modifier>*</modifier></type><name>pairs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>progress</name></name> <modifier>*</modifier></type><name>progress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>load_multi_pack_index</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>verify_midx_error</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Looking for referenced packfiles"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>prepare_midx_pack</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>midx_report</name><argument_list>(<argument><expr><literal type="string">"failed to load pack in position %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">255</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>oid_fanout1</name> <init>= <expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_fanout</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>oid_fanout2</name> <init>= <expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>chunk_oid_fanout</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>oid_fanout1</name> <operator>&gt;</operator> <name>oid_fanout2</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>midx_report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"oid fanout out of order: fanout[%d] = %"</literal><name>PRIx32</name><literal type="string">" &gt; %"</literal><name>PRIx32</name><literal type="string">" = fanout[%d]"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>i</name></expr></argument>, <argument><expr><name>oid_fanout1</name></expr></argument>, <argument><expr><name>oid_fanout2</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>start_sparse_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Verifying OID order in multi-pack-index"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid1</name></decl>, <decl><type ref="prev"/><name>oid2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid1</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid2</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oidcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>midx_report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"oid lookup out of order: oid[%d] = %s &gt;= %s = oid[%d]"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>midx_display_sparse_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_int_id</name> <operator>=</operator> <call><name>nth_midxed_pack_int_id</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>start_sparse_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sorting objects by packfile"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr></argument>, <argument><expr><name>compare_pair_pos_vs_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>start_sparse_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Verifying object offsets"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pack_entry</name></name></type> <name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>off_t</name></type> <name>m_offset</name></decl>, <decl><type ref="prev"/><name>p_offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pairs</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pack_int_id</name> <operator>!=</operator> <name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_int_id</name> <operator>&amp;&amp;</operator>

<name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name><name>pairs</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pack_int_id</name></expr>]</index></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>close_pack_fd</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name><name>pairs</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pack_int_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close_pack_index</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name><name>pairs</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pack_int_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fill_midx_entry</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>midx_report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to load pack entry for oid[%d] = %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>open_pack_index</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>midx_report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to load pack-index for packfile %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>e</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>m_offset</name> <operator>=</operator> <name><name>e</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>p_offset</name> <operator>=</operator> <call><name>find_pack_entry_one</name><argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>m_offset</name> <operator>!=</operator> <name>p_offset</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>midx_report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"incorrect object offset for oid[%d] = %s: %"</literal><name>PRIx64</name><literal type="string">" != %"</literal><name>PRIx64</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m_offset</name></expr></argument>, <argument><expr><name>p_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>midx_display_sparse_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>verify_midx_error</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>expire_midx_packs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_dir</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>count</name></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>packs_to_drop</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>load_multi_pack_index</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>progress</name></name> <modifier>*</modifier></type><name>progress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Counting referenced objects"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pack_int_id</name> <init>= <expr><call><name>nth_midxed_pack_int_id</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>count</name><index>[<expr><name>pack_int_id</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Finding and deleting unreferenced packfiles"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pack_name</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>count</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prepare_midx_pack</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pack_keep</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pack_name</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pack_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close_pack</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packs_to_drop</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>pack_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unlink_pack_path</name><argument_list>(<argument><expr><name>pack_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pack_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>packs_to_drop</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>write_midx_internal</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>packs_to_drop</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packs_to_drop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>repack_info</name> <block>{

<decl_stmt><decl><type><name>timestamp_t</name></type> <name>mtime</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>referenced_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pack_int_id</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_by_mtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>repack_info</name></name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> struct <name>repack_info</name> <operator>*</operator><operator>)</operator><name>a_</name></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> struct <name>repack_info</name> <operator>*</operator><operator>)</operator><name>b_</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>mtime</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>mtime</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>mtime</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>mtime</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fill_included_packs_all</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>include_pack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>include_pack</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fill_included_packs_batch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>include_pack</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>batch_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>packs_to_repack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>repack_info</name></name> <modifier>*</modifier></type><name>pack_info</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>repack_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>pack_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_int_id</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prepare_midx_pack</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pack_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mtime</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>mtime</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>batch_size</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pack_int_id</name> <init>= <expr><call><name>nth_midxed_pack_int_id</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>pack_info</name><index>[<expr><name>pack_int_id</name></expr>]</index></name><operator>.</operator><name>referenced_objects</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name>pack_info</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>, <argument><expr><name>compare_by_mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>total_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>packs_to_repack</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>total_size</name> <operator>&lt;</operator> <name>batch_size</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pack_int_id</name> <init>= <expr><name><name>pack_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pack_int_id</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>packs</name><index>[<expr><name>pack_int_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>expected_size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>open_pack_index</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>expected_size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pack_size</name></name>

<operator>*</operator> <name><name>pack_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>referenced_objects</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>expected_size</name> <operator>/=</operator> <name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>expected_size</name> <operator>&gt;=</operator> <name>batch_size</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>packs_to_repack</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>total_size</name> <operator>+=</operator> <name>expected_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>include_pack</name><index>[<expr><name>pack_int_id</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pack_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>total_size</name> <operator>&lt;</operator> <name>batch_size</name> <operator>||</operator> <name>packs_to_repack</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>midx_repack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_dir</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>batch_size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>include_pack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>cmd</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>base_name</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>load_multi_pack_index</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>include_pack</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>num_packs</name></name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>batch_size</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>fill_included_packs_batch</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>include_pack</name></expr></argument>, <argument><expr><name>batch_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>fill_included_packs_all</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>include_pack</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="string">"pack-objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_name</name></expr></argument>, <argument><expr><name>object_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_name</name></expr></argument>, <argument><expr><literal type="string">"/pack/pack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>base_name</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MIDX_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="string">"--progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="string">"-q"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>git_cmd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name><name>cmd</name><operator>.</operator><name>out</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>start_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not start pack-objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pack_int_id</name> <init>= <expr><call><name>nth_midxed_pack_int_id</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>include_pack</name><index>[<expr><name>pack_int_id</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xwrite</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>in</name></name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xwrite</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>finish_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not finish pack-objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>write_midx_internal</name><argument_list>(<argument><expr><name>object_dir</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>m</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_midx</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>include_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

</unit>
