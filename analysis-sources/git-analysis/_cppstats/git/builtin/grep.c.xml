<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\builtin\grep.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_THE_INDEX_COMPATIBILITY_MACROS</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blob.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree-walk.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parse-options.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string-list.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"userdiff.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grep.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quote.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pathspec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"submodule.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"submodule-config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"packfile.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>grep_usage</name><index>[]</index></name> <init>= <expr><block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git grep [&lt;options&gt;] [-e] &lt;pattern&gt; [&lt;rev&gt;...] [[--] &lt;path&gt;...]"</literal></expr></argument>)</argument_list></call></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recurse_submodules</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>num_threads</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_t</name> <modifier>*</modifier></type><name>threads</name></decl>;</decl_stmt>

<struct>struct <name>work_item</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>grep_source</name></name></type> <name>source</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>done</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>out</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TODO_SIZE</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>work_item</name></name></type> <name><name>todo</name><index>[<expr><name>TODO_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>todo_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>todo_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>todo_done</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>all_work_added</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>grep_mutex</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>grep_lock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grep_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>grep_unlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grep_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_cond_t</name></type> <name>cond_add</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_cond_t</name></type> <name>cond_write</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_cond_t</name></type> <name>cond_result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>skip_first_line</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_work</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>binary</name></name> <operator>!=</operator> <name>GREP_BINARY_TEXT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>grep_source_load_driver</name><argument_list>(<argument><expr><name>gs</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>grep_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>todo_end</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>todo_done</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_write</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>grep_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>todo</name><index>[<expr><name>todo_end</name></expr>]</index></name><operator>.</operator><name>source</name> <operator>=</operator> <operator>*</operator><name>gs</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>todo</name><index>[<expr><name>todo_end</name></expr>]</index></name><operator>.</operator><name>done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>todo</name><index>[<expr><name>todo_end</name></expr>]</index></name><operator>.</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>todo_end</name> <operator>=</operator> <operator>(</operator><name>todo_end</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>work_item</name></name> <modifier>*</modifier></type><name>get_work</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>work_item</name></name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>grep_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>todo_start</name> <operator>==</operator> <name>todo_end</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>all_work_added</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_add</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>grep_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>todo_start</name> <operator>==</operator> <name>todo_end</name> <operator>&amp;&amp;</operator> <name>all_work_added</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>&amp;</operator><name><name>todo</name><index>[<expr><name>todo_start</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>todo_start</name> <operator>=</operator> <operator>(</operator><name>todo_start</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>grep_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>work_done</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>work_item</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>old_done</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>grep_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>old_done</name> <operator>=</operator> <name>todo_done</name></expr>;</expr_stmt>

<for>for<control>(<init>;</init> <condition><expr><name><name>todo</name><index>[<expr><name>todo_done</name></expr>]</index></name><operator>.</operator><name>done</name> <operator>&amp;&amp;</operator> <name>todo_done</name> <operator>!=</operator> <name>todo_start</name></expr>;</condition>

<incr><expr><name>todo_done</name> <operator>=</operator> <operator>(</operator><name>todo_done</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>&amp;</operator><name><name>todo</name><index>[<expr><name>todo_done</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>skip_first_line</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>skip_first_line</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>write_or_die</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>grep_source_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>old_done</name> <operator>!=</operator> <name>todo_done</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>all_work_added</name> <operator>&amp;&amp;</operator> <name>todo_done</name> <operator>==</operator> <name>todo_end</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>grep_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>run</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>work_item</name></name> <modifier>*</modifier></type><name>w</name> <init>= <expr><call><name>get_work</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>w</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>output_priv</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>grep_source</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_source_clear_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>work_done</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free_grep_patterns</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator> <name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>strbuf_out</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>work_item</name></name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>output_priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>start_threads</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grep_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grep_attr_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_add</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_write</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_result</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>grep_use_locks</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>enable_obj_read_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>todo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>threads</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>num_threads</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>threads</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>grep_opt_dup</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>output</name></name> <operator>=</operator> <name>strbuf_out</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>debug</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>compile_grep_patterns</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>run</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"grep: failed to create thread: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>wait_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAVE_THREADS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"Never call this function unless you have started threads"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>grep_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>all_work_added</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>todo_done</name> <operator>!=</operator> <name>todo_end</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>grep_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><call><name>pthread_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator> <name>h</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grep_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grep_attr_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>grep_use_locks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>disable_obj_read_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_cmd_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>st</name> <init>= <expr><call><name>grep_config</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_color_default_config</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>st</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"grep.threads"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>num_threads</name> <operator>=</operator> <call><name>git_config_int</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num_threads</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid number of threads specified (%d) for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>num_threads</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>HAVE_THREADS</name> <operator>&amp;&amp;</operator> <name>num_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no threads support, ignoring %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num_threads</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"submodule.recurse"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>recurse_submodules</name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>st</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_oid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tree_name_len</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>pathbuf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_source</name></name></type> <name>gs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>relative</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>prefix_length</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>quote_path_relative</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>tree_name_len</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>tree_name_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>grep_source_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>, <argument><expr><name>GREP_SOURCE_OID</name></expr></argument>, <argument><expr><name><name>pathbuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>add_work</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>grep_source</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_source_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_source</name></name></type> <name>gs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>relative</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>prefix_length</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>quote_path_relative</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>grep_source_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>, <argument><expr><name>GREP_SOURCE_FILE</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>add_work</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>grep_source</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_source_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>append_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>path_list</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>output_priv</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>data</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><name>path_list</name></expr></argument>, <argument><expr><call><name>xstrndup</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_pager</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>path_list</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>output_priv</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>child</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>status</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path_list</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>child</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>path_list</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>child</name><operator>.</operator><name>dir</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>child</name><operator>.</operator><name>use_shell</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>run_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>grep_cache</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cached</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>grep_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>tree_desc</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tn_len</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>check_attr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_submodule</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cached</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name></type> <name>subrepo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>superproject</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>submodule</name></name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name></type> <name>subopt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>submodule_from_path</name><argument_list>(<argument><expr><name>superproject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_submodule_active</name><argument_list>(<argument><expr><name>superproject</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>repo_submodule_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>, <argument><expr><name>superproject</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>obj_read_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>repo_read_gitmodules</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_to_alternates_memory</name><argument_list>(<argument><expr><name><name>subrepo</name><operator>.</operator><name>objects</name><operator>-&gt;</operator><name>odb</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>obj_read_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subopt</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>subopt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>subopt</name><operator>.</operator><name>repo</name></name> <operator>=</operator> <operator>&amp;</operator><name>subrepo</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oid</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>tree_desc</name></name></type> <name>tree</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>base</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>obj_read_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>parse_object_or_die</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>obj_read_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>read_object_with_reference</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>object</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>tree_type</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to read tree (%s)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>object</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_tree_desc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>grep_tree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subopt</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><name><name>base</name><operator>.</operator><name>len</name></name></expr></argument>,

<argument><expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>grep_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subopt</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name>cached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>repo_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_cache</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cached</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>name</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>name_base_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>repo</name><operator>-&gt;</operator><name>submodule_prefix</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name_base_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>submodule_prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name><name>repo</name><operator>-&gt;</operator><name>submodule_prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>repo_read_index</name><argument_list>(<argument><expr><name>repo</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"index file corrupt"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nr</name> <operator>&lt;</operator> <name><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>nr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>nr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name>name_base_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>match_pathspec</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cached</name> <operator>||</operator> <operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_VALID</name><operator>)</operator> <operator>||</operator>

<call><name>ce_skip_worktree</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ce_intent_to_add</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>grep_oid</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>grep_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>recurse_submodules</name> <operator>&amp;&amp;</operator> <call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>submodule_path_match</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>grep_submodule</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>cached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><name>nr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>nr</name> <operator>&lt;</operator> <name><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>nr</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<expr_stmt><expr><name>nr</name><operator>--</operator></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>status_only</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>tree_desc</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tn_len</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>check_attr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>interesting</name></name></type> <name>match</name> <init>= <expr><name>entry_not_interesting</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>name_entry</name></name></type> <name>entry</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_baselen</name> <init>= <expr><name><name>base</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>name</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>name_base_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>repo</name><operator>-&gt;</operator><name>submodule_prefix</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name><name>repo</name><operator>-&gt;</operator><name>submodule_prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name_base_len</name> <operator>=</operator> <name><name>name</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><call><name>tree_entry</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>te_len</name> <init>= <expr><call><name>tree_entry_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name> <operator>!=</operator> <name>all_entries_interesting</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>tn_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>tree_entry_interesting</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name>name_base_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name> <operator>==</operator> <name>all_entries_not_interesting</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name> <operator>==</operator> <name>entry_not_interesting</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name>te_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>grep_oid</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>tn_len</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>check_attr</name></expr> ?</condition><then> <expr><name><name>base</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>tn_len</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>tree_desc</name></name></type> <name>sub</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to read tree (%s)"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_tree_desc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>grep_tree</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>tn_len</name></expr></argument>,

<argument><expr><name>check_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>recurse_submodules</name> <operator>&amp;&amp;</operator> <call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>grep_submodule</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>oid</name></name></expr></argument>,

<argument><expr><name><name>base</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>tn_len</name></expr></argument>,

<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>old_baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>status_only</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_BLOB</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>grep_oid</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_COMMIT</name> <operator>||</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TREE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>tree_desc</name></name></type> <name>tree</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>read_object_with_reference</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>tree_type</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to read tree (%s)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><name>PATH_MAX</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>init_tree_desc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>grep_tree</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><name><name>base</name><operator>.</operator><name>len</name></name></expr></argument>,

<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to grep from object of type %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_objects</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_array</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>nr</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>nr</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>real_obj</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>obj_read_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>real_obj</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>item</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>obj_read_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>recurse_submodules</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>submodule_free</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>obj_read_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gitmodules_config_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>real_obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>obj_read_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grep_object</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name>real_obj</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,

<argument><expr><name><name>list</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>status_only</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_directory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>exc_std</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_struct</name></name></type> <name>dir</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_index</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>dir</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>DIR_NO_GITLINKS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exc_std</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setup_standard_excludes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fill_directory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dir</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dir_path_match</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>dir</name><operator>.</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>grep_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>dir</name><operator>.</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>status_only</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>context_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>grep_opt</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>unset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>grep_opt</name><operator>-&gt;</operator><name>pre_context</name></name> <operator>=</operator> <name><name>grep_opt</name><operator>-&gt;</operator><name>post_context</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>endp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"switch `%c' expects a numerical value"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>short_name</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>grep_opt</name><operator>-&gt;</operator><name>pre_context</name></name> <operator>=</operator> <name><name>grep_opt</name><operator>-&gt;</operator><name>post_context</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>file_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>grep_opt</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>from_stdin</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>patterns</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>from_stdin</name> <operator>=</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>patterns</name> <operator>=</operator> <ternary><condition><expr><name>from_stdin</name></expr> ?</condition><then> <expr><name>stdin</name></expr> </then><else>: <expr><call><name>fopen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>patterns</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot open '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><call><name>strbuf_getline</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>patterns</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>append_grep_pat</name><argument_list>(<argument><expr><name>grep_opt</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>++</operator><name>lno</name></expr></argument>,

<argument><expr><name>GREP_PATTERN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from_stdin</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>patterns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>not_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>grep_opt</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_grep_pattern</name><argument_list>(<argument><expr><name>grep_opt</name></expr></argument>, <argument><expr><literal type="string">"--not"</literal></expr></argument>, <argument><expr><literal type="string">"command line"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GREP_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>and_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>grep_opt</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_grep_pattern</name><argument_list>(<argument><expr><name>grep_opt</name></expr></argument>, <argument><expr><literal type="string">"--and"</literal></expr></argument>, <argument><expr><literal type="string">"command line"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GREP_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>open_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>grep_opt</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_grep_pattern</name><argument_list>(<argument><expr><name>grep_opt</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>, <argument><expr><literal type="string">"command line"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GREP_OPEN_PAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>close_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>grep_opt</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_grep_pattern</name><argument_list>(<argument><expr><name>grep_opt</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="string">"command line"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GREP_CLOSE_PAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pattern_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>grep_opt</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_grep_pattern</name><argument_list>(<argument><expr><name>grep_opt</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-e option"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GREP_PATTERN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmd_grep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cached</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>untracked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>opt_exclude</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>seen_dashdash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>external_grep_allowed__ignored</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_in_pager</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_pager</name> <init>= <expr><literal type="string">"dummy"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name></type> <name>opt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_array</name></name></type> <name>list</name> <init>= <expr><name>OBJECT_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pathspec</name></name></type> <name>pathspec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>path_list</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>use_index</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pattern_type_arg</name> <init>= <expr><name>GREP_PATTERN_TYPE_UNSPECIFIED</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>allow_revs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"cached"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cached</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"search in index instead of in the work tree"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_NEGBIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"no-index"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_index</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"find in contents not managed by git"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"untracked"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>untracked</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"search in both tracked and untracked files"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"exclude-standard"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt_exclude</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"ignore files specified via '.gitignore'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"recurse-submodules"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>recurse_submodules</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"recursively search in each submodule"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'v'</literal></expr></argument>, <argument><expr><literal type="string">"invert-match"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>invert</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show non-matching lines"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><literal type="string">"ignore-case"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>ignore_case</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"case insensitive matching"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'w'</literal></expr></argument>, <argument><expr><literal type="string">"word-regexp"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>word_regexp</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"match patterns only at word boundaries"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>binary</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"process binary files as text"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>GREP_BINARY_TEXT</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'I'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>binary</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"don't match patterns in binary files"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>GREP_BINARY_NOMATCH</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"textconv"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>allow_textconv</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"process binary files with textconv filters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"recursive"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>max_depth</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"search in subdirectories (default)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,

<expr><block>{ <expr><name>OPTION_INTEGER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"max-depth"</literal></expr>, <expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>max_depth</name></name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"depth"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"descend at most &lt;depth&gt; levels"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,

<expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,

<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'E'</literal></expr></argument>, <argument><expr><literal type="string">"extended-regexp"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pattern_type_arg</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use extended POSIX regular expressions"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>GREP_PATTERN_TYPE_ERE</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'G'</literal></expr></argument>, <argument><expr><literal type="string">"basic-regexp"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pattern_type_arg</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use basic POSIX regular expressions (default)"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>GREP_PATTERN_TYPE_BRE</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>, <argument><expr><literal type="string">"fixed-strings"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pattern_type_arg</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"interpret patterns as fixed strings"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>GREP_PATTERN_TYPE_FIXED</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'P'</literal></expr></argument>, <argument><expr><literal type="string">"perl-regexp"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pattern_type_arg</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use Perl-compatible regular expressions"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>GREP_PATTERN_TYPE_PCRE</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>, <argument><expr><literal type="string">"line-number"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>linenum</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show line numbers"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"column"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>columnnum</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show column number of first match"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_NEGBIT</name><argument_list>(<argument><expr><literal type="char">'h'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>pathname</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"don't show filenames"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="char">'H'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>pathname</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show filenames"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_NEGBIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"full-name"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>relative</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show filenames relative to top directory"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'l'</literal></expr></argument>, <argument><expr><literal type="string">"files-with-matches"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>name_only</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show only filenames instead of matching lines"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"name-only"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>name_only</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"synonym for --files-with-matches"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'L'</literal></expr></argument>, <argument><expr><literal type="string">"files-without-match"</literal></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>unmatch_name_only</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show only the names of files without match"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL_F</name><argument_list>(<argument><expr><literal type="char">'z'</literal></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>null_following_name</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print NUL after filenames"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>PARSE_OPT_NOCOMPLETE</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'o'</literal></expr></argument>, <argument><expr><literal type="string">"only-matching"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>only_matching</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show only matching parts of a line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>count</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show the number of matches instead of matching lines"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT__COLOR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>color</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"highlight matches"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"break"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>file_break</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print empty line between matches from different files"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"heading"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>heading</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show filename only once above matches from same file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_CALLBACK</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"context"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show &lt;n&gt; context lines before and after matches"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>context_callback</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="char">'B'</literal></expr></argument>, <argument><expr><literal type="string">"before-context"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>pre_context</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show &lt;n&gt; context lines before matches"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="char">'A'</literal></expr></argument>, <argument><expr><literal type="string">"after-context"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>post_context</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show &lt;n&gt; context lines after matches"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"threads"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_threads</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use &lt;n&gt; worker threads"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_NUMBER_CALLBACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"shortcut for -C NUM"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>context_callback</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'p'</literal></expr></argument>, <argument><expr><literal type="string">"show-function"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>funcname</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show a line with the function name before matches"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'W'</literal></expr></argument>, <argument><expr><literal type="string">"function-context"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>funcbody</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show the surrounding function"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_CALLBACK</name><argument_list>(<argument><expr><literal type="char">'f'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"read patterns from file"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file_callback</name></expr></argument>)</argument_list></call></expr>,

<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>&amp;</operator><name>opt</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"pattern"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"match &lt;pattern&gt;"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>, <expr><name>pattern_callback</name></expr> }</block></expr>,

<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"and"</literal></expr>, <expr><operator>&amp;</operator><name>opt</name></expr>, <expr><name>NULL</name></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"combine patterns specified with -e"</literal></expr></argument>)</argument_list></call></expr>,

<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>, <expr><name>and_callback</name></expr> }</block></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"or"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,

<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"not"</literal></expr>, <expr><operator>&amp;</operator><name>opt</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">""</literal></expr>,

<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>, <expr><name>not_callback</name></expr> }</block></expr>,

<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'('</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>&amp;</operator><name>opt</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">""</literal></expr>,

<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name> <operator>|</operator> <name>PARSE_OPT_NODASH</name></expr>,

<expr><name>open_callback</name></expr> }</block></expr>,

<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">')'</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>&amp;</operator><name>opt</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">""</literal></expr>,

<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name> <operator>|</operator> <name>PARSE_OPT_NODASH</name></expr>,

<expr><name>close_callback</name></expr> }</block></expr>,

<expr><call><name>OPT__QUIET</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>status_only</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"indicate hit with exit status without output"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"all-match"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>all_match</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show only matches from files that match all patterns"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"debug"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>.</operator><name>debug</name></name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show parse tree for grep expression"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>PARSE_OPT_HIDDEN</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>,

<expr><block>{ <expr><name>OPTION_STRING</name></expr>, <expr><literal type="char">'O'</literal></expr>, <expr><literal type="string">"open-files-in-pager"</literal></expr>, <expr><operator>&amp;</operator><name>show_in_pager</name></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"pager"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show matching files in the pager"</literal></expr></argument>)</argument_list></call></expr>,

<expr><name>PARSE_OPT_OPTARG</name> <operator>|</operator> <name>PARSE_OPT_NOCOMPLETE</name></expr>,

<expr><name>NULL</name></expr>, <expr><operator>(</operator><name>intptr_t</name><operator>)</operator><name>default_pager</name></expr> }</block></expr>,

<expr><call><name>OPT_BOOL_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ext-grep"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>external_grep_allowed__ignored</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"allow calling of grep(1) (ignored by this build)"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>PARSE_OPT_NOCOMPLETE</name></expr></argument>)</argument_list></call></expr>,

<macro><name>OPT_END</name><argument_list>()</argument_list></macro>

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_grep_defaults</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>grep_cmd_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>grep_usage</name></expr></argument>,

<argument><expr><name>PARSE_OPT_KEEP_DASHDASH</name> <operator>|</operator>

<name>PARSE_OPT_STOP_AT_NON_OPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_commit_pattern_type</name><argument_list>(<argument><expr><name>pattern_type_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_index</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>startup_info</name><operator>-&gt;</operator><name>have_repository</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fallback</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>git_config_get_bool</name><argument_list>(<argument><expr><literal type="string">"grep.fallbacktonoindex"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fallback</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>use_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setup_git_directory</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_index</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>recurse_submodules</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opt</name><operator>.</operator><name>pattern_list</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opt</name><operator>.</operator><name>pattern_list</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_grep_pattern</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"command line"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>GREP_PATTERN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_in_pager</name> <operator>==</operator> <name>default_pager</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>show_in_pager</name> <operator>=</operator> <call><name>git_pager</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_in_pager</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>color</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>name_only</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>null_following_name</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>output_priv</name></name> <operator>=</operator> <operator>&amp;</operator><name>path_list</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>append_path</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_list</name></expr></argument>, <argument><expr><name>show_in_pager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>.</operator><name>pattern_list</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no pattern given"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>.</operator><name>invert</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>only_matching</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>seen_dashdash</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>allow_revs</name> <operator>=</operator> <name>use_index</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>untracked</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_context</name></name></type> <name>oc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_revs</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>seen_dashdash</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--no-index or --untracked cannot be used with revs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid_with_context</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,

<argument><expr><name>GET_OID_RECORD_PATH</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>seen_dashdash</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to resolve revision: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>parse_object_or_die</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>seen_dashdash</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>verify_non_filename</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_object_array_with_path</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><name><name>oc</name><operator>.</operator><name>mode</name></name></expr></argument>, <argument><expr><name><name>oc</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>oc</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>seen_dashdash</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>verify_filename</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name> <operator>==</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>allow_revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>parse_pathspec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathspec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>PATHSPEC_PREFER_CWD</name> <operator>|</operator>

<operator>(</operator><ternary><condition><expr><name><name>opt</name><operator>.</operator><name>max_depth</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>PATHSPEC_MAXDEPTH_VALID</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,

<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pathspec</name><operator>.</operator><name>max_depth</name></name> <operator>=</operator> <name><name>opt</name><operator>.</operator><name>max_depth</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pathspec</name><operator>.</operator><name>recursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pathspec</name><operator>.</operator><name>recurse_submodules</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>recurse_submodules</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>recurse_submodules</name> <operator>&amp;&amp;</operator> <name>untracked</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--untracked not supported with --recurse-submodules"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_in_pager</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>num_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid option combination, ignoring --threads"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num_threads</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>HAVE_THREADS</name> <operator>&amp;&amp;</operator> <name>num_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no threads support, ignoring --threads"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num_threads</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>num_threads</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid number of threads specified (%d)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>num_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>num_threads</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>num_threads</name> <operator>=</operator> <ternary><condition><expr><name>HAVE_THREADS</name></expr> ?</condition><then> <expr><call><name>online_cpus</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAVE_THREADS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"Somebody got num_threads calculation wrong!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>opt</name><operator>.</operator><name>name_only</name></name> <operator>||</operator> <name><name>opt</name><operator>.</operator><name>unmatch_name_only</name></name> <operator>||</operator> <name><name>opt</name><operator>.</operator><name>count</name></name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>opt</name><operator>.</operator><name>pre_context</name></name> <operator>||</operator> <name><name>opt</name><operator>.</operator><name>post_context</name></name> <operator>||</operator>

<name><name>opt</name><operator>.</operator><name>file_break</name></name> <operator>||</operator> <name><name>opt</name><operator>.</operator><name>funcbody</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>skip_first_line</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>recurse_submodules</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>repo_read_gitmodules</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>startup_info</name><operator>-&gt;</operator><name>have_repository</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>get_packed_git</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>start_threads</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>compile_grep_patterns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_in_pager</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cached</name> <operator>||</operator> <name><name>list</name><operator>.</operator><name>nr</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--open-files-in-pager only works on the worktree"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_in_pager</name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>.</operator><name>pattern_list</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opt</name><operator>.</operator><name>pattern_list</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pager</name> <init>= <expr><name><name>path_list</name><operator>.</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pager</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>is_dir_sep</name><argument_list>(<argument><expr><name><name>pager</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pager</name> <operator>+=</operator> <name>len</name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>.</operator><name>ignore_case</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"less"</literal></expr></argument>, <argument><expr><name>pager</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_list</name></expr></argument>, <argument><expr><literal type="string">"-I"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"less"</literal></expr></argument>, <argument><expr><name>pager</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"vi"</literal></expr></argument>, <argument><expr><name>pager</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"+/%s%s"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"less"</literal></expr></argument>, <argument><expr><name>pager</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"*"</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>opt</name><operator>.</operator><name>pattern_list</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_list</name></expr></argument>,

<argument><expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>show_in_pager</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opt</name><operator>.</operator><name>status_only</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setup_pager</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_index</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>untracked</name> <operator>||</operator> <name>cached</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--cached or --untracked cannot be used with --no-index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_index</name> <operator>||</operator> <name>untracked</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>use_exclude</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>opt_exclude</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>use_index</name></expr> </then><else>: <expr><operator>!</operator><operator>!</operator><name>opt_exclude</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>grep_directory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathspec</name></expr></argument>, <argument><expr><name>use_exclude</name></expr></argument>, <argument><expr><name>use_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>opt_exclude</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--[no-]exclude-standard cannot be used for tracked contents"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>list</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cached</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setup_work_tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>grep_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathspec</name></expr></argument>, <argument><expr><name>cached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cached</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"both --cached and trees are given"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>grep_objects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathspec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>wait_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name> <operator>&amp;&amp;</operator> <name>show_in_pager</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>run_pager</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>clear_pathspec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_grep_patterns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>!</operator><name>hit</name></expr>;</return>

</block_content>}</block></function>

</unit>
