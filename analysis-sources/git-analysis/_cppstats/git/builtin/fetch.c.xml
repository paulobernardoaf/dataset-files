<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\builtin\fetch.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refspec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oidset.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string-list.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transport.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parse-options.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sigchain.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"submodule-config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"submodule.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"connected.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"argv-array.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"packfile.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list-objects-filter-options.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"branch.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"promisor-remote.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-graph.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCED_UPDATES_DELAY_WARNING_IN_MS</name></cpp:macro> <cpp:value>(10 * 1000)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>builtin_fetch_usage</name><index>[]</index></name> <init>= <expr><block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;...]]"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git fetch [&lt;options&gt;] &lt;group&gt;"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)...]"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git fetch --all [&lt;options&gt;]"</literal></expr></argument>)</argument_list></call></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<enum>enum <block>{

<decl><name>TAGS_UNSET</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>TAGS_DEFAULT</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>TAGS_SET</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>

}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>fetch_prune_config</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>fetch_show_forced_updates</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>forced_updates_ms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>prune</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRUNE_BY_DEFAULT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>fetch_prune_tags_config</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>prune_tags</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRUNE_TAGS_BY_DEFAULT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>all</name></decl>, <decl><type ref="prev"/><name>append</name></decl>, <decl><type ref="prev"/><name>dry_run</name></decl>, <decl><type ref="prev"/><name>force</name></decl>, <decl><type ref="prev"/><name>keep</name></decl>, <decl><type ref="prev"/><name>multiple</name></decl>, <decl><type ref="prev"/><name>update_head_ok</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>verbosity</name></decl>, <decl><type ref="prev"/><name>deepen_relative</name></decl>, <decl><type ref="prev"/><name>set_upstream</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>progress</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>enable_auto_gc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tags</name> <init>= <expr><name>TAGS_DEFAULT</name></expr></init></decl>, <decl><type ref="prev"/><name>unshallow</name></decl>, <decl><type ref="prev"/><name>update_shallow</name></decl>, <decl><type ref="prev"/><name>deepen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_jobs</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>submodule_fetch_jobs_config</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>fetch_parallel_config</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>enum</name> <name>transport_family</name></name></type> <name>family</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>depth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>deepen_since</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>upload_pack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>deepen_not</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>default_rla</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>gtransport</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>gsecondary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>submodule_prefix</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recurse_submodules</name> <init>= <expr><name>RECURSE_SUBMODULES_DEFAULT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recurse_submodules_default</name> <init>= <expr><name>RECURSE_SUBMODULES_ON_DEMAND</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>shown_url</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>refspec</name></name></type> <name>refmap</name> <init>= <expr><name>REFSPEC_INIT_FETCH</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>list_objects_filter_options</name></name></type> <name>filter_options</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>server_options</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>negotiation_tip</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>fetch_write_commit_graph</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>git_fetch_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"fetch.prune"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fetch_prune_config</name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"fetch.prunetags"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fetch_prune_tags_config</name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"fetch.showforcedupdates"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fetch_show_forced_updates</name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"submodule.recurse"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><ternary><condition><expr><call><name>git_config_bool</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><name>RECURSE_SUBMODULES_ON</name></expr> </then><else>: <expr><name>RECURSE_SUBMODULES_OFF</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>recurse_submodules</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"submodule.fetchjobs"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>submodule_fetch_jobs_config</name> <operator>=</operator> <call><name>parse_submodule_fetchjobs</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"fetch.recursesubmodules"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>recurse_submodules</name> <operator>=</operator> <call><name>parse_fetch_recurse_submodules_arg</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"fetch.parallel"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fetch_parallel_config</name> <operator>=</operator> <call><name>git_config_int</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fetch_parallel_config</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fetch.parallel cannot be negative"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>git_default_config</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_refmap_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refmap</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>builtin_fetch_options</name><index>[]</index></name> <init>= <expr><block>{

<expr><call><name>OPT__VERBOSITY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>verbosity</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>all</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"fetch from all remotes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"set-upstream"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>set_upstream</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"set upstream for git pull/fetch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>append</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"append to .git/FETCH_HEAD instead of overwriting"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"upload-pack"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>upload_pack</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"path"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"path to upload pack on remote end"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT__FORCE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>force</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"force overwrite of local reference"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'m'</literal></expr></argument>, <argument><expr><literal type="string">"multiple"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>multiple</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"fetch from multiple remotes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>, <argument><expr><literal type="string">"tags"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tags</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"fetch all tags and associated objects"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TAGS_SET</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tags</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not fetch all tags (--no-tags)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TAGS_UNSET</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="char">'j'</literal></expr></argument>, <argument><expr><literal type="string">"jobs"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_jobs</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"number of submodules fetched in parallel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'p'</literal></expr></argument>, <argument><expr><literal type="string">"prune"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>prune</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"prune remote-tracking branches no longer on remote"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'P'</literal></expr></argument>, <argument><expr><literal type="string">"prune-tags"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>prune_tags</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"prune local tags no longer on remote and clobber changed tags"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"recurse-submodules"</literal></expr>, <expr><operator>&amp;</operator><name>recurse_submodules</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"on-demand"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"control recursive fetching of submodules"</literal></expr></argument>)</argument_list></call></expr>,

<expr><name>PARSE_OPT_OPTARG</name></expr>, <expr><name>option_fetch_parse_recurse_submodules</name></expr> }</block></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"dry-run"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dry_run</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"dry run"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'k'</literal></expr></argument>, <argument><expr><literal type="string">"keep"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>keep</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"keep downloaded pack"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'u'</literal></expr></argument>, <argument><expr><literal type="string">"update-head-ok"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>update_head_ok</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"allow updating of HEAD ref"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"progress"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"force progress reporting"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"depth"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"depth"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"deepen history of shallow clone"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"shallow-since"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>deepen_since</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"time"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"deepen history of shallow repository based on time"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_STRING_LIST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"shallow-exclude"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>deepen_not</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"revision"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"deepen history of shallow clone, excluding rev"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"deepen"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>deepen_relative</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"deepen history of shallow clone"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"unshallow"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>unshallow</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"convert to a complete repository"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>PARSE_OPT_NONEG</name></expr></argument>)</argument_list></call></expr>,

<expr><block>{ <expr><name>OPTION_STRING</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"submodule-prefix"</literal></expr>, <expr><operator>&amp;</operator><name>submodule_prefix</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"dir"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"prepend this to submodule path output"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_HIDDEN</name></expr> }</block></expr>,

<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"recurse-submodules-default"</literal></expr>,

<expr><operator>&amp;</operator><name>recurse_submodules_default</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"on-demand"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"default for recursive fetching of submodules "</literal>

<literal type="string">"(lower priority than config files)"</literal></expr></argument>)</argument_list></call></expr>,

<expr><name>PARSE_OPT_HIDDEN</name></expr>, <expr><name>option_fetch_parse_recurse_submodules</name></expr> }</block></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"update-shallow"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>update_shallow</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"accept refs that update .git/shallow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"refmap"</literal></expr>, <expr><name>NULL</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"refmap"</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"specify fetch refmap"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>, <expr><name>parse_refmap_arg</name></expr> }</block></expr>,

<expr><call><name>OPT_STRING_LIST</name><argument_list>(<argument><expr><literal type="char">'o'</literal></expr></argument>, <argument><expr><literal type="string">"server-option"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>server_options</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"server-specific"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"option to transmit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'4'</literal></expr></argument>, <argument><expr><literal type="string">"ipv4"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>family</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use IPv4 addresses only"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>TRANSPORT_FAMILY_IPV4</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'6'</literal></expr></argument>, <argument><expr><literal type="string">"ipv6"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>family</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use IPv6 addresses only"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>TRANSPORT_FAMILY_IPV6</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_STRING_LIST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"negotiation-tip"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>negotiation_tip</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"revision"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"report that we have only objects reachable from this object"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_PARSE_LIST_OBJECTS_FILTER</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter_options</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"auto-gc"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>enable_auto_gc</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"run 'gc --auto' after fetching"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"show-forced-updates"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fetch_show_forced_updates</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"check for forced-updates on all updated branches"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"write-commit-graph"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fetch_write_commit_graph</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"write the commit-graph after fetching"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<macro><name>OPT_END</name><argument_list>()</argument_list></macro>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unlock_pack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>gtransport</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>transport_unlock_pack</name><argument_list>(<argument><expr><name>gtransport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>gsecondary</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>transport_unlock_pack</name><argument_list>(<argument><expr><name>gsecondary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unlock_pack_on_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>unlock_pack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigchain_pop</name><argument_list>(<argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_merge_config</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>head</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_refs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>branch</name><operator>-&gt;</operator><name>merge_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>rm</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>old_tail</name> <init>= <expr><operator>*</operator><name>tail</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec_item</name></name></type> <name>refspec</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <operator>*</operator><name>head</name></expr>;</init> <condition><expr><name>rm</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>branch_merge_matches</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>rm</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>=</operator> <name>FETCH_HEAD_MERGE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>rm</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refspec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>refspec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>refspec</name><operator>.</operator><name>src</name></name> <operator>=</operator> <name><name>branch</name><operator>-&gt;</operator><name>merge</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>src</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_fetch_map</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refspec</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <operator>*</operator><name>old_tail</name></expr>;</init> <condition><expr><name>rm</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>=</operator> <name>FETCH_HEAD_MERGE</name></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_fetch_oidset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>oidset</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>rm</name> <init>= <expr><operator>*</operator><name>head</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>rm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>oidset_insert</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<struct>struct <name>refname_hash_entry</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>ent</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ignore</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>refname</name><index>[<expr><name>FLEX_ARRAY</name></expr>]</index></name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>refname_hash_entry_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>hashmap_cmp_fn_data</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>entry_or_key</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keydata</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>refname_hash_entry</name></name> <modifier>*</modifier></type><name>e1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>e1</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>refname_hash_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e2</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>entry_or_key</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>refname_hash_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>keydata</name></expr> ?</condition><then> <expr><name>keydata</name></expr> </then><else>: <expr><name><name>e2</name><operator>-&gt;</operator><name>refname</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>refname_hash_entry</name></name> <modifier>*</modifier></type><name>refname_hash_add</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>refname_hash_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FLEX_ALLOC_MEM</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>, <argument><expr><call><name>strhash</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_add</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ent</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_one_refname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbdata</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>refname_map</name> <init>= <expr><name>cbdata</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>refname_hash_add</name><argument_list>(<argument><expr><name>refname_map</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>refname_hash_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>refname_hash_entry_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>refname_hash_exists</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>!</operator><operator>!</operator><call><name>hashmap_get_from_hash</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><call><name>strhash</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_item</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refname_hash_entry</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ignore</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_non_local_tags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>head</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name></type> <name>existing_refs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name></type> <name>remote_refs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>oidset</name></name></type> <name>fetch_oids</name> <init>= <expr><name>OIDSET_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>remote_refs_list</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>remote_ref_item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>refname_hash_entry</name></name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>quick_flags</name> <init>= <expr><name>OBJECT_INFO_QUICK</name> <operator>|</operator> <name>OBJECT_INFO_SKIP_FETCH_OBJECT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>refname_hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>existing_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refname_hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>create_fetch_oidset</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fetch_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>for_each_ref</name><argument_list>(<argument><expr><name>add_one_refname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>existing_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>refs</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ends_with</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"^{}"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>has_object_file_with_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><name>quick_flags</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>oidset_contains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fetch_oids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>has_object_file_with_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>quick_flags</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>oidset_contains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fetch_oids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>clear_item</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>has_object_file_with_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>quick_flags</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>oidset_contains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fetch_oids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>clear_item</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>refname_hash_exists</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_refs</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>refname_hash_exists</name><argument_list>(<argument><expr><operator>&amp;</operator><name>existing_refs</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>refname_hash_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_refs</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_refs_list</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><operator>&amp;</operator><name>existing_refs</name></expr></argument>, <argument><expr>struct <name>refname_hash_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>has_object_file_with_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>quick_flags</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>oidset_contains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fetch_oids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>clear_item</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<macro><name>for_each_string_list_item</name><argument_list>(<argument>remote_ref_item</argument>, <argument>&amp;remote_refs_list</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name> <init>= <expr><name><name>remote_ref_item</name><operator>-&gt;</operator><name>string</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>rm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hash</name> <init>= <expr><call><name>strhash</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>hashmap_get_entry_from_hash</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_refs</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>,

<argument><expr>struct <name>refname_hash_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unseen remote ref?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>ignore</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rm</name> <operator>=</operator> <call><name>alloc_ref</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>=</operator> <call><name>alloc_ref</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>*</operator><name>tail</name> <operator>=</operator> <name>rm</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_refs</name></expr></argument>, <argument><expr>struct <name>refname_hash_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_refs_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidset_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fetch_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>get_ref_map</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_refs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>tags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>autotags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>rm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>ref_map</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>orefs</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>oref_tail</name> <init>= <expr><operator>&amp;</operator><name>orefs</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name></type> <name>existing_refs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>fetch_refspec</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>get_fetch_map</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dst</name> <operator>&amp;&amp;</operator> <name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>autotags</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <name>ref_map</name></expr>;</init> <condition><expr><name>rm</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>=</operator> <name>FETCH_HEAD_MERGE</name></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>refmap</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fetch_refspec</name> <operator>=</operator> <operator>&amp;</operator><name>refmap</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>fetch_refspec</name> <operator>=</operator> <operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fetch_refspec</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>get_fetch_map</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fetch_refspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oref_tail</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>refmap</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"--refmap option is only meaningful with command-line refspec(s)."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name> <init>= <expr><call><name>branch_get</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_merge</name> <init>= <expr><call><name>branch_has_merge_config</name><argument_list>(<argument><expr><name>branch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>remote</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name><operator>.</operator><name>nr</name></name> <operator>||</operator>

<operator>(</operator><name>has_merge</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>remote_name</name></name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>remote</name><operator>-&gt;</operator><name>fetch</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>get_fetch_map</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>remote</name><operator>-&gt;</operator><name>fetch</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dst</name> <operator>&amp;&amp;</operator>

<name><name>remote</name><operator>-&gt;</operator><name>fetch</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>autotags</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_merge</name> <operator>&amp;&amp;</operator> <name>ref_map</name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name><operator>.</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ref_map</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>=</operator> <name>FETCH_HEAD_MERGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>has_merge</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>remote_name</name></name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_merge_config</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_map</name></expr></argument>, <argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ref_map</name> <operator>=</operator> <call><name>get_remote_ref</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref_map</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Couldn't find remote ref HEAD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ref_map</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>=</operator> <name>FETCH_HEAD_MERGE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>ref_map</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tags</name> <operator>==</operator> <name>TAGS_SET</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>get_fetch_map</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><name>tag_refspec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>tags</name> <operator>==</operator> <name>TAGS_DEFAULT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>autotags</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>find_non_local_tags</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>orefs</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <name>orefs</name></expr>;</init> <condition><expr><name>rm</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>=</operator> <name>FETCH_HEAD_IGNORE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>ref_map</name> <operator>=</operator> <call><name>ref_remove_duplicates</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refname_hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>existing_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>for_each_ref</name><argument_list>(<argument><expr><name>add_one_refname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>existing_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <name>ref_map</name></expr>;</init> <condition><expr><name>rm</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name> <init>= <expr><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>refname_hash_entry</name></name> <modifier>*</modifier></type><name>peer_item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hash</name> <init>= <expr><call><name>strhash</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>peer_item</name> <operator>=</operator> <call><name>hashmap_get_entry_from_hash</name><argument_list>(<argument><expr><operator>&amp;</operator><name>existing_refs</name></expr></argument>,

<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>,

<argument><expr>struct <name>refname_hash_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>peer_item</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>old_oid</name> <init>= <expr><operator>&amp;</operator><name><name>peer_item</name><operator>-&gt;</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><name>old_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><operator>&amp;</operator><name>existing_refs</name></expr></argument>, <argument><expr>struct <name>refname_hash_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ref_map</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE_REF_ERROR_OTHER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE_REF_ERROR_DF_CONFLICT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>s_update_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>action</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>check_old</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rla</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"GIT_REFLOG_ACTION"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_transaction</name></name> <modifier>*</modifier></type><name>transaction</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>df_conflict</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dry_run</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rla</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>rla</name> <operator>=</operator> <name><name>default_rla</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>rla</name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>transaction</name> <operator>=</operator> <call><name>ref_transaction_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transaction</name> <operator>||</operator>

<call><name>ref_transaction_update</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>check_old</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ref_transaction_commit</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>df_conflict</name> <operator>=</operator> <operator>(</operator><name>ret</name> <operator>==</operator> <name>TRANSACTION_NAME_CONFLICT</name><operator>)</operator></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ref_transaction_free</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>

<expr_stmt><expr><call><name>ref_transaction_free</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>df_conflict</name></expr> ?</condition><then> <expr><name>STORE_REF_ERROR_DF_CONFLICT</name></expr>

</then><else>: <expr><name>STORE_REF_ERROR_OTHER</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>refcol_width</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>compact_format</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>adjust_refcol_width</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>rlen</name></decl>, <decl><type ref="prev"/><name>llen</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>verbosity</name> <operator>&amp;&amp;</operator> <call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>term_columns</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>utf8_strwidth</name><argument_list>(<argument><expr><call><name>prettify_refname</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llen</name> <operator>=</operator> <call><name>utf8_strwidth</name><argument_list>(<argument><expr><call><name>prettify_refname</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>compact_format</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>llen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <name>max</name> <operator>*</operator> <literal type="number">2</literal> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">21</literal> <operator>+</operator> <name>rlen</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <name>llen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>refcol_width</name> <operator>&lt;</operator> <name>rlen</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>refcol_width</name> <operator>=</operator> <name>rlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>prepare_format_display</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>rm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name> <init>= <expr><literal type="string">"full"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>git_config_get_string_const</name><argument_list>(<argument><expr><literal type="string">"fetch.output"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"full"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>compact_format</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"compact"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>compact_format</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"configuration fetch.output contains invalid value %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <name>ref_map</name></expr>;</init> <condition><expr><name>rm</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>REF_STATUS_REJECT_SHALLOW</name> <operator>||</operator>

<operator>!</operator><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>||</operator>

<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>adjust_refcol_width</name><argument_list>(<argument><expr><name>rm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_remote_to_local</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>display</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>local</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><literal type="string">"%-*s -&gt; %s"</literal></expr></argument>, <argument><expr><name>refcol_width</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_and_replace</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>haystack</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>placeholder</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>plen</name></decl>, <decl><type ref="prev"/><name>nlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ends_with</name><argument_list>(<argument><expr><name><name>haystack</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>haystack</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>haystack</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>nlen</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>haystack</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name><name>haystack</name><operator>-&gt;</operator><name>buf</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>plen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>plen</name> <operator>&gt;</operator> <name>nlen</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>nlen</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_splice</name><argument_list>(<argument><expr><name>haystack</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name><name>haystack</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>,

<argument><expr><name>placeholder</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>placeholder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_compact</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>display</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>local</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>r</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>l</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><literal type="string">"%-*s -&gt; *"</literal></expr></argument>, <argument><expr><name>refcol_width</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>find_and_replace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>local</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>find_and_replace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>print_remote_to_local</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>l</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>format_display</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>display</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>code</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>summary</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>local</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>summary_width</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><operator>(</operator><name>summary_width</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>summary</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>gettext_width</name><argument_list>(<argument><expr><name>summary</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><literal type="string">"%c %-*s "</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>summary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>compact_format</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>print_remote_to_local</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>print_compact</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><literal type="string">" (%s)"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>update_local_ref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_ref</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>display</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>summary_width</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>current</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>updated</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>current_branch</name> <init>= <expr><call><name>branch_get</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pretty_ref</name> <init>= <expr><call><name>prettify_refname</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fast_forward</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"object %s not found"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"[up to date]"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pretty_ref</name></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>current_branch</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>current_branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><name>update_head_ok</name> <operator>||</operator> <call><name>is_bare_repository</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><literal type="char">'!'</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"[rejected]"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"can't fetch in current branch"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pretty_ref</name></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>starts_with</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>force</name> <operator>||</operator> <name><name>ref</name><operator>-&gt;</operator><name>force</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>s_update_ref</name><argument_list>(<argument><expr><literal type="string">"updating tag"</literal></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name></expr> ?</condition><then> <expr><literal type="char">'!'</literal></expr> </then><else>: <expr><literal type="char">'t'</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"[tag update]"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name>r</name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to update local ref"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pretty_ref</name></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><literal type="char">'!'</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"[rejected]"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"would clobber existing tag"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pretty_ref</name></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>updated</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current</name> <operator>||</operator> <operator>!</operator><name>updated</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><ternary><condition><expr><name>remote_ref</name></expr> ?</condition><then> <expr><name><name>remote_ref</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"storing tag"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>what</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"[new tag]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"storing head"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>what</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"[new branch]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"storing ref"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>what</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"[new ref]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>s_update_ref</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name></expr> ?</condition><then> <expr><literal type="char">'!'</literal></expr> </then><else>: <expr><literal type="char">'*'</literal></expr></else></ternary></expr></argument>, <argument><expr><name>what</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>r</name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to update local ref"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pretty_ref</name></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fetch_show_forced_updates</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>t_before</name> <init>= <expr><call><name>getnanotime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fast_forward</name> <operator>=</operator> <call><name>in_merge_bases</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>updated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>forced_updates_ms</name> <operator>+=</operator> <operator>(</operator><call><name>getnanotime</name><argument_list>()</argument_list></call> <operator>-</operator> <name>t_before</name><operator>)</operator> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fast_forward</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fast_forward</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>quickref</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add_unique_abbrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quickref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quickref</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add_unique_abbrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quickref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>s_update_ref</name><argument_list>(<argument><expr><literal type="string">"fast-forward"</literal></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name></expr> ?</condition><then> <expr><literal type="char">'!'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>quickref</name><operator>.</operator><name>buf</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>r</name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to update local ref"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pretty_ref</name></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quickref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>force</name> <operator>||</operator> <name><name>ref</name><operator>-&gt;</operator><name>force</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>quickref</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add_unique_abbrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quickref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quickref</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add_unique_abbrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quickref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>s_update_ref</name><argument_list>(<argument><expr><literal type="string">"forced-update"</literal></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name></expr> ?</condition><then> <expr><literal type="char">'!'</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>quickref</name><operator>.</operator><name>buf</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>r</name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to update local ref"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"forced update"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pretty_ref</name></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quickref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr><literal type="char">'!'</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"[rejected]"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"non-fast-forward"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pretty_ref</name></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>iterate_ref_map</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rm</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><operator>*</operator><name>rm</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ref</name> <operator>&amp;&amp;</operator> <name><name>ref</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>REF_STATUS_REJECT_SHALLOW</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>*</operator><name>rm</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>warn_show_forced_updates</name><index>[]</index></name> <init>=

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Fetch normally indicates which branches had a forced update,\n"</literal>

<literal type="string">"but that check has been disabled. To re-enable, use '--show-forced-updates'\n"</literal>

<literal type="string">"flag or run 'git config fetch.showForcedUpdates true'."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>warn_time_show_forced_updates</name><index>[]</index></name> <init>=

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"It took %.2f seconds to check forced updates. You can use\n"</literal>

<literal type="string">"'--no-show-forced-updates' or run 'git config fetch.showForcedUpdates false'\n"</literal>

<literal type="string">" to avoid this check.\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>store_updated_refs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>raw_url</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote_name</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>connectivity_checked</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>url_len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>note</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>kind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>rm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>url</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><ternary><condition><expr><name>dry_run</name></expr> ?</condition><then> <expr><literal type="string">"/dev/null"</literal></expr> </then><else>: <expr><call><name>git_path_fetch_head</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>want_status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>summary_width</name> <init>= <expr><call><name>transport_summary_width</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot open %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>raw_url</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>url</name> <operator>=</operator> <call><name>transport_anonymize_url</name><argument_list>(<argument><expr><name>raw_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>url</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"foreign"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>connectivity_checked</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>check_connected_options</name></name></type> <name>opt</name> <init>= <expr><name>CHECK_CONNECTED_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter_options</name><operator>.</operator><name>choice</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>check_refs_are_promisor_objects_only</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rm</name> <operator>=</operator> <name>ref_map</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_connected</name><argument_list>(<argument><expr><name>iterate_ref_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s did not send all necessary objects\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>abort</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>prepare_format_display</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>want_status</name> <operator>=</operator> <name>FETCH_HEAD_MERGE</name></expr>;</init>

<condition><expr><name>want_status</name> <operator>&lt;=</operator> <name>FETCH_HEAD_IGNORE</name></expr>;</condition>

<incr><expr><name>want_status</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <name>ref_map</name></expr>;</init> <condition><expr><name>rm</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>merge_status_marker</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>REF_STATUS_REJECT_SHALLOW</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>want_status</name> <operator>==</operator> <name>FETCH_HEAD_MERGE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"reject %s because shallow roots are not allowed to be updated"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name></name></expr> ?</condition><then> <expr><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name><name>rm</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>,

<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>=</operator> <name>FETCH_HEAD_NOT_FOR_MERGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>!=</operator> <name>want_status</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>alloc_ref</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>force</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>recurse_submodules</name> <operator>!=</operator> <name>RECURSE_SUBMODULES_OFF</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>check_for_new_submodule_commits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>what</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>what</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="string">"branch"</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>what</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="string">"tag"</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/remotes/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>what</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="string">"remote-tracking branch"</literal></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>what</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>url_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>url_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>url</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name>url_len</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">4</literal> <operator>&lt;</operator> <name>i</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">".git"</literal></expr></argument>, <argument><expr><name>url</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>url_len</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>what</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>kind</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>note</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>note</name></expr></argument>, <argument><expr><literal type="string">"'%s' of "</literal></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>fetch_head_status</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>FETCH_HEAD_NOT_FOR_MERGE</name></expr>:</case>

<expr_stmt><expr><name>merge_status_marker</name> <operator>=</operator> <literal type="string">"not-for-merge"</literal></expr>;</expr_stmt>

<case>case <expr><name>FETCH_HEAD_MERGE</name></expr>:</case>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s\t%s\t%s"</literal></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>merge_status_marker</name></expr></argument>,

<argument><expr><name><name>note</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>url_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><literal type="char">'\n'</literal> <operator>==</operator> <name><name>url</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name><name>url</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rc</name> <operator>|=</operator> <call><name>update_local_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>rm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note</name></expr></argument>,

<argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><operator>&amp;</operator><name>note</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>,

<argument><expr><ternary><condition><expr><operator>*</operator><name>kind</name></expr> ?</condition><then> <expr><name>kind</name></expr> </then><else>: <expr><literal type="string">"branch"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>*</operator><name>what</name></expr> ?</condition><then> <expr><name>what</name></expr> </then><else>: <expr><literal type="string">"HEAD"</literal></expr></else></ternary></expr></argument>,

<argument><expr><literal type="string">"FETCH_HEAD"</literal></expr></argument>, <argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>note</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>shown_url</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"From %.*s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>url_len</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>shown_url</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>note</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>STORE_REF_ERROR_DF_CONFLICT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"some local refs could not be updated; try running\n"</literal>

<literal type="string">" 'git remote prune %s' to remove any old, conflicting "</literal>

<literal type="string">"branches"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>remote_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>advice_fetch_show_forced_updates</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fetch_show_forced_updates</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>warn_show_forced_updates</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>forced_updates_ms</name> <operator>&gt;</operator> <name>FORCED_UPDATES_DELAY_WARNING_IN_MS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>warn_time_show_forced_updates</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>forced_updates_ms</name> <operator>/</operator> <literal type="number">1000.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>abort</name>:</label>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>rc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_exist_and_connected</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>rm</name> <init>= <expr><name>ref_map</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>check_connected_options</name></name></type> <name>opt</name> <init>= <expr><name>CHECK_CONNECTED_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>deepen</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>rm</name></expr>;</init> <condition><expr><name>r</name></expr>;</condition> <incr><expr><name>r</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_object_file_with_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>,

<argument><expr><name>OBJECT_INFO_SKIP_FETCH_OBJECT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>quiet</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><call><name>check_connected</name><argument_list>(<argument><expr><name>iterate_ref_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fetch_refs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>transport</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>check_exist_and_connected</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>trace2_region_enter</name><argument_list>(<argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><literal type="string">"fetch_refs"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>transport_fetch_refs</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace2_region_leave</name><argument_list>(<argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><literal type="string">"fetch_refs"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>transport_unlock_pack</name><argument_list>(<argument><expr><name>transport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>consume_refs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>transport</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>connectivity_checked</name> <init>= <expr><ternary><condition><expr><name><name>transport</name><operator>-&gt;</operator><name>smart_options</name></name></expr>

?</condition><then> <expr><name><name>transport</name><operator>-&gt;</operator><name>smart_options</name><operator>-&gt;</operator><name>connectivity_checked</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>trace2_region_enter</name><argument_list>(<argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><literal type="string">"consume_refs"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>store_updated_refs</name><argument_list>(<argument><expr><name><name>transport</name><operator>-&gt;</operator><name>url</name></name></expr></argument>,

<argument><expr><name><name>transport</name><operator>-&gt;</operator><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name>connectivity_checked</name></expr></argument>,

<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>transport_unlock_pack</name><argument_list>(<argument><expr><name>transport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace2_region_leave</name><argument_list>(<argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><literal type="string">"consume_refs"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prune_refs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>raw_url</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>url_len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>stale_refs</name> <init>= <expr><call><name>get_stale_heads</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>url</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>summary_width</name> <init>= <expr><call><name>transport_summary_width</name><argument_list>(<argument><expr><name>stale_refs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dangling_msg</name> <init>= <expr><ternary><condition><expr><name>dry_run</name></expr>

?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (%s will become dangling)"</literal></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (%s has become dangling)"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>raw_url</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>url</name> <operator>=</operator> <call><name>transport_anonymize_url</name><argument_list>(<argument><expr><name>raw_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>url</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"foreign"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>url_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>url_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>url</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name>url_len</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">4</literal> <operator>&lt;</operator> <name>i</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">".git"</literal></expr></argument>, <argument><expr><name>url</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>url_len</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dry_run</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>refnames</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>stale_refs</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refnames</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>delete_refs</name><argument_list>(<argument><expr><literal type="string">"fetch: prune"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>refnames</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refnames</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>stale_refs</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shown_url</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"From %.*s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>url_len</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>shown_url</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>format_display</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"[deleted]"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"(none)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>prettify_refname</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>summary_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s\n"</literal></expr></argument>,<argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>warn_dangling_symref</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>dangling_msg</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_refs</name><argument_list>(<argument><expr><name>stale_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_not_current_branch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>current_branch</name> <init>= <expr><call><name>branch_get</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_bare_repository</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>current_branch</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>ref_map</name></expr>;</condition> <incr><expr><name>ref_map</name> <operator>=</operator> <name><name>ref_map</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>ref_map</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>current_branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>,

<argument><expr><name><name>ref_map</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Refusing to fetch into current branch %s "</literal>

<literal type="string">"of non-bare repository"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>current_branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>truncate_fetch_head</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>git_path_fetch_head</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen_for_writing</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot open %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_option</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>transport</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>transport_set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Option \"%s\" value \"%s\" is not valid for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>transport</name><operator>-&gt;</operator><name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Option \"%s\" is ignored for %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>transport</name><operator>-&gt;</operator><name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>oid_array</name></name> <modifier>*</modifier></type><name>oids</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>oid_array_append</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_negotiation_tips</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>git_transport_options</name></name> <modifier>*</modifier></type><name>smart_options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>oid_array</name></name> <modifier>*</modifier></type><name>oids</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>oids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>negotiation_tip</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>negotiation_tip</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_nr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_glob_specials</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s is not a valid object"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>oid_array_append</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>old_nr</name> <operator>=</operator> <name><name>oids</name><operator>-&gt;</operator><name>nr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>for_each_glob_ref</name><argument_list>(<argument><expr><name>add_oid</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>old_nr</name> <operator>==</operator> <name><name>oids</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"Ignoring --negotiation-tip=%s because it does not match any refs"</literal></expr></argument>,

<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>smart_options</name><operator>-&gt;</operator><name>negotiation_tips</name></name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>prepare_transport</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deepen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>transport</name></decl>;</decl_stmt>

<expr_stmt><expr><name>transport</name> <operator>=</operator> <call><name>transport_get</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>transport_set_verbosity</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>transport</name><operator>-&gt;</operator><name>family</name></name> <operator>=</operator> <name>family</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>upload_pack</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_UPLOADPACK</name></expr></argument>, <argument><expr><name>upload_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>keep</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_KEEP</name></expr></argument>, <argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_DEPTH</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deepen</name> <operator>&amp;&amp;</operator> <name>deepen_since</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_DEEPEN_SINCE</name></expr></argument>, <argument><expr><name>deepen_since</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deepen</name> <operator>&amp;&amp;</operator> <name><name>deepen_not</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_DEEPEN_NOT</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>deepen_not</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deepen_relative</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_DEEPEN_RELATIVE</name></expr></argument>, <argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>update_shallow</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_UPDATE_SHALLOW</name></expr></argument>, <argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter_options</name><operator>.</operator><name>choice</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spec</name> <init>=

<expr><call><name>expand_list_objects_filter_spec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter_options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_LIST_OBJECTS_FILTER</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_FROM_PROMISOR</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>negotiation_tip</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>transport</name><operator>-&gt;</operator><name>smart_options</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_negotiation_tips</name><argument_list>(<argument><expr><name><name>transport</name><operator>-&gt;</operator><name>smart_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"Ignoring --negotiation-tip because the protocol does not support it."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>transport</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>backfill_tags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>transport</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cannot_reuse</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cannot_reuse</name> <operator>=</operator> <name><name>transport</name><operator>-&gt;</operator><name>cannot_reuse</name></name> <operator>||</operator>

<name>deepen_since</name> <operator>||</operator> <name><name>deepen_not</name><operator>.</operator><name>nr</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cannot_reuse</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gsecondary</name> <operator>=</operator> <call><name>prepare_transport</name><argument_list>(<argument><expr><name><name>transport</name><operator>-&gt;</operator><name>remote</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>transport</name> <operator>=</operator> <name>gsecondary</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>transport_set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_FOLLOWTAGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>transport_set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_DEPTH</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>transport_set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_DEEPEN_RELATIVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fetch_refs</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>consume_refs</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>gsecondary</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>transport_disconnect</name><argument_list>(<argument><expr><name>gsecondary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>gsecondary</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_fetch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>transport</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>autotags</name> <init>= <expr><operator>(</operator><name><name>transport</name><operator>-&gt;</operator><name>remote</name><operator>-&gt;</operator><name>fetch_tags</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retcode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_refs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>ref_prefixes</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>must_list_refs</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tags</name> <operator>==</operator> <name>TAGS_DEFAULT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>transport</name><operator>-&gt;</operator><name>remote</name><operator>-&gt;</operator><name>fetch_tags</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>tags</name> <operator>=</operator> <name>TAGS_SET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>transport</name><operator>-&gt;</operator><name>remote</name><operator>-&gt;</operator><name>fetch_tags</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>tags</name> <operator>=</operator> <name>TAGS_UNSET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>append</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dry_run</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retcode</name> <operator>=</operator> <call><name>truncate_fetch_head</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retcode</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>refspec_ref_prefixes</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_prefixes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>must_list_refs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>exact_sha1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>must_list_refs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>transport</name><operator>-&gt;</operator><name>remote</name></name> <operator>&amp;&amp;</operator> <name><name>transport</name><operator>-&gt;</operator><name>remote</name><operator>-&gt;</operator><name>fetch</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>refspec_ref_prefixes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>transport</name><operator>-&gt;</operator><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_prefixes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tags</name> <operator>==</operator> <name>TAGS_SET</name> <operator>||</operator> <name>tags</name> <operator>==</operator> <name>TAGS_DEFAULT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>must_list_refs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref_prefixes</name><operator>.</operator><name>argc</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_prefixes</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>must_list_refs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>trace2_region_enter</name><argument_list>(<argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><literal type="string">"remote_refs"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>remote_refs</name> <operator>=</operator> <call><name>transport_get_remote_refs</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_prefixes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace2_region_leave</name><argument_list>(<argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><literal type="string">"remote_refs"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>remote_refs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_prefixes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ref_map</name> <operator>=</operator> <call><name>get_ref_map</name><argument_list>(<argument><expr><name><name>transport</name><operator>-&gt;</operator><name>remote</name></name></expr></argument>, <argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>,

<argument><expr><name>tags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>autotags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>update_head_ok</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>check_not_current_branch</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tags</name> <operator>==</operator> <name>TAGS_DEFAULT</name> <operator>&amp;&amp;</operator> <name>autotags</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>transport_set_option</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>TRANS_OPT_FOLLOWTAGS</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prune</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>prune_refs</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>ref_map</name></expr></argument>, <argument><expr><name><name>transport</name><operator>-&gt;</operator><name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>prune_refs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>transport</name><operator>-&gt;</operator><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>,

<argument><expr><name>ref_map</name></expr></argument>,

<argument><expr><name><name>transport</name><operator>-&gt;</operator><name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fetch_refs</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>ref_map</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>consume_refs</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free_refs</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retcode</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>set_upstream</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name> <init>= <expr><call><name>branch_get</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>rm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>source_ref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <name>ref_map</name></expr>;</init> <condition><expr><name>rm</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rm</name><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>source_ref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multiple branches detected, incompatible with --set-upstream"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>skip</name>;</goto>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>source_ref</name> <operator>=</operator> <name>rm</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>source_ref</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>source_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>starts_with</name><argument_list>(<argument><expr><name><name>source_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>install_branch_config</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>transport</name><operator>-&gt;</operator><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>source_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name><name>source_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/remotes/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"not setting upstream for a remote remote-tracking branch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name><name>source_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"not setting upstream for a remote tag"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unknown branch type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no source branch found.\n"</literal>

<literal type="string">"you need to specify exactly one branch with the --set-upstream option."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>skip</name>:</label>

<expr_stmt><expr><call><name>free_refs</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tags</name> <operator>==</operator> <name>TAGS_DEFAULT</name> <operator>&amp;&amp;</operator> <name>autotags</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>ref_map</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ref_map</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_non_local_tags</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ref_map</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>backfill_tags</name><argument_list>(<argument><expr><name>transport</name></expr></argument>, <argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free_refs</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>

<return>return <expr><name>retcode</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_one_remote_for_fetch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>priv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>priv</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>remote</name><operator>-&gt;</operator><name>skip_default_update</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>remote_group_data</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_remote_group</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>priv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>remote_group_data</name></name> <modifier>*</modifier></type><name>g</name> <init>= <expr><name>priv</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"remotes."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>value</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>wordlen</name> <init>= <expr><call><name>strcspn</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">" \t\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>string_list_append_nodup</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>list</name></name></expr></argument>,

<argument><expr><call><name>xstrndup</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>wordlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>value</name> <operator>+=</operator> <name>wordlen</name> <operator>+</operator> <operator>(</operator><name><name>value</name><index>[<expr><name>wordlen</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_remote_or_group</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>prev_nr</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>nr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>remote_group_data</name></name></type> <name>g</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>g</name><operator>.</operator><name>list</name></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>get_remote_group</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>nr</name></name> <operator>==</operator> <name>prev_nr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name> <init>= <expr><call><name>remote_get</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remote_is_configured</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_options_to_argv</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>argv_array</name></name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dry_run</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--dry-run"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prune</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><ternary><condition><expr><name>prune</name></expr> ?</condition><then> <expr><literal type="string">"--prune"</literal></expr> </then><else>: <expr><literal type="string">"--no-prune"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prune_tags</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><ternary><condition><expr><name>prune_tags</name></expr> ?</condition><then> <expr><literal type="string">"--prune-tags"</literal></expr> </then><else>: <expr><literal type="string">"--no-prune-tags"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>update_head_ok</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--update-head-ok"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>force</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--force"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>keep</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--keep"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>recurse_submodules</name> <operator>==</operator> <name>RECURSE_SUBMODULES_ON</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--recurse-submodules"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>recurse_submodules</name> <operator>==</operator> <name>RECURSE_SUBMODULES_ON_DEMAND</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--recurse-submodules=on-demand"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tags</name> <operator>==</operator> <name>TAGS_SET</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--tags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>tags</name> <operator>==</operator> <name>TAGS_UNSET</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--no-tags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"-v"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"-v"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>verbosity</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"-q"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>parallel_fetch_state</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>remotes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fetch_next_remote</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>task_cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>parallel_fetch_state</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>cb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>remote</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>remotes</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>remote</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>remotes</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name><operator>++</operator></expr>]</index></name><operator>.</operator><name>string</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>task_cb</name> <operator>=</operator> <name>remote</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_pushv</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>git_cmd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Fetching %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fetch_failed_to_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>task_cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>parallel_fetch_state</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>cb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote</name> <init>= <expr><name>task_cb</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Could not fetch %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fetch_finished</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>task_cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>parallel_fetch_state</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>cb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote</name> <init>= <expr><name>task_cb</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not fetch '%s' (exit code: %d)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fetch_multiple</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_children</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>argv</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>append</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dry_run</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>errcode</name> <init>= <expr><call><name>truncate_fetch_head</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>errcode</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_pushl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>, <argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><literal type="string">"--append"</literal></expr></argument>, <argument><expr><literal type="string">"--no-auto-gc"</literal></expr></argument>,

<argument><expr><literal type="string">"--no-write-commit-graph"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_options_to_argv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>max_children</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>list</name><operator>-&gt;</operator><name>nr</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>parallel_fetch_state</name></name></type> <name>state</name> <init>= <expr><block>{ <expr><name><name>argv</name><operator>.</operator><name>argv</name></name></expr>, <expr><name>list</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--end-of-options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>run_processes_parallel_tr2</name><argument_list>(<argument><expr><name>max_children</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>fetch_next_remote</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>fetch_failed_to_start</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>fetch_finished</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>,

<argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><literal type="string">"parallel/fetch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>result</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>list</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Fetching %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>run_command_v_opt</name><argument_list>(<argument><expr><name><name>argv</name><operator>.</operator><name>argv</name></name></expr></argument>, <argument><expr><name>RUN_GIT_CMD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Could not fetch %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>!</operator><operator>!</operator><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>fetch_one_setup_partial</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>filter_options</name><operator>.</operator><name>no_filter</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_promisor_remote</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>filter_options</name><operator>.</operator><name>choice</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter_options</name><operator>.</operator><name>choice</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>partial_clone_register</name><argument_list>(<argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>filter_options</name><operator>.</operator><name>choice</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>partial_clone_get_default_filter_spec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter_options</name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fetch_one</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prune_tags_ok</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec</name></name></type> <name>rs</name> <init>= <expr><name>REFSPEC_INIT_FETCH</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>exit_code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>maybe_prune_tags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>remote_via_config</name> <init>= <expr><call><name>remote_is_configured</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>remote</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No remote repository specified. Please, specify either a URL or a\n"</literal>

<literal type="string">"remote name from which new revisions should be fetched."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>gtransport</name> <operator>=</operator> <call><name>prepare_transport</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prune</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name><name>remote</name><operator>-&gt;</operator><name>prune</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prune</name> <operator>=</operator> <name><name>remote</name><operator>-&gt;</operator><name>prune</name></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>fetch_prune_config</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prune</name> <operator>=</operator> <name>fetch_prune_config</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>prune</name> <operator>=</operator> <name>PRUNE_BY_DEFAULT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prune_tags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name><name>remote</name><operator>-&gt;</operator><name>prune_tags</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prune_tags</name> <operator>=</operator> <name><name>remote</name><operator>-&gt;</operator><name>prune_tags</name></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>fetch_prune_tags_config</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prune_tags</name> <operator>=</operator> <name>fetch_prune_tags_config</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>prune_tags</name> <operator>=</operator> <name>PRUNE_TAGS_BY_DEFAULT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>maybe_prune_tags</name> <operator>=</operator> <name>prune_tags_ok</name> <operator>&amp;&amp;</operator> <name>prune_tags</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>maybe_prune_tags</name> <operator>&amp;&amp;</operator> <name>remote_via_config</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><name>TAG_REFSPEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>maybe_prune_tags</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>argc</name> <operator>||</operator> <operator>!</operator><name>remote_via_config</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rs</name></expr></argument>, <argument><expr><name>TAG_REFSPEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"tag"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"You need to specify a tag name."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"refs/tags/%s:refs/tags/%s"</literal></expr></argument>,

<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rs</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rs</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>server_options</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>gtransport</name><operator>-&gt;</operator><name>server_options</name></name> <operator>=</operator> <operator>&amp;</operator><name>server_options</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sigchain_push_common</name><argument_list>(<argument><expr><name>unlock_pack_on_signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>unlock_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigchain_push</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exit_code</name> <operator>=</operator> <call><name>do_fetch</name><argument_list>(<argument><expr><name>gtransport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigchain_pop</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refspec_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>transport_disconnect</name><argument_list>(<argument><expr><name>gtransport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>gtransport</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>exit_code</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmd_fetch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>list</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prune_tags_ok</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>argv_gc_auto</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>packet_trace_identity</name><argument_list>(<argument><expr><literal type="string">"fetch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>default_rla</name></expr></argument>, <argument><expr><literal type="string">"fetch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>default_rla</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fetch_config_from_gitmodules</name><argument_list>(<argument><expr><operator>&amp;</operator><name>submodule_fetch_jobs_config</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>recurse_submodules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_fetch_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>,

<argument><expr><name>builtin_fetch_options</name></expr></argument>, <argument><expr><name>builtin_fetch_usage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>deepen_relative</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>deepen_relative</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Negative depth in --deepen is not supported"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--deepen and --depth are mutually exclusive"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>depth</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>deepen_relative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>unshallow</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>depth</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--depth and --unshallow cannot be used together"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_repository_shallow</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--unshallow on a complete repository does not make sense"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>depth</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>INFINITE_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&amp;&amp;</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"depth %s is not a positive number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>||</operator> <name>deepen_since</name> <operator>||</operator> <name><name>deepen_not</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>deepen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter_options</name><operator>.</operator><name>choice</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>has_promisor_remote</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"--filter can only be used when extensions.partialClone is set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>all</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fetch --all does not take a repository argument"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fetch --all does not make sense with refspecs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>for_each_remote</name><argument_list>(<argument><expr><name>get_one_remote_for_fetch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>remote</name> <operator>=</operator> <call><name>remote_get</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>multiple</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_remote_or_group</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No such remote or remote group: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>add_remote_or_group</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>.</operator><name>nr</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Fetching a group and specifying refspecs does not make sense"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>remote</name> <operator>=</operator> <call><name>remote_get</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prune_tags_ok</name> <operator>=</operator> <operator>(</operator><name>argc</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>remote</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>filter_options</name><operator>.</operator><name>choice</name></name> <operator>||</operator> <call><name>has_promisor_remote</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fetch_one_setup_partial</name><argument_list>(<argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>fetch_one</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prune_tags_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>max_children</name> <init>= <expr><name>max_jobs</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter_options</name><operator>.</operator><name>choice</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--filter can only be used with the remote "</literal>

<literal type="string">"configured in extensions.partialclone"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_children</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>max_children</name> <operator>=</operator> <name>fetch_parallel_config</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>fetch_multiple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><name>max_children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>recurse_submodules</name> <operator>!=</operator> <name>RECURSE_SUBMODULES_OFF</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>options</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_children</name> <init>= <expr><name>max_jobs</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>max_children</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>max_children</name> <operator>=</operator> <name>submodule_fetch_jobs_config</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_children</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>max_children</name> <operator>=</operator> <name>fetch_parallel_config</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_options_to_argv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>fetch_populated_submodules</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>,

<argument><expr><name>submodule_prefix</name></expr></argument>,

<argument><expr><name>recurse_submodules</name></expr></argument>,

<argument><expr><name>recurse_submodules_default</name></expr></argument>,

<argument><expr><name>verbosity</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>,

<argument><expr><name>max_children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>prepare_repo_settings</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fetch_write_commit_graph</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>

<operator>(</operator><name>fetch_write_commit_graph</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<name><name>the_repository</name><operator>-&gt;</operator><name>settings</name><operator>.</operator><name>fetch_write_commit_graph</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>commit_graph_flags</name> <init>= <expr><name>COMMIT_GRAPH_WRITE_SPLIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>commit_graph_flags</name> <operator>|=</operator> <name>COMMIT_GRAPH_WRITE_PROGRESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>write_commit_graph_reachable</name><argument_list>(<argument><expr><name><name>the_repository</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>odb</name></name></expr></argument>,

<argument><expr><name>commit_graph_flags</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>close_object_store</name><argument_list>(<argument><expr><name><name>the_repository</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enable_auto_gc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>argv_array_pushl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv_gc_auto</name></expr></argument>, <argument><expr><literal type="string">"gc"</literal></expr></argument>, <argument><expr><literal type="string">"--auto"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv_gc_auto</name></expr></argument>, <argument><expr><literal type="string">"--quiet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>run_command_v_opt</name><argument_list>(<argument><expr><name><name>argv_gc_auto</name><operator>.</operator><name>argv</name></name></expr></argument>, <argument><expr><name>RUN_GIT_CMD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv_gc_auto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

</unit>
