<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\ref-filter.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parse-options.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wildmatch.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"color.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quote.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ref-filter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revision.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"git-compat-util.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trailer.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wt-status.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-slab.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-graph.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"worktree.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hashmap.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"argv-array.h"</cpp:file></cpp:include>

<struct><specifier>static</specifier> struct <name>ref_msg</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gone</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ahead</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>behind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ahead_behind</name></decl>;</decl_stmt>

}</block> <decl><name>msgs</name> <init>= <expr><block>{

<expr><literal type="string">"gone"</literal></expr>,

<expr><literal type="string">"ahead %d"</literal></expr>,

<expr><literal type="string">"behind %d"</literal></expr>,

<expr><literal type="string">"ahead %d, behind %d"</literal></expr>

}</block></expr></init></decl>;</struct>

<function><type><name>void</name></type> <name>setup_ref_filter_porcelain_msg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>msgs</name><operator>.</operator><name>gone</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"gone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>msgs</name><operator>.</operator><name>ahead</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"ahead %d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>msgs</name><operator>.</operator><name>behind</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"behind %d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>msgs</name><operator>.</operator><name>ahead_behind</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"ahead %d, behind %d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{ <decl><name>FIELD_STR</name></decl>, <decl><name>FIELD_ULONG</name></decl>, <decl><name>FIELD_TIME</name></decl> }</block></enum></type> <name>cmp_type</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{ <decl><name>COMPARE_EQUAL</name></decl>, <decl><name>COMPARE_UNEQUAL</name></decl>, <decl><name>COMPARE_NONE</name></decl> }</block></enum></type> <name>cmp_status</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{ <decl><name>SOURCE_NONE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>SOURCE_OBJ</name></decl>, <decl><name>SOURCE_OTHER</name></decl> }</block></enum></type> <name>info_source</name>;</typedef>

<struct>struct <name>align</name> <block>{

<decl_stmt><decl><type><name>align_type</name></type> <name>position</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>width</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>if_then_else</name> <block>{

<decl_stmt><decl><type><name>cmp_status</name></type> <name>cmp_status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>then_atom_seen</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>,

<decl><type ref="prev"/><name>else_atom_seen</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>,

<decl><type ref="prev"/><name>condition_satisfied</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>refname_atom</name> <block>{

<enum>enum <block>{ <decl><name>R_NORMAL</name></decl>, <decl><name>R_SHORT</name></decl>, <decl><name>R_LSTRIP</name></decl>, <decl><name>R_RSTRIP</name></decl> }</block> <decl><name>option</name></decl>;</enum>

<decl_stmt><decl><type><name>int</name></type> <name>lstrip</name></decl>, <decl><type ref="prev"/><name>rstrip</name></decl>;</decl_stmt>

}</block>;</struct>

<struct><specifier>static</specifier> struct <name>expand_data</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>off_t</name></type> <name>disk_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>delta_base_oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>content</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_info</name></name></type> <name>info</name></decl>;</decl_stmt>

}</block> <decl><name>oi</name></decl>, <decl><type ref="prev"/><name>oi_deref</name></decl>;</struct>

<struct>struct <name>ref_to_worktree_entry</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>ent</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>worktree</name></name> <modifier>*</modifier></type><name>wt</name></decl>;</decl_stmt> 

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ref_to_worktree_map_cmpfnc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_lookupdata</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>kptr</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keydata_aka_refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_to_worktree_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>ref_to_worktree_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>kptr</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>ref_to_worktree_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>wt</name><operator>-&gt;</operator><name>head_ref</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>keydata_aka_refname</name></expr> ?</condition><then> <expr><name>keydata_aka_refname</name></expr> </then><else>: <expr><name><name>k</name><operator>-&gt;</operator><name>wt</name><operator>-&gt;</operator><name>head_ref</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct><specifier>static</specifier> struct <name>ref_to_worktree_map</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name></type> <name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>worktree</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>worktrees</name></decl>;</decl_stmt>

}</block> <decl><name>ref_to_worktree_map</name></decl>;</struct>

<struct><specifier>static</specifier> struct <name>used_atom</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>cmp_type</name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>info_source</name></type> <name>source</name></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><name>char</name></type> <name><name>color</name><index>[<expr><name>COLOR_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>align</name></name></type> <name>align</name></decl>;</decl_stmt>

<struct>struct <block>{

<enum>enum <block>{

<decl><name>RR_REF</name></decl>, <decl><name>RR_TRACK</name></decl>, <decl><name>RR_TRACKSHORT</name></decl>, <decl><name>RR_REMOTE_NAME</name></decl>, <decl><name>RR_REMOTE_REF</name></decl>

}</block> <decl><name>option</name></decl>;</enum>

<decl_stmt><decl><type><name><name>struct</name> <name>refname_atom</name></name></type> <name>refname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nobracket</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>push</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>push_remote</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block> <decl><name>remote_ref</name></decl>;</struct>

<struct>struct <block>{

<enum>enum <block>{ <decl><name>C_BARE</name></decl>, <decl><name>C_BODY</name></decl>, <decl><name>C_BODY_DEP</name></decl>, <decl><name>C_LINES</name></decl>, <decl><name>C_SIG</name></decl>, <decl><name>C_SUB</name></decl>, <decl><name>C_TRAILERS</name></decl> }</block> <decl><name>option</name></decl>;</enum>

<decl_stmt><decl><type><name><name>struct</name> <name>process_trailer_options</name></name></type> <name>trailer_opts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nlines</name></decl>;</decl_stmt>

}</block> <decl><name>contents</name></decl>;</struct>

<struct>struct <block>{

<decl_stmt><decl><type><name>cmp_status</name></type> <name>cmp_status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

}</block> <decl><name>if_then_else</name></decl>;</struct>

<struct>struct <block>{

<enum>enum <block>{ <decl><name>O_FULL</name></decl>, <decl><name>O_LENGTH</name></decl>, <decl><name>O_SHORT</name></decl> }</block> <decl><name>option</name></decl>;</enum>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>length</name></decl>;</decl_stmt>

}</block> <decl><name>objectname</name></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>refname_atom</name></name></type> <name>refname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

}</block> <decl><name>u</name></decl>;</union>

}</block> <decl><modifier>*</modifier><name>used_atom</name></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>used_atom_cnt</name></decl>, <decl><type ref="prev"/><name>need_tagged</name></decl>, <decl><type ref="prev"/><name>need_symref</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>strbuf_addf_ret</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_vaddf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>color_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>color_value</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>color_value</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"expected format: %%(color:&lt;color&gt;)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>color_parse</name><argument_list>(<argument><expr><name>color_value</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>color</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized color: %%(color:%s)"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>color_value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>want_color</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>use_color</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>color_parse</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>color</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>refname_atom_parser_internal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refname_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>R_NORMAL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"short"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>R_SHORT</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"lstrip="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"strip="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>R_LSTRIP</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strtol_i</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>lstrip</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Integer value expected refname:lstrip=%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"rstrip="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <name>R_RSTRIP</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strtol_i</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>rstrip</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Integer value expected refname:rstrip=%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized %%(%s) argument: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>remote_ref_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>params</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>atom</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"push"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>starts_with</name><argument_list>(<argument><expr><name><name>atom</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"push:"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>RR_REF</name></expr>;</expr_stmt>

<return>return <expr><call><name>refname_atom_parser_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>refname</name></name></expr></argument>,

<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>nobracket</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>params</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>params</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"track"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>RR_TRACK</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"trackshort"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>RR_TRACKSHORT</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"nobracket"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>nobracket</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"remotename"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>RR_REMOTE_NAME</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push_remote</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"remoteref"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>RR_REMOTE_REF</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push_remote</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>RR_REF</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>refname_atom_parser_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>refname</name></name></expr></argument>,

<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>objecttype_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%%(objecttype) does not take arguments"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>atom</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi_deref</name><operator>.</operator><name>info</name><operator>.</operator><name>typep</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi_deref</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>info</name><operator>.</operator><name>typep</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>objectsize_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>atom</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi_deref</name><operator>.</operator><name>info</name><operator>.</operator><name>sizep</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi_deref</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>info</name><operator>.</operator><name>sizep</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"disk"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>atom</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi_deref</name><operator>.</operator><name>info</name><operator>.</operator><name>disk_sizep</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi_deref</name><operator>.</operator><name>disk_size</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>info</name><operator>.</operator><name>disk_sizep</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi</name><operator>.</operator><name>disk_size</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized %%(objectsize) argument: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>deltabase_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%%(deltabase) does not take arguments"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>atom</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi_deref</name><operator>.</operator><name>info</name><operator>.</operator><name>delta_base_oid</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi_deref</name><operator>.</operator><name>delta_base_oid</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>info</name><operator>.</operator><name>delta_base_oid</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi</name><operator>.</operator><name>delta_base_oid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>body_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%%(body) does not take arguments"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>C_BODY_DEP</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>subject_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%%(subject) does not take arguments"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>C_SUB</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>trailers_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>params</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>trailer_opts</name><operator>.</operator><name>no_divider</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>params</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>params</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"unfold"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>trailer_opts</name><operator>.</operator><name>unfold</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"only"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>trailer_opts</name><operator>.</operator><name>only_trailers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unknown %%(trailers) argument: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>C_TRAILERS</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>contents_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>C_BARE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"body"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>C_BODY</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"signature"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>C_SIG</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"subject"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>C_SUB</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"trailers"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>trailers_atom_parser</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>arg</name></expr> ?</condition><then> <expr><name>arg</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"lines="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>C_LINES</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strtoul_ui</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>nlines</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"positive value expected contents:lines=%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized %%(contents) argument: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>objectname_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>O_FULL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"short"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>O_SHORT</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"short="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name>O_LENGTH</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strtoul_ui</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call> <operator>||</operator>

<name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"positive value expected objectname:short=%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name>MINIMUM_ABBREV</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>MINIMUM_ABBREV</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized %%(objectname) argument: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>refname_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>refname_atom_parser_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>refname</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>align_type</name></type> <name>parse_align_position</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"right"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ALIGN_RIGHT</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"middle"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ALIGN_MIDDLE</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"left"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ALIGN_LEFT</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>align_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>align</name></name> <modifier>*</modifier></type><name>align</name> <init>= <expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>align</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>params</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>width</name> <init>= <expr><operator>~</operator><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"expected format: %%(align:&lt;width&gt;,&lt;position&gt;)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>align</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name>ALIGN_LEFT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>params</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>params</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>position</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"position="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>position</name> <operator>=</operator> <call><name>parse_align_position</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>position</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized position:%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>align</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name>position</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"width="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strtoul_ui</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized width:%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strtoul_ui</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>position</name> <operator>=</operator> <call><name>parse_align_position</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>align</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name>position</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized %%(align) argument: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>width</name> <operator>==</operator> <operator>~</operator><literal type="number">0U</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"positive width expected with the %%(align) atom"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>align</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>if_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>if_then_else</name><operator>.</operator><name>cmp_status</name></name> <operator>=</operator> <name>COMPARE_NONE</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"equals="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>if_then_else</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>if_then_else</name><operator>.</operator><name>cmp_status</name></name> <operator>=</operator> <name>COMPARE_EQUAL</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"notequals="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>if_then_else</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>if_then_else</name><operator>.</operator><name>cmp_status</name></name> <operator>=</operator> <name>COMPARE_UNEQUAL</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized %%(if) argument: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>head_atom_parser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>unused_err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>head</name></name> <operator>=</operator> <call><name>resolve_refdup</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><name>RESOLVE_REF_READING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>info_source</name></type> <name>source</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>cmp_type</name></type> <name>cmp_type</name></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>parser</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>

}</block> <decl><name><name>valid_atom</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><literal type="string">"refname"</literal></expr>, <expr><name>SOURCE_NONE</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>refname_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"objecttype"</literal></expr>, <expr><name>SOURCE_OTHER</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>objecttype_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"objectsize"</literal></expr>, <expr><name>SOURCE_OTHER</name></expr>, <expr><name>FIELD_ULONG</name></expr>, <expr><name>objectsize_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"objectname"</literal></expr>, <expr><name>SOURCE_OTHER</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>objectname_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"deltabase"</literal></expr>, <expr><name>SOURCE_OTHER</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>deltabase_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"tree"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"parent"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"numparent"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_ULONG</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"object"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"type"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"tag"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"author"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"authorname"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"authoremail"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"authordate"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_TIME</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"committer"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"committername"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"committeremail"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"committerdate"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_TIME</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"tagger"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"taggername"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"taggeremail"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"taggerdate"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_TIME</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"creator"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"creatordate"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_TIME</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"subject"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>subject_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"body"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>body_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"trailers"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>trailers_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"contents"</literal></expr>, <expr><name>SOURCE_OBJ</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>contents_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"upstream"</literal></expr>, <expr><name>SOURCE_NONE</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>remote_ref_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"push"</literal></expr>, <expr><name>SOURCE_NONE</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>remote_ref_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"symref"</literal></expr>, <expr><name>SOURCE_NONE</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>refname_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"flag"</literal></expr>, <expr><name>SOURCE_NONE</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"HEAD"</literal></expr>, <expr><name>SOURCE_NONE</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>head_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"color"</literal></expr>, <expr><name>SOURCE_NONE</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>color_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"worktreepath"</literal></expr>, <expr><name>SOURCE_NONE</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"align"</literal></expr>, <expr><name>SOURCE_NONE</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>align_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"end"</literal></expr>, <expr><name>SOURCE_NONE</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"if"</literal></expr>, <expr><name>SOURCE_NONE</name></expr>, <expr><name>FIELD_STR</name></expr>, <expr><name>if_atom_parser</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"then"</literal></expr>, <expr><name>SOURCE_NONE</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"else"</literal></expr>, <expr><name>SOURCE_NONE</name></expr> }</block></expr>,

}</block></expr></init></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REF_FORMATTING_STATE_INIT</name></cpp:macro> <cpp:value>{ 0, NULL }</cpp:value></cpp:define>

<struct>struct <name>ref_formatting_stack</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>output</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>at_end</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>at_end_data</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>ref_formatting_state</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>quote_style</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>atom_value</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>handler</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>atomv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>uintmax_t</name></type> <name>value</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_ref_filter_atom</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>atom</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>at</name></decl>, <decl><type ref="prev"/><name>atom_len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>atom</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name>sp</name> <operator>&lt;</operator> <name>ep</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>ep</name> <operator>&lt;=</operator> <name>sp</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"malformed field name: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ep</name><operator>-</operator><name>atom</name><operator>)</operator></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>ep</name> <operator>-</operator> <name>atom</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>, <argument><expr><name>ep</name> <operator>-</operator> <name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>atom_len</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>arg</name></expr> ?</condition><then> <expr><name>arg</name></expr> </then><else>: <expr><name>ep</name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name>sp</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>valid_atom</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>valid_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>atom_len</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>valid_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>valid_atom</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unknown field name: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ep</name><operator>-</operator><name>atom</name><operator>)</operator></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>valid_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>source</name> <operator>!=</operator> <name>SOURCE_NONE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>have_git_dir</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"not a git repository, but the field '%.*s' requires access to object data"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ep</name><operator>-</operator><name>atom</name><operator>)</operator></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>at</name> <operator>=</operator> <name>used_atom_cnt</name></expr>;</expr_stmt>

<expr_stmt><expr><name>used_atom_cnt</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REALLOC_ARRAY</name><argument_list>(<argument><expr><name>used_atom</name></expr></argument>, <argument><expr><name>used_atom_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>ep</name> <operator>-</operator> <name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name><name>valid_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cmp_type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name><operator>.</operator><name>source</name> <operator>=</operator> <name><name>valid_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>source</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name><operator>.</operator><name>source</name> <operator>==</operator> <name>SOURCE_OBJ</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>atom</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi_deref</name><operator>.</operator><name>info</name><operator>.</operator><name>contentp</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi_deref</name><operator>.</operator><name>content</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>info</name><operator>.</operator><name>contentp</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi</name><operator>.</operator><name>content</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>+</operator> <operator>(</operator><name>arg</name> <operator>-</operator> <name>atom</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name><operator>.</operator><name>u</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name><operator>.</operator><name>u</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>valid_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parser</name> <operator>&amp;&amp;</operator> <name><name>valid_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>parser</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>atom</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>need_tagged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>valid_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"symref"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>need_symref</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>at</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>quote_formatting</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quote_style</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>quote_style</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>QUOTE_NONE</name></expr>:</case>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>QUOTE_SHELL</name></expr>:</case>

<expr_stmt><expr><call><name>sq_quote_buf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>QUOTE_PERL</name></expr>:</case>

<expr_stmt><expr><call><name>perl_quote_buf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>QUOTE_PYTHON</name></expr>:</case>

<expr_stmt><expr><call><name>python_quote_buf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>QUOTE_TCL</name></expr>:</case>

<expr_stmt><expr><call><name>tcl_quote_buf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>append_atom</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>unused_err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>quote_formatting</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>quote_style</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>push_stack_element</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ref_formatting_stack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>*</operator><name>stack</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>stack</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pop_stack_element</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>current</name> <init>= <expr><operator>*</operator><name>stack</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prev</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>stack</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>end_align_handler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>*</operator><name>stack</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>align</name></name> <modifier>*</modifier></type><name>align</name> <init>= <expr><operator>(</operator>struct <name>align</name> <operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>at_end_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>s</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_utf8_align</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>align</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><name><name>align</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>output</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_swap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>align_atom_handler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>atomv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>unused_err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>new_stack</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>push_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>new_stack</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_stack</name><operator>-&gt;</operator><name>at_end</name></name> <operator>=</operator> <name>end_align_handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_stack</name><operator>-&gt;</operator><name>at_end_data</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>atomv</name><operator>-&gt;</operator><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>align</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>if_then_else_handler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>*</operator><name>stack</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>cur</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>if_then_else</name></name> <modifier>*</modifier></type><name>if_then_else</name> <init>= <expr><operator>(</operator>struct <name>if_then_else</name> <operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>at_end_data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>if_then_else</name><operator>-&gt;</operator><name>then_atom_seen</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(if) atom used without a %%(then) atom"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>if_then_else</name><operator>-&gt;</operator><name>else_atom_seen</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>if_then_else</name><operator>-&gt;</operator><name>condition_satisfied</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pop_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_swap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prev</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pop_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>if_then_else</name><operator>-&gt;</operator><name>condition_satisfied</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>stack</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>if_then_else</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>if_atom_handler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>atomv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>unused_err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>new_stack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>if_then_else</name></name> <modifier>*</modifier></type><name>if_then_else</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>if_then_else</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <name><name>atomv</name><operator>-&gt;</operator><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>if_then_else</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>cmp_status</name></name> <operator>=</operator> <name><name>atomv</name><operator>-&gt;</operator><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>if_then_else</name><operator>.</operator><name>cmp_status</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>push_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>new_stack</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_stack</name><operator>-&gt;</operator><name>at_end</name></name> <operator>=</operator> <name>if_then_else_handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_stack</name><operator>-&gt;</operator><name>at_end_data</name></name> <operator>=</operator> <name>if_then_else</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_empty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>then_atom_handler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>atomv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>if_then_else</name></name> <modifier>*</modifier></type><name>if_then_else</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>at_end</name></name> <operator>==</operator> <name>if_then_else_handler</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>if_then_else</name> <operator>=</operator> <operator>(</operator>struct <name>if_then_else</name> <operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>at_end_data</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>if_then_else</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(then) atom used without an %%(if) atom"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>if_then_else</name><operator>-&gt;</operator><name>then_atom_seen</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(then) atom used more than once"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>if_then_else</name><operator>-&gt;</operator><name>else_atom_seen</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(then) atom used after %%(else)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>then_atom_seen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>if_then_else</name><operator>-&gt;</operator><name>cmp_status</name></name> <operator>==</operator> <name>COMPARE_EQUAL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>output</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>condition_satisfied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>if_then_else</name><operator>-&gt;</operator><name>cmp_status</name></name> <operator>==</operator> <name>COMPARE_UNEQUAL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>output</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>condition_satisfied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>output</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_empty</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>output</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>condition_satisfied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>else_atom_handler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>atomv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>if_then_else</name></name> <modifier>*</modifier></type><name>if_then_else</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>at_end</name></name> <operator>==</operator> <name>if_then_else_handler</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>if_then_else</name> <operator>=</operator> <operator>(</operator>struct <name>if_then_else</name> <operator>*</operator><operator>)</operator><name><name>prev</name><operator>-&gt;</operator><name>at_end_data</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>if_then_else</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(else) atom used without an %%(if) atom"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>if_then_else</name><operator>-&gt;</operator><name>then_atom_seen</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(else) atom used without a %%(then) atom"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>if_then_else</name><operator>-&gt;</operator><name>else_atom_seen</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(else) atom used more than once"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>if_then_else</name><operator>-&gt;</operator><name>else_atom_seen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>push_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>at_end_data</name></name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>at_end_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>at_end</name></name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>at_end</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>end_atom_handler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>atomv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_stack</name></name> <modifier>*</modifier></type><name>current</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>s</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>current</name><operator>-&gt;</operator><name>at_end</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(end) atom used without corresponding atom"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>current</name><operator>-&gt;</operator><name>at_end</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>current</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>quote_formatting</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>output</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>quote_style</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_swap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pop_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>find_next</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>cp</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>verify_ref_format</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>format</name><operator>-&gt;</operator><name>need_color_reset_at_eol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name><name>format</name><operator>-&gt;</operator><name>format</name></name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sp</name> <operator>=</operator> <call><name>find_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>color</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ep</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>at</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ep</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"malformed format string %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>at</name> <operator>=</operator> <call><name>parse_ref_filter_atom</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>sp</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>at</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>ep</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>used_atom</name><index>[<expr><name>at</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"color:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>color</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>format</name><operator>-&gt;</operator><name>need_color_reset_at_eol</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>color</name></expr></argument>, <argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>format</name><operator>-&gt;</operator><name>need_color_reset_at_eol</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>want_color</name><argument_list>(<argument><expr><name><name>format</name><operator>-&gt;</operator><name>use_color</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>format</name><operator>-&gt;</operator><name>need_color_reset_at_eol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grab_objectname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"objectname"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>O_SHORT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>find_unique_abbrev</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>O_FULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>O_LENGTH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>find_unique_abbrev</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>objectname</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unknown %%(objectname) option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>grab_common_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deref</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>expand_data</name></name> <modifier>*</modifier></type><name>oi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>deref</name> <operator>!=</operator> <operator>(</operator><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"objecttype"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>oi</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"objectsize:disk"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>oi</name><operator>-&gt;</operator><name>disk_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%"</literal><name>PRIuMAX</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>oi</name><operator>-&gt;</operator><name>disk_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"objectsize"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>oi</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%"</literal><name>PRIuMAX</name></expr></argument> , <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>oi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"deltabase"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>delta_base_oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>deref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>grab_objectname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>grab_tag_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deref</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><operator>(</operator>struct <name>tag</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>deref</name> <operator>!=</operator> <operator>(</operator><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"tag"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>tag</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>tag</name><operator>-&gt;</operator><name>tagged</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>tag</name><operator>-&gt;</operator><name>tagged</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>tag</name><operator>-&gt;</operator><name>tagged</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>tagged</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>grab_commit_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deref</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>deref</name> <operator>!=</operator> <operator>(</operator><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"tree"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"numparent"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>commit_list_count</name><argument_list>(<argument><expr><name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%lu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>v</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"parent"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>s</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>parents</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>parents</name></expr>;</condition> <incr><expr><name>parents</name> <operator>=</operator> <name><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>parents</name> <operator>!=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>find_wholine</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>who</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wholen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>who</name></expr></argument>, <argument><expr><name>wholen</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>buf</name><index>[<expr><name>wholen</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>buf</name> <operator>+</operator> <name>wholen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>eol</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>eol</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>eol</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="string">""</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>copy_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><call><name>strchrnul</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>eol</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>copy_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" &lt;"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cp</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>copy_email</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>email</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eoemail</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>email</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>eoemail</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>email</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eoemail</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>email</name></expr></argument>, <argument><expr><name>eoemail</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>email</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>copy_subject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>grab_date</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>atomname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eoemail</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&gt; "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zone</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>timestamp_t</name></type> <name>timestamp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>tz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>date_mode</name></name></type> <name>date_mode</name> <init>= <expr><block>{ <expr><name>DATE_NORMAL</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>formatp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>formatp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>atomname</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>formatp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>formatp</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>parse_date_format</name><argument_list>(<argument><expr><name>formatp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>date_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eoemail</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>parse_timestamp</name><argument_list>(<argument><expr><name>eoemail</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zone</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>==</operator> <name>TIME_MAX</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>zone</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tz</name> <operator>==</operator> <name>LONG_MIN</name> <operator>||</operator> <name>tz</name> <operator>==</operator> <name>LONG_MAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><call><name>show_date</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>date_mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>

<return>return;</return>

<label><name>bad</name>:</label>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>grab_person</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>who</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deref</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wholen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>who</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wholine</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>deref</name> <operator>!=</operator> <operator>(</operator><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>who</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>wholen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>wholen</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>wholen</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>wholen</name></expr></argument>, <argument><expr><literal type="string">"email"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>wholen</name></expr></argument>, <argument><expr><literal type="string">"date"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wholine</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wholine</name> <operator>=</operator> <call><name>find_wholine</name><argument_list>(<argument><expr><name>who</name></expr></argument>, <argument><expr><name>wholen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wholine</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>wholen</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>copy_line</name><argument_list>(<argument><expr><name>wholine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>wholen</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>copy_name</name><argument_list>(<argument><expr><name>wholine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>wholen</name></expr></argument>, <argument><expr><literal type="string">"email"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>copy_email</name><argument_list>(<argument><expr><name>wholine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>wholen</name></expr></argument>, <argument><expr><literal type="string">"date"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>grab_date</name><argument_list>(<argument><expr><name>wholine</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>who</name></expr></argument>, <argument><expr><literal type="string">"tagger"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>who</name></expr></argument>, <argument><expr><literal type="string">"committer"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wholine</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wholine</name> <operator>=</operator> <call><name>find_wholine</name><argument_list>(<argument><expr><name>who</name></expr></argument>, <argument><expr><name>wholen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wholine</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>deref</name> <operator>!=</operator> <operator>(</operator><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"creatordate"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>grab_date</name><argument_list>(<argument><expr><name>wholine</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"creator"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>copy_line</name><argument_list>(<argument><expr><name>wholine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_subpos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sub</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>sublen</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>body</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>bodylen</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>nonsiglen</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sig</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>siglen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>buf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>buf</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>eol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>eol</name></expr>;</expr_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><operator>*</operator><name>buf</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>buf</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><operator>*</operator><name>sig</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>parse_signature</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>siglen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>sub</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>buf</name> <operator>&lt;</operator> <operator>*</operator><name>sig</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>buf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>buf</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>eol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>eol</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>sublen</name> <operator>=</operator> <name>buf</name> <operator>-</operator> <operator>*</operator><name>sub</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sublen</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>sub</name><operator>)</operator><index>[<expr><operator>*</operator><name>sublen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>sublen</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>buf</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>buf</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><operator>*</operator><name>body</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>bodylen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nonsiglen</name> <operator>=</operator> <operator>*</operator><name>sig</name> <operator>-</operator> <name>buf</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>append_lines</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lines</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lines</name> <operator>&amp;&amp;</operator> <name>sp</name> <operator>&lt;</operator> <name>buf</name> <operator>+</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <operator>(</operator><name>sp</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>eol</name></expr> ?</condition><then> <expr><name>eol</name> <operator>-</operator> <name>sp</name></expr> </then><else>: <expr><name>size</name> <operator>-</operator> <operator>(</operator><name>sp</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>grab_sub_body_contents</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deref</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subpos</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bodypos</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sigpos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>sublen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bodylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nonsiglen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>siglen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name> <init>= <expr><operator>&amp;</operator><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>atom</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>deref</name> <operator>!=</operator> <operator>(</operator><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"subject"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"body"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"trailers"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"contents"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subpos</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>find_subpos</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>subpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublen</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>bodypos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bodylen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nonsiglen</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>sigpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>siglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>C_SUB</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>copy_subject</name><argument_list>(<argument><expr><name>subpos</name></expr></argument>, <argument><expr><name>sublen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>C_BODY_DEP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>bodypos</name></expr></argument>, <argument><expr><name>bodylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>C_BODY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>bodypos</name></expr></argument>, <argument><expr><name>nonsiglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>C_SIG</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>sigpos</name></expr></argument>, <argument><expr><name>siglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>C_LINES</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>s</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contents_end</name> <init>= <expr><name>bodylen</name> <operator>+</operator> <name>bodypos</name> <operator>-</operator> <name>siglen</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>append_lines</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>subpos</name></expr></argument>, <argument><expr><name>contents_end</name> <operator>-</operator> <name>subpos</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>nlines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>C_TRAILERS</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>s</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>format_trailers_from_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>subpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>trailer_opts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>contents</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>C_BARE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>subpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_missing_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>grab_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deref</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>OBJ_TAG</name></expr>:</case>

<expr_stmt><expr><call><name>grab_tag_values</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grab_sub_body_contents</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grab_person</name><argument_list>(<argument><expr><literal type="string">"tagger"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>OBJ_COMMIT</name></expr>:</case>

<expr_stmt><expr><call><name>grab_commit_values</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grab_sub_body_contents</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grab_person</name><argument_list>(<argument><expr><literal type="string">"author"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grab_person</name><argument_list>(<argument><expr><literal type="string">"committer"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>OBJ_TREE</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>OBJ_BLOB</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Eh? Object of type %d?"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type><name>copy_advance</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>src</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>dst</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>src</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><name>dst</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lstrip_ref_components</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>remaining</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>to_free</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>refname</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><ternary><condition><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr> ?</condition><then> <expr><name>i</name><operator>++</operator></expr> </then><else>: <expr><operator>*</operator><name>p</name><operator>++</operator></expr></else></ternary></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name>remaining</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>start</name><operator>++</operator></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'/'</literal></expr>:</case>

<expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>start</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rstrip_ref_components</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>remaining</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>to_free</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>refname</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><ternary><condition><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr> ?</condition><then> <expr><name>i</name><operator>++</operator></expr> </then><else>: <expr><operator>*</operator><name>p</name><operator>++</operator></expr></else></ternary></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name>remaining</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>remaining</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>start</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_ref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refname_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>option</name></name> <operator>==</operator> <name>R_SHORT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>shorten_unambiguous_ref</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>warn_ambiguous_refs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>option</name></name> <operator>==</operator> <name>R_LSTRIP</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>lstrip_ref_components</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>lstrip</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>option</name></name> <operator>==</operator> <name>R_RSTRIP</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rstrip_ref_components</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>rstrip</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_remote_ref_details</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>num_ours</name></decl>, <decl><type ref="prev"/><name>num_theirs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>RR_REF</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>show_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>refname</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>RR_TRACK</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>stat_tracking_info</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_ours</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_theirs</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push</name></name></expr></argument>,

<argument><expr><name>AHEAD_BEHIND_FULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>msgs</name><operator>.</operator><name>gone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>num_ours</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>num_theirs</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>num_ours</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><name><name>msgs</name><operator>.</operator><name>behind</name></name></expr></argument>, <argument><expr><name>num_theirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>num_theirs</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><name><name>msgs</name><operator>.</operator><name>ahead</name></name></expr></argument>, <argument><expr><name>num_ours</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><name><name>msgs</name><operator>.</operator><name>ahead_behind</name></name></expr></argument>,

<argument><expr><name>num_ours</name></expr></argument>, <argument><expr><name>num_theirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>nobracket</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>to_free</name> <init>= <expr><operator>*</operator><name>s</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"[%s]"</literal></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>RR_TRACKSHORT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>stat_tracking_info</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_ours</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_theirs</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push</name></name></expr></argument>,

<argument><expr><name>AHEAD_BEHIND_FULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num_ours</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>num_theirs</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>num_ours</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>num_theirs</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>RR_REMOTE_NAME</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>explicit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote</name> <init>= <expr><ternary><condition><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push</name></name></expr> ?</condition><then>

<expr><call><name>pushremote_for_branch</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>explicit</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>remote_for_branch</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>explicit</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><ternary><condition><expr><name>explicit</name></expr> ?</condition><then> <expr><name>remote</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>option</name></name> <operator>==</operator> <name>RR_REMOTE_REF</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>merge</name></decl>;</decl_stmt>

<expr_stmt><expr><name>merge</name> <operator>=</operator> <call><name>remote_ref_for_branch</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><ternary><condition><expr><name>merge</name></expr> ?</condition><then> <expr><name>merge</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unhandled RR_* enum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>get_head_description</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>desc</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>wt_status_state</name></name></type> <name>state</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>wt_status_get_state</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>rebase_in_progress</name></name> <operator>||</operator>

<name><name>state</name><operator>.</operator><name>rebase_interactive_in_progress</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>branch</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no branch, rebasing %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>state</name><operator>.</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no branch, rebasing detached HEAD %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>state</name><operator>.</operator><name>detached_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>bisect_in_progress</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no branch, bisect started on %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>state</name><operator>.</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>detached_from</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>detached_at</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><name>HEAD_DETACHED_AT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><name>HEAD_DETACHED_FROM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>detached_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no branch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>onto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>detached_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_symref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>show_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_refname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>kind</name></name> <operator>&amp;</operator> <name>FILTER_REFS_DETACHED_HEAD</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>get_head_description</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>show_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deref</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>obj</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>expand_data</name></name> <modifier>*</modifier></type><name>oi</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>eaten</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>oi</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>contentp</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>oi</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>sizep</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>oi</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>typep</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oid_object_info_extended</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>info</name></name></expr></argument>,

<argument><expr><name>OBJECT_INFO_LOOKUP_REPLACE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"missing object %s for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>oi</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>disk_sizep</name></name> <operator>&amp;&amp;</operator> <name><name>oi</name><operator>-&gt;</operator><name>disk_size</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"Object size is less than zero."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>oi</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>contentp</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>obj</name> <operator>=</operator> <call><name>parse_object_buffer</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>oi</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>oi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>oi</name><operator>-&gt;</operator><name>content</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eaten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>obj</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eaten</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>oi</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"parse_object_buffer failed on %s for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oi</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>grab_values</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><operator>*</operator><name>obj</name></expr></argument>, <argument><expr><name><name>oi</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>grab_common_values</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>deref</name></expr></argument>, <argument><expr><name>oi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eaten</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>oi</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>populate_worktree_map</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>worktree</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>worktrees</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>worktrees</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>worktrees</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>head_ref</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_to_worktree_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>wt</name></name> <operator>=</operator> <name><name>worktrees</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>,

<argument><expr><call><name>strhash</name><argument_list>(<argument><expr><name><name>worktrees</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>head_ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_add</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>lazy_init_worktree_map</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ref_to_worktree_map</name><operator>.</operator><name>worktrees</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ref_to_worktree_map</name><operator>.</operator><name>worktrees</name></name> <operator>=</operator> <call><name>get_worktrees</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ref_to_worktree_map</name><operator>.</operator><name>map</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ref_to_worktree_map_cmpfnc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>populate_worktree_map</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ref_to_worktree_map</name><operator>.</operator><name>map</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>ref_to_worktree_map</name><operator>.</operator><name>worktrees</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_worktree_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>entry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_to_worktree_entry</name></name> <modifier>*</modifier></type><name>lookup_result</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lazy_init_worktree_map</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><call><name>strhash</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>hashmap_get</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ref_to_worktree_map</name><operator>.</operator><name>map</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lookup_result</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>struct <name>ref_to_worktree_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name><name>lookup_result</name><operator>-&gt;</operator><name>wt</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>populate_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_info</name></name></type> <name>empty</name> <init>= <expr><name>OBJECT_INFO_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>used_atom_cnt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>atom_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_symref</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ref</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;</operator> <name>REF_ISSYMREF</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name> <operator>=</operator> <call><name>resolve_refdup</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name>RESOLVE_REF_READING</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>used_atom</name></name> <modifier>*</modifier></type><name>atom</name> <init>= <expr><operator>&amp;</operator><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>value</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>deref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>handler</name></name> <operator>=</operator> <name>append_atom</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>atom</name></name> <operator>=</operator> <name>atom</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>deref</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"refname"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>refname</name> <operator>=</operator> <call><name>get_refname</name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"worktreepath"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_BRANCHES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>get_worktree_path</name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"symref"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>refname</name> <operator>=</operator> <call><name>get_symref</name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"upstream"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch_name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>,

<argument><expr><operator>&amp;</operator><name>branch_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>branch</name> <operator>=</operator> <call><name>branch_get</name><argument_list>(<argument><expr><name>branch_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>refname</name> <operator>=</operator> <call><name>branch_get_upstream</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>refname</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fill_remote_ref_details</name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch_name</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>,

<argument><expr><operator>&amp;</operator><name>branch_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>branch</name> <operator>=</operator> <call><name>branch_get</name><argument_list>(<argument><expr><name>branch_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>remote_ref</name><operator>.</operator><name>push_remote</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>refname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>refname</name> <operator>=</operator> <call><name>branch_get_push</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>refname</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>v</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_remote_ref_details</name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"color:"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>color</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cp</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;</operator> <name>REF_ISSYMREF</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>copy_advance</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">",symref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;</operator> <name>REF_ISPACKED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>copy_advance</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">",packed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name>buf</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>deref</name> <operator>&amp;&amp;</operator> <call><name>grab_objectname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>objectname</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>head</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"align"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>handler</name></name> <operator>=</operator> <name>align_atom_handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"end"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>handler</name></name> <operator>=</operator> <name>end_atom_handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"if"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"if:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>handler</name></name> <operator>=</operator> <name>if_atom_handler</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"then"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>handler</name></name> <operator>=</operator> <name>then_atom_handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>handler</name></name> <operator>=</operator> <name>else_atom_handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>deref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%s^{}"</literal></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>value</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>s</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>source</name> <operator>==</operator> <name>SOURCE_NONE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"missing object %s for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>objectname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>need_tagged</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>info</name><operator>.</operator><name>contentp</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>oi</name><operator>.</operator><name>content</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oi</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>empty</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oi_deref</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>empty</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>objectname</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_object</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oi</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_tagged</name> <operator>||</operator> <operator>(</operator><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_TAG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>oi_deref</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <operator>*</operator><call><name>get_tagged_oid</name><argument_list>(<argument><expr><operator>(</operator>struct <name>tag</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>get_object</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oi_deref</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_ref_atom_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>atom</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>populate_value</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fill_missing_values</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>value</name><index>[<expr><name>atom</name></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>patterns</name> <init>= <expr><name><name>filter</name><operator>-&gt;</operator><name>name_patterns</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WM_CASEFOLD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>refname</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>refname</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"refs/remotes/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>refname</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"refs/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>refname</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>patterns</name></expr>;</condition> <incr><expr><name>patterns</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>wildmatch</name><argument_list>(<argument><expr><operator>*</operator><name>patterns</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_name_as_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pattern</name> <init>= <expr><name><name>filter</name><operator>-&gt;</operator><name>name_patterns</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><name>WM_PATHNAME</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WM_CASEFOLD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>pattern</name></expr>;</condition> <incr><expr><name>pattern</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pattern</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>plen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>plen</name> <operator>&lt;=</operator> <name>namelen</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>refname</name><index>[<expr><name>plen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator>

<name><name>refname</name><index>[<expr><name>plen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator>

<name><name>p</name><index>[<expr><name>plen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>wildmatch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_pattern_match</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name><name>filter</name><operator>-&gt;</operator><name>name_patterns</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>match_as_path</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>match_name_as_path</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>match_pattern</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>qsort_strcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>va</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>vb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>va</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>vb</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_longest_prefixes_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>patterns</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>patterns</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name><name>prefix</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name> <operator>||</operator> <call><name>is_glob_special</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>end</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>end</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>end</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>end</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>patterns</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name><name>prefix</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>!=</operator> <name><name>patterns</name><index>[<expr><name>end</name></expr>]</index><index>[<expr><name><name>prefix</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>patterns</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name><name>prefix</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_longest_prefixes_1</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>patterns</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_longest_prefixes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>patterns</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>sorted</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>prefix</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>argv_array_pushv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorted</name></expr></argument>, <argument><expr><name>patterns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name><name>sorted</name><operator>.</operator><name>argv</name></name></expr></argument>, <argument><expr><name><name>sorted</name><operator>.</operator><name>argc</name></name></expr></argument>, <argument><expr><name>qsort_strcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_longest_prefixes_1</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>, <argument><expr><name><name>sorted</name><operator>.</operator><name>argv</name></name></expr></argument>, <argument><expr><name><name>sorted</name><operator>.</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>for_each_fullref_in_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>,

<parameter><decl><type><name>each_ref_fn</name></type> <name>cb</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>broken</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>prefixes</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>filter</name><operator>-&gt;</operator><name>match_as_path</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>for_each_fullref_in</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>cb_data</name></expr></argument>, <argument><expr><name>broken</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>for_each_fullref_in</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>cb_data</name></expr></argument>, <argument><expr><name>broken</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>filter</name><operator>-&gt;</operator><name>name_patterns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>for_each_fullref_in</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>cb_data</name></expr></argument>, <argument><expr><name>broken</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>find_longest_prefixes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixes</name></expr></argument>, <argument><expr><name><name>filter</name><operator>-&gt;</operator><name>name_patterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>for_each_string_list_item</name><argument_list>(<argument>prefix</argument>, <argument>&amp;prefixes</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>for_each_fullref_in</name><argument_list>(<argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>cb_data</name></expr></argument>, <argument><expr><name>broken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>match_points_at</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>oid_array</name></name> <modifier>*</modifier></type><name>points_at</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>tagged_oid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oid_array_lookup</name><argument_list>(<argument><expr><name>points_at</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>oid</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>parse_object</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>obj</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"malformed object at '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>tagged_oid</name> <operator>=</operator> <call><name>get_tagged_oid</name><argument_list>(<argument><expr><operator>(</operator>struct <name>tag</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tagged_oid</name> <operator>&amp;&amp;</operator> <call><name>oid_array_lookup</name><argument_list>(<argument><expr><name>points_at</name></expr></argument>, <argument><expr><name>tagged_oid</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>tagged_oid</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>new_ref_array_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FLEX_ALLOC_STR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>objectname</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ref</name></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref_array_push</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array</name></name> <modifier>*</modifier></type><name>array</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>new_ref_array_item</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>items</name></name></expr></argument>, <argument><expr><name><name>array</name><operator>-&gt;</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>array</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>

<return>return <expr><name>ref</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ref_kind_from_refname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<struct><specifier>static</specifier> struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>kind</name></decl>;</decl_stmt>

}</block> <decl><name><name>ref_kind</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><literal type="string">"refs/heads/"</literal></expr> , <expr><name>FILTER_REFS_BRANCHES</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"refs/remotes/"</literal></expr> , <expr><name>FILTER_REFS_REMOTES</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"refs/tags/"</literal></expr>, <expr><name>FILTER_REFS_TAGS</name></expr>}</block></expr>

}</block></expr></init></decl>;</struct>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FILTER_REFS_DETACHED_HEAD</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>ref_kind</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>ref_kind</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>ref_kind</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>kind</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>FILTER_REFS_OTHERS</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_ref_kind</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_BRANCHES</name> <operator>||</operator>

<name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_REMOTES</name> <operator>||</operator>

<name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_TAGS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>ref_kind_from_refname</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>ref_filter_cbdata</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array</name></name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>contains_cache</name></name></type> <name>contains_cache</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>contains_cache</name></name></type> <name>no_contains_cache</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ref_filter_handler</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_filter_cbdata</name></name> <modifier>*</modifier></type><name>ref_cbdata</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name> <init>= <expr><name><name>ref_cbdata</name><operator>-&gt;</operator><name>filter</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>kind</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>REF_BAD_NAME</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ignoring ref with broken name %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>REF_ISBROKEN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ignoring broken ref %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>filter_ref_kind</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>kind</name> <operator>&amp;</operator> <name><name>filter</name><operator>-&gt;</operator><name>kind</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>filter_pattern_match</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>points_at</name><operator>.</operator><name>nr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>match_points_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>filter</name><operator>-&gt;</operator><name>points_at</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>merge_commit</name></name> <operator>||</operator> <name><name>filter</name><operator>-&gt;</operator><name>with_commit</name></name> <operator>||</operator> <name><name>filter</name><operator>-&gt;</operator><name>no_commit</name></name> <operator>||</operator> <name><name>filter</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>,

<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>with_commit</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>commit_contains</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>filter</name><operator>-&gt;</operator><name>with_commit</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref_cbdata</name><operator>-&gt;</operator><name>contains_cache</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>no_commit</name></name> <operator>&amp;&amp;</operator>

<call><name>commit_contains</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>filter</name><operator>-&gt;</operator><name>no_commit</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref_cbdata</name><operator>-&gt;</operator><name>no_contains_cache</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>ref_array_push</name><argument_list>(<argument><expr><name><name>ref_cbdata</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>commit</name></name> <operator>=</operator> <name>commit</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_array_item</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>item</name><operator>-&gt;</operator><name>symref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>item</name><operator>-&gt;</operator><name>value</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>ref_array_clear</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array</name></name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free_array_item</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>nr</name></name> <operator>=</operator> <name><name>array</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>used_atom_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>used_atom</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name>used_atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>used_atom_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref_to_worktree_map</name><operator>.</operator><name>worktrees</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ref_to_worktree_map</name><operator>.</operator><name>map</name></name><operator>)</operator></expr></argument>,

<argument><expr>struct <name>ref_to_worktree_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_worktrees</name><argument_list>(<argument><expr><name><name>ref_to_worktree_map</name><operator>.</operator><name>worktrees</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref_to_worktree_map</name><operator>.</operator><name>worktrees</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_merge_filter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_filter_cbdata</name></name> <modifier>*</modifier></type><name>ref_cbdata</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name></type> <name>revs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>old_nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name> <init>= <expr><name><name>ref_cbdata</name><operator>-&gt;</operator><name>filter</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array</name></name> <modifier>*</modifier></type><name>array</name> <init>= <expr><name><name>ref_cbdata</name><operator>-&gt;</operator><name>array</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>to_clear</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>commit</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>array</name><operator>-&gt;</operator><name>nr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>repo_init_revisions</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>array</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>add_pending_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_clear</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>commit</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>merge_commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UNINTERESTING</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_pending_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>filter</name><operator>-&gt;</operator><name>merge_commit</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>limited</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prepare_revision_walk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"revision walk setup failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>old_nr</name> <operator>=</operator> <name><name>array</name><operator>-&gt;</operator><name>nr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>array</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>commit</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_merged</name> <init>= <expr><operator>!</operator><operator>!</operator><operator>(</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_merged</name> <operator>==</operator> <operator>(</operator><name><name>filter</name><operator>-&gt;</operator><name>merge</name></name> <operator>==</operator> <name>REF_FILTER_MERGED_INCLUDE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>array</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free_array_item</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>clear_commit_marks_many</name><argument_list>(<argument><expr><name>old_nr</name></expr></argument>, <argument><expr><name>to_clear</name></expr></argument>, <argument><expr><name>ALL_REV_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_commit_marks</name><argument_list>(<argument><expr><name><name>filter</name><operator>-&gt;</operator><name>merge_commit</name></name></expr></argument>, <argument><expr><name>ALL_REV_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>to_clear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>filter_refs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array</name></name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_filter_cbdata</name></name></type> <name>ref_cbdata</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>broken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ref_cbdata</name><operator>.</operator><name>array</name></name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref_cbdata</name><operator>.</operator><name>filter</name></name> <operator>=</operator> <name>filter</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>FILTER_REFS_INCLUDE_BROKEN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>broken</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>type</name> <operator>&amp;</operator> <name>FILTER_REFS_KIND_MASK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_contains_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref_cbdata</name><operator>.</operator><name>contains_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_contains_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref_cbdata</name><operator>.</operator><name>no_contains_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"filter_refs: invalid type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_BRANCHES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>for_each_fullref_in</name><argument_list>(<argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><name>ref_filter_handler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_cbdata</name></expr></argument>, <argument><expr><name>broken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_REMOTES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>for_each_fullref_in</name><argument_list>(<argument><expr><literal type="string">"refs/remotes/"</literal></expr></argument>, <argument><expr><name>ref_filter_handler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_cbdata</name></expr></argument>, <argument><expr><name>broken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_TAGS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>for_each_fullref_in</name><argument_list>(<argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>, <argument><expr><name>ref_filter_handler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_cbdata</name></expr></argument>, <argument><expr><name>broken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>&amp;</operator> <name>FILTER_REFS_ALL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>for_each_fullref_in_pattern</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>ref_filter_handler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_cbdata</name></expr></argument>, <argument><expr><name>broken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>&amp;</operator> <name>FILTER_REFS_DETACHED_HEAD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>head_ref</name><argument_list>(<argument><expr><name>ref_filter_handler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref_cbdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>clear_contains_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref_cbdata</name><operator>.</operator><name>contains_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_contains_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref_cbdata</name><operator>.</operator><name>no_contains_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>merge_commit</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_merge_filter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_cbdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_ref_sorting</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>va</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>cmp_type</name></type> <name>cmp_type</name> <init>= <expr><name><name>used_atom</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>atom</name></name></expr>]</index></name><operator>.</operator><name>type</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp_fn</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_ref_atom_value</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>atom</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>va</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_ref_atom_value</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>atom</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmp_fn</name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ignore_case</name></name></expr> ?</condition><then> <expr><name>strcasecmp</name></expr> </then><else>: <expr><name>strcmp</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>versioncmp</name><argument_list>(<argument><expr><name><name>va</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>vb</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>cmp_type</name> <operator>==</operator> <name>FIELD_STR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>cmp_fn</name><argument_list>(<argument><expr><name><name>va</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>vb</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>va</name><operator>-&gt;</operator><name>value</name></name> <operator>&lt;</operator> <name><name>vb</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>va</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name><name>vb</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>cmp_fn</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>reverse</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>cmp</name></expr> </then><else>: <expr><name>cmp</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_refs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ref_sorting</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>ref_array_item</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>a_</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>ref_array_item</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>b_</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>ref_sorting</name></expr>;</init> <condition><expr><name>s</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>cmp_ref_sorting</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>ref_array_sort</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier></type><name>sorting</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_array</name></name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>QSORT_S</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>items</name></name></expr></argument>, <argument><expr><name><name>array</name><operator>-&gt;</operator><name>nr</name></name></expr></argument>, <argument><expr><name>compare_refs</name></expr></argument>, <argument><expr><name>sorting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>append_literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>output</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>ep</name> <operator>||</operator> <name>cp</name> <operator>&lt;</operator> <name>ep</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><call><name>hex2chr</name><argument_list>(<argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>ch</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cp</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>format_ref_array_item</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>final_buf</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>error_buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_formatting_state</name></name></type> <name>state</name> <init>= <expr><name>REF_FORMATTING_STATE_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>.</operator><name>quote_style</name></name> <operator>=</operator> <name><name>format</name><operator>-&gt;</operator><name>quote_style</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>push_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>.</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name><name>format</name><operator>-&gt;</operator><name>format</name></name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sp</name> <operator>=</operator> <call><name>find_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>cp</name> <operator>=</operator> <name>ep</name> <operator>+</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name> <modifier>*</modifier></type><name>atomv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>sp</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>append_literal</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>parse_ref_filter_atom</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>sp</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ep</name></expr></argument>, <argument><expr><name>error_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>get_ref_atom_value</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>atomv</name></expr></argument>, <argument><expr><name>error_buf</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name><name>atomv</name><operator>-&gt;</operator><name>handler</name></name><argument_list>(<argument><expr><name>atomv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>error_buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pop_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>.</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>cp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_literal</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>format</name><operator>-&gt;</operator><name>need_color_reset_at_eol</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>atom_value</name></name></type> <name>resetv</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>resetv</name><operator>.</operator><name>s</name></name> <operator>=</operator> <name>GIT_COLOR_RESET</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>append_atom</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resetv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>error_buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pop_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>.</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pop_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>.</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strbuf_addf_ret</name><argument_list>(<argument><expr><name>error_buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format: %%(end) atom missing"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><name>final_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>.</operator><name>stack</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pop_stack_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>.</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>show_ref_array_item</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>final_buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>error_buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>format_ref_array_item</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>final_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>error_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>final_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>final_buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>error_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>final_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>pretty_print_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>ref_item</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ref_item</name> <operator>=</operator> <call><name>new_ref_array_item</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref_item</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <call><name>ref_kind_from_refname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>show_ref_array_item</name><argument_list>(<argument><expr><name>ref_item</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_array_item</name><argument_list>(<argument><expr><name>ref_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_sorting_atom</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>atom</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_format</name></name></type> <name>dummy</name> <init>= <expr><name>REF_FORMAT_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>atom</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>parse_ref_filter_atom</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier></type><name>ref_default_sorting</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>cstr_name</name><index>[]</index></name> <init>= <expr><literal type="string">"refname"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier></type><name>sorting</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sorting</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sorting</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sorting</name><operator>-&gt;</operator><name>atom</name></name> <operator>=</operator> <call><name>parse_sorting_atom</name><argument_list>(<argument><expr><name>cstr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>sorting</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>parse_ref_sorting</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>sorting_tail</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>sorting_tail</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>sorting_tail</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>reverse</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"version:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"v:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>atom</name></name> <operator>=</operator> <call><name>parse_sorting_atom</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>parse_opt_ref_sorting</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>parse_ref_sorting</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>parse_opt_merge_filter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>no_merged</name> <init>= <expr><call><name>starts_with</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rf</name><operator>-&gt;</operator><name>merge</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>no_merged</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"option `%s' is incompatible with --merged"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"option `%s' is incompatible with --no-merged"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>merge</name></name> <operator>=</operator> <ternary><condition><expr><name>no_merged</name></expr>

?</condition><then> <expr><name>REF_FILTER_MERGED_OMIT</name></expr>

</then><else>: <expr><name>REF_FILTER_MERGED_INCLUDE</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"malformed object name %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>merge_commit</name></name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rf</name><operator>-&gt;</operator><name>merge_commit</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"option `%s' must point to a commit"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
