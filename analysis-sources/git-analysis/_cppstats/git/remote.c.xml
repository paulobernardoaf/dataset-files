<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\remote.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refspec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revision.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string-list.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mergesort.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"argv-array.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"advice.h"</cpp:file></cpp:include>

<enum>enum <name>map_direction</name> <block>{ <decl><name>FROM_SRC</name></decl>, <decl><name>FROM_DST</name></decl> }</block>;</enum>

<struct>struct <name>counted_string</name> <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>rewrite</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>baselen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>counted_string</name></name> <modifier>*</modifier></type><name>instead_of</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>instead_of_nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>instead_of_alloc</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>rewrites</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rewrite</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rewrite</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rewrite_alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rewrite_nr</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>remote</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>remotes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>remotes_alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>remotes_nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>hashmap</name></name></type> <name>remotes_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>branch</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>branches</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>branches_alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>branches_nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>current_branch</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pushremote_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rewrites</name></name></type> <name>rewrites</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rewrites</name></name></type> <name>rewrites_push</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>valid_remote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><operator>!</operator><operator>!</operator><name><name>remote</name><operator>-&gt;</operator><name>url</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><operator>!</operator><name><name>remote</name><operator>-&gt;</operator><name>foreign_vcs</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias_url</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>url</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rewrites</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>counted_string</name></name> <modifier>*</modifier></type><name>longest</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>longest_i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>longest</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>longest_i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rewrite_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>instead_of_nr</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>instead_of</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>!</operator><name>longest</name> <operator>||</operator>

<name><name>longest</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>instead_of</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>len</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>longest</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>instead_of</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>longest_i</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>longest</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>url</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>longest_i</name></expr>]</index></name><operator>-&gt;</operator><name>base</name></expr></argument>, <argument><expr><name>url</name> <operator>+</operator> <name><name>longest</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_url</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>url</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>remote</name><operator>-&gt;</operator><name>url</name></name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>url_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>url_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>url</name><index>[<expr><name><name>remote</name><operator>-&gt;</operator><name>url_nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>url</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_pushurl</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pushurl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>remote</name><operator>-&gt;</operator><name>pushurl</name></name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>pushurl_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>pushurl_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>pushurl</name><index>[<expr><name><name>remote</name><operator>-&gt;</operator><name>pushurl_nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pushurl</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_pushurl_alias</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>url</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pushurl</name> <init>= <expr><call><name>alias_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rewrites_push</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pushurl</name> <operator>!=</operator> <name>url</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_pushurl</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>pushurl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_url_alias</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>url</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>add_url</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><call><name>alias_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rewrites</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_pushurl_alias</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>remotes_hash_key</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>remotes_hash_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_cmp_data</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>entry_or_key</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keydata</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>remotes_hash_key</name></name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>keydata</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>remote</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>entry_or_key</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>remote</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>name</name><index>[<expr><name><name>key</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>init_remotes_hash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>remotes_hash</name><operator>.</operator><name>cmpfn</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remotes_hash</name></expr></argument>, <argument><expr><name>remotes_hash_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>make_remote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>ret</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>replaced</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>remotes_hash_key</name></name></type> <name>lookup</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>lookup_entry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>init_remotes_hash</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lookup</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lookup</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lookup_entry</name></expr></argument>, <argument><expr><call><name>memhash</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>hashmap_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remotes_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lookup_entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>container_of</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>struct <name>remote</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>remote</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>prune</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>prune_tags</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>xstrndup</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refspec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>-&gt;</operator><name>push</name></name></expr></argument>, <argument><expr><name>REFSPEC_PUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refspec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><name>REFSPEC_FETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name>remotes</name></expr></argument>, <argument><expr><name>remotes_nr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>remotes_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remotes</name><index>[<expr><name>remotes_nr</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>, <argument><expr><name><name>lookup_entry</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>replaced</name> <operator>=</operator> <call><name>hashmap_put_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remotes_hash</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>replaced</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_merge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>merge_name</name></name></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>merge_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>merge_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>branch</name><operator>-&gt;</operator><name>merge_name</name><index>[<expr><name><name>branch</name><operator>-&gt;</operator><name>merge_nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>make_branch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>branches_nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>len</name></expr> ?</condition><then> <expr><operator>(</operator><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>branches</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>branches</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>name</name><index>[<expr><name>len</name></expr>]</index></name><operator>)</operator></expr> </then><else>:

<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>branches</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>branches</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name>branches</name></expr></argument>, <argument><expr><name>branches_nr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>branches_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>branch</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>branches</name><index>[<expr><name>branches_nr</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>xstrndup</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>refname</name></name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"refs/heads/%s"</literal></expr></argument>, <argument><expr><name><name>ret</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>rewrite</name></name> <modifier>*</modifier></type><name>make_rewrite</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rewrites</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rewrite</name></name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rewrite_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>len</name></expr>

?</condition><then> <expr><operator>(</operator><name>len</name> <operator>==</operator> <name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>baselen</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>base</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>

</then><else>: <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>base</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>rewrite_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>rewrite_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rewrite</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>rewrite</name><index>[<expr><name><name>r</name><operator>-&gt;</operator><name>rewrite_nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>xstrndup</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>baselen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>baselen</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_instead_of</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rewrite</name></name> <modifier>*</modifier></type><name>rewrite</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>instead_of</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>rewrite</name><operator>-&gt;</operator><name>instead_of</name></name></expr></argument>, <argument><expr><name><name>rewrite</name><operator>-&gt;</operator><name>instead_of_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>rewrite</name><operator>-&gt;</operator><name>instead_of_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rewrite</name><operator>-&gt;</operator><name>instead_of</name><index>[<expr><name><name>rewrite</name><operator>-&gt;</operator><name>instead_of_nr</name></name></expr>]</index></name><operator>.</operator><name>s</name> <operator>=</operator> <name>instead_of</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rewrite</name><operator>-&gt;</operator><name>instead_of</name><index>[<expr><name><name>rewrite</name><operator>-&gt;</operator><name>instead_of_nr</name></name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>instead_of</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rewrite</name><operator>-&gt;</operator><name>instead_of_nr</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>skip_spaces</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_remotes_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen_or_warn</name><argument_list>(<argument><expr><call><name>git_path</name><argument_list>(<argument><expr><literal type="string">"remotes/%s"</literal></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>configured_in_repo</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator> <name>REMOTE_REMOTES</name></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>strbuf_getline</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_rtrim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"URL:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_url_alias</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><call><name>xstrdup</name><argument_list>(<argument><expr><call><name>skip_spaces</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"Push:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>push</name></name></expr></argument>, <argument><expr><call><name>skip_spaces</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"Pull:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><call><name>skip_spaces</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_branches_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>frag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen_or_warn</name><argument_list>(<argument><expr><call><name>git_path</name><argument_list>(<argument><expr><literal type="string">"branches/%s"</literal></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_getline_lf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_trim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>configured_in_repo</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator> <name>REMOTE_BRANCHES</name></expr>;</expr_stmt>

<expr_stmt><expr><name>frag</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>frag</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>frag</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>frag</name> <operator>=</operator> <literal type="string">"master"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>add_url_alias</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/%s:refs/heads/%s"</literal></expr></argument>,

<argument><expr><name>frag</name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"HEAD:refs/heads/%s"</literal></expr></argument>, <argument><expr><name>frag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>push</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>fetch_tags</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>namelen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subkey</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_config_key</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"branch"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subkey</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>branch</name> <operator>=</operator> <call><name>make_branch</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"remote"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>branch</name><operator>-&gt;</operator><name>remote_name</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"pushremote"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>branch</name><operator>-&gt;</operator><name>pushremote_name</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"merge"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>config_error_nonbool</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_merge</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_config_key</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"url"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subkey</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rewrite</name></name> <modifier>*</modifier></type><name>rewrite</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"insteadof"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>config_error_nonbool</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rewrite</name> <operator>=</operator> <call><name>make_rewrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rewrites</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_instead_of</name><argument_list>(<argument><expr><name>rewrite</name></expr></argument>, <argument><expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"pushinsteadof"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>config_error_nonbool</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rewrite</name> <operator>=</operator> <call><name>make_rewrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rewrites_push</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_instead_of</name><argument_list>(<argument><expr><name>rewrite</name></expr></argument>, <argument><expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_config_key</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"remote"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subkey</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"pushdefault"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pushremote_name</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"config remote shorthand cannot begin with '/': %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>remote</name> <operator>=</operator> <call><name>make_remote</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator> <name>REMOTE_CONFIG</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>current_config_scope</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CONFIG_SCOPE_LOCAL</name> <operator>||</operator>

<call><name>current_config_scope</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CONFIG_SCOPE_WORKTREE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>configured_in_repo</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"mirror"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>mirror</name></name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"skipdefaultupdate"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>skip_default_update</name></name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"skipfetchall"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>skip_default_update</name></name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"prune"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>prune</name></name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"prunetags"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>prune_tags</name></name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"url"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_url</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"pushurl"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_pushurl</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"push"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>push</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"fetch"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"receivepack"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>remote</name><operator>-&gt;</operator><name>receivepack</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>receivepack</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"more than one receivepack given, using the first"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"uploadpack"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>remote</name><operator>-&gt;</operator><name>uploadpack</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>uploadpack</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"more than one uploadpack given, using the first"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"tagopt"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"--no-tags"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>fetch_tags</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"--tags"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>remote</name><operator>-&gt;</operator><name>fetch_tags</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"proxy"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>http_proxy</name></name></expr></argument>,

<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"proxyauthmethod"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>http_proxy_authmethod</name></name></expr></argument>,

<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>, <argument><expr><literal type="string">"vcs"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>git_config_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>foreign_vcs</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>alias_all_urls</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>remotes_nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>add_pushurl_aliases</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pushurl_nr</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pushurl</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>alias_url</name><argument_list>(<argument><expr><name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>pushurl</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rewrites</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>add_pushurl_aliases</name> <operator>=</operator> <name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pushurl_nr</name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>url_nr</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>add_pushurl_aliases</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_pushurl_alias</name><argument_list>(<argument><expr><name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>url</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>url</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>alias_url</name><argument_list>(<argument><expr><name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>url</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rewrites</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_config</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>loaded</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>loaded</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>loaded</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>current_branch</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>startup_info</name><operator>-&gt;</operator><name>have_repository</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>head_ref</name> <init>= <expr><call><name>resolve_ref_unsafe</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>head_ref</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>REF_ISSYMREF</name><operator>)</operator> <operator>&amp;&amp;</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>head_ref</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>current_branch</name> <operator>=</operator> <call><name>make_branch</name><argument_list>(<argument><expr><name>head_ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>handle_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>alias_all_urls</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>valid_remote_nick</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <call><name>is_dot_or_dotdot</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_dir_sep</name><argument_list>(<argument><expr><operator>*</operator><name>name</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></while>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote_for_branch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>explicit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>branch</name> <operator>&amp;&amp;</operator> <name><name>branch</name><operator>-&gt;</operator><name>remote_name</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>explicit</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>explicit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name><name>branch</name><operator>-&gt;</operator><name>remote_name</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>explicit</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>explicit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="string">"origin"</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pushremote_for_branch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>explicit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>branch</name> <operator>&amp;&amp;</operator> <name><name>branch</name><operator>-&gt;</operator><name>pushremote_name</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>explicit</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>explicit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name><name>branch</name><operator>-&gt;</operator><name>pushremote_name</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pushremote_name</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>explicit</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>explicit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>pushremote_name</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>remote_for_branch</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>explicit</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote_ref_for_branch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>for_push</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>branch</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>for_push</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>branch</name><operator>-&gt;</operator><name>merge_nr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>branch</name><operator>-&gt;</operator><name>merge_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>remote_name</name> <init>=

<expr><call><name>pushremote_for_branch</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name> <init>= <expr><call><name>remote_get</name><argument_list>(<argument><expr><name>remote_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>remote</name> <operator>&amp;&amp;</operator> <name><name>remote</name><operator>-&gt;</operator><name>push</name><operator>.</operator><name>nr</name></name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>dst</name> <operator>=</operator> <call><name>apply_refspecs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>push</name></name></expr></argument>,

<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>dst</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote_get_1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>get_default</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>name_given</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>read_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name_given</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>get_default</name><argument_list>(<argument><expr><name>current_branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_given</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>make_remote</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>valid_remote_nick</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>have_git_dir</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_remote</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>read_remotes_file</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_remote</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>read_branches_file</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>name_given</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>valid_remote</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_url_alias</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_remote</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>remote_get_1</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>remote_for_branch</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>pushremote_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>remote_get_1</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pushremote_for_branch</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>remote_is_configured</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_repo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>remote</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>in_repo</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>remote</name><operator>-&gt;</operator><name>configured_in_repo</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>!</operator><operator>!</operator><name><name>remote</name><operator>-&gt;</operator><name>origin</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>for_each_remote</name><parameter_list>(<parameter><decl><type><name>each_remote_fn</name></type> <name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>priv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>read_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>remotes_nr</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>result</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>remotes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>fn</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>priv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_duplicate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ref2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ref1</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>!=</operator> <name>FETCH_HEAD_IGNORE</name> <operator>&amp;&amp;</operator>

<name><name>ref2</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>!=</operator> <name>FETCH_HEAD_IGNORE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot fetch both %s and %s to %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ref2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ref2</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ref1</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>!=</operator> <name>FETCH_HEAD_IGNORE</name> <operator>&amp;&amp;</operator>

<name><name>ref2</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>==</operator> <name>FETCH_HEAD_IGNORE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s usually tracks %s, not %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>ref2</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ref2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ref1</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>==</operator> <name>FETCH_HEAD_IGNORE</name> <operator>&amp;&amp;</operator>

<name><name>ref2</name><operator>-&gt;</operator><name>fetch_head_status</name></name> <operator>==</operator> <name>FETCH_HEAD_IGNORE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s tracks both %s and %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>ref2</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ref2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"Internal error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ref2</name><operator>-&gt;</operator><name>peer_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ref2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_remove_duplicates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>refs</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name>retval</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ref_map</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><name>ref_map</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ref_map</name> <operator>=</operator> <name><name>ref_map</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>item</name> <init>=

<expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refs</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>handle_duplicate</name><argument_list>(<argument><expr><operator>(</operator>struct <name>ref</name> <operator>*</operator><operator>)</operator><name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>remote_has_url</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>url</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>remote</name><operator>-&gt;</operator><name>url_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>remote</name><operator>-&gt;</operator><name>url</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_name_with_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>kstar</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>klen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ksuffixlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>namelen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>kstar</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"key '%s' of pattern had no '*'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>klen</name> <operator>=</operator> <name>kstar</name> <operator>-</operator> <name>key</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ksuffixlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>kstar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>namelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>namelen</name> <operator>&gt;=</operator> <name>klen</name> <operator>+</operator> <name>ksuffixlen</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>namelen</name> <operator>-</operator> <name>ksuffixlen</name></expr></argument>, <argument><expr><name>kstar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ksuffixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vstar</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vstar</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"value '%s' of pattern has no '*'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vstar</name> <operator>-</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>klen</name></expr></argument>, <argument><expr><name>namelen</name> <operator>-</operator> <name>klen</name> <operator>-</operator> <name>ksuffixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>vstar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>query_refspecs_multiple</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>query</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>results</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>find_src</name> <init>= <expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>find_src</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>dst</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"query_refspecs_multiple: need either src or dst"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>refspec</name> <init>= <expr><operator>&amp;</operator><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><ternary><condition><expr><name>find_src</name></expr> ?</condition><then> <expr><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr> </then><else>: <expr><name><name>refspec</name><operator>-&gt;</operator><name>src</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><ternary><condition><expr><name>find_src</name></expr> ?</condition><then> <expr><name><name>refspec</name><operator>-&gt;</operator><name>src</name></name></expr> </then><else>: <expr><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle</name> <init>= <expr><ternary><condition><expr><name>find_src</name></expr> ?</condition><then> <expr><name><name>query</name><operator>-&gt;</operator><name>dst</name></name></expr> </then><else>: <expr><name><name>query</name><operator>-&gt;</operator><name>src</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name> <init>= <expr><ternary><condition><expr><name>find_src</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>src</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>dst</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>refspec</name><operator>-&gt;</operator><name>pattern</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>match_name_with_pattern</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>needle</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>string_list_append_nodup</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>needle</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>query_refspecs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>find_src</name> <init>= <expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle</name> <init>= <expr><ternary><condition><expr><name>find_src</name></expr> ?</condition><then> <expr><name><name>query</name><operator>-&gt;</operator><name>dst</name></name></expr> </then><else>: <expr><name><name>query</name><operator>-&gt;</operator><name>src</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name> <init>= <expr><ternary><condition><expr><name>find_src</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>src</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>dst</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>find_src</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>dst</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"query_refspecs: need either src or dst"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>refspec</name> <init>= <expr><operator>&amp;</operator><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><ternary><condition><expr><name>find_src</name></expr> ?</condition><then> <expr><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr> </then><else>: <expr><name><name>refspec</name><operator>-&gt;</operator><name>src</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><ternary><condition><expr><name>find_src</name></expr> ?</condition><then> <expr><name><name>refspec</name><operator>-&gt;</operator><name>src</name></name></expr> </then><else>: <expr><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>refspec</name><operator>-&gt;</operator><name>pattern</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>match_name_with_pattern</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>needle</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <name><name>refspec</name><operator>-&gt;</operator><name>force</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>needle</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <name><name>refspec</name><operator>-&gt;</operator><name>force</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>apply_refspecs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec_item</name></name></type> <name>query</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>refspec_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>query</name><operator>.</operator><name>src</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>query_refspecs</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>query</name><operator>.</operator><name>dst</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>remote_find_tracking</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>refspec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>query_refspecs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><name>refspec</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>alloc_ref_with_prefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>prefixlen</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>st_add4</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ref</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <name>prefixlen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ref</name></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>alloc_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>alloc_ref_with_prefix</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>copy_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>cpy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>st_add3</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ref</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cpy</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cpy</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>symref</name></name> <operator>=</operator> <call><name>xstrdup_or_null</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>remote_status</name></name> <operator>=</operator> <call><name>xstrdup_or_null</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>remote_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>=</operator> <call><name>copy_ref</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cpy</name></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>copy_ref_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>ret</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>copy_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_one_ref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free_one_ref</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>remote_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_refs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_one_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ref</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>ref_compare_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>va</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>vb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>va</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>vb</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ref_list_get_next</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>ref</name> <operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ref_list_set_next</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>next</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator>struct <name>ref</name> <operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>sort_ref_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <call><name>llist_mergesort</name><argument_list>(<argument><expr><operator>*</operator><name>l</name></expr></argument>, <argument><expr><name>ref_list_get_next</name></expr></argument>, <argument><expr><name>ref_list_set_next</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>count_refspec_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>matched_ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>patlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>matched_weak</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>matched</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>weak_match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>weak_match</name> <operator>=</operator> <name>match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>refs</name></expr>;</condition> <incr><expr><name>refs</name> <operator>=</operator> <name><name>refs</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>refs</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>refname_match</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>!=</operator> <name>patlen</name> <operator>&amp;&amp;</operator>

<name>patlen</name> <operator>!=</operator> <name>namelen</name> <operator>-</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>matched_weak</name> <operator>=</operator> <name>refs</name></expr>;</expr_stmt>

<expr_stmt><expr><name>weak_match</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>matched</name> <operator>=</operator> <name>refs</name></expr>;</expr_stmt>

<expr_stmt><expr><name>match</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matched</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>matched_ref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>matched_ref</name> <operator>=</operator> <name>matched_weak</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>weak_match</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>matched_ref</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>matched_ref</name> <operator>=</operator> <name>matched</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>match</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tail_link_ref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>*</operator><name>tail</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>alloc_delete_ref</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>alloc_ref</name><argument_list>(<argument><expr><literal type="string">"(delete)"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ref</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>try_explicit_object_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>name</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>match</name> <operator>=</operator> <call><name>alloc_delete_ref</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>match</name> <operator>=</operator> <call><name>alloc_ref</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>match</name><operator>)</operator><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>make_linked_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>alloc_ref</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tail_link_ref</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>guess_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>resolve_ref_unsafe</name><argument_list>(<argument><expr><name><name>peer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>RESOLVE_REF_READING</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_explicit_lhs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>match</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>allocated_match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>count_refspec_match</name><argument_list>(<argument><expr><name><name>rs</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>allocated_match</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>allocated_match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>try_explicit_object_name</name><argument_list>(<argument><expr><name><name>rs</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"src refspec %s does not match any"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rs</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>allocated_match</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>allocated_match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<default>default:</default>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"src refspec %s matches more than one"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rs</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_push_unqualified_ref_name_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst_value</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>matched_src_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The destination you provided is not a full refname (i.e.,\n"</literal>

<literal type="string">"starting with \"refs/\"). We tried to guess what you meant by:\n"</literal>

<literal type="string">"\n"</literal>

<literal type="string">"- Looking for a ref that matches '%s' on the remote side.\n"</literal>

<literal type="string">"- Checking if the &lt;src&gt; being pushed ('%s')\n"</literal>

<literal type="string">" is a ref in \"refs/{heads,tags}/\". If so we add a corresponding\n"</literal>

<literal type="string">" refs/{heads,tags}/ prefix on the remote side.\n"</literal>

<literal type="string">"\n"</literal>

<literal type="string">"Neither worked, so we gave up. You must fully qualify the ref."</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>dst_value</name></expr></argument>, <argument><expr><name>matched_src_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>advice_push_unqualified_ref_name</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>matched_src_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"'%s' is not a valid object, "</literal>

<literal type="string">"match_explicit_lhs() should catch this!"</literal></expr></argument>,

<argument><expr><name>matched_src_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The &lt;src&gt; part of the refspec is a commit object.\n"</literal>

<literal type="string">"Did you mean to create a new branch by pushing to\n"</literal>

<literal type="string">"'%s:refs/heads/%s'?"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>matched_src_name</name></expr></argument>, <argument><expr><name>dst_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_TAG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The &lt;src&gt; part of the refspec is a tag object.\n"</literal>

<literal type="string">"Did you mean to create a new tag by pushing to\n"</literal>

<literal type="string">"'%s:refs/tags/%s'?"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>matched_src_name</name></expr></argument>, <argument><expr><name>dst_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_TREE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The &lt;src&gt; part of the refspec is a tree object.\n"</literal>

<literal type="string">"Did you mean to tag a new tree by pushing to\n"</literal>

<literal type="string">"'%s:refs/tags/%s'?"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>matched_src_name</name></expr></argument>, <argument><expr><name>dst_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_BLOB</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The &lt;src&gt; part of the refspec is a blob object.\n"</literal>

<literal type="string">"Did you mean to tag a new blob by pushing to\n"</literal>

<literal type="string">"'%s:refs/tags/%s'?"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>matched_src_name</name></expr></argument>, <argument><expr><name>dst_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"'%s' should be commit/tag/tree/blob, is '%d'"</literal></expr></argument>,

<argument><expr><name>matched_src_name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_explicit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>dst_tail</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>matched_src</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>matched_dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>allocated_src</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst_value</name> <init>= <expr><name><name>rs</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst_guess</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rs</name><operator>-&gt;</operator><name>pattern</name></name> <operator>||</operator> <name><name>rs</name><operator>-&gt;</operator><name>matching</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>matched_src</name> <operator>=</operator> <name>matched_dst</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>match_explicit_lhs</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matched_src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocated_src</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst_value</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dst_value</name> <operator>=</operator> <call><name>resolve_ref_unsafe</name><argument_list>(<argument><expr><name><name>matched_src</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name>RESOLVE_REF_READING</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst_value</name> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>REF_ISSYMREF</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>dst_value</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s cannot be resolved to branch"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>matched_src</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>count_refspec_match</name><argument_list>(<argument><expr><name>dst_value</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matched_dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>dst_value</name></expr></argument>, <argument><expr><literal type="string">"refs/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>matched_dst</name> <operator>=</operator> <call><name>make_linked_ref</name><argument_list>(<argument><expr><name>dst_value</name></expr></argument>, <argument><expr><name>dst_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>matched_src</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to delete '%s': remote ref does not exist"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>dst_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>dst_guess</name> <operator>=</operator> <call><name>guess_ref</name><argument_list>(<argument><expr><name>dst_value</name></expr></argument>, <argument><expr><name>matched_src</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>matched_dst</name> <operator>=</operator> <call><name>make_linked_ref</name><argument_list>(<argument><expr><name>dst_guess</name></expr></argument>, <argument><expr><name>dst_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dst_guess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>show_push_unqualified_ref_name_error</name><argument_list>(<argument><expr><name>dst_value</name></expr></argument>,

<argument><expr><name><name>matched_src</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>matched_dst</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"dst refspec %s matches more than one"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>dst_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matched_dst</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matched_dst</name><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"dst ref %s receives from more than one src"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>matched_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>matched_dst</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>=</operator> <ternary><condition><expr><name>allocated_src</name></expr> ?</condition><then>

<expr><name>matched_src</name></expr> </then><else>:

<expr><call><name>copy_ref</name><argument_list>(<argument><expr><name>matched_src</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>matched_dst</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <name><name>rs</name><operator>-&gt;</operator><name>force</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_explicit_refs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>dst_tail</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>errs</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>errs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>errs</name> <operator>+=</operator> <call><name>match_explicit</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dst_tail</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>errs</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_ref_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>send_mirror</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_pat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>matching_refs</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>matching</name></name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>matching_refs</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>force</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>matching_refs</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>pattern</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst_side</name> <init>= <expr><ternary><condition><expr><name><name>item</name><operator>-&gt;</operator><name>dst</name></name></expr> ?</condition><then> <expr><name><name>item</name><operator>-&gt;</operator><name>dst</name></name></expr> </then><else>: <expr><name><name>item</name><operator>-&gt;</operator><name>src</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>match</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <name>FROM_SRC</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>match_name_with_pattern</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>dst_side</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>match_name_with_pattern</name><argument_list>(<argument><expr><name>dst_side</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>matching_refs</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>matching_refs</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <operator>&amp;</operator><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>matching_refs</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pat</name><operator>-&gt;</operator><name>matching</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>send_mirror</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret_pat</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ret_pat</name> <operator>=</operator> <name>pat</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail_ref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>head</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><name>head</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>tail</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><name>tail</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>tips</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tip</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>, <decl><type ref="prev"/><name>alloc</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_to_tips</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tips</name></name> <modifier>*</modifier></type><name>tips</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name> <operator>||</operator> <operator>(</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>TMP_MARK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>TMP_MARK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>tips</name><operator>-&gt;</operator><name>tip</name></name></expr></argument>, <argument><expr><name><name>tips</name><operator>-&gt;</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>tips</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tips</name><operator>-&gt;</operator><name>tip</name><index>[<expr><name><name>tips</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>commit</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_missing_tags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>dst_tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>dst_tag</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>src_tag</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>tips</name></name></type> <name>sent_tips</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sent_tips</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sent_tips</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <operator>*</operator><name>dst</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_to_tips</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sent_tips</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_to_tips</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sent_tips</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst_tag</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>clear_commit_marks_many</name><argument_list>(<argument><expr><name><name>sent_tips</name><operator>.</operator><name>nr</name></name></expr></argument>, <argument><expr><name><name>sent_tips</name><operator>.</operator><name>tip</name></name></expr></argument>, <argument><expr><name>TMP_MARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>src</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>string_list_has_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst_tag</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src_tag</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sent_tips</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>reachable_flag</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>found_commits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>src_commits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nr_src_commits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>alloc_src_commits</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>src_commits</name></expr></argument>, <argument><expr><name>alloc_src_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>for_each_string_list_item</name><argument_list>(<argument>item</argument>, <argument>&amp;src_tag</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>,

<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name>src_commits</name></expr></argument>, <argument><expr><name>nr_src_commits</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>alloc_src_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>src_commits</name><index>[<expr><name>nr_src_commits</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>commit</name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name>found_commits</name> <operator>=</operator> <call><name>get_reachable_subset</name><argument_list>(<argument><expr><name><name>sent_tips</name><operator>.</operator><name>tip</name></name></expr></argument>, <argument><expr><name><name>sent_tips</name><operator>.</operator><name>nr</name></name></expr></argument>,

<argument><expr><name>src_commits</name></expr></argument>, <argument><expr><name>nr_src_commits</name></expr></argument>,

<argument><expr><name>reachable_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>for_each_string_list_item</name><argument_list>(<argument>item</argument>, <argument>&amp;src_tag</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>dst_ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>,

<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>reachable_flag</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>dst_ref</name> <operator>=</operator> <call><name>make_linked_ref</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>dst_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst_ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst_ref</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>=</operator> <call><name>copy_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>clear_commit_marks_many</name><argument_list>(<argument><expr><name>nr_src_commits</name></expr></argument>, <argument><expr><name>src_commits</name></expr></argument>, <argument><expr><name>reachable_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>src_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name>found_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>sent_tips</name><operator>.</operator><name>tip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>find_ref_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>( <init>;</init> <condition><expr><name>list</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator>struct <name>ref</name> <operator>*</operator><operator>)</operator><name>list</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>prepare_ref_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>ref_index</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>( <init>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>string_list_append_nodup</name><argument_list>(<argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>string_list_sort</name><argument_list>(<argument><expr><name>ref_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>check_push_refs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>rs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>pattern</name></name> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>matching</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>|=</operator> <call><name>match_explicit_lhs</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>match_push_refs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>dst</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>send_all</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>MATCH_REFS_ALL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>send_mirror</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>MATCH_REFS_MIRROR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>send_prune</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>MATCH_REFS_PRUNE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>errs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>dst_tail</name> <init>= <expr><call><name>tail_ref</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>dst_ref_index</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rs</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errs</name> <operator>=</operator> <call><name>match_explicit_refs</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>*</operator><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst_tail</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>src</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>dst_item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>dst_peer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>pat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst_name</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dst_name</name> <operator>=</operator> <call><name>get_ref_match</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>send_mirror</name></expr></argument>, <argument><expr><name>FROM_SRC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst_name</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dst_ref_index</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>prepare_ref_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst_ref_index</name></expr></argument>, <argument><expr><operator>*</operator><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>dst_item</name> <operator>=</operator> <call><name>string_list_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst_ref_index</name></expr></argument>, <argument><expr><name>dst_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dst_peer</name> <operator>=</operator> <ternary><condition><expr><name>dst_item</name></expr> ?</condition><then> <expr><name><name>dst_item</name><operator>-&gt;</operator><name>util</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dst_peer</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>dst_peer</name><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>free_name</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>pat</name><operator>-&gt;</operator><name>matching</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>send_all</name> <operator>||</operator> <name>send_mirror</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>free_name</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>dst_peer</name> <operator>=</operator> <call><name>make_linked_ref</name><argument_list>(<argument><expr><name>dst_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst_peer</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst_ref_index</name></expr></argument>,

<argument><expr><name><name>dst_peer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>dst_peer</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>dst_peer</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>=</operator> <call><name>copy_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst_peer</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <name><name>pat</name><operator>-&gt;</operator><name>force</name></name></expr>;</expr_stmt>

<label><name>free_name</name>:</label>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dst_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst_ref_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>MATCH_REFS_FOLLOW_TAGS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_missing_tags</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>send_prune</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>src_ref_index</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <operator>*</operator><name>dst</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src_name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>src_name</name> <operator>=</operator> <call><name>get_ref_match</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>send_mirror</name></expr></argument>, <argument><expr><name>FROM_DST</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>src_name</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>src_ref_index</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>prepare_ref_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src_ref_index</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>string_list_has_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src_ref_index</name></expr></argument>,

<argument><expr><name>src_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>=</operator> <call><name>alloc_delete_ref</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>src_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src_ref_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errs</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_ref_status_for_push</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_refs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>send_mirror</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>force_update</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>remote_refs</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>force_ref_update</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>force</name></name> <operator>||</operator> <name>force_update</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>reject_reason</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>send_mirror</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>deletion</name></name> <operator>=</operator> <call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>deletion</name></name> <operator>&amp;&amp;</operator>

<call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>REF_STATUS_UPTODATE</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>expect_old_sha1</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid_expect</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>reject_reason</name> <operator>=</operator> <name>REF_STATUS_REJECT_STALE</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>force_ref_update</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reject_reason</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>deletion</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>reject_reason</name> <operator>=</operator> <name>REF_STATUS_REJECT_ALREADY_EXISTS</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>has_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>reject_reason</name> <operator>=</operator> <name>REF_STATUS_REJECT_FETCH_FIRST</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>reject_reason</name> <operator>=</operator> <name>REF_STATUS_REJECT_NEEDS_FORCE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ref_newer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>reject_reason</name> <operator>=</operator> <name>REF_STATUS_REJECT_NONFASTFORWARD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_ref_update</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>reject_reason</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>reject_reason</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>forced_update</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_merge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>ret</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>-&gt;</operator><name>merge</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ret</name><operator>-&gt;</operator><name>remote_name</name></name> <operator>||</operator> <operator>!</operator><name><name>ret</name><operator>-&gt;</operator><name>merge_nr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>merge_nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>remote</name> <operator>=</operator> <call><name>remote_get</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>remote_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>merge</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>merge_nr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>ret</name><operator>-&gt;</operator><name>merge</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ret</name><operator>-&gt;</operator><name>merge_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>merge</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name><name>ret</name><operator>-&gt;</operator><name>merge</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>merge</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>src</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>merge_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remote_find_tracking</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name><name>ret</name><operator>-&gt;</operator><name>merge</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>remote_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwim_ref</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>merge_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>merge_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>merge</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dst</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>merge</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dst</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>merge_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>read_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>name</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>current_branch</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>make_branch</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>set_merge</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>branch_has_merge_config</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>branch</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>!</operator><name><name>branch</name><operator>-&gt;</operator><name>merge</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>branch_merge_matches</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>branch</name> <operator>||</operator> <name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name><name>branch</name><operator>-&gt;</operator><name>merge_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>refname_match</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>merge</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>src</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>__attribute__</name><argument_list>(<argument>(format (printf,<literal type="number">2</literal>,<literal type="number">3</literal>))</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_buf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_vaddf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch_get_upstream</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>branch</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HEAD does not point to a branch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>branch</name><operator>-&gt;</operator><name>merge</name></name> <operator>||</operator> <operator>!</operator><name><name>branch</name><operator>-&gt;</operator><name>merge</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ref_exists</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no such branch: '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no upstream configured for branch '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>branch</name><operator>-&gt;</operator><name>merge</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>dst</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"upstream branch '%s' not stored as a remote-tracking branch"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>merge</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>branch</name><operator>-&gt;</operator><name>merge</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>dst</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tracking_for_push_dest</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>apply_refspecs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"push destination '%s' on remote '%s' has no local tracking branch"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch_get_push_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl>;</decl_stmt>

<expr_stmt><expr><name>remote</name> <operator>=</operator> <call><name>remote_get</name><argument_list>(<argument><expr><call><name>pushremote_for_branch</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>remote</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"branch '%s' has no remote for pushing"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>remote</name><operator>-&gt;</operator><name>push</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>apply_refspecs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>push</name></name></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"push refspecs for '%s' do not include '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>remote</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>tracking_for_push_dest</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>remote</name><operator>-&gt;</operator><name>mirror</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>tracking_for_push_dest</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>push_default</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>PUSH_DEFAULT_NOTHING</name></expr>:</case>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"push has no destination (push.default is 'nothing')"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>PUSH_DEFAULT_MATCHING</name></expr>:</case>

<case>case <expr><name>PUSH_DEFAULT_CURRENT</name></expr>:</case>

<return>return <expr><call><name>tracking_for_push_dest</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>PUSH_DEFAULT_UPSTREAM</name></expr>:</case>

<return>return <expr><call><name>branch_get_upstream</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>PUSH_DEFAULT_UNSPECIFIED</name></expr>:</case>

<case>case <expr><name>PUSH_DEFAULT_SIMPLE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>up</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

<expr_stmt><expr><name>up</name> <operator>=</operator> <call><name>branch_get_upstream</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>up</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>tracking_for_push_dest</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cur</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot resolve 'simple' push to a single destination"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>cur</name></expr>;</return>

</block_content>}</block>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unhandled push situation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch_get_push</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>branch</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error_buf</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HEAD does not point to a branch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>branch</name><operator>-&gt;</operator><name>push_tracking_ref</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>branch</name><operator>-&gt;</operator><name>push_tracking_ref</name></name> <operator>=</operator> <call><name>branch_get_push_1</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name><name>branch</name><operator>-&gt;</operator><name>push_tracking_ref</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ignore_symref_update</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>resolve_ref_unsafe</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<return>return <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>REF_ISSYMREF</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>get_expanded_map</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_refs</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>refspec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>ret</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>remote_refs</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expn_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>match_name_with_pattern</name><argument_list>(<argument><expr><name><name>refspec</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expn_name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>ignore_symref_update</name><argument_list>(<argument><expr><name>expn_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>cpy</name> <init>= <expr><call><name>copy_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>=</operator> <call><name>alloc_ref</name><argument_list>(<argument><expr><name>expn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>refspec</name><operator>-&gt;</operator><name>force</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>cpy</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>cpy</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>find_ref_by_name_abbrev</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>best_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>best_score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>refs</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>score</name> <init>= <expr><call><name>refname_match</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>best_score</name> <operator>&lt;</operator> <name>score</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>best_match</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>

<expr_stmt><expr><name>best_score</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>best_match</name></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>get_remote_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_refs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>find_ref_by_name_abbrev</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>copy_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>get_local_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"refs/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>alloc_ref</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"heads/"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"tags/"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>starts_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"remotes/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>alloc_ref_with_prefix</name><argument_list>(<argument><expr><literal type="string">"refs/"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>alloc_ref_with_prefix</name><argument_list>(<argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>get_fetch_map</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_refs</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>refspec</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref_map</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>rmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>refspec</name><operator>-&gt;</operator><name>pattern</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ref_map</name> <operator>=</operator> <call><name>get_expanded_map</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><name>refspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><ternary><condition><expr><name><name>refspec</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name><name>refspec</name><operator>-&gt;</operator><name>src</name></name></expr> </then><else>: <expr><literal type="string">"HEAD"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>refspec</name><operator>-&gt;</operator><name>exact_sha1</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ref_map</name> <operator>=</operator> <call><name>alloc_ref</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_oid_hex</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref_map</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ref_map</name><operator>-&gt;</operator><name>exact_oid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ref_map</name> <operator>=</operator> <call><name>get_remote_ref</name><argument_list>(<argument><expr><name>remote_refs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ref_map</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"couldn't find remote ref %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ref_map</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ref_map</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>=</operator> <call><name>get_local_ref</name><argument_list>(<argument><expr><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref_map</name><operator>-&gt;</operator><name>peer_ref</name></name> <operator>&amp;&amp;</operator> <name><name>refspec</name><operator>-&gt;</operator><name>force</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ref_map</name><operator>-&gt;</operator><name>peer_ref</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>rmp</name> <operator>=</operator> <operator>&amp;</operator><name>ref_map</name></expr>;</init> <condition><expr><operator>*</operator><name>rmp</name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>rmp</name><operator>)</operator><operator>-&gt;</operator><name>peer_ref</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>rmp</name><operator>)</operator><operator>-&gt;</operator><name><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></name></expr></argument>, <argument><expr><literal type="string">"refs/"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>check_refname_format</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>rmp</name><operator>)</operator><operator>-&gt;</operator><name><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ignore</name> <init>= <expr><operator>*</operator><name>rmp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"* Ignoring funny ref '%s' locally"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><operator>(</operator><operator>*</operator><name>rmp</name><operator>)</operator><operator>-&gt;</operator><name><name>peer_ref</name><operator>-&gt;</operator><name>name</name></name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>rmp</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>rmp</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ignore</name><operator>-&gt;</operator><name>peer_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ignore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rmp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>rmp</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ref_map</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>tail_link_ref</name><argument_list>(<argument><expr><name>ref_map</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>resolve_remote_symref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>list</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>symref</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt></block_content></block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>stat_branch_pair</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_ours</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_theirs</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>ahead_behind_flags</name></name></type> <name>abf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>ours</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>theirs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name></type> <name>revs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>argv</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_ref</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>theirs</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>theirs</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_ref</name><argument_list>(<argument><expr><name>branch_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ours</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ours</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>num_theirs</name> <operator>=</operator> <operator>*</operator><name>num_ours</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>theirs</name> <operator>==</operator> <name>ours</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>abf</name> <operator>==</operator> <name>AHEAD_BEHIND_QUICK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>abf</name> <operator>!=</operator> <name>AHEAD_BEHIND_FULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"stat_branch_pair: invalid abf '%d'"</literal></expr></argument>, <argument><expr><name>abf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--left-right"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_pushf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>, <argument><expr><literal type="string">"%s...%s"</literal></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ours</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>theirs</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>repo_init_revisions</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>setup_revisions</name><argument_list>(<argument><expr><name><name>argv</name><operator>.</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>argv</name><operator>.</operator><name>argv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prepare_revision_walk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"revision walk setup failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>get_revision</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>SYMMETRIC_LEFT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_ours</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_theirs</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>clear_commit_marks</name><argument_list>(<argument><expr><name>ours</name></expr></argument>, <argument><expr><name>ALL_REV_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_commit_marks</name><argument_list>(<argument><expr><name>theirs</name></expr></argument>, <argument><expr><name>ALL_REV_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>stat_tracking_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_ours</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_theirs</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tracking_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>for_push</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>ahead_behind_flags</name></name></type> <name>abf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <ternary><condition><expr><name>for_push</name></expr> ?</condition><then> <expr><call><name>branch_get_push</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>branch_get_upstream</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tracking_name</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>tracking_name</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>base</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>stat_branch_pair</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>num_ours</name></expr></argument>, <argument><expr><name>num_theirs</name></expr></argument>, <argument><expr><name>abf</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>format_tracking_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>ahead_behind_flags</name></name></type> <name>abf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ours</name></decl>, <decl><type ref="prev"/><name>theirs</name></decl>, <decl><type ref="prev"/><name>sti</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>full_base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>upstream_is_gone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sti</name> <operator>=</operator> <call><name>stat_tracking_info</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ours</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>theirs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>full_base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>abf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sti</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>full_base</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>upstream_is_gone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>shorten_unambiguous_ref</name><argument_list>(<argument><expr><name>full_base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>upstream_is_gone</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Your branch is based on '%s', but the upstream is gone.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>advice_status_hints</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (use \"git branch --unset-upstream\" to fixup)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>sti</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Your branch is up to date with '%s'.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>abf</name> <operator>==</operator> <name>AHEAD_BEHIND_QUICK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Your branch and '%s' refer to different commits.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>advice_status_hints</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (use \"%s\" for details)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"git status --ahead-behind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>theirs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>Q_</name><argument_list>(<argument><expr><literal type="string">"Your branch is ahead of '%s' by %d commit.\n"</literal></expr></argument>,

<argument><expr><literal type="string">"Your branch is ahead of '%s' by %d commits.\n"</literal></expr></argument>,

<argument><expr><name>ours</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>base</name></expr></argument>, <argument><expr><name>ours</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>advice_status_hints</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (use \"git push\" to publish your local commits)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>ours</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>Q_</name><argument_list>(<argument><expr><literal type="string">"Your branch is behind '%s' by %d commit, "</literal>

<literal type="string">"and can be fast-forwarded.\n"</literal></expr></argument>,

<argument><expr><literal type="string">"Your branch is behind '%s' by %d commits, "</literal>

<literal type="string">"and can be fast-forwarded.\n"</literal></expr></argument>,

<argument><expr><name>theirs</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>base</name></expr></argument>, <argument><expr><name>theirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>advice_status_hints</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (use \"git pull\" to update your local branch)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>Q_</name><argument_list>(<argument><expr><literal type="string">"Your branch and '%s' have diverged,\n"</literal>

<literal type="string">"and have %d and %d different commit each, "</literal>

<literal type="string">"respectively.\n"</literal></expr></argument>,

<argument><expr><literal type="string">"Your branch and '%s' have diverged,\n"</literal>

<literal type="string">"and have %d and %d different commits each, "</literal>

<literal type="string">"respectively.\n"</literal></expr></argument>,

<argument><expr><name>ours</name> <operator>+</operator> <name>theirs</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>base</name></expr></argument>, <argument><expr><name>ours</name></expr></argument>, <argument><expr><name>theirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>advice_status_hints</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (use \"git pull\" to merge the remote branch into yours)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>one_local_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>local_tail</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_refname_format</name><argument_list>(<argument><expr><name>refname</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>alloc_ref</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>*</operator><name>local_tail</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>local_tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>get_local_heads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>local_refs</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>local_tail</name> <init>= <expr><operator>&amp;</operator><name>local_refs</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>for_each_ref</name><argument_list>(<argument><expr><name>one_local_ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>local_refs</name></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>guess_remote_head</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>all</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>list</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>head</name><operator>-&gt;</operator><name>symref</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>copy_ref</name><argument_list>(<argument><expr><call><name>find_ref_by_name</name><argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><name><name>head</name><operator>-&gt;</operator><name>symref</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>find_ref_by_name</name><argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/master"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&amp;&amp;</operator> <call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>copy_ref</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>refs</name></expr>;</init> <condition><expr><name>r</name></expr>;</condition> <incr><expr><name>r</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>head</name> <operator>&amp;&amp;</operator>

<call><name>starts_with</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>old_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>copy_ref</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>stale_heads_info</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>ref_names</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stale_refs_tail</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_stale_heads_cb</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stale_heads_info</name></name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>matches</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>refspec_item</name></name></type> <name>query</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>stale</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>refspec_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>query</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>refname</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>query_refspecs_multiple</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>rs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matches</name><operator>.</operator><name>nr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>clean_exit</name>;</goto></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REF_ISSYMREF</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>clean_exit</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>stale</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>matches</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>string_list_has_string</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ref_names</name></name></expr></argument>, <argument><expr><name><name>matches</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>stale</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>stale</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>make_linked_ref</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>stale_refs_tail</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>new_oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>clean_exit</name>:</label>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>matches</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>get_stale_heads</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refspec</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>fetch_map</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>stale_refs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>ref_names</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stale_heads_info</name></name></type> <name>info</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>info</name><operator>.</operator><name>ref_names</name></name> <operator>=</operator> <operator>&amp;</operator><name>ref_names</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>info</name><operator>.</operator><name>stale_refs_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name>stale_refs</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>info</name><operator>.</operator><name>rs</name></name> <operator>=</operator> <name>rs</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>fetch_map</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_names</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>string_list_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>for_each_ref</name><argument_list>(<argument><expr><name>get_stale_heads_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_names</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>stale_refs</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_cas_option</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>push_cas_option</name></name> <modifier>*</modifier></type><name>cas</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cas</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cas</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cas</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cas</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cas</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>push_cas</name></name> <modifier>*</modifier></type><name>add_cas_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>push_cas_option</name></name> <modifier>*</modifier></type><name>cas</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>refnamelen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>push_cas</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>cas</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>cas</name><operator>-&gt;</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cas</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>cas</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name><name>cas</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>refname</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>refnamelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>entry</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_push_cas_option</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>push_cas_option</name></name> <modifier>*</modifier></type><name>cas</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colon</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>push_cas</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>unset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>clear_cas_option</name><argument_list>(<argument><expr><name>cas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cas</name><operator>-&gt;</operator><name>use_tracking_for_rest</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>colon</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>add_cas_entry</name><argument_list>(<argument><expr><name>cas</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>colon</name> <operator>-</operator> <name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>colon</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>use_tracking</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>colon</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>expect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>colon</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>expect</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot parse expected object name '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>colon</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>parseopt_push_cas_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>parse_push_cas_option</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_empty_cas</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>push_cas_option</name></name> <modifier>*</modifier></type><name>cas</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>!</operator><name><name>cas</name><operator>-&gt;</operator><name>use_tracking_for_rest</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cas</name><operator>-&gt;</operator><name>nr</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>remote_tracking</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>apply_refspecs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote</name><operator>-&gt;</operator><name>fetch</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>read_ref</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>apply_cas</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>push_cas_option</name></name> <modifier>*</modifier></type><name>cas</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cas</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>push_cas</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>&amp;</operator><name><name>cas</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>refname_match</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>expect_old_sha1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>use_tracking</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid_expect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>expect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>remote_tracking</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid_expect</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid_expect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return;</return>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cas</name><operator>-&gt;</operator><name>use_tracking_for_rest</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>expect_old_sha1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>remote_tracking</name><argument_list>(<argument><expr><name>remote</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid_expect</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>old_oid_expect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>apply_push_cas</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>push_cas_option</name></name> <modifier>*</modifier></type><name>cas</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>remote</name></name> <modifier>*</modifier></type><name>remote</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>remote_refs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ref</name></name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>remote_refs</name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>apply_cas</name><argument_list>(<argument><expr><name>cas</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

</unit>
