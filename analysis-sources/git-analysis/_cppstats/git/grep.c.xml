<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\grep.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grep.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"userdiff.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xdiff-interface.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diffcore.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quote.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"help.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>grep_source_load</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>grep_source_is_binary</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>grep_opt</name></name></type> <name>grep_defaults</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_general_context</name> <modifier>*</modifier></type><name>pcre2_global_context</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>pcre2_malloc</name><parameter_list>(<parameter><decl><type><name>PCRE2_SIZE</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>MAYBE_UNUSED</name> <name>void</name> <modifier>*</modifier></type><name>memory_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pcre2_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>MAYBE_UNUSED</name> <name>void</name> <modifier>*</modifier></type><name>memory_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>color_grep_slots</name><index>[]</index></name> <init>= <expr><block>{

<expr><index>[<expr><name>GREP_COLOR_CONTEXT</name></expr>]</index> <operator>=</operator> <literal type="string">"context"</literal></expr>,

<expr><index>[<expr><name>GREP_COLOR_FILENAME</name></expr>]</index> <operator>=</operator> <literal type="string">"filename"</literal></expr>,

<expr><index>[<expr><name>GREP_COLOR_FUNCTION</name></expr>]</index> <operator>=</operator> <literal type="string">"function"</literal></expr>,

<expr><index>[<expr><name>GREP_COLOR_LINENO</name></expr>]</index> <operator>=</operator> <literal type="string">"lineNumber"</literal></expr>,

<expr><index>[<expr><name>GREP_COLOR_COLUMNNO</name></expr>]</index> <operator>=</operator> <literal type="string">"column"</literal></expr>,

<expr><index>[<expr><name>GREP_COLOR_MATCH_CONTEXT</name></expr>]</index> <operator>=</operator> <literal type="string">"matchContext"</literal></expr>,

<expr><index>[<expr><name>GREP_COLOR_MATCH_SELECTED</name></expr>]</index> <operator>=</operator> <literal type="string">"matchSelected"</literal></expr>,

<expr><index>[<expr><name>GREP_COLOR_SELECTED</name></expr>]</index> <operator>=</operator> <literal type="string">"selected"</literal></expr>,

<expr><index>[<expr><name>GREP_COLOR_SEP</name></expr>]</index> <operator>=</operator> <literal type="string">"separator"</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>std_output</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>color_set</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>color_bytes</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>COLOR_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>color_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>init_grep_defaults</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>&amp;</operator><name>grep_defaults</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>run_once</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>run_once</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>run_once</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>opt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name> <operator>=</operator> <name>repo</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>relative</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pathname</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>max_depth</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_type_option</name></name> <operator>=</operator> <name>GREP_PATTERN_TYPE_UNSPECIFIED</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_CONTEXT</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_FILENAME</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_FUNCTION</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_LINENO</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_COLUMNNO</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_MATCH_CONTEXT</name></expr>]</index></name></expr></argument>, <argument><expr><name>GIT_COLOR_BOLD_RED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_MATCH_SELECTED</name></expr>]</index></name></expr></argument>, <argument><expr><name>GIT_COLOR_BOLD_RED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_SELECTED</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_SEP</name></expr>]</index></name></expr></argument>, <argument><expr><name>GIT_COLOR_CYAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>only_matching</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>output</name></name> <operator>=</operator> <name>std_output</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_pattern_type_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GREP_PATTERN_TYPE_UNSPECIFIED</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"basic"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GREP_PATTERN_TYPE_BRE</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"extended"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GREP_PATTERN_TYPE_ERE</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"fixed"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GREP_PATTERN_TYPE_FIXED</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"perl"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GREP_PATTERN_TYPE_PCRE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"bad %s argument: %s"</literal></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>define_list_config_array_extra</name><argument_list>(<argument>color_grep_slots</argument>, <argument>{<literal type="string">"match"</literal>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><name>int</name></type> <name>grep_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>&amp;</operator><name>grep_defaults</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>userdiff_config</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"grep.extendedregexp"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>extended_regexp_option</name></name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"grep.patterntype"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_type_option</name></name> <operator>=</operator> <call><name>parse_pattern_type_arg</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"grep.linenumber"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>linenum</name></name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"grep.column"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>columnnum</name></name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"grep.fullname"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>relative</name></name> <operator>=</operator> <operator>!</operator><call><name>git_config_bool</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"color.grep"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <call><name>git_config_colorbool</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"color.grep.match"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>grep_config</name><argument_list>(<argument><expr><literal type="string">"color.grep.matchcontext"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grep_config</name><argument_list>(<argument><expr><literal type="string">"color.grep.matchselected"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"color.grep."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>LOOKUP_CONFIG</name><argument_list>(<argument><expr><name>color_grep_slots</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>color</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>color</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>config_error_nonbool</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>color_parse</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>grep_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>&amp;</operator><name>grep_defaults</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE2</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pcre2_global_context</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pcre2_global_context</name> <operator>=</operator> <call><name>pcre2_general_context_create</name><argument_list>(

<argument><expr><name>pcre2_malloc</name></expr></argument>, <argument><expr><name>pcre2_free</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pcre_malloc</name> <operator>=</operator> <name>malloc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pcre_free</name> <operator>=</operator> <name>free</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>opt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name> <operator>=</operator> <name>repo</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>prefix_length</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>prefix</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>prefix</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>header_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>header_list</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>only_matching</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>only_matching</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>extended_regexp_option</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>extended_regexp_option</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_type_option</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>pattern_type_option</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>linenum</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>linenum</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>columnnum</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>columnnum</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>max_depth</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>max_depth</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pathname</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>pathname</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>relative</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>relative</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>output</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>output</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NR_GREP_COLORS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>color_set</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>grep_destroy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>pcre2_general_context_free</name><argument_list>(<argument><expr><name>pcre2_global_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>grep_set_pattern_type_option</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>grep_pattern_type</name></name></type> <name>pattern_type</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pattern_type</name> <operator>!=</operator> <name>GREP_PATTERN_TYPE_ERE</name> <operator>&amp;&amp;</operator>

<name><name>opt</name><operator>-&gt;</operator><name>extended_regexp_option</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>extended_regexp_option</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>pattern_type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_PATTERN_TYPE_UNSPECIFIED</name></expr>:</case>

<case>case <expr><name>GREP_PATTERN_TYPE_BRE</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>GREP_PATTERN_TYPE_ERE</name></expr>:</case>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>extended_regexp_option</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_PATTERN_TYPE_FIXED</name></expr>:</case>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>fixed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_PATTERN_TYPE_PCRE</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pcre2</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pcre1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>grep_commit_pattern_type</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>grep_pattern_type</name></name></type> <name>pattern_type</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pattern_type</name> <operator>!=</operator> <name>GREP_PATTERN_TYPE_UNSPECIFIED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>grep_set_pattern_type_option</name><argument_list>(<argument><expr><name>pattern_type</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_type_option</name></name> <operator>!=</operator> <name>GREP_PATTERN_TYPE_UNSPECIFIED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>grep_set_pattern_type_option</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_type_option</name></name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>extended_regexp_option</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>grep_set_pattern_type_option</name><argument_list>(<argument><expr><name>GREP_PATTERN_TYPE_ERE</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>create_grep_pat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>patlen</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>grep_pat_token</name></name></type> <name>t</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>grep_header_field</name></name></type> <name>field</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>=</operator> <name>patlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator> <name>origin</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>no</name></name> <operator>=</operator> <name>no</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_append_grep_pat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>*</operator><name>tail</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_PATTERN</name></expr>:</case> 

<case>case <expr><name>GREP_PATTERN_HEAD</name></expr>:</case>

<case>case <expr><name>GREP_PATTERN_BODY</name></expr>:</case>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>new_pat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>++</operator><name>len</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>--</operator><name>cp</name><operator>)</operator> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nl</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nl</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>new_pat</name> <operator>=</operator> <call><name>create_grep_pat</name><argument_list>(<argument><expr><name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>,

<argument><expr><name><name>p</name><operator>-&gt;</operator><name>no</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_pat</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>new_pat</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_pat</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>append_header_grep_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>grep_header_field</name></name></type> <name>field</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>create_grep_pat</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"header"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>GREP_PATTERN_HEAD</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <name>GREP_HEADER_REFLOG</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>use_reflog_filter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>do_append_grep_pat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>header_tail</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>append_grep_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>grep_pat_token</name></name></type> <name>t</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>append_grep_pat</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>origin</name></expr></argument>, <argument><expr><name>no</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>append_grep_pat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>patlen</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>grep_pat_token</name></name></type> <name>t</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>create_grep_pat</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>, <argument><expr><name>no</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>do_append_grep_pat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>pattern_tail</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>grep_opt_dup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>grep_opt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <operator>*</operator><name>opt</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>pattern_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>pattern_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ret</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>pat</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</init> <condition><expr><name>pat</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pat</name> <operator>=</operator> <name><name>pat</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>pat</name><operator>-&gt;</operator><name>token</name></name> <operator>==</operator> <name>GREP_PATTERN_HEAD</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>append_header_grep_pattern</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>pat</name><operator>-&gt;</operator><name>field</name></name></expr></argument>,

<argument><expr><name><name>pat</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>append_grep_pat</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>pat</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name><name>pat</name><operator>-&gt;</operator><name>patternlen</name></name></expr></argument>,

<argument><expr><name><name>pat</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>, <argument><expr><name><name>pat</name><operator>-&gt;</operator><name>no</name></name></expr></argument>, <argument><expr><name><name>pat</name><operator>-&gt;</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NORETURN</name> <name>void</name></type> <name>compile_regexp_failed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>where</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>no</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><name>where</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"In '%s' at %d, "</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>origin</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><name>where</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>where</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s'%s': %s"</literal></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_fixed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_regex_special</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_pcre1_regexp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>erroffset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><name>PCRE_MULTILINE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>study_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>ignore_locale</name></name> <operator>&amp;&amp;</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_tables</name></name> <operator>=</operator> <call><name>pcre_maketables</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE_CASELESS</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>ignore_locale</name></name> <operator>&amp;&amp;</operator> <call><name>is_utf8_locale</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE_UTF8</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_regexp</name></name> <operator>=</operator> <call><name>pcre_compile</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>erroffset</name></expr></argument>,

<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pcre1_regexp</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>compile_regexp_failed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCRE_CONFIG_JIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_LIBPCRE1_JIT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>pcre_config</name><argument_list>(<argument><expr><name>PCRE_CONFIG_JIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pcre1_jit_on</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre1_jit_on=%d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_jit_on</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_jit_on</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>study_options</name> <operator>=</operator> <name>PCRE_STUDY_JIT_COMPILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_extra_info</name></name> <operator>=</operator> <call><name>pcre_study</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_regexp</name></name></expr></argument>, <argument><expr><name>study_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pcre1_extra_info</name></name> <operator>&amp;&amp;</operator> <name>error</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pcre1match</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name><name>ovector</name><index>[<expr><literal type="number">30</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr><name>PCRE_NO_UTF8_CHECK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTBOL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PCRE_NOTBOL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pcre_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_regexp</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_extra_info</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>,

<argument><expr><name>eol</name> <operator>-</operator> <name>line</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>,

<argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ret</name> <operator>!=</operator> <name>PCRE_ERROR_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"pcre_exec failed with error code %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>rm_so</name></name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>rm_eo</name></name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_pcre1_regexp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>pcre_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_regexp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCRE_CONFIG_JIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_jit_on</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pcre_free_study</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_extra_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>pcre_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_extra_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>pcre_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pcre1_tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_pcre1_regexp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"cannot use Perl-compatible regexes when not compiled with USE_LIBPCRE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pcre1match</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_pcre1_regexp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_pcre2_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>erroffset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><name>PCRE2_MULTILINE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>jitret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>patinforet</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>jitsizearg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>pcre2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_compile_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>ignore_locale</name></name> <operator>&amp;&amp;</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pcre2_global_context</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"pcre2_global_context uninitialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_tables</name></name> <operator>=</operator> <call><name>pcre2_maketables</name><argument_list>(<argument><expr><name>pcre2_global_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_compile_context</name></name> <operator>=</operator> <call><name>pcre2_compile_context_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pcre2_set_character_tables</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_compile_context</name></name></expr></argument>,

<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_CASELESS</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>ignore_locale</name></name> <operator>&amp;&amp;</operator> <call><name>is_utf8_locale</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>fixed</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>is_fixed</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_UTF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name> <operator>=</operator> <call><name>pcre2_compile</name><argument_list>(<argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>,

<argument><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>erroffset</name></expr></argument>,

<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_compile_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_match_data</name></name> <operator>=</operator> <call><name>pcre2_match_data_create_from_pattern</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pcre2_match_data</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Couldn't allocate PCRE2 match data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pcre2_get_error_message</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_regexp_failed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>pcre2_config</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_JIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pcre2_jit_on</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2_jit_on=%d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_jit_on</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_jit_on</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>jitret</name> <operator>=</operator> <call><name>pcre2_jit_compile</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr></argument>, <argument><expr><name>PCRE2_JIT_COMPLETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>jitret</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Couldn't JIT the PCRE2 pattern '%s', got '%d'\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>jitret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>patinforet</name> <operator>=</operator> <call><name>pcre2_pattern_info</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr></argument>, <argument><expr><name>PCRE2_INFO_JITSIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jitsizearg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>patinforet</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"pcre2_pattern_info() failed: %d"</literal></expr></argument>, <argument><expr><name>patinforet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>jitsizearg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_jit_on</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2_jit_on=%d: (*NO_JIT) in regex\n"</literal></expr></argument>,

<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_jit_on</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pcre2match</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTBOL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PCRE2_NOTBOL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_jit_on</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pcre2_jit_match</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>line</name></expr></argument>,

<argument><expr><name>eol</name> <operator>-</operator> <name>line</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_match_data</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pcre2_match</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>line</name></expr></argument>,

<argument><expr><name>eol</name> <operator>-</operator> <name>line</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_match_data</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ret</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pcre2_get_error_message</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s failed with error code %d: %s"</literal></expr></argument>,

<argument><expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_jit_on</name></name></expr> ?</condition><then> <expr><literal type="string">"pcre2_jit_match"</literal></expr> </then><else>: <expr><literal type="string">"pcre2_match"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>ret</name></expr></argument>,

<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ovector</name> <operator>=</operator> <call><name>pcre2_get_ovector_pointer</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_match_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>rm_so</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>rm_eo</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_pcre2_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>pcre2_compile_context_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_compile_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_match_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pcre2_tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_pcre2_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"cannot use Perl-compatible regexes when not compiled with USE_LIBPCRE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pcre2match</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_pcre2_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_fixed_regexp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>regflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>basic_regex_quote_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>regflags</name> <operator>|=</operator> <name>REG_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>regexp</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>regflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"fixed %s\n"</literal></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>regerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>regexp</name></name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_regexp_failed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_regexp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>regflags</name> <init>= <expr><name>REG_NEWLINE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>word_regexp</name></name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>word_regexp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>fixed</name></name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>fixed</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>pcre2</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"given pattern contains NULL byte (via -f &lt;file&gt;). This is only supported with -P under PCRE v2"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>is_fixed</name></name> <operator>=</operator> <call><name>is_fixed</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>fixed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>is_fixed</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>no_jit</name> <init>= <expr><literal type="string">"(*NO_JIT)"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>no_jit_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>no_jit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>no_jit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>is_fixed</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name> <operator>+</operator> <name>no_jit_len</name></expr></argument>,

<argument><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>-</operator> <name>no_jit_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>is_fixed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>fixed</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>is_fixed</name></name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPCRE2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pcre2</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>is_fixed</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>compile_pcre2_pattern</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_pattern</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>old_patternlen</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">"\\Q"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">"\\E"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_pcre2_pattern</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name>old_pattern</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>=</operator> <name>old_patternlen</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<expr_stmt><expr><call><name>compile_fixed_regexp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>pcre2</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>compile_pcre2_pattern</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>pcre1</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>compile_pcre1_regexp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>ignore_case</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>regflags</name> <operator>|=</operator> <name>REG_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>extended_regexp_option</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>regflags</name> <operator>|=</operator> <name>REG_EXTENDED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>regexp</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>regflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>regerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>regexp</name></name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_regexp_failed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>compile_pattern_or</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>compile_pattern_atom</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>list</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_PATTERN</name></expr>:</case> 

<case>case <expr><name>GREP_PATTERN_HEAD</name></expr>:</case>

<case>case <expr><name>GREP_PATTERN_BODY</name></expr>:</case>

<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grep_expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>GREP_NODE_ATOM</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>atom</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<return>return <expr><name>x</name></expr>;</return>

<case>case <expr><name>GREP_OPEN_PAREN</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>compile_pattern_or</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>list</name> <operator>||</operator> <name><operator>(</operator><operator>*</operator><name>list</name><operator>)</operator><operator>-&gt;</operator><name>token</name></name> <operator>!=</operator> <name>GREP_CLOSE_PAREN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unmatched parenthesis"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>list</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<return>return <expr><name>x</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>compile_pattern_not</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>list</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_NOT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"--not not followed by pattern expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grep_expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>GREP_NODE_NOT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>unary</name></name> <operator>=</operator> <call><name>compile_pattern_not</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>unary</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"--not followed by non pattern expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>x</name></expr>;</return>

<default>default:</default>

<return>return <expr><call><name>compile_pattern_atom</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>compile_pattern_and</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>compile_pattern_not</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>list</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>==</operator> <name>GREP_AND</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"--and not followed by pattern expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>compile_pattern_and</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>y</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"--and not followed by pattern expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grep_expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>GREP_NODE_AND</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>

<return>return <expr><name>z</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>x</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>compile_pattern_or</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>compile_pattern_and</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>list</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>!=</operator> <name>GREP_CLOSE_PAREN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>compile_pattern_or</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>y</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"not a pattern expression %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grep_expr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>GREP_NODE_OR</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>

<return>return <expr><name>z</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>x</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>compile_pattern_expr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>compile_pattern_or</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>indent</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>in</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_grep_pat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_AND</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"*and*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>GREP_OPEN_PAREN</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"*(*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>GREP_CLOSE_PAREN</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"*)*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>GREP_NOT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"*not*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>GREP_OR</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"*or*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>GREP_PATTERN</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pattern"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>GREP_PATTERN_HEAD</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pattern_head"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>GREP_PATTERN_BODY</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pattern_body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<default>default:</default> <break>break;</break>

<case>case <expr><name>GREP_PATTERN_HEAD</name></expr>:</case>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"&lt;head %d&gt;"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>GREP_PATTERN_BODY</name></expr>:</case>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"&lt;body&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<default>default:</default> <break>break;</break>

<case>case <expr><name>GREP_PATTERN_HEAD</name></expr>:</case>

<case>case <expr><name>GREP_PATTERN_BODY</name></expr>:</case>

<case>case <expr><name>GREP_PATTERN</name></expr>:</case>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>patternlen</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_grep_expression_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>indent</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_NODE_TRUE</name></expr>:</case>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"true\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_NODE_ATOM</name></expr>:</case>

<expr_stmt><expr><call><name>dump_grep_pat</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_NODE_NOT</name></expr>:</case>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"(not\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_grep_expression_1</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>unary</name></name></expr></argument>, <argument><expr><name>in</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>indent</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_NODE_AND</name></expr>:</case>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"(and\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_grep_expression_1</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>in</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_grep_expression_1</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>in</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>indent</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_NODE_OR</name></expr>:</case>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"(or\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_grep_expression_1</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>in</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_grep_expression_1</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>in</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>indent</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_grep_expression</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>all_match</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[all-match]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dump_grep_expression_1</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>grep_true_expr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>GREP_NODE_TRUE</name></expr>;</expr_stmt>

<return>return <expr><name>z</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>grep_or_expr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>GREP_NODE_OR</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>

<return>return <expr><name>z</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>prep_header_patterns</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>header_expr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><argument_list>(<argument><expr><name><name>header_group</name><index>[<expr><name>GREP_HEADER_FIELD_MAX</name></expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>grep_header_field</name></name></type> <name>fld</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>header_list</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>header_list</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>!=</operator> <name>GREP_PATTERN_HEAD</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"a non-header pattern in grep header list."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name> <operator>&lt;</operator> <name>GREP_HEADER_FIELD_MIN</name> <operator>||</operator>

<name>GREP_HEADER_FIELD_MAX</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unknown header field %d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>compile_regexp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>fld</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fld</name> <operator>&lt;</operator> <name>GREP_HEADER_FIELD_MAX</name></expr>;</condition> <incr><expr><name>fld</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>header_group</name><index>[<expr><name>fld</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>header_list</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>compile_pattern_atom</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>h</name> <operator>||</operator> <name>pp</name> <operator>!=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"malformed header expr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>header_group</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>header_group</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr>]</index></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>header_group</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr>]</index></name> <operator>=</operator> <call><name>grep_or_expr</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>header_group</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>header_expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>fld</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fld</name> <operator>&lt;</operator> <name>GREP_HEADER_FIELD_MAX</name></expr>;</condition> <incr><expr><name>fld</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>header_group</name><index>[<expr><name>fld</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>header_expr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>header_expr</name> <operator>=</operator> <call><name>grep_true_expr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>header_expr</name> <operator>=</operator> <call><name>grep_or_expr</name><argument_list>(<argument><expr><name><name>header_group</name><index>[<expr><name>fld</name></expr>]</index></name></expr></argument>, <argument><expr><name>header_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>header_expr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>grep_splice_or</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>x</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name>GREP_NODE_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name> <operator>&amp;&amp;</operator>

<name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name>GREP_NODE_TRUE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>z</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_grep_patterns_real</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>header_expr</name> <init>= <expr><call><name>prep_header_patterns</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_PATTERN</name></expr>:</case> 

<case>case <expr><name>GREP_PATTERN_HEAD</name></expr>:</case>

<case>case <expr><name>GREP_PATTERN_BODY</name></expr>:</case>

<expr_stmt><expr><call><name>compile_regexp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>extended</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>all_match</name></name> <operator>||</operator> <name>header_expr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>extended</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>extended</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name> <operator>=</operator> <call><name>compile_pattern_expr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"incomplete pattern expression: %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>header_expr</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name> <operator>=</operator> <name>header_expr</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>all_match</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name> <operator>=</operator> <call><name>grep_splice_or</name><argument_list>(<argument><expr><name>header_expr</name></expr></argument>,

<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name> <operator>=</operator> <call><name>grep_or_expr</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name></expr></argument>,

<argument><expr><name>header_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>all_match</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>compile_grep_patterns</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>compile_grep_patterns_real</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dump_grep_expression</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_pattern_expr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_NODE_TRUE</name></expr>:</case>

<case>case <expr><name>GREP_NODE_ATOM</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>GREP_NODE_NOT</name></expr>:</case>

<expr_stmt><expr><call><name>free_pattern_expr</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>unary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_NODE_AND</name></expr>:</case>

<case>case <expr><name>GREP_NODE_OR</name></expr>:</case>

<expr_stmt><expr><call><name>free_pattern_expr</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_pattern_expr</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_grep_patterns</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name>n</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_PATTERN</name></expr>:</case> 

<case>case <expr><name>GREP_PATTERN_HEAD</name></expr>:</case>

<case>case <expr><name>GREP_PATTERN_BODY</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_regexp</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free_pcre1_regexp</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free_pcre2_pattern</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>regexp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>extended</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free_pattern_expr</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>end_of_line</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>left</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>l</name> <init>= <expr><operator>*</operator><name>left</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>l</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>l</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>left</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>

<return>return <expr><name>cp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>word_char</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>isalnum</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'_'</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>output_color</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>color</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>want_color</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>color</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>color</name> <operator>&amp;&amp;</operator> <name><name>color</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>GIT_COLOR_RESET</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>GIT_COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>output_sep</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>sign</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>null_following_name</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"\0"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sign</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_SEP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_FILENAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>null_following_name</name></name></expr> ?</condition><then> <expr><literal type="string">"\0"</literal></expr> </then><else>: <expr><literal type="string">"\n"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>patmatch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre1_regexp</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <operator>!</operator><call><name>pcre1match</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pcre2_pattern</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <operator>!</operator><call><name>pcre2match</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <operator>!</operator><call><name>regexec_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>regexp</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>eol</name> <operator>-</operator> <name>line</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>match</name></expr></argument>,

<argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>strip_timestamp</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eol_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><operator>*</operator><name>eol_p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>bol</name> <operator>&lt;</operator> <operator>--</operator><name>eol</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>eol</name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>eol_p</name> <operator>=</operator> <operator>++</operator><name>eol</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>eol</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>ch</name></expr>;</return>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>field</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

}</block> <decl><name><name>header_field</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><literal type="string">"author "</literal></expr>, <expr><literal type="number">7</literal></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"committer "</literal></expr>, <expr><literal type="number">10</literal></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"reflog "</literal></expr>, <expr><literal type="number">7</literal></expr> }</block></expr>,

}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_one_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>grep_context</name></name></type> <name>ctx</name></decl></parameter>,

<parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>saved_ch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>bol</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>!=</operator> <name>GREP_PATTERN</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>==</operator> <name>GREP_PATTERN_HEAD</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>ctx</name> <operator>==</operator> <name>GREP_CONTEXT_HEAD</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>==</operator> <name>GREP_PATTERN_HEAD</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>field</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>header_field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>field</name> <operator>=</operator> <name><name>header_field</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr>]</index></name><operator>.</operator><name>field</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>header_field</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>bol</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bol</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>field</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_HEADER_AUTHOR</name></expr>:</case>

<case>case <expr><name>GREP_HEADER_COMMITTER</name></expr>:</case>

<expr_stmt><expr><name>saved_ch</name> <operator>=</operator> <call><name>strip_timestamp</name><argument_list>(<argument><expr><name>bol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<label><name>again</name>:</label>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>patmatch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>word_regexp</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>eol</name> <operator>-</operator> <name>bol</name><operator>)</operator> <operator>&lt;</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>||</operator>

<operator>(</operator><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>eol</name> <operator>-</operator> <name>bol</name><operator>)</operator> <operator>&lt;</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"regexp returned nonsense"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><operator>(</operator><operator>(</operator><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>!</operator><call><name>word_char</name><argument_list>(<argument><expr><name><name>bol</name><index>[<expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>(</operator><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>==</operator> <operator>(</operator><name>eol</name><operator>-</operator><name>bol</name><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>!</operator><call><name>word_char</name><argument_list>(<argument><expr><name><name>bol</name><index>[<expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pmatch</name><operator>-&gt;</operator><name>rm_so</name></name> <operator>==</operator> <name><name>pmatch</name><operator>-&gt;</operator><name>rm_eo</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hit</name> <operator>&amp;&amp;</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>+</operator> <name>bol</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>eol</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bol</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>+</operator> <name>bol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>word_char</name><argument_list>(<argument><expr><name><name>bol</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bol</name> <operator>&lt;</operator> <name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>REG_NOTBOL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bol</name> <operator>&lt;</operator> <name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>again</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>==</operator> <name>GREP_PATTERN_HEAD</name> <operator>&amp;&amp;</operator> <name>saved_ch</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <name>saved_ch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>+=</operator> <name>bol</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>+=</operator> <name>bol</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_expr_eval</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>grep_context</name></name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>col</name></decl></parameter>,

<parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>icol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>collect_hits</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a valid grep expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_NODE_TRUE</name></expr>:</case>

<expr_stmt><expr><name>h</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_NODE_ATOM</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>regmatch_t</name></type> <name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>match_one_pattern</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>atom</name></name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>col</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tmp</name><operator>.</operator><name>rm_so</name></name> <operator>&lt;</operator> <operator>*</operator><name>col</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>col</name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>rm_so</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>GREP_NODE_NOT</name></expr>:</case>

<expr_stmt><expr><name>h</name> <operator>=</operator> <operator>!</operator><call><name>match_expr_eval</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>unary</name></name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>icol</name></expr></argument>, <argument><expr><name>col</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_NODE_AND</name></expr>:</case>

<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>match_expr_eval</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>col</name></expr></argument>,

<argument><expr><name>icol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>columnnum</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>h</name> <operator>&amp;=</operator> <call><name>match_expr_eval</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>,

<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>icol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>GREP_NODE_OR</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>collect_hits</name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>columnnum</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><call><name>match_expr_eval</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>,

<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>icol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>match_expr_eval</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>bol</name></expr></argument>,

<argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>icol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>match_expr_eval</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name></name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>col</name></expr></argument>,

<argument><expr><name>icol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>collect_hits</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name><operator>-&gt;</operator><name>hit</name></name> <operator>|=</operator> <name>h</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>h</name> <operator>|=</operator> <call><name>match_expr_eval</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>col</name></expr></argument>,

<argument><expr><name>icol</name></expr></argument>, <argument><expr><name>collect_hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unexpected node type (internal error) %d"</literal></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>collect_hits</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>hit</name></name> <operator>|=</operator> <name>h</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>h</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_expr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>grep_context</name></name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>col</name></decl></parameter>,

<parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>icol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>collect_hits</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>match_expr_eval</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>icol</name></expr></argument>, <argument><expr><name>collect_hits</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_line</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>col</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name> <modifier>*</modifier></type><name>icol</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>grep_context</name></name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>collect_hits</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>extended</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>match_expr</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>icol</name></expr></argument>,

<argument><expr><name>collect_hits</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>regmatch_t</name></type> <name>tmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>match_one_pattern</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>columnnum</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>col</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tmp</name><operator>.</operator><name>rm_so</name></name> <operator>&lt;</operator> <operator>*</operator><name>col</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>col</name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>rm_so</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_next_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>grep_context</name></name></type> <name>ctx</name></decl></parameter>,

<parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>regmatch_t</name></type> <name>match</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_one_pattern</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>match</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>match</name><operator>.</operator><name>rm_so</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>match</name><operator>.</operator><name>rm_eo</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pmatch</name><operator>-&gt;</operator><name>rm_so</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pmatch</name><operator>-&gt;</operator><name>rm_eo</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>match</name><operator>.</operator><name>rm_so</name></name> <operator>&gt;</operator> <name><name>pmatch</name><operator>-&gt;</operator><name>rm_so</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>match</name><operator>.</operator><name>rm_so</name></name> <operator>==</operator> <name><name>pmatch</name><operator>-&gt;</operator><name>rm_so</name></name> <operator>&amp;&amp;</operator> <name><name>match</name><operator>.</operator><name>rm_eo</name></name> <operator>&lt;</operator> <name><name>pmatch</name><operator>-&gt;</operator><name>rm_eo</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pmatch</name><operator>-&gt;</operator><name>rm_so</name></name> <operator>=</operator> <name><name>match</name><operator>.</operator><name>rm_so</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pmatch</name><operator>-&gt;</operator><name>rm_eo</name></name> <operator>=</operator> <name><name>match</name><operator>.</operator><name>rm_eo</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>next_match</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>grep_context</name></name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>pmatch</name><operator>-&gt;</operator><name>rm_so</name></name> <operator>=</operator> <name><name>pmatch</name><operator>-&gt;</operator><name>rm_eo</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bol</name> <operator>&lt;</operator> <name>eol</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_PATTERN</name></expr>:</case> 

<case>case <expr><name>GREP_PATTERN_HEAD</name></expr>:</case>

<case>case <expr><name>GREP_PATTERN_BODY</name></expr>:</case>

<expr_stmt><expr><name>hit</name> <operator>|=</operator> <call><name>match_next_pattern</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>,

<argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_line_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name></type> <name>lno</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>cno</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>sign</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>heading</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_FILENAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name> <operator>=</operator> <name>lno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>heading</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>pathname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_FILENAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_sep</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>linenum</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>lno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_LINENO</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_sep</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>columnnum</name></name> <operator>&amp;&amp;</operator> <name>cno</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIuMAX</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>cno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_COLUMNNO</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_sep</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_line</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>lno</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>cno</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>sign</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rest</name> <init>= <expr><name>eol</name> <operator>-</operator> <name>bol</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match_color</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line_color</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>file_break</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>show_hunk_mark</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>pre_context</name></name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>post_context</name></name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>funcbody</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>show_hunk_mark</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_SEP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lno</name> <operator>&gt;</operator> <name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_SEP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>only_matching</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>show_line_header</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>lno</name></expr></argument>, <argument><expr><name>cno</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>color</name></name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>only_matching</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>regmatch_t</name></type> <name>match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>grep_context</name></name></type> <name>ctx</name> <init>= <expr><name>GREP_CONTEXT_BODY</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>eol</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>eflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>color</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>match_color</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_MATCH_SELECTED</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>match_color</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_MATCH_CONTEXT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>line_color</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_SELECTED</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>sign</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>line_color</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_CONTEXT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>sign</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>line_color</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_FUNCTION</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>next_match</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>match</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>match</name><operator>.</operator><name>rm_so</name></name> <operator>==</operator> <name><name>match</name><operator>.</operator><name>rm_eo</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>only_matching</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>show_line_header</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>lno</name></expr></argument>, <argument><expr><name>cno</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name><name>match</name><operator>.</operator><name>rm_so</name></name></expr></argument>, <argument><expr><name>line_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name> <operator>+</operator> <name><name>match</name><operator>.</operator><name>rm_so</name></name></expr></argument>,

<argument><expr><name><name>match</name><operator>.</operator><name>rm_eo</name></name> <operator>-</operator> <name><name>match</name><operator>.</operator><name>rm_so</name></name></expr></argument>, <argument><expr><name>match_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>only_matching</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bol</name> <operator>+=</operator> <name><name>match</name><operator>.</operator><name>rm_eo</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cno</name> <operator>+=</operator> <name><name>match</name><operator>.</operator><name>rm_eo</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>rest</name> <operator>-=</operator> <name><name>match</name><operator>.</operator><name>rm_eo</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>eflags</name> <operator>=</operator> <name>REG_NOTBOL</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>only_matching</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>line_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><name>int</name></type> <name>grep_use_locks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>grep_attr_mutex</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>grep_attr_lock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>grep_use_locks</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grep_attr_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>grep_attr_unlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>grep_use_locks</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grep_attr_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_funcname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>xdemitconf_t</name> <modifier>*</modifier></type><name>xecfg</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>xecfg</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>xecfg</name><operator>-&gt;</operator><name>find_func</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>grep_source_load_driver</name><argument_list>(<argument><expr><name>gs</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>driver</name><operator>-&gt;</operator><name>funcname</name><operator>.</operator><name>pattern</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>userdiff_funcname</name></name> <modifier>*</modifier></type><name>pe</name> <init>= <expr><operator>&amp;</operator><name><name>gs</name><operator>-&gt;</operator><name>driver</name><operator>-&gt;</operator><name>funcname</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xdiff_set_find_func</name><argument_list>(<argument><expr><name>xecfg</name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>cflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>xecfg</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>xecfg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<return>return <expr><call><name><name>xecfg</name><operator>-&gt;</operator><name>find_func</name></name><argument_list>(<argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name> <operator>-</operator> <name>bol</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,

<argument><expr><name><name>xecfg</name><operator>-&gt;</operator><name>find_func_priv</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bol</name> <operator>==</operator> <name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>*</operator><name>bol</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>bol</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>||</operator> <operator>*</operator><name>bol</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_funcname_line</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>lno</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>bol</name> <operator>&gt;</operator> <name><name>gs</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><operator>--</operator><name>bol</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>bol</name> <operator>&gt;</operator> <name><name>gs</name><operator>-&gt;</operator><name>buf</name></name> <operator>&amp;&amp;</operator> <name><name>bol</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bol</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>lno</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lno</name> <operator>&lt;=</operator> <name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>match_funcname</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>show_line</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>is_empty_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_pre_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>lno</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>cur</name> <init>= <expr><name>lno</name></expr></init></decl>, <decl><type ref="prev"/><name>from</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>funcname_lno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>orig_from</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>funcname_needed</name> <init>= <expr><operator>!</operator><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>funcname</name></name></expr></init></decl>, <decl><type ref="prev"/><name>comment_needed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>pre_context</name></name> <operator>&lt;</operator> <name>lno</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name>lno</name> <operator>-</operator> <name><name>opt</name><operator>-&gt;</operator><name>pre_context</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&lt;=</operator> <name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>orig_from</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>funcbody</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>match_funcname</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>comment_needed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>funcname_needed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>bol</name> <operator>&gt;</operator> <name><name>gs</name><operator>-&gt;</operator><name>buf</name></name> <operator>&amp;&amp;</operator> <name>cur</name> <operator>&gt;</operator> <name>from</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next_bol</name> <init>= <expr><name>bol</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><operator>--</operator><name>bol</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>bol</name> <operator>&gt;</operator> <name><name>gs</name><operator>-&gt;</operator><name>buf</name></name> <operator>&amp;&amp;</operator> <name><name>bol</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bol</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>cur</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>comment_needed</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>is_empty_line</name><argument_list>(<argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>match_funcname</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>comment_needed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name>orig_from</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>&lt;</operator> <name>from</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cur</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>bol</name> <operator>=</operator> <name>next_bol</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>funcname_needed</name> <operator>&amp;&amp;</operator> <call><name>match_funcname</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>funcname_lno</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>

<expr_stmt><expr><name>funcname_needed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>funcbody</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>comment_needed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name>orig_from</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>funcname</name></name> <operator>&amp;&amp;</operator> <name>funcname_needed</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>show_funcname_line</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>cur</name> <operator>&lt;</operator> <name>lno</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><name>bol</name></expr></init></decl>, <decl><type ref="prev"/><name>sign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>cur</name> <operator>==</operator> <name>funcname_lno</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'='</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>eol</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>eol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><call><name>show_line</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bol</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>cur</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>should_lookahead</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>extended</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>invert</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>token</name></name> <operator>!=</operator> <name>GREP_PATTERN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>look_ahead</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>left_p</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>lno_p</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>bol_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>lno</name> <init>= <expr><operator>*</operator><name>lno_p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name> <init>= <expr><operator>*</operator><name>bol_p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_pat</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last_bol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regoff_t</name></type> <name>earliest</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>pattern_list</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regmatch_t</name></type> <name>m</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>patmatch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>bol</name> <operator>+</operator> <operator>*</operator><name>left_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hit</name> <operator>||</operator> <name><name>m</name><operator>.</operator><name>rm_so</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>m</name><operator>.</operator><name>rm_eo</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>earliest</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>m</name><operator>.</operator><name>rm_so</name></name> <operator>&lt;</operator> <name>earliest</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>earliest</name> <operator>=</operator> <name><name>m</name><operator>.</operator><name>rm_so</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>earliest</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>bol_p</name> <operator>=</operator> <name>bol</name> <operator>+</operator> <operator>*</operator><name>left_p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>left_p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>bol</name> <operator>+</operator> <name>earliest</name></expr>;</init> <condition><expr><name>bol</name> <operator>&lt;</operator> <name>sp</name> <operator>&amp;&amp;</operator> <name><name>sp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>;</condition> <incr><expr><name>sp</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for> 

<expr_stmt><expr><name>last_bol</name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>bol</name></expr>;</init> <condition><expr><name>sp</name> <operator>&lt;</operator> <name>last_bol</name></expr>;</condition> <incr><expr><name>sp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>lno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>left_p</name> <operator>-=</operator> <name>last_bol</name> <operator>-</operator> <name>bol</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>bol_p</name> <operator>=</operator> <name>last_bol</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>lno_p</name> <operator>=</operator> <name>lno</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fill_textconv_grep</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>userdiff_driver</name></name> <modifier>*</modifier></type><name>driver</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>df</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>driver</name> <operator>||</operator> <operator>!</operator><name><name>driver</name><operator>-&gt;</operator><name>textconv</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>grep_source_load</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>df</name> <operator>=</operator> <call><name>alloc_filespec</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_SOURCE_OID</name></expr>:</case>

<expr_stmt><expr><call><name>fill_filespec</name><argument_list>(<argument><expr><name>df</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0100644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_SOURCE_FILE</name></expr>:</case>

<expr_stmt><expr><call><name>fill_filespec</name><argument_list>(<argument><expr><name>df</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0100644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"attempt to textconv something without a path?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>obj_read_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>fill_textconv</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>driver</name></expr></argument>, <argument><expr><name>df</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>obj_read_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_filespec</name><argument_list>(<argument><expr><name>df</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_source_clear_data</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_empty_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bol</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>bol</name> <operator>&lt;</operator> <name>eol</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>bol</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bol</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><name>bol</name> <operator>==</operator> <name>eol</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_source_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>collect_hits</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>peek_bol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>left</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>lno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>last_hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>binary_match_only</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>try_lookahead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>show_function</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>userdiff_driver</name></name> <modifier>*</modifier></type><name>textconv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>grep_context</name></name></type> <name>ctx</name> <init>= <expr><name>GREP_CONTEXT_HEAD</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>xdemitconf_t</name></type> <name>xecfg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>status_only</name></name> <operator>&amp;&amp;</operator> <name><name>gs</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"grep call which could print a name requires "</literal>

<literal type="string">"grep_source.name be non-NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>output</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>output</name></name> <operator>=</operator> <name>std_output</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>pre_context</name></name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>post_context</name></name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>file_break</name></name> <operator>||</operator>

<name><name>opt</name><operator>-&gt;</operator><name>funcbody</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>show_hunk_mark</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>output</name></name> <operator>!=</operator> <name>std_output</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>show_hunk_mark</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>last_shown</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>allow_textconv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>grep_source_load_driver</name><argument_list>(<argument><expr><name>gs</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_attr_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>obj_read_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>textconv</name> <operator>=</operator> <call><name>userdiff_get_textconv</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>driver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>obj_read_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_attr_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>textconv</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_BINARY_DEFAULT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>grep_source_is_binary</name><argument_list>(<argument><expr><name>gs</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>binary_match_only</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>GREP_BINARY_NOMATCH</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>grep_source_is_binary</name><argument_list>(<argument><expr><name>gs</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<break>break;</break>

<case>case <expr><name>GREP_BINARY_TEXT</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unknown binary handling mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xecfg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xecfg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name></name> <operator>=</operator> <operator>&amp;</operator><name>xecfg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>try_lookahead</name> <operator>=</operator> <call><name>should_lookahead</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fill_textconv_grep</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>textconv</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bol</name> <operator>=</operator> <name><name>gs</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>gs</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>left</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>cno</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>icol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>try_lookahead</name>

<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>last_hit</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>show_function</name> <operator>||</operator>

<name>lno</name> <operator>&lt;=</operator> <name>last_hit</name> <operator>+</operator> <name><name>opt</name><operator>-&gt;</operator><name>post_context</name></name><operator>)</operator><operator>)</operator>

<operator>&amp;&amp;</operator> <call><name>look_ahead</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bol</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>bol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>eol</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ctx</name> <operator>==</operator> <name>GREP_CONTEXT_HEAD</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>eol</name> <operator>==</operator> <name>bol</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ctx</name> <operator>=</operator> <name>GREP_CONTEXT_BODY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>match_line</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>col</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>icol</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>collect_hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>collect_hits</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>next_line</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>invert</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <operator>!</operator><name>hit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>unmatch_name_only</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>hit</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<goto>goto <name>next_line</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>status_only</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>name_only</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>show_name</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>next_line</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>binary_match_only</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"Binary file "</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_FILENAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">" matches\n"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>pre_context</name></name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>funcbody</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>show_pre_context</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>lno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>funcname</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>show_funcname_line</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>lno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cno</name> <operator>=</operator> <ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>invert</name></name></expr> ?</condition><then> <expr><name>icol</name></expr> </then><else>: <expr><name>col</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>show_line</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lno</name></expr></argument>, <argument><expr><name>cno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_hit</name> <operator>=</operator> <name>lno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>funcbody</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>show_function</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>next_line</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_function</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>peek_bol</name> <operator>||</operator> <name>peek_bol</name> <operator>&lt;</operator> <name>bol</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>peek_left</name> <init>= <expr><name>left</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>peek_eol</name> <init>= <expr><name>eol</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>peek_bol</name> <operator>=</operator> <name>bol</name></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>is_empty_line</name><argument_list>(<argument><expr><name>peek_bol</name></expr></argument>, <argument><expr><name>peek_eol</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>peek_bol</name> <operator>=</operator> <name>peek_eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>peek_eol</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>peek_bol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peek_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>match_funcname</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><name>peek_bol</name></expr></argument>, <argument><expr><name>peek_eol</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>show_function</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_function</name> <operator>||</operator>

<operator>(</operator><name>last_hit</name> <operator>&amp;&amp;</operator> <name>lno</name> <operator>&lt;=</operator> <name>last_hit</name> <operator>+</operator> <name><name>opt</name><operator>-&gt;</operator><name>post_context</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>show_line</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lno</name></expr></argument>, <argument><expr><name>col</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>next_line</name>:</label>

<expr_stmt><expr><name>bol</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>left</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>left</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>lno</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>collect_hits</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>status_only</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>opt</name><operator>-&gt;</operator><name>unmatch_name_only</name></name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>unmatch_name_only</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>show_name</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xdiff_clear_find_func</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xecfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>count</name></name> <operator>&amp;&amp;</operator> <name>count</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>pathname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>output_color</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>colors</name><index>[<expr><name>GREP_COLOR_FILENAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_sep</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%u\n"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>opt</name><operator>-&gt;</operator><name>output</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>!</operator><operator>!</operator><name>last_hit</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clr_hit_marker</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>hit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name> <operator>!=</operator> <name>GREP_NODE_OR</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name><operator>-&gt;</operator><name>hit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>chk_hit_marker</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_expr</name></name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>node</name></name> <operator>!=</operator> <name>GREP_NODE_OR</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>x</name><operator>-&gt;</operator><name>hit</name></name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>left</name><operator>-&gt;</operator><name>hit</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>binary</name><operator>.</operator><name>right</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>grep_source</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>all_match</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>grep_source_1</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>clr_hit_marker</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_source_1</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>chk_hit_marker</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>pattern_expression</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>grep_source_1</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>grep_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_opt</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>grep_source</name></name></type> <name>gs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>grep_source_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>, <argument><expr><name>GREP_SOURCE_BUF</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>grep_source</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_source_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>grep_source_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>grep_source_type</name></name></type> <name>type</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>identifier</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>xstrdup_or_null</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>xstrdup_or_null</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>driver</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_SOURCE_FILE</name></expr>:</case>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>identifier</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_SOURCE_OID</name></expr>:</case>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>identifier</name></name> <operator>=</operator> <call><name>oiddup</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_SOURCE_BUF</name></expr>:</case>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>identifier</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>grep_source_clear</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grep_source_clear_data</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>grep_source_clear_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_SOURCE_FILE</name></expr>:</case>

<case>case <expr><name>GREP_SOURCE_OID</name></expr>:</case>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>GREP_SOURCE_BUF</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_source_load_oid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gs</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"'%s': unable to read %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_source_load_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name><name>gs</name><operator>-&gt;</operator><name>identifier</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<label><name>err_ret</name>:</label>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to stat '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>xsize_t</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>err_ret</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>xmallocz</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>!=</operator> <call><name>read_in_full</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"'%s': short read"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_source_load</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GREP_SOURCE_FILE</name></expr>:</case>

<return>return <expr><call><name>grep_source_load_file</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>GREP_SOURCE_OID</name></expr>:</case>

<return>return <expr><call><name>grep_source_load_oid</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>GREP_SOURCE_BUF</name></expr>:</case>

<return>return <expr><ternary><condition><expr><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"invalid grep_source type to load"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>grep_source_load_driver</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>driver</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>grep_attr_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>path</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>driver</name></name> <operator>=</operator> <call><name>userdiff_find_by_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gs</name><operator>-&gt;</operator><name>driver</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>driver</name></name> <operator>=</operator> <call><name>userdiff_find_by_name</name><argument_list>(<argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>grep_attr_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grep_source_is_binary</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grep_source</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>grep_source_load_driver</name><argument_list>(<argument><expr><name>gs</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>driver</name><operator>-&gt;</operator><name>binary</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>gs</name><operator>-&gt;</operator><name>driver</name><operator>-&gt;</operator><name>binary</name></name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grep_source_load</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>buffer_is_binary</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
