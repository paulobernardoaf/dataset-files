<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\add-patch.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"add-interactive.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"strbuf.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"argv-array.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pathspec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"color.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/terminal.h"</cpp:file></cpp:include>

<enum>enum <name>prompt_mode_type</name> <block>{

<decl><name>PROMPT_MODE_CHANGE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>PROMPT_DELETION</name></decl>, <decl><name>PROMPT_HUNK</name></decl>,

<decl><name>PROMPT_MODE_MAX</name></decl>, 

}</block>;</enum>

<struct>struct <name>patch_mode</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>diff_cmd</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name><name>apply_args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name><name>apply_check_args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>is_reverse</name><range>:<expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>index_only</name><range>:<expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>apply_for_checkout</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>prompt_mode</name><index>[<expr><name>PROMPT_MODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>edit_hunk_hint</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>help_patch_text</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_add</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-files"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Stage mode change [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Stage deletion [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<macro><name>N_</name><argument_list>(<argument><literal type="string">"Stage this hunk [y,n,q,a,d%s,?]? "</literal></argument>)</argument_list></macro>

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for staging."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<macro><name>N_</name><argument_list>(<argument><literal type="string">"y - stage this hunk\n"</literal>

<literal type="string">"n - do not stage this hunk\n"</literal>

<literal type="string">"q - quit; do not stage this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - stage this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not stage this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></argument>)</argument_list></macro></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_stash</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-index"</literal></expr>, <expr><literal type="string">"HEAD"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Stash mode change [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Stash deletion [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Stash this hunk [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for stashing."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<call><name>N_</name><argument_list>(<argument><expr><literal type="string">"y - stash this hunk\n"</literal>

<literal type="string">"n - do not stash this hunk\n"</literal>

<literal type="string">"q - quit; do not stash this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - stash this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not stash this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_reset_head</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-index"</literal></expr>, <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"-R"</literal></expr>, <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"-R"</literal></expr>, <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>is_reverse</name> <operator>=</operator> <literal type="number">1</literal></expr>,

<expr><operator>.</operator><name>index_only</name> <operator>=</operator> <literal type="number">1</literal></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Unstage mode change [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Unstage deletion [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Unstage this hunk [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for unstaging."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<call><name>N_</name><argument_list>(<argument><expr><literal type="string">"y - unstage this hunk\n"</literal>

<literal type="string">"n - do not unstage this hunk\n"</literal>

<literal type="string">"q - quit; do not unstage this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - unstage this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not unstage this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_reset_nothead</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-index"</literal></expr>, <expr><literal type="string">"-R"</literal></expr>, <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"--cached"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>index_only</name> <operator>=</operator> <literal type="number">1</literal></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply mode change to index [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply deletion to index [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply this hunk to index [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for applying."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<call><name>N_</name><argument_list>(<argument><expr><literal type="string">"y - apply this hunk to index\n"</literal>

<literal type="string">"n - do not apply this hunk to index\n"</literal>

<literal type="string">"q - quit; do not apply this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - apply this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not apply this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_checkout_index</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-files"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"-R"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"-R"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>is_reverse</name> <operator>=</operator> <literal type="number">1</literal></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard mode change from worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard deletion from worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard this hunk from worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for discarding."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<call><name>N_</name><argument_list>(<argument><expr><literal type="string">"y - discard this hunk from worktree\n"</literal>

<literal type="string">"n - do not discard this hunk from worktree\n"</literal>

<literal type="string">"q - quit; do not discard this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - discard this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not discard this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_checkout_head</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-index"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_for_checkout</name> <operator>=</operator> <literal type="number">1</literal></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"-R"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>is_reverse</name> <operator>=</operator> <literal type="number">1</literal></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard mode change from index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard deletion from index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard this hunk from index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for discarding."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<call><name>N_</name><argument_list>(<argument><expr><literal type="string">"y - discard this hunk from index and worktree\n"</literal>

<literal type="string">"n - do not discard this hunk from index and worktree\n"</literal>

<literal type="string">"q - quit; do not discard this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - discard this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not discard this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_checkout_nothead</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-index"</literal></expr>, <expr><literal type="string">"-R"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_for_checkout</name> <operator>=</operator> <literal type="number">1</literal></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply mode change to index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply deletion to index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply this hunk to index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for applying."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<call><name>N_</name><argument_list>(<argument><expr><literal type="string">"y - apply this hunk to index and worktree\n"</literal>

<literal type="string">"n - do not apply this hunk to index and worktree\n"</literal>

<literal type="string">"q - quit; do not apply this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - apply this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not apply this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_worktree_head</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-index"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"-R"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><literal type="string">"-R"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>is_reverse</name> <operator>=</operator> <literal type="number">1</literal></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard mode change from index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard deletion from index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Discard this hunk from index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for discarding."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<call><name>N_</name><argument_list>(<argument><expr><literal type="string">"y - discard this hunk from worktree\n"</literal>

<literal type="string">"n - do not discard this hunk from worktree\n"</literal>

<literal type="string">"q - quit; do not discard this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - discard this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not discard this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>patch_mode</name></name></type> <name>patch_mode_worktree_nothead</name> <init>= <expr><block>{

<expr><operator>.</operator><name>diff_cmd</name> <operator>=</operator> <block>{ <expr><literal type="string">"diff-index"</literal></expr>, <expr><literal type="string">"-R"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_args</name> <operator>=</operator> <block>{ <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>apply_check_args</name> <operator>=</operator> <block>{ <expr><name>NULL</name></expr> }</block></expr>,

<expr><operator>.</operator><name>prompt_mode</name> <operator>=</operator> <block>{

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply mode change to index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply deletion to index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply this hunk to index and worktree [y,n,q,a,d%s,?]? "</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr>,

<expr><operator>.</operator><name>edit_hunk_hint</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"If the patch applies cleanly, the edited hunk "</literal>

<literal type="string">"will immediately be marked for applying."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>help_patch_text</name> <operator>=</operator>

<call><name>N_</name><argument_list>(<argument><expr><literal type="string">"y - apply this hunk to worktree\n"</literal>

<literal type="string">"n - do not apply this hunk to worktree\n"</literal>

<literal type="string">"q - quit; do not apply this hunk or any of the remaining "</literal>

<literal type="string">"ones\n"</literal>

<literal type="string">"a - apply this hunk and all later hunks in the file\n"</literal>

<literal type="string">"d - do not apply this hunk or any of the later hunks in "</literal>

<literal type="string">"the file\n"</literal></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<struct>struct <name>hunk_header</name> <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>old_offset</name></decl>, <decl><type ref="prev"/><name>old_count</name></decl>, <decl><type ref="prev"/><name>new_offset</name></decl>, <decl><type ref="prev"/><name>new_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>extra_start</name></decl>, <decl><type ref="prev"/><name>extra_end</name></decl>, <decl><type ref="prev"/><name>colored_extra_start</name></decl>, <decl><type ref="prev"/><name>colored_extra_end</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>hunk</name> <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>colored_start</name></decl>, <decl><type ref="prev"/><name>colored_end</name></decl>, <decl><type ref="prev"/><name>splittable_into</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>delta</name></decl>;</decl_stmt>

<enum>enum <block>{ <decl><name>UNDECIDED_HUNK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>SKIP_HUNK</name></decl>, <decl><name>USE_HUNK</name></decl> }</block> <decl><name>use</name></decl>;</enum>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk_header</name></name></type> <name>header</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>add_p_state</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>add_i_state</name></name></type> <name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>answer</name></decl>, <decl><type ref="prev"/><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>plain</name></decl>, <decl><type ref="prev"/><name>colored</name></decl>;</decl_stmt>

<struct>struct <name>file_diff</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name></type> <name>head</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>hunk_nr</name></decl>, <decl><type ref="prev"/><name>hunk_alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>deleted</name><range>:<expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>mode_change</name><range>:<expr><literal type="number">1</literal></expr></range></decl>,<decl><type ref="prev"/><name>binary</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block> <decl><modifier>*</modifier><name>file_diff</name></decl>;</struct>

<decl_stmt><decl><type><name>size_t</name></type> <name>file_diff_nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>patch_mode</name></name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>revision</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>err</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>error_color</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>reset_color</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setup_child_process</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>arg</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>git_cmd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_pushf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>env_array</name></name></expr></argument>,

<argument><expr><name>INDEX_ENVIRONMENT</name> <literal type="string">"=%s"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>r</name><operator>-&gt;</operator><name>index_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_range</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pend</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pend</name> <operator>==</operator> <operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pend</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>pend</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>pend</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>*</operator><name>p</name> <operator>==</operator> <name>pend</name> <operator>+</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_hunk_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk_header</name></name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>&amp;</operator><name><name>hunk</name><operator>-&gt;</operator><name>header</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"@@ -"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>parse_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>header</name><operator>-&gt;</operator><name>old_offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>

<operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">" +"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>parse_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>

<operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">" @@"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not parse hunk header '%.*s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name>line</name><operator>)</operator></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>eol</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>eol</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>extra_start</name></name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>extra_end</name></name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>colored_extra_start</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>colored_extra_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memmem</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>eol</name> <operator>-</operator> <name>line</name></expr></argument>, <argument><expr><literal type="string">"@@ -"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not parse colored hunk header '%.*s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name>line</name><operator>)</operator></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memmem</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>eol</name> <operator>-</operator> <name>p</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">" @@"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not parse colored hunk header '%.*s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name>line</name><operator>)</operator></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name> <operator>=</operator> <name>eol</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>eol</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>colored_extra_start</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">3</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>colored_extra_end</name></name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_octal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>p</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr></argument> &gt;</argument_list></name> <literal type="char">'7'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></while>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_diff</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>args</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>diff_algorithm</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>interactive_diff_algorithm</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>plain</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>colored</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>cp</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>colored_p</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>colored_pend</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>marker</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>file_diff_alloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>color_arg_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>argv_array_pushv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>diff_cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>diff_algorithm</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_pushf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><literal type="string">"--diff-algorithm=%s"</literal></expr></argument>, <argument><expr><name>diff_algorithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>revision</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>revision</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>get_oid</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><call><name>empty_tree_oid_hex</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>revision</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>color_arg_index</name> <operator>=</operator> <name><name>args</name><operator>.</operator><name>argc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_pushl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><literal type="string">"--no-color"</literal></expr></argument>, <argument><expr><literal type="string">"-p"</literal></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ps</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>original</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cp</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name><name>args</name><operator>.</operator><name>argv</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>capture_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name>plain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not parse diff"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plain</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_complete_line</name><argument_list>(<argument><expr><name>plain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>want_color_fd</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>colored_cp</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>diff_filter</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>interactive_diff_filter</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colored_cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>args</name><operator>.</operator><name>argv</name><index>[<expr><name>color_arg_index</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"--color"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>colored_cp</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name><name>args</name><operator>.</operator><name>argv</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>colored</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>capture_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>colored_cp</name></expr></argument>, <argument><expr><name>colored</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not parse colored diff"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>diff_filter</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>filter_cp</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter_cp</name></expr></argument>,

<argument><expr><name>diff_filter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>filter_cp</name><operator>.</operator><name>git_cmd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>filter_cp</name><operator>.</operator><name>use_shell</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pipe_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter_cp</name></expr></argument>,

<argument><expr><name><name>colored</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>colored</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>colored</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to run '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>diff_filter</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_swap</name><argument_list>(<argument><expr><name>colored</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_complete_line</name><argument_list>(<argument><expr><name>colored</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>colored_p</name> <operator>=</operator> <name><name>colored</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>colored_pend</name> <operator>=</operator> <name>colored_p</name> <operator>+</operator> <name><name>colored</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>plain</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>!=</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>pend</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>deleted</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mode_change</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <name>pend</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"diff "</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>file_diff_nr</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>file_diff</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>file_diff_nr</name></name></expr></argument>,

<argument><expr><name>file_diff_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file_diff</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>file_diff</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>file_diff_nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>file_diff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>file_diff</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hunk</name> <operator>=</operator> <operator>&amp;</operator><name><name>file_diff</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored_p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name> <operator>=</operator> <name>colored_p</name> <operator>-</operator> <name><name>colored</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>marker</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"diff starts with unexpected line:\n"</literal>

<literal type="string">"%.*s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></if> 

<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"@@ "</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>(</operator><name>hunk</name> <operator>==</operator> <operator>&amp;</operator><name><name>file_diff</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;&amp;</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"deleted file"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>deleted</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>marker</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>marker</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name></expr></argument>, <argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr></argument>,

<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hunk</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name> <operator>=</operator> <name>colored_p</name> <operator>-</operator> <name><name>colored</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>deleted</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>parse_hunk_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>marker</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>hunk</name> <operator>==</operator> <operator>&amp;</operator><name><name>file_diff</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;&amp;</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"old mode "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode_change</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>is_octal</name><argument_list>(<argument><expr><name>mode_change</name></expr></argument>, <argument><expr><name>eol</name> <operator>-</operator> <name>mode_change</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"double mode change?\n\n%.*s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"mode change in the middle?\n\n%.*s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name></expr></argument>, <argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr></argument>,

<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>hunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored_p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name> <operator>=</operator>

<name>colored_p</name> <operator>-</operator> <name><name>colored</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>hunk</name> <operator>==</operator> <operator>&amp;</operator><name><name>file_diff</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;&amp;</operator>

<call><name>skip_prefix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"new mode "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode_change</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>is_octal</name><argument_list>(<argument><expr><name>mode_change</name></expr></argument>, <argument><expr><name>eol</name> <operator>-</operator> <name>mode_change</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"'new mode' without 'old mode'?\n\n%.*s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"mode change in the middle?\n\n%.*s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name> <operator>!=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"'new mode' does not immediately follow "</literal>

<literal type="string">"'old mode'?\n\n%.*s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>hunk</name> <operator>==</operator> <operator>&amp;</operator><name><name>file_diff</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;&amp;</operator>

<call><name>starts_with</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"Binary files "</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>deleted</name></name> <operator>&amp;&amp;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"diff contains delete *and* a mode change?!?\n%.*s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <operator>(</operator><name><name>plain</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>start</name></name><operator>)</operator><operator>)</operator></expr></argument>,

<argument><expr><name><name>plain</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>marker</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>marker</name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>marker</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>marker</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name>eol</name> <operator>==</operator> <name>pend</name></expr> ?</condition><then> <expr><name>pend</name></expr> </then><else>: <expr><name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>plain</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colored_eol</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>colored_p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>,

<argument><expr><name>colored_pend</name> <operator>-</operator> <name>colored_p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>colored_eol</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>colored_p</name> <operator>=</operator> <name>colored_eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>p</name> <operator>!=</operator> <name>pend</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>mismatched_output</name>;</goto></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>colored_p</name> <operator>=</operator> <name>colored_pend</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>=</operator> <name>colored_p</name> <operator>-</operator> <name><name>colored</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode_change</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"mode change in hunk #%d???"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>marker</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>marker</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>colored_p</name> <operator>!=</operator> <name>colored_pend</name></expr>)</condition> <block>{<block_content>

<label><name>mismatched_output</name>:</label>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"mismatched output from interactive.diffFilter"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Your filter must maintain a one-to-one correspondence\n"</literal>

<literal type="string">"between its input and output lines."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>find_next_line</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name><name>sb</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"looking for next line beyond buffer (%d &gt;= %d)\n%s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sb</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>sb</name><operator>-&gt;</operator><name>len</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>eol</name> <operator>-</operator> <name><name>sb</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>render_hunk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl></parameter>,

<parameter><decl><type><name>ssize_t</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colored</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk_header</name></name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>&amp;</operator><name><name>hunk</name><operator>-&gt;</operator><name>header</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hunk</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>old_offset</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>hunk</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>new_offset</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>old_offset</name> <init>= <expr><name><name>header</name><operator>-&gt;</operator><name>old_offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>new_offset</name> <init>= <expr><name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>colored</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>extra_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>extra_end</name></name> <operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>extra_start</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>fraginfo_color</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>colored_extra_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>colored_extra_end</name></name>

<operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>colored_extra_start</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>is_reverse</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>old_offset</name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>new_offset</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"@@ -%lu,%lu +%lu,%lu @@"</literal></expr></argument>,

<argument><expr><name>old_offset</name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name></expr></argument>,

<argument><expr><name>new_offset</name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>GIT_COLOR_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name></expr></argument>,

<argument><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>-</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,

<argument><expr><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>render_diff_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colored</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>skip_mode_change</name> <init>=

<expr><name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name> <operator>&amp;&amp;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>!=</operator> <name>USE_HUNK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>head</name> <init>= <expr><operator>&amp;</operator><name><name>file_diff</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>first</name> <init>= <expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_mode_change</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>render_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>colored</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name><name>head</name><operator>-&gt;</operator><name>colored_start</name></name></expr></argument>,

<argument><expr><name><name>first</name><operator>-&gt;</operator><name>colored_start</name></name> <operator>-</operator> <name><name>head</name><operator>-&gt;</operator><name>colored_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name><name>first</name><operator>-&gt;</operator><name>colored_end</name></name></expr></argument>,

<argument><expr><name><name>head</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>-</operator> <name><name>first</name><operator>-&gt;</operator><name>colored_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name><name>head</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>first</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <name><name>head</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name><name>first</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>head</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>first</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_hunks</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name></decl></parameter>,

<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>hunk_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_all</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>merged</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><operator>*</operator><name>hunk_index</name></expr></init></decl>, <decl><type ref="prev"/><name>delta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name> <init>= <expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk_header</name></name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>&amp;</operator><name><name>merged</name><operator>-&gt;</operator><name>header</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_all</name> <operator>&amp;&amp;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>!=</operator> <name>USE_HUNK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>merged</name> <operator>=</operator> <operator>*</operator><name>hunk</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>merged</name><operator>-&gt;</operator><name>colored_start</name></name> <operator>=</operator> <name><name>merged</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>hunk</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <operator>&amp;</operator><name><name>hunk</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>use_all</name> <operator>&amp;&amp;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>!=</operator> <name>USE_HUNK</name><operator>)</operator> <operator>||</operator>

<name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name> <operator>&gt;=</operator> <name><name>next</name><operator>-&gt;</operator><name>new_offset</name></name> <operator>+</operator> <name><name>merged</name><operator>-&gt;</operator><name>delta</name></name> <operator>||</operator>

<name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name>

<operator>&lt;</operator> <name><name>next</name><operator>-&gt;</operator><name>new_offset</name></name> <operator>+</operator> <name><name>merged</name><operator>-&gt;</operator><name>delta</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>merged</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name> <operator>&amp;&amp;</operator> <name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>merged</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plain</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>overlapping_line_count</name> <init>= <expr><name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name>

<operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name> <operator>-</operator> <name><name>merged</name><operator>-&gt;</operator><name>delta</name></name>

<operator>-</operator> <name><name>next</name><operator>-&gt;</operator><name>new_offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>overlap_end</name> <init>= <expr><name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>overlap_start</name> <init>= <expr><name>overlap_end</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>overlap_next</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>overlapping_line_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>overlap_next</name> <operator>=</operator> <call><name>find_next_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></argument>,

<argument><expr><name>overlap_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>overlap_next</name> <operator>&gt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"failed to find %d context lines "</literal>

<literal type="string">"in:\n%.*s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>overlapping_line_count</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr></argument>,

<argument><expr><name>plain</name> <operator>+</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>plain</name><index>[<expr><name>overlap_end</name></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"expected context line "</literal>

<literal type="string">"#%d in\n%.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name>

<operator>-</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr></argument>,

<argument><expr><name>plain</name> <operator>+</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>overlap_start</name> <operator>=</operator> <name>overlap_end</name></expr>;</expr_stmt>

<expr_stmt><expr><name>overlap_end</name> <operator>=</operator> <name>overlap_next</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>overlap_end</name> <operator>-</operator> <name>overlap_start</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>merged</name><operator>-&gt;</operator><name>start</name></name> <operator>||</operator>

<call><name>memcmp</name><argument_list>(<argument><expr><name>plain</name> <operator>+</operator> <name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name>len</name></expr></argument>,

<argument><expr><name>plain</name> <operator>+</operator> <name>overlap_start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"hunks do not overlap:\n%.*s\n"</literal>

<literal type="string">"\tdoes not end with:\n%.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>merged</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr></argument>,

<argument><expr><name>plain</name> <operator>+</operator> <name><name>merged</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>plain</name> <operator>+</operator> <name>overlap_start</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>start</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></argument>, <argument><expr><name>plain</name> <operator>+</operator> <name><name>merged</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,

<argument><expr><name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>merged</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>plain</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>merged</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></argument>,

<argument><expr><name>plain</name> <operator>+</operator> <name>overlap_end</name></expr></argument>,

<argument><expr><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name>overlap_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>merged</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>merged</name><operator>-&gt;</operator><name>splittable_into</name></name> <operator>+=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>merged</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>merged</name><operator>-&gt;</operator><name>delta</name></name> <operator>+=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>old_offset</name></name> <operator>+</operator> <name><name>next</name><operator>-&gt;</operator><name>old_count</name></name>

<operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>old_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>new_offset</name></name> <operator>+</operator> <name>delta</name>

<operator>+</operator> <name><name>next</name><operator>-&gt;</operator><name>new_count</name></name> <operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>*</operator><name>hunk_index</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>hunk_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>reassemble_patch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_all</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>save_len</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>render_diff_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name></type> <name>merged</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>hunk</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_all</name> <operator>&amp;&amp;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>!=</operator> <name>USE_HUNK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>delta</name> <operator>+=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>old_count</name></name>

<operator>-</operator> <name><name>hunk</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>new_count</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>merge_hunks</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>use_all</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hunk</name> <operator>=</operator> <operator>&amp;</operator><name>merged</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>render_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></argument>, <argument><expr><name>save_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>delta</name> <operator>+=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>split_hunk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>hunk_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>colored</name> <init>= <expr><operator>!</operator><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name></expr></init></decl>, <decl><type ref="prev"/><name>first</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name> <init>= <expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>hunk_index</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>splittable_into</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>end</name></decl>, <decl><type ref="prev"/><name>colored_end</name></decl>, <decl><type ref="prev"/><name>current</name></decl>, <decl><type ref="prev"/><name>colored_current</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>context_line_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk_header</name></name></type> <name>remaining</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>marker</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name> <operator>&gt;=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"invalid hunk index: %d (must be &gt;= 0 and &lt; %d)"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>hunk_index</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>splittable_into</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>colored_end</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>remaining</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name> <operator>+=</operator> <name>splittable_into</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name></expr></argument>, <argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr></argument>, <argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name> <operator>+</operator> <name>splittable_into</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>hunk_index</name> <operator>+</operator> <name>splittable_into</name></expr></argument>,

<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>hunk_index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><operator>(</operator><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name> <operator>-</operator> <name>hunk_index</name> <operator>-</operator> <name>splittable_into</name><operator>)</operator>

<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hunk</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>hunk_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hunk</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>splittable_into</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>&amp;</operator><name><name>hunk</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>colored_current</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>marker</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>context_line_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>splittable_into</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name><index>[<expr><name>current</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ch</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"buffer overrun while splitting hunks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>marker</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>marker</name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>ch</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>start</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>colored_start</name> <operator>=</operator> <name>colored_current</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>context_line_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>marker</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>(</operator><name>ch</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>!=</operator> <literal type="char">'+'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<label><name>next_hunk_line</name>:</label>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <ternary><condition><expr><name>marker</name></expr> ?</condition><then> <expr><name>marker</name></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>context_line_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unhandled diff marker: '%c'"</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>marker</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>find_next_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>colored_current</name> <operator>=</operator>

<call><name>find_next_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name></name></expr></argument>,

<argument><expr><name>colored_current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>||</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"counts are off: %d/%d"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>=</operator> <name>context_line_count</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name> <operator>=</operator> <name>context_line_count</name></expr>;</expr_stmt>

<expr_stmt><expr><name>context_line_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<goto>goto <name>next_hunk_line</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>remaining</name><operator>.</operator><name>old_offset</name></name> <operator>+=</operator> <name><name>header</name><operator>-&gt;</operator><name>old_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remaining</name><operator>.</operator><name>old_count</name></name> <operator>-=</operator> <name><name>header</name><operator>-&gt;</operator><name>old_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remaining</name><operator>.</operator><name>new_offset</name></name> <operator>+=</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>remaining</name><operator>.</operator><name>new_count</name></name> <operator>-=</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>header</name><operator>.</operator><name>old_offset</name></name> <operator>=</operator>

<name><name>header</name><operator>-&gt;</operator><name>old_offset</name></name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>old_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>header</name><operator>.</operator><name>new_offset</name></name> <operator>=</operator>

<name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>+=</operator> <name>context_line_count</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name> <operator>+=</operator> <name>context_line_count</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>=</operator> <name>colored_current</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hunk</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>=</operator> <name><name>hunk</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>use</name></expr>;</expr_stmt>

<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>&amp;</operator><name><name>hunk</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name> <operator>=</operator> <name>context_line_count</name></expr>;</expr_stmt>

<expr_stmt><expr><name>context_line_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>splittable_into</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>marker</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>old_offset</name></name> <operator>!=</operator> <name><name>remaining</name><operator>.</operator><name>old_offset</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"miscounted old_offset: %lu != %lu"</literal></expr></argument>,

<argument><expr><name><name>header</name><operator>-&gt;</operator><name>old_offset</name></name></expr></argument>, <argument><expr><name><name>remaining</name><operator>.</operator><name>old_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name> <operator>!=</operator> <name><name>remaining</name><operator>.</operator><name>new_offset</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"miscounted new_offset: %lu != %lu"</literal></expr></argument>,

<argument><expr><name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name></expr></argument>, <argument><expr><name><name>remaining</name><operator>.</operator><name>new_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>=</operator> <name><name>remaining</name><operator>.</operator><name>old_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name> <operator>=</operator> <name><name>remaining</name><operator>.</operator><name>new_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colored</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>=</operator> <name>colored_end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>recolor_hunk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plain</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>current</name></decl>, <decl><type ref="prev"/><name>eol</name></decl>, <decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_start</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>current</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr>;</init> <condition><expr><name>current</name> <operator>&lt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>eol</name> <operator>=</operator> <name>current</name></expr>;</init> <condition><expr><name>eol</name> <operator>&lt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>;</condition> <incr><expr><name>eol</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>plain</name><index>[<expr><name>eol</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <operator>(</operator><name>eol</name> <operator>&lt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>eol</name> <operator>&gt;</operator> <name>current</name> <operator>&amp;&amp;</operator> <name><name>plain</name><index>[<expr><name>eol</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>eol</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>plain</name><index>[<expr><name>current</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr> ?</condition><then>

<expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>file_old_color</name></name></expr> </then><else>:

<expr><ternary><condition><expr><name><name>plain</name><index>[<expr><name>current</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr> ?</condition><then>

<expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>file_new_color</name></name></expr> </then><else>:

<expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>context_color</name></name></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name></name></expr></argument>, <argument><expr><name>plain</name> <operator>+</operator> <name>current</name></expr></argument>, <argument><expr><name>eol</name> <operator>-</operator> <name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name></name></expr></argument>, <argument><expr><name>GIT_COLOR_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>next</name> <operator>&gt;</operator> <name>eol</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name></name></expr></argument>, <argument><expr><name>plain</name> <operator>+</operator> <name>eol</name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>colored_end</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>edit_hunk_manually</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_commented_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Manual hunk edit mode -- see bottom for "</literal>

<literal type="string">"a quick guide.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>render_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_commented_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"---\n"</literal>

<literal type="string">"To remove '%c' lines, make them ' ' lines "</literal>

<literal type="string">"(context).\n"</literal>

<literal type="string">"To remove '%c' lines, delete them.\n"</literal>

<literal type="string">"Lines starting with %c will be removed.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>is_reverse</name></name></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>is_reverse</name></name></expr> ?</condition><then> <expr><literal type="char">'-'</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr></argument>,

<argument><expr><name>comment_line_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_commented_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>edit_hunk_hint</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_commented_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"If it does not apply cleanly, you will be "</literal>

<literal type="string">"given an opportunity to\n"</literal>

<literal type="string">"edit again. If all lines of the hunk are "</literal>

<literal type="string">"removed, then the edit is\n"</literal>

<literal type="string">"aborted and the hunk is left unchanged.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strbuf_edit_interactively</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"addp-hunk-edit.diff"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>next</name> <init>= <expr><call><name>find_next_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>comment_line_char</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hunk</name><operator>-&gt;</operator><name>end</name></name> <operator>==</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>recolor_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name><index>[<expr><name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator>

<call><name>parse_hunk_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not parse hunk header"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type> <name>recount_edited_hunk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>orig_old_count</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>orig_new_count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk_header</name></name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>&amp;</operator><name><name>hunk</name><operator>-&gt;</operator><name>header</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>=</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <case>case <expr><literal type="char">'\n'</literal></expr>:</case>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>find_next_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>orig_old_count</name> <operator>-</operator> <name>orig_new_count</name>

<operator>-</operator> <name><name>header</name><operator>-&gt;</operator><name>old_count</name></name> <operator>+</operator> <name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>run_apply_check</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>cp</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>reassemble_patch</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>,

<argument><expr><literal type="string">"apply"</literal></expr></argument>, <argument><expr><literal type="string">"--check"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_pushv</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>apply_check_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pipe_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"'git apply --cached' failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_single_character</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>use_single_key</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>read_key_without_echo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>res</name> <operator>==</operator> <name>EOF</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strbuf_getline</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_trim_trailing_newline</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prompt_yesno</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prompt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>color_fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>prompt_color</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_single_character</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>tolower</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> <return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><literal type="char">'y'</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>edit_hunk_loop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>plain_len</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plain</name><operator>.</operator><name>len</name></name></expr></init></decl>, <decl><type ref="prev"/><name>colored_len</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name></type> <name>backup</name></decl>;</decl_stmt>

<expr_stmt><expr><name>backup</name> <operator>=</operator> <operator>*</operator><name>hunk</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>edit_hunk_manually</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>hunk</name> <operator>=</operator> <name>backup</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>delta</name></name> <operator>+=</operator>

<call><name>recount_edited_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>,

<argument><expr><name><name>backup</name><operator>.</operator><name>header</name><operator>.</operator><name>old_count</name></name></expr></argument>,

<argument><expr><name><name>backup</name><operator>.</operator><name>header</name><operator>.</operator><name>new_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>run_apply_check</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></argument>, <argument><expr><name>plain_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name></name></expr></argument>, <argument><expr><name>colored_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>hunk</name> <operator>=</operator> <name>backup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>prompt_yesno</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Your edited hunk does not apply. "</literal>

<literal type="string">"Edit again (saying \"no\" discards!) "</literal>

<literal type="string">"[y/n]? "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_for_checkout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>diff</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>is_reverse</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reverse</name> <init>= <expr><ternary><condition><expr><name>is_reverse</name></expr> ?</condition><then> <expr><literal type="string">"-R"</literal></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>check_index</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>check_worktree</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>apply_index</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>apply_worktree</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>applies_index</name></decl>, <decl><type ref="prev"/><name>applies_worktree</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>check_index</name></expr></argument>,

<argument><expr><literal type="string">"apply"</literal></expr></argument>, <argument><expr><literal type="string">"--cached"</literal></expr></argument>, <argument><expr><literal type="string">"--check"</literal></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>applies_index</name> <operator>=</operator> <operator>!</operator><call><name>pipe_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check_index</name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>check_worktree</name></expr></argument>,

<argument><expr><literal type="string">"apply"</literal></expr></argument>, <argument><expr><literal type="string">"--check"</literal></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>applies_worktree</name> <operator>=</operator> <operator>!</operator><call><name>pipe_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check_worktree</name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>applies_worktree</name> <operator>&amp;&amp;</operator> <name>applies_index</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>apply_index</name></expr></argument>,

<argument><expr><literal type="string">"apply"</literal></expr></argument>, <argument><expr><literal type="string">"--cached"</literal></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pipe_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>apply_index</name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>apply_worktree</name></expr></argument>,

<argument><expr><literal type="string">"apply"</literal></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pipe_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>apply_worktree</name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>applies_index</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The selected hunks do not apply to the index!"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prompt_yesno</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Apply them to the worktree "</literal>

<literal type="string">"anyway? "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>apply_worktree</name></expr></argument>,

<argument><expr><literal type="string">"apply"</literal></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>pipe_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>apply_worktree</name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,

<argument><expr><name><name>diff</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Nothing was applied.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>diff</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>diff</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUMMARY_HEADER_WIDTH</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUMMARY_LINE_WIDTH</name></cpp:macro> <cpp:value>80</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>summarize_hunk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk_header</name></name> <modifier>*</modifier></type><name>header</name> <init>= <expr><operator>&amp;</operator><name><name>hunk</name><operator>-&gt;</operator><name>header</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>plain</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plain</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" -%lu,%lu +%lu,%lu "</literal></expr></argument>,

<argument><expr><name><name>header</name><operator>-&gt;</operator><name>old_offset</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>old_count</name></name></expr></argument>,

<argument><expr><name><name>header</name><operator>-&gt;</operator><name>new_offset</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>new_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>len</name> <operator>&lt;</operator> <name>SUMMARY_HEADER_WIDTH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addchars</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>,

<argument><expr><name>SUMMARY_HEADER_WIDTH</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name><name>out</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>hunk</name><operator>-&gt;</operator><name>start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>find_next_line</name><argument_list>(<argument><expr><name>plain</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>plain</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>hunk</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>plain</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><call><name>find_next_line</name><argument_list>(<argument><expr><name>plain</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>len</name> <operator>&gt;</operator> <name>SUMMARY_LINE_WIDTH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>SUMMARY_LINE_WIDTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_complete_line</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPLAY_HUNKS_LINES</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>display_hunks</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>start_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>end_index</name> <init>= <expr><name>start_index</name> <operator>+</operator> <name>DISPLAY_HUNKS_LINES</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end_index</name> <operator>&gt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>end_index</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>start_index</name> <operator>&lt;</operator> <name>end_index</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name> <init>= <expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>start_index</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"%c%2d: "</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>==</operator> <name>USE_HUNK</name></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr>

</then><else>: <expr><ternary><condition><expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>==</operator> <name>SKIP_HUNK</name></expr> ?</condition><then> <expr><literal type="char">'-'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></else></ternary></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>start_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>summarize_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>end_index</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>help_patch_remainder</name><index>[]</index></name> <init>=

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"j - leave this hunk undecided, see next undecided hunk\n"</literal>

<literal type="string">"J - leave this hunk undecided, see next hunk\n"</literal>

<literal type="string">"k - leave this hunk undecided, see previous undecided hunk\n"</literal>

<literal type="string">"K - leave this hunk undecided, see previous hunk\n"</literal>

<literal type="string">"g - select a hunk to go to\n"</literal>

<literal type="string">"/ - search for a hunk matching the given regex\n"</literal>

<literal type="string">"s - split the current hunk into smaller hunks\n"</literal>

<literal type="string">"e - manually edit the current hunk\n"</literal>

<literal type="string">"? - print help\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>patch_update_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>add_p_state</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>file_diff</name></name> <modifier>*</modifier></type><name>file_diff</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>hunk_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>undecided_previous</name></decl>, <decl><type ref="prev"/><name>undecided_next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>hunk</name></name> <modifier>*</modifier></type><name>hunk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>cp</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>colored</name> <init>= <expr><operator>!</operator><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>colored</name><operator>.</operator><name>len</name></name></expr></init></decl>, <decl><type ref="prev"/><name>quit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>prompt_mode_type</name></name></type> <name>prompt_mode_type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>render_diff_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>, <argument><expr><name>colored</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name> <operator>&gt;=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hunk_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hunk</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>hunk_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>undecided_previous</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>hunk_index</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>use</name> <operator>==</operator> <name>UNDECIDED_HUNK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>undecided_previous</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>undecided_next</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>hunk_index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>use</name> <operator>==</operator> <name>UNDECIDED_HUNK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>undecided_next</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>undecided_previous</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>undecided_next</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>!=</operator> <name>UNDECIDED_HUNK</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>render_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>colored</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>undecided_previous</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">",k"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">",K"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>undecided_next</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">",j"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">",J"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">",g,/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">",s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>file_diff</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">",e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>deleted</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prompt_mode_type</name> <operator>=</operator> <name>PROMPT_DELETION</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hunk_index</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prompt_mode_type</name> <operator>=</operator> <name>PROMPT_MODE_CHANGE</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>prompt_mode_type</name> <operator>=</operator> <name>PROMPT_HUNK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>color_fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>prompt_color</name></name></expr></argument>,

<argument><expr><literal type="string">"(%"</literal><name>PRIuMAX</name><literal type="string">"/%"</literal><name>PRIuMAX</name><literal type="string">") "</literal></expr></argument>,

<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>hunk_index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>color_fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>prompt_color</name></name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>prompt_mode</name><index>[<expr><name>prompt_mode_type</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_single_character</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>tolower</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'y'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>=</operator> <name>USE_HUNK</name></expr>;</expr_stmt>

<label><name>soft_increment</name>:</label>

<expr_stmt><expr><name>hunk_index</name> <operator>=</operator> <ternary><condition><expr><name>undecided_next</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then>

<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr> </then><else>: <expr><name>undecided_next</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>=</operator> <name>SKIP_HUNK</name></expr>;</expr_stmt>

<goto>goto <name>soft_increment</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>hunk_index</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>;</condition> <incr><expr><name>hunk_index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>hunk</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>hunk_index</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>==</operator> <name>UNDECIDED_HUNK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>=</operator> <name>USE_HUNK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'d'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>hunk_index</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>;</condition> <incr><expr><name>hunk_index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>hunk</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>hunk_index</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>==</operator> <name>UNDECIDED_HUNK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>=</operator> <name>SKIP_HUNK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>quit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hunk_index</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No previous hunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'J'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hunk_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No next hunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>undecided_previous</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hunk_index</name> <operator>=</operator> <name>undecided_previous</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No previous hunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>undecided_next</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hunk_index</name> <operator>=</operator> <name>undecided_next</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No next hunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>response</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No other hunks to goto"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_trim</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>hunk_index</name> <operator>-</operator> <name>DISPLAY_HUNKS_LINES</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>display_hunks</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr> ?</condition><then>

<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"go to which hunk (&lt;ret&gt; to see "</literal>

<literal type="string">"more)? "</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"go to which hunk? "</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strbuf_getline</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>,

<argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_trim_trailing_newline</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>strbuf_trim</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>response</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pend</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pend</name> <operator>||</operator> <name>pend</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Invalid number: '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>response</name> <operator>&amp;&amp;</operator> <name>response</name> <operator>&lt;=</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hunk_index</name> <operator>=</operator> <name>response</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>Q_</name><argument_list>(<argument><expr><literal type="string">"Sorry, only %d hunk available."</literal></expr></argument>,

<argument><expr><literal type="string">"Sorry, only %d hunks available."</literal></expr></argument>,

<argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>regex_t</name></type> <name>regex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No other hunks to search"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_trim_trailing_newline</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"search for regex? "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strbuf_getline</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>,

<argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_trim_trailing_newline</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>answer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name></name></expr></argument>,

<argument><expr><name>REG_EXTENDED</name> <operator>|</operator> <name>REG_NOSUB</name> <operator>|</operator> <name>REG_NEWLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>regerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Malformed search regexp %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>hunk_index</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>render_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>

<operator>!=</operator> <name>REG_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>hunk_index</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No hunk matches the given pattern"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></for>

<expr_stmt><expr><name>hunk_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>splittable_into</name> <init>= <expr><name><name>hunk</name><operator>-&gt;</operator><name>splittable_into</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>splittable_into</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sorry, cannot split this hunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>split_hunk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>,

<argument><expr><name>hunk</name> <operator>-</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>color_fprintf_ln</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>header_color</name></name></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Split into %d hunks."</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>splittable_into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>answer</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>hunk_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>mode_change</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sorry, cannot edit this hunk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>edit_hunk_loop</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>, <argument><expr><name>hunk</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>hunk</name><operator>-&gt;</operator><name>use</name></name> <operator>=</operator> <name>USE_HUNK</name></expr>;</expr_stmt>

<goto>goto <name>soft_increment</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><name>help_patch_remainder</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eol</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>color_fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>help_color</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,

<argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>help_patch_text</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>eol</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>color_fprintf_ln</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>help_color</name></name></expr></argument>,

<argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>file_diff</name><operator>-&gt;</operator><name>hunk</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>use</name> <operator>==</operator> <name>USE_HUNK</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>file_diff</name><operator>-&gt;</operator><name>hunk_nr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>reassemble_patch</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>file_diff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>discard_index</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>apply_for_checkout</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>apply_for_checkout</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>is_reverse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>setup_child_process</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="string">"apply"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_pushv</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mode</name><operator>-&gt;</operator><name>apply_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pipe_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"'git apply' failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>repo_read_index</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>repo_refresh_and_write_index</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name>REFRESH_QUIET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>quit</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_add_p</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>add_p_mode</name></name></type> <name>mode</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>revision</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>add_p_state</name></name></type> <name>s</name> <init>= <expr><block>{

<expr><block>{ <expr><name>r</name></expr> }</block></expr>, <expr><name>STRBUF_INIT</name></expr>, <expr><name>STRBUF_INIT</name></expr>, <expr><name>STRBUF_INIT</name></expr>, <expr><name>STRBUF_INIT</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>binary_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_add_i_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ADD_P_STASH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_stash</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ADD_P_RESET</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>revision</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>revision</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_reset_head</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_reset_nothead</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ADD_P_CHECKOUT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>revision</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_checkout_index</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>revision</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_checkout_head</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_checkout_nothead</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ADD_P_WORKTREE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>revision</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_checkout_index</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>revision</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_worktree_head</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_worktree_nothead</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <operator>&amp;</operator><name>patch_mode_add</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>revision</name></name> <operator>=</operator> <name>revision</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>discard_index</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>repo_read_index</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>

<operator>(</operator><operator>!</operator><name><name>s</name><operator>.</operator><name>mode</name><operator>-&gt;</operator><name>index_only</name></name> <operator>&amp;&amp;</operator>

<call><name>repo_refresh_and_write_index</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>REFRESH_QUIET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<call><name>parse_diff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>plain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>colored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_add_i_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>.</operator><name>file_diff_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>.</operator><name>file_diff</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>binary</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>.</operator><name>file_diff</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hunk_nr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>binary_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>patch_update_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>file_diff</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>.</operator><name>file_diff_nr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No changes.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>binary_count</name> <operator>==</operator> <name><name>s</name><operator>.</operator><name>file_diff_nr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Only binary files changed.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>answer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>plain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>colored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_add_i_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
