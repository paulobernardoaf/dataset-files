<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats\git\run-command.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"exec-cmd.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sigchain.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"argv-array.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread-utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"strbuf.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string-list.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quote.h"</cpp:file></cpp:include>

<function><type><name>void</name></type> <name>child_process_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>child</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>child</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>child</name><operator>-&gt;</operator><name>env_array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>child_process_clear</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>child</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>child</name><operator>-&gt;</operator><name>env_array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>child_to_clean</name> <block>{

<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>process</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_to_clean</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>child_to_clean</name></name> <modifier>*</modifier></type><name>children_to_clean</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>installed_child_cleanup_handler</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_children</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_signal</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_to_clean</name></name> <modifier>*</modifier></type><name>children_to_wait_for</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>children_to_clean</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_to_clean</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>children_to_clean</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>children_to_clean</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>process</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_signal</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>process</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>process</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>process</name><operator>-&gt;</operator><name>clean_on_exit_handler</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>trace_printf</name><argument_list>(

<argument><expr><literal type="string">"trace: run_command: running exit handler for pid %"</literal>

<name>PRIuMAX</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>

)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>process</name><operator>-&gt;</operator><name>clean_on_exit_handler</name></name><argument_list>(<argument><expr><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>process</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>process</name><operator>-&gt;</operator><name>wait_after_clean</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>children_to_wait_for</name></expr>;</expr_stmt>

<expr_stmt><expr><name>children_to_wait_for</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_signal</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><name>children_to_wait_for</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_to_clean</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>children_to_wait_for</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>children_to_wait_for</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>waitpid</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></while> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_signal</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_children_on_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>cleanup_children</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigchain_pop</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_children_on_exit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>cleanup_children</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mark_child_for_cleanup</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>process</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_to_clean</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>process</name></name> <operator>=</operator> <name>process</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>children_to_clean</name></expr>;</expr_stmt>

<expr_stmt><expr><name>children_to_clean</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>installed_child_cleanup_handler</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>cleanup_children_on_exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigchain_push_common</name><argument_list>(<argument><expr><name>cleanup_children_on_signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>installed_child_cleanup_handler</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_child_for_cleanup</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_to_clean</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name>children_to_clean</name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name></expr>;</condition> <incr><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_to_clean</name></name> <modifier>*</modifier></type><name>clean_me</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>clean_me</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>clean_me</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>clean_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>close_pair</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>fd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_executable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>||</operator> 

<operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GIT_WINDOWS_NATIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>ends_with</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".exe"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>S_IXUSR</name></expr>;</return></block_content></block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;=</operator> <operator>~</operator><name>S_IXUSR</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"#!"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>|=</operator> <name>S_IXUSR</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXUSR</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>locate_in_PATH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PATH"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchrnul</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_executable</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>end</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>exists_in_PATH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>locate_in_PATH</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>found</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>sane_execvp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GIT_WINDOWS_NATIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>exec_id</name> <init>= <expr><call><name>trace2_exec</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>execvp</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GIT_WINDOWS_NATIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ec</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>trace2_exec_result</name><argument_list>(<argument><expr><name>exec_id</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EACCES</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><call><name>exists_in_PATH</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>EACCES</name></expr> </then><else>: <expr><name>ENOENT</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOTDIR</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>prepare_shell_cmd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>argv_array</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"shell command is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcspn</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"|&amp;;&lt;&gt;()$`\\\"' \t\n*?[#~=%"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GIT_WINDOWS_NATIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>SHELL_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"sh"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_pushf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s \"$@\""</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_pushv</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>out</name><operator>-&gt;</operator><name>argv</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GIT_WINDOWS_NATIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>child_notifier</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<enum>enum <name>child_errcode</name> <block>{

<decl><name>CHILD_ERR_CHDIR</name></decl>,

<decl><name>CHILD_ERR_DUP2</name></decl>,

<decl><name>CHILD_ERR_CLOSE</name></decl>,

<decl><name>CHILD_ERR_SIGPROCMASK</name></decl>,

<decl><name>CHILD_ERR_ENOENT</name></decl>,

<decl><name>CHILD_ERR_SILENT</name></decl>,

<decl><name>CHILD_ERR_ERRNO</name></decl>

}</block>;</enum>

<struct>struct <name>child_err</name> <block>{

<decl_stmt><decl><type><name><name>enum</name> <name>child_errcode</name></name></type> <name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>syserr</name></decl>;</decl_stmt> 

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_die</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>child_errcode</name></name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_err</name></name></type> <name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>err</name></name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>syserr</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xwrite</name><argument_list>(<argument><expr><name>child_notifier</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_dup2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_die</name><argument_list>(<argument><expr><name>CHILD_ERR_DUP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_close</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_die</name><argument_list>(<argument><expr><name>CHILD_ERR_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_close_pair</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>fd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>child_close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fake_fatal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vreportf</name><argument_list>(<argument><expr><literal type="string">"fatal: "</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_error_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>msg</name><index>[]</index></name> <init>= <expr><literal type="string">"error() should not be called in child\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xwrite</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_warn_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>msg</name><index>[]</index></name> <init>= <expr><literal type="string">"warn() should not be called in child\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xwrite</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>NORETURN</name></type> <name>child_die_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>msg</name><index>[]</index></name> <init>= <expr><literal type="string">"die() should not be called in child\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xwrite</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_err_spew</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>child_err</name></name> <modifier>*</modifier></type><name>cerr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>old_errfn</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>old_errfn</name> <operator>=</operator> <call><name>get_error_routine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_error_routine</name><argument_list>(<argument><expr><name>fake_fatal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>cerr</name><operator>-&gt;</operator><name>syserr</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>cerr</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>CHILD_ERR_CHDIR</name></expr>:</case>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"exec '%s': cd to '%s' failed"</literal></expr></argument>,

<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CHILD_ERR_DUP2</name></expr>:</case>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"dup2() in child failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CHILD_ERR_CLOSE</name></expr>:</case>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"close() in child failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CHILD_ERR_SIGPROCMASK</name></expr>:</case>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"sigprocmask failed restoring signals"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CHILD_ERR_ENOENT</name></expr>:</case>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"cannot run %s"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CHILD_ERR_SILENT</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>CHILD_ERR_ERRNO</name></expr>:</case>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"cannot exec '%s'"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>set_error_routine</name><argument_list>(<argument><expr><name>old_errfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_cmd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>argv_array</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"command is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>SHELL_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>git_cmd</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>prepare_git_cmd</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>use_shell</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>prepare_shell_cmd</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>argv_array_pushv</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>program</name> <init>= <expr><call><name>locate_in_PATH</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>program</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>out</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>program</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>prep_childenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>deltaenv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>environ</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>childenv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>env</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>key</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>environ</name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>equals</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>equals</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>equals</name> <operator>-</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>string_list_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>deltaenv</name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>equals</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>equals</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>equals</name> <operator>-</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>string_list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>childenv</name></expr></argument>, <argument><expr><name><name>env</name><operator>.</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>env</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>childenv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>env</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>childenv</name><index>[<expr><name><name>env</name><operator>.</operator><name>nr</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>childenv</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>atfork_state</name> <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>cs</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>sigset_t</name></type> <name>old</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_BUG</name><parameter_list>(<parameter><type><name>err</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int e = (err); if (e) BUG("%s: %s", msg, strerror(e)); } while(0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>atfork_prepare</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atfork_state</name></name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>sigset_t</name></type> <name>all</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sigfillset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>all</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"sigfillset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>all</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>old</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"sigprocmask"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>CHECK_BUG</name><argument_list>(<argument><expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>all</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>old</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"blocking all signals"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_BUG</name><argument_list>(<argument><expr><call><name>pthread_setcancelstate</name><argument_list>(<argument><expr><name>PTHREAD_CANCEL_DISABLE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"disabling cancellation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>atfork_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>atfork_state</name></name> <modifier>*</modifier></type><name>as</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>old</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"sigprocmask"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>CHECK_BUG</name><argument_list>(<argument><expr><call><name>pthread_setcancelstate</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"re-enabling cancellation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_BUG</name><argument_list>(<argument><expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>as</name><operator>-&gt;</operator><name>old</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"restoring signal mask"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>set_cloexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>flags</name> <operator>|</operator> <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>wait_or_whine</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_signal</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>code</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pid_t</name></type> <name>waiting</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>failed_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>waiting</name> <operator>=</operator> <call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></while> 

<if_stmt><if>if <condition>(<expr><name>in_signal</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>waiting</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>failed_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"waitpid for %s failed"</literal></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>waiting</name> <operator>!=</operator> <name>pid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"waitpid is confused (%s)"</literal></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>SIGINT</name> <operator>&amp;&amp;</operator> <name>code</name> <operator>!=</operator> <name>SIGQUIT</name> <operator>&amp;&amp;</operator> <name>code</name> <operator>!=</operator> <name>SIGPIPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s died of signal %d"</literal></expr></argument>, <argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">128</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"waitpid is confused (%s)"</literal></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>clear_child_for_cleanup</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>failed_errno</name></expr>;</expr_stmt>

<return>return <expr><name>code</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>trace_add_env</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>deltaenv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>envs</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>printed_unset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>deltaenv</name></expr>;</init> <condition><expr><name>e</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>e</name></expr>;</condition> <incr><expr><name>e</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>key</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>equals</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>e</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>equals</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>*</operator><name>e</name></expr></argument>, <argument><expr><name>equals</name> <operator>-</operator> <operator>*</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>envs</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>equals</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>envs</name></expr></argument>, <argument><expr><operator>*</operator><name>e</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>envs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>envs</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>envs</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>||</operator> <operator>!</operator><call><name>getenv</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>printed_unset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="string">" unset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>printed_unset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>printed_unset</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>envs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>envs</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>envs</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oldval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="string">" %s="</literal></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sq_quote_buf_pretty</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>envs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>trace_run_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>trace_want</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trace_default_key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"trace: run_command:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" cd "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sq_quote_buf_pretty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>env</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>trace_add_env</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>git_cmd</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" git"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sq_quote_argv_pretty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace_printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>start_command</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>need_in</name></decl>, <decl><type ref="prev"/><name>need_out</name></decl>, <decl><type ref="prev"/><name>need_err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>fdin</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>fdout</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>fderr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>failed_errno</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>args</name><operator>.</operator><name>argv</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>env</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>env</name></name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>env_array</name><operator>.</operator><name>argv</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>need_in</name> <operator>=</operator> <operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>no_stdin</name></name> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>in</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>fdin</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>failed_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">"standard input"</literal></expr>;</expr_stmt>

<goto>goto <name>fail_pipe</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <name><name>fdin</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>need_out</name> <operator>=</operator> <operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>no_stdout</name></name>

<operator>&amp;&amp;</operator> <operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>stdout_to_stderr</name></name>

<operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>out</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>fdout</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>failed_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">"standard output"</literal></expr>;</expr_stmt>

<goto>goto <name>fail_pipe</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <name><name>fdout</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>need_err</name> <operator>=</operator> <operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>no_stderr</name></name> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>err</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_err</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>fderr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>failed_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">"standard error"</literal></expr>;</expr_stmt>

<label><name>fail_pipe</name>:</label>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"cannot create %s pipe for %s: %s"</literal></expr></argument>,

<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>failed_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_process_clear</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>failed_errno</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name><name>fderr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>trace2_child_start</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace_run_command</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GIT_WINDOWS_NATIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name><name>notify_pipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>null_fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>childenv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>argv</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_err</name></name></type> <name>cerr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>atfork_state</name></name></type> <name>as</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prepare_cmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>failed_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>silent_exec_failure</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"cannot run %s"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>end_of_spawn</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>notify_pipe</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>notify_pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>notify_pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>no_stdin</name></name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>no_stdout</name></name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>no_stderr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>null_fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><literal type="string">"/dev/null"</literal></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>null_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"open /dev/null failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>set_cloexec</name><argument_list>(<argument><expr><name>null_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>childenv</name> <operator>=</operator> <call><name>prep_childenv</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>atfork_prepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>failed_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>sig</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_die_routine</name><argument_list>(<argument><expr><name>child_die_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_error_routine</name><argument_list>(<argument><expr><name>child_error_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_warn_routine</name><argument_list>(<argument><expr><name>child_warn_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>notify_pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_cloexec</name><argument_list>(<argument><expr><name><name>notify_pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>child_notifier</name> <operator>=</operator> <name><name>notify_pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>no_stdin</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name>null_fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>need_in</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name><name>fdin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_close_pair</name><argument_list>(<argument><expr><name>fdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>no_stderr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name>null_fd</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>need_err</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name><name>fderr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_close_pair</name><argument_list>(<argument><expr><name>fderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>no_stdout</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name>null_fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>stdout_to_stderr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>need_out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name><name>fdout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_close_pair</name><argument_list>(<argument><expr><name>fdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>child_dup2</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>dir</name></name> <operator>&amp;&amp;</operator> <call><name>chdir</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_die</name><argument_list>(<argument><expr><name>CHILD_ERR_CHDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>sig</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>sig</name> <operator>&lt;</operator> <name>NSIG</name></expr>;</condition> <incr><expr><name>sig</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SIG_IGN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>as</name><operator>.</operator><name>old</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_die</name><argument_list>(<argument><expr><name>CHILD_ERR_SIGPROCMASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>execve</name><argument_list>(<argument><expr><name><name>argv</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name><name>argv</name><operator>.</operator><name>argv</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>childenv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOEXEC</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>execve</name><argument_list>(<argument><expr><name><name>argv</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name><name>argv</name><operator>.</operator><name>argv</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>childenv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>silent_exec_failure</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>child_die</name><argument_list>(<argument><expr><name>CHILD_ERR_SILENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>child_die</name><argument_list>(<argument><expr><name>CHILD_ERR_ENOENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>child_die</name><argument_list>(<argument><expr><name>CHILD_ERR_ERRNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>atfork_parent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"cannot fork() for %s"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>clean_on_exit</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mark_child_for_cleanup</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>notify_pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>xread</name><argument_list>(<argument><expr><name><name>notify_pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cerr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cerr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cerr</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>wait_or_whine</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_err_spew</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>failed_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>notify_pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>null_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>null_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>childenv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<label><name>end_of_spawn</name>:</label>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fhin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>fhout</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>fherr</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sargv</name> <init>= <expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>nargv</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>no_stdin</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fhin</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><literal type="string">"/dev/null"</literal></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fhin</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name><name>fdin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fhin</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>no_stderr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fherr</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><literal type="string">"/dev/null"</literal></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>need_err</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fherr</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name><name>fderr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fherr</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>no_stdout</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fhout</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><literal type="string">"/dev/null"</literal></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>stdout_to_stderr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fhout</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name>fherr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>need_out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fhout</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name><name>fdout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fhout</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>git_cmd</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>prepare_git_cmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nargv</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>use_shell</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>prepare_shell_cmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nargv</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <call><name>mingw_spawnvpe</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>env</name></name></expr></argument>,

<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>fhin</name></expr></argument>, <argument><expr><name>fhout</name></expr></argument>, <argument><expr><name>fherr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>failed_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>silent_exec_failure</name></name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"cannot spawn %s"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>clean_on_exit</name></name> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mark_child_for_cleanup</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <name>sargv</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fhin</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fhin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fhout</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fhout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fherr</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fherr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>trace2_child_exit</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_err</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>child_process_clear</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>failed_errno</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fdin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fdout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_err</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fderr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>finish_command</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>wait_or_whine</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>trace2_child_exit</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_process_clear</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>finish_command_in_signal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>wait_or_whine</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>trace2_child_exit</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_command</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>err</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"run_command with a pipe can cause deadlock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>start_command</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>finish_command</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_command_v_opt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>run_command_v_opt_cd_env</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_command_v_opt_tr2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tr2_class</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>run_command_v_opt_cd_env_tr2</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tr2_class</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_command_v_opt_cd_env</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>run_command_v_opt_cd_env_tr2</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_command_v_opt_cd_env_tr2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tr2_class</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>cmd</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>no_stdin</name></name> <operator>=</operator> <ternary><condition><expr><name>opt</name> <operator>&amp;</operator> <name>RUN_COMMAND_NO_STDIN</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>git_cmd</name></name> <operator>=</operator> <ternary><condition><expr><name>opt</name> <operator>&amp;</operator> <name>RUN_GIT_CMD</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>stdout_to_stderr</name></name> <operator>=</operator> <ternary><condition><expr><name>opt</name> <operator>&amp;</operator> <name>RUN_COMMAND_STDOUT_TO_STDERR</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>silent_exec_failure</name></name> <operator>=</operator> <ternary><condition><expr><name>opt</name> <operator>&amp;</operator> <name>RUN_SILENT_EXEC_FAILURE</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>use_shell</name></name> <operator>=</operator> <ternary><condition><expr><name>opt</name> <operator>&amp;</operator> <name>RUN_USING_SHELL</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>clean_on_exit</name></name> <operator>=</operator> <ternary><condition><expr><name>opt</name> <operator>&amp;</operator> <name>RUN_CLEAN_ON_EXIT</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>dir</name></name> <operator>=</operator> <name>dir</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>env</name></name> <operator>=</operator> <name>env</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>trace2_child_class</name></name> <operator>=</operator> <name>tr2_class</name></expr>;</expr_stmt>

<return>return <expr><call><name>run_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_t</name></type> <name>main_thread</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>main_thread_set</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_key_t</name></type> <name>async_key</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_key_t</name></type> <name>async_die_counter</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>run_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>async</name></name> <modifier>*</modifier></type><name>async</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>intptr_t</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>isolate_sigpipe</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>sigset_t</name></type> <name>mask</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><literal type="string">"unable to block SIGPIPE in async thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pthread_setspecific</name><argument_list>(<argument><expr><name>async_key</name></expr></argument>, <argument><expr><name>async</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>async</name><operator>-&gt;</operator><name>proc</name></name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>proc_in</name></name></expr></argument>, <argument><expr><name><name>async</name><operator>-&gt;</operator><name>proc_out</name></name></expr></argument>, <argument><expr><name><name>async</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NORETURN</name> <name>void</name></type> <name>die_async</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vreportf</name><argument_list>(<argument><expr><literal type="string">"fatal: "</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>in_async</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>async</name></name> <modifier>*</modifier></type><name>async</name> <init>= <expr><call><name>pthread_getspecific</name><argument_list>(<argument><expr><name>async_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>proc_in</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>proc_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>proc_out</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>proc_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>pthread_exit</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>async_die_is_recursing</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>pthread_getspecific</name><argument_list>(<argument><expr><name>async_die_counter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pthread_setspecific</name><argument_list>(<argument><expr><name>async_die_counter</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>in_async</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>main_thread_set</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<return>return <expr><operator>!</operator><call><name>pthread_equal</name><argument_list>(<argument><expr><name>main_thread</name></expr></argument>, <argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>NORETURN</name></type> <name>async_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>pthread_exit</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<struct><specifier>static</specifier> struct <block>{

<function_decl><type><name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>handlers</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>size_t</name></type> <name>nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>alloc</name></decl>;</decl_stmt>

}</block> <decl><name>git_atexit_hdlrs</name></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>git_atexit_installed</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>git_atexit_dispatch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><name><name>git_atexit_hdlrs</name><operator>.</operator><name>nr</name></name></expr> ;</init> <condition><expr><name>i</name></expr> ;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>git_atexit_hdlrs</name><operator>.</operator><name>handlers</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>(</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>git_atexit_clear</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>git_atexit_hdlrs</name><operator>.</operator><name>handlers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>git_atexit_hdlrs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>git_atexit_hdlrs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>git_atexit_installed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>atexit</name></cpp:undef>

<function><type><name>int</name></type> <name>git_atexit</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>handler</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>git_atexit_hdlrs</name><operator>.</operator><name>handlers</name></name></expr></argument>, <argument><expr><name><name>git_atexit_hdlrs</name><operator>.</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>git_atexit_hdlrs</name><operator>.</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>git_atexit_hdlrs</name><operator>.</operator><name>handlers</name><index>[<expr><name><name>git_atexit_hdlrs</name><operator>.</operator><name>nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>git_atexit_installed</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>atexit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>git_atexit_dispatch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>git_atexit_installed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>atexit</name></cpp:macro> <cpp:value>git_atexit</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>process_is_async</name></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>in_async</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>process_is_async</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>NORETURN</name></type> <name>async_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>check_pipe</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EPIPE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>in_async</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>async_exit</name><argument_list>(<argument><expr><literal type="number">141</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">141</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>start_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>async</name></name> <modifier>*</modifier></type><name>async</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>need_in</name></decl>, <decl><type ref="prev"/><name>need_out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>fdin</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>fdout</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>proc_in</name></decl>, <decl><type ref="prev"/><name>proc_out</name></decl>;</decl_stmt>

<expr_stmt><expr><name>need_in</name> <operator>=</operator> <name><name>async</name><operator>-&gt;</operator><name>in</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>fdin</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>out</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"cannot create pipe"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>async</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <name><name>fdin</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>need_out</name> <operator>=</operator> <name><name>async</name><operator>-&gt;</operator><name>out</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>fdout</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"cannot create pipe"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>async</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <name><name>fdout</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>proc_in</name> <operator>=</operator> <name><name>fdin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>proc_in</name> <operator>=</operator> <name><name>async</name><operator>-&gt;</operator><name>in</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>proc_in</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>proc_out</name> <operator>=</operator> <name><name>fdout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>proc_out</name> <operator>=</operator> <name><name>async</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>proc_out</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>async</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>pid</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"fork (async) failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>async</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fdin</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fdout</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>git_atexit_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>process_is_async</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><operator>!</operator><operator>!</operator><call><name><name>async</name><operator>-&gt;</operator><name>proc</name></name><argument_list>(<argument><expr><name>proc_in</name></expr></argument>, <argument><expr><name>proc_out</name></expr></argument>, <argument><expr><name><name>async</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mark_child_for_cleanup</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fdin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fdout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>main_thread_set</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>main_thread_set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>main_thread</name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_key_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>async_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_key_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>async_die_counter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_die_routine</name><argument_list>(<argument><expr><name>die_async</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_die_is_recursing_routine</name><argument_list>(<argument><expr><name>async_die_is_recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>proc_in</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_cloexec</name><argument_list>(<argument><expr><name>proc_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>proc_out</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_cloexec</name><argument_list>(<argument><expr><name>proc_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>async</name><operator>-&gt;</operator><name>proc_in</name></name> <operator>=</operator> <name>proc_in</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>async</name><operator>-&gt;</operator><name>proc_out</name></name> <operator>=</operator> <name>proc_out</name></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>async</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>run_thread</name></expr></argument>, <argument><expr><name>async</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot create async thread: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>error</name>:</label>

<if_stmt><if>if <condition>(<expr><name>need_in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close_pair</name><argument_list>(<argument><expr><name>fdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>async</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>finish_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>async</name></name> <modifier>*</modifier></type><name>async</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>wait_or_whine</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><literal type="string">"child process"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>async</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"pthread_join failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>ret</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>async_with_fork</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><literal type="number">1</literal></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>find_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>path</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_git_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><literal type="string">"hooks/%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>X_OK</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRIP_EXTENSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><name>STRIP_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>X_OK</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EACCES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EACCES</name> <operator>&amp;&amp;</operator> <name>advice_ignored_hook</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>advise_given</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>string_list_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advise_given</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advise_given</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The '%s' hook was ignored because "</literal>

<literal type="string">"it's not set as executable.\n"</literal>

<literal type="string">"You can disable this warning with "</literal>

<literal type="string">"`git config advice.ignoredHook false`."</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_hook_ve</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>hook</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>find_hook</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hook</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hook</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name><name>hook</name><operator>.</operator><name>env</name></name> <operator>=</operator> <name>env</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hook</name><operator>.</operator><name>no_stdin</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hook</name><operator>.</operator><name>stdout_to_stderr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hook</name><operator>.</operator><name>trace2_hook_name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<return>return <expr><call><name>run_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hook</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_hook_le</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>run_hook_ve</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>io_pump</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt> 

<union>union <block>{

<struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

}</block> <decl><name>out</name></decl>;</struct>

<struct>struct <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>hint</name></decl>;</decl_stmt>

}</block> <decl><name>in</name></decl>;</struct>

}</block> <decl><name>u</name></decl>;</union>

<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pfd</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pump_io_round</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>io_pump</name></name> <modifier>*</modifier></type><name>slots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pfd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pollsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_pump</name></name> <modifier>*</modifier></type><name>io</name> <init>= <expr><operator>&amp;</operator><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pfd</name><index>[<expr><name>pollsize</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>io</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pfd</name><index>[<expr><name>pollsize</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name><name>io</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>pfd</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pfd</name><index>[<expr><name>pollsize</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pollsize</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>poll</name><argument_list>(<argument><expr><name>pfd</name></expr></argument>, <argument><expr><name>pollsize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"poll failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_pump</name></name> <modifier>*</modifier></type><name>io</name> <init>= <expr><operator>&amp;</operator><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>io</name><operator>-&gt;</operator><name>pfd</name><operator>-&gt;</operator><name>revents</name></name> <operator>&amp;</operator> <operator>(</operator><name>POLLOUT</name><operator>|</operator><name>POLLIN</name><operator>|</operator><name>POLLHUP</name><operator>|</operator><name>POLLERR</name><operator>|</operator><name>POLLNVAL</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>POLLOUT</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name> <init>= <expr><call><name>xwrite</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,

<argument><expr><name><name>io</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>out</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>io</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>out</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>out</name><operator>.</operator><name>buf</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>out</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>io</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>out</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>POLLIN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name> <init>= <expr><call><name>strbuf_read_once</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>buf</name></name></expr></argument>,

<argument><expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>io</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pump_io</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>io_pump</name></name> <modifier>*</modifier></type><name>slots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pfd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>pfd</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>pump_io_round</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>pfd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></while> 

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>pipe_command</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>child_process</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>in_len</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>out_hint</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>err_hint</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_pump</name></name></type> <name><name>io</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>in</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>start_command</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>in</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>in</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>POLLOUT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>out</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>out</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>in_len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>hint</name></name> <operator>=</operator> <name>out_hint</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>err</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><index>[<expr><name>nr</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>in</name><operator>.</operator><name>hint</name></name> <operator>=</operator> <name>err_hint</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pump_io</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>finish_command</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>finish_command</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<enum>enum <name>child_state</name> <block>{

<decl><name>GIT_CP_FREE</name></decl>,

<decl><name>GIT_CP_WORKING</name></decl>,

<decl><name>GIT_CP_WAIT_CLEANUP</name></decl>,

}</block>;</enum>

<struct>struct <name>parallel_processes</name> <block>{

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_processes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nr_processes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>get_next_task_fn</name></type> <name>get_next_task</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>start_failure_fn</name></type> <name>start_failure</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>task_finished_fn</name></type> <name>task_finished</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name><name>enum</name> <name>child_state</name></name></type> <name>state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>process</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block> <decl><modifier>*</modifier><name>children</name></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pfd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>shutdown</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>output_owner</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buffered_output</name></decl>;</decl_stmt> 

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>default_start_failure</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pp_cb</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pp_task_cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>default_task_finished</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>result</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pp_cb</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pp_task_cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>kill_children</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parallel_processes</name></name> <modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>==</operator> <name>GIT_CP_WORKING</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>process</name><operator>.</operator><name>pid</name></name></expr></argument>, <argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>parallel_processes</name></name> <modifier>*</modifier></type><name>pp_for_signal</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_children_on_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>kill_children</name><argument_list>(<argument><expr><name>pp_for_signal</name></expr></argument>, <argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigchain_pop</name><argument_list>(<argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pp_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parallel_processes</name></name> <modifier>*</modifier></type><name>pp</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,

<parameter><decl><type><name>get_next_task_fn</name></type> <name>get_next_task</name></decl></parameter>,

<parameter><decl><type><name>start_failure_fn</name></type> <name>start_failure</name></decl></parameter>,

<parameter><decl><type><name>task_finished_fn</name></type> <name>task_finished</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>online_cpus</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace_printf</name><argument_list>(<argument><expr><literal type="string">"run_processes_parallel: preparing to run up to %d tasks"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>get_next_task</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"you need to specify a get_next_task function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>get_next_task</name></name> <operator>=</operator> <name>get_next_task</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>start_failure</name></name> <operator>=</operator> <ternary><condition><expr><name>start_failure</name></expr> ?</condition><then> <expr><name>start_failure</name></expr> </then><else>: <expr><name>default_start_failure</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>task_finished</name></name> <operator>=</operator> <ternary><condition><expr><name>task_finished</name></expr> ?</condition><then> <expr><name>task_finished</name></expr> </then><else>: <expr><name>default_task_finished</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>nr_processes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>output_owner</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>shutdown</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>pfd</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>pp</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>buffered_output</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_process_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>pfd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name> <operator>|</operator> <name>POLLHUP</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>pfd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>pp_for_signal</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigchain_push_common</name><argument_list>(<argument><expr><name>handle_children_on_signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pp_cleanup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parallel_processes</name></name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>trace_printf</name><argument_list>(<argument><expr><literal type="string">"run_processes_parallel: done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_process_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>buffered_output</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>buffered_output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigchain_pop_common</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pp_start_one</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parallel_processes</name></name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>code</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>==</operator> <name>GIT_CP_FREE</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"bookkeeping is hard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name><name>pp</name><operator>-&gt;</operator><name>get_next_task</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>process</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>,

<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>code</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>buffered_output</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>process</name><operator>.</operator><name>err</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>process</name><operator>.</operator><name>stdout_to_stderr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>process</name><operator>.</operator><name>no_stdin</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>start_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>process</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name><name>pp</name><operator>-&gt;</operator><name>start_failure</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>,

<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,

<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>buffered_output</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>shutdown</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>code</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>nr_processes</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>GIT_CP_WORKING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>pfd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>process</name><operator>.</operator><name>err</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pp_buffer_stderr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parallel_processes</name></name> <modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>output_timeout</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>pfd</name></name></expr></argument>, <argument><expr><name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr></argument>, <argument><expr><name>output_timeout</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>pp_cleanup</name><argument_list>(<argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"poll"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>==</operator> <name>GIT_CP_WORKING</name> <operator>&amp;&amp;</operator>

<name><name>pp</name><operator>-&gt;</operator><name>pfd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <operator>(</operator><name>POLLIN</name> <operator>|</operator> <name>POLLHUP</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>strbuf_read_once</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>,

<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>process</name><operator>.</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>process</name><operator>.</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>GIT_CP_WAIT_CLEANUP</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pp_output</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parallel_processes</name></name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>pp</name><operator>-&gt;</operator><name>output_owner</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>==</operator> <name>GIT_CP_WORKING</name> <operator>&amp;&amp;</operator>

<name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>err</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pp_collect_finished</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parallel_processes</name></name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>nr_processes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>==</operator> <name>GIT_CP_WAIT_CLEANUP</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>pp</name><operator>-&gt;</operator><name>max_processes</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>finish_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name><name>pp</name><operator>-&gt;</operator><name>task_finished</name></name><argument_list>(<argument><expr><name>code</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>, <argument><expr><name><name>pp</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,

<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>nr_processes</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>GIT_CP_FREE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>pfd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>child_process_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name><name>pp</name><operator>-&gt;</operator><name>output_owner</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>buffered_output</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>buffered_output</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>buffered_output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>children</name><index>[<expr><operator>(</operator><name><name>pp</name><operator>-&gt;</operator><name>output_owner</name></name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>%</operator> <name>n</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>==</operator> <name>GIT_CP_WORKING</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name><name>pp</name><operator>-&gt;</operator><name>output_owner</name></name> <operator>=</operator> <operator>(</operator><name><name>pp</name><operator>-&gt;</operator><name>output_owner</name></name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>%</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_processes_parallel</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,

<parameter><decl><type><name>get_next_task_fn</name></type> <name>get_next_task</name></decl></parameter>,

<parameter><decl><type><name>start_failure_fn</name></type> <name>start_failure</name></decl></parameter>,

<parameter><decl><type><name>task_finished_fn</name></type> <name>task_finished</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pp_cb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>output_timeout</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>spawn_cap</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>parallel_processes</name></name></type> <name>pp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>get_next_task</name></expr></argument>, <argument><expr><name>start_failure</name></expr></argument>, <argument><expr><name>task_finished</name></expr></argument>, <argument><expr><name>pp_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>

<condition><expr><name>i</name> <operator>&lt;</operator> <name>spawn_cap</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pp</name><operator>.</operator><name>shutdown</name></name> <operator>&amp;&amp;</operator>

<name><name>pp</name><operator>.</operator><name>nr_processes</name></name> <operator>&lt;</operator> <name><name>pp</name><operator>.</operator><name>max_processes</name></name></expr>;</condition>

<incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pp_start_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>code</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>pp</name><operator>.</operator><name>shutdown</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>kill_children</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>, <argument><expr><operator>-</operator><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pp</name><operator>.</operator><name>nr_processes</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>pp_buffer_stderr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>, <argument><expr><name>output_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pp_output</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pp_collect_finished</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>pp</name><operator>.</operator><name>shutdown</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>kill_children</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>, <argument><expr><operator>-</operator><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>pp_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_processes_parallel_tr2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>get_next_task_fn</name></type> <name>get_next_task</name></decl></parameter>,

<parameter><decl><type><name>start_failure_fn</name></type> <name>start_failure</name></decl></parameter>,

<parameter><decl><type><name>task_finished_fn</name></type> <name>task_finished</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pp_cb</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tr2_category</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tr2_label</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>trace2_region_enter_printf</name><argument_list>(<argument><expr><name>tr2_category</name></expr></argument>, <argument><expr><name>tr2_label</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"max:%d"</literal></expr></argument>,

<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>online_cpus</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>n</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>run_processes_parallel</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>get_next_task</name></expr></argument>, <argument><expr><name>start_failure</name></expr></argument>,

<argument><expr><name>task_finished</name></expr></argument>, <argument><expr><name>pp_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace2_region_leave</name><argument_list>(<argument><expr><name>tr2_category</name></expr></argument>, <argument><expr><name>tr2_label</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

</unit>
