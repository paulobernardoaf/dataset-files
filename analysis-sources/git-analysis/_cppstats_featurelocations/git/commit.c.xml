<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\commit.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pkt-line.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revision.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"notes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"alloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gpg-interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mergesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-slab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prio-queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sha1-lookup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wt-status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"advice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>read_commit_extra_header_lines</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>int</name></type> <name>save_commit_buffer</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commit_type</name> <init>= <expr><literal type="string">"commit"</literal></expr></init></decl>;</decl_stmt>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>lookup_commit_reference_gently</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quiet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>deref_tag</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
<argument><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>obj</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>object_as_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>OBJ_COMMIT</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>lookup_commit_reference</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>lookup_commit_or_die</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ref_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not parse %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s %s is not a commit!"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>ref_name</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>lookup_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>lookup_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>obj</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>create_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><call><name>alloc_commit_node</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>object_as_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>OBJ_COMMIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>lookup_commit_reference_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid_committish</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>commit</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>timestamp_t</name></type> <name>parse_commit_date</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dateptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>+</operator> <literal type="number">6</literal> <operator>&gt;=</operator> <name>tail</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"author"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>buf</name> <operator>&lt;</operator> <name>tail</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>buf</name><operator>++</operator> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>+</operator> <literal type="number">9</literal> <operator>&gt;=</operator> <name>tail</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"committer"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>buf</name> <operator>&lt;</operator> <name>tail</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>buf</name><operator>++</operator> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>&gt;=</operator> <name>tail</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dateptr</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf</name> <operator>&lt;</operator> <name>tail</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>buf</name><operator>++</operator> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>&gt;=</operator> <name>tail</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>parse_timestamp</name><argument_list>(<argument><expr><name>dateptr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>commit_graft_sha1_access</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_graft</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>commit_graft_table</name> <init>= <expr><name>table</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name><name>commit_graft_table</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name><name>oid</name><operator>.</operator><name>hash</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>commit_graft_pos</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sha1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>sha1_pos</name><argument_list>(<argument><expr><name>sha1</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name></name></expr></argument>,
<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name></expr></argument>,
<argument><expr><name>commit_graft_sha1_access</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>register_commit_graft</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit_graft</name></name> <modifier>*</modifier></type><name>graft</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>ignore_dups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>commit_graft_pos</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>graft</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pos</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ignore_dups</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>graft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>graft</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name></name></expr></argument>,
<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name></name> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name></name> <operator>+</operator> <name>pos</name></expr></argument>,
<argument><expr><operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name> <operator>-</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>graft</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit_graft</name></name> <modifier>*</modifier></type><name>read_graft_line</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>phase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_graft</name></name> <modifier>*</modifier></type><name>graft</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>dummy_oid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_rtrim</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>line</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>




<for>for <control>(<init><expr><name>phase</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>phase</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>phase</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>oid</name> <operator>=</operator> <ternary><condition><expr><name>graft</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>graft</name><operator>-&gt;</operator><name>oid</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name>dummy_oid</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_oid_hex</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_graft_data</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>tail</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>oid</name> <operator>=</operator> <ternary><condition><expr><name>graft</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>graft</name><operator>-&gt;</operator><name>parent</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>&amp;</operator><name>dummy_oid</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>tail</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>parse_oid_hex</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_graft_data</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>graft</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>graft</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><call><name>st_add</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>graft</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><call><name>st_mult</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>object_id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>graft</name><operator>-&gt;</operator><name>nr_parent</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>graft</name></expr>;</return>

<label><name>bad_graft_data</name>:</label>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bad graft data: %s"</literal></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>graft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_graft_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>graft_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen_or_warn</name><argument_list>(<argument><expr><name>graft_file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>advice_graft_file_deprecated</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Support for &lt;GIT_DIR&gt;/info/grafts is deprecated\n"</literal>
<literal type="string">"and will be removed in a future Git version.\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"Please use \"git replace --convert-graft-file\"\n"</literal>
<literal type="string">"to convert the grafts into replace refs.\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"Turn this message off by running\n"</literal>
<literal type="string">"\"git config advice.graftFileDeprecated false\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>!</operator><call><name>strbuf_getwholeline</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>commit_graft</name></name> <modifier>*</modifier></type><name>graft</name> <init>= <expr><call><name>read_graft_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>graft</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>register_commit_graft</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>graft</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"duplicate graft data: %s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>prepare_commit_graft</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graft_file</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>commit_graft_prepared</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>startup_info</name><operator>-&gt;</operator><name>have_repository</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>graft_file</name> <operator>=</operator> <call><name>get_graft_file</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_graft_file</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>graft_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>is_repository_shallow</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>commit_graft_prepared</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit_graft</name></name> <modifier>*</modifier></type><name>lookup_commit_graft</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>prepare_commit_graft</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>commit_graft_pos</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>for_each_commit_graft</name><parameter_list>(<parameter><decl><type><name>each_commit_graft_fn</name></type> <name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>the_repository</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ret</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fn</name><argument_list>(<argument><expr><name><name>the_repository</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>cb_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>unregister_shallow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>commit_graft_pos</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>the_repository</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MOVE_ARRAY</name><argument_list>(<argument><expr><name><name>the_repository</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name></name> <operator>+</operator> <name>pos</name></expr></argument>,
<argument><expr><name><name>the_repository</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts</name></name> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>the_repository</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name> <operator>-</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>the_repository</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>grafts_nr</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>commit_buffer</name> <block>{
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
}</block>;</struct>
<expr_stmt><expr><call><name>define_commit_slab</name><argument_list>(<argument><expr><name>buffer_slab</name></expr></argument>, <argument><expr>struct <name>commit_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name><name>struct</name> <name>buffer_slab</name></name> <modifier>*</modifier></type><name>allocate_commit_buffer_slab</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>buffer_slab</name></name> <modifier>*</modifier></type><name>bs</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>init_buffer_slab</name><argument_list>(<argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>bs</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_commit_buffer_slab</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>buffer_slab</name></name> <modifier>*</modifier></type><name>bs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>clear_buffer_slab</name><argument_list>(<argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_commit_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_buffer</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>buffer_slab_at</name><argument_list>(
<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>buffer_slab</name></name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>get_cached_commit_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_buffer</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>buffer_slab_peek</name><argument_list>(
<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>buffer_slab</name></name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sizep</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sizep</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name><name>v</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>repo_get_commit_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>get_cached_commit_buffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name>sizep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>repo_read_object_file</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"cannot read commit object %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"expected commit for %s, got %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sizep</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>repo_unuse_commit_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_buffer</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>buffer_slab_peek</name><argument_list>(
<argument><expr><name><name>r</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>buffer_slab</name></name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>v</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>buffer</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_commit_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsed_object_pool</name></name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_buffer</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>buffer_slab_peek</name><argument_list>(
<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>buffer_slab</name></name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>set_commit_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>maybe_tree</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>repo_get_commit_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>commit</name><operator>-&gt;</operator><name>maybe_tree</name></name> <operator>||</operator> <operator>!</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>parsed</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>commit</name><operator>-&gt;</operator><name>maybe_tree</name></name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>commit</name><operator>-&gt;</operator><name>graph_pos</name></name> <operator>!=</operator> <name>COMMIT_NOT_FROM_GRAPH</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>get_commit_tree_in_graph</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>get_commit_tree_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name> <init>= <expr><call><name>get_commit_tree</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>tree</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>release_commit_memory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsed_object_pool</name></name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>set_commit_tree</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_commit_buffer</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>parsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>detach_commit_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_buffer</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>buffer_slab_peek</name><argument_list>(
<argument><expr><name><name>the_repository</name><operator>-&gt;</operator><name>parsed_objects</name><operator>-&gt;</operator><name>buffer_slab</name></name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sizep</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sizep</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>parse_commit_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check_graph</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bufptr</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_graft</name></name> <modifier>*</modifier></type><name>graft</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>tree_entry_len</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>+</operator> <literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>parent_entry_len</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>+</operator> <literal type="number">7</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>parsed</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>parents</name></name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>parents</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tail</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tail</name> <operator>&lt;=</operator> <name>bufptr</name> <operator>+</operator> <name>tree_entry_len</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><literal type="string">"tree "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<name><name>bufptr</name><index>[<expr><name>tree_entry_len</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bogus commit object %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_oid_hex</name><argument_list>(<argument><expr><name>bufptr</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bad tree pointer in commit %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tree</name> <operator>=</operator> <call><name>lookup_tree</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tree</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bad tree pointer %s in commit %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>set_commit_tree</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>tree_entry_len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>pptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>graft</name> <operator>=</operator> <call><name>lookup_commit_graft</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>bufptr</name> <operator>+</operator> <name>parent_entry_len</name> <operator>&lt;</operator> <name>tail</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><literal type="string">"parent "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>new_parent</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tail</name> <operator>&lt;=</operator> <name>bufptr</name> <operator>+</operator> <name>parent_entry_len</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator>
<call><name>get_oid_hex</name><argument_list>(<argument><expr><name>bufptr</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>)</argument_list></call> <operator>||</operator>
<name><name>bufptr</name><index>[<expr><name>parent_entry_len</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bad parents in commit %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>parent_entry_len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>graft</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>graft</name><operator>-&gt;</operator><name>nr_parent</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>grafts_replace_parents</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>new_parent</name> <operator>=</operator> <call><name>lookup_commit</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_parent</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bad parent %s in commit %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pptr</name> <operator>=</operator> <operator>&amp;</operator><call><name>commit_list_insert</name><argument_list>(<argument><expr><name>new_parent</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>graft</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>new_parent</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>graft</name><operator>-&gt;</operator><name>nr_parent</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>new_parent</name> <operator>=</operator> <call><name>lookup_commit</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>graft</name><operator>-&gt;</operator><name>parent</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_parent</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bad graft parent %s in commit %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>graft</name><operator>-&gt;</operator><name>parent</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pptr</name> <operator>=</operator> <operator>&amp;</operator><call><name>commit_list_insert</name><argument_list>(<argument><expr><name>new_parent</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>date</name></name> <operator>=</operator> <call><name>parse_commit_date</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>check_graph</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_commit_graph_info</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>parsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_parse_commit_internal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>quiet_on_missing</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>use_commit_graph</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>parsed</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>use_commit_graph</name> <operator>&amp;&amp;</operator> <call><name>parse_commit_in_graph</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>repo_read_object_file</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>quiet_on_missing</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
<expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Could not read %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Object %s not a commit"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_commit_buffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>save_commit_buffer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_commit_buffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_parse_commit_gently</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quiet_on_missing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>repo_parse_commit_internal</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>quiet_on_missing</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>parse_commit_or_die</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>parse_commit</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unable to parse commit %s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>item</name></expr> ?</condition><then> <expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>find_commit_subject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commit_buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>subject</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>commit_buffer</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skip_blank_lines</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>eol</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>subject</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><name>eol</name> <operator>-</operator> <name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>commit_list_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>new_list</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>commit_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>new_list</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_list</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>list_p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>list_p</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt>
<return>return <expr><name>new_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name></type> <name>commit_list_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr> )</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>copy_commit_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>head</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name> <init>= <expr><operator>&amp;</operator><name>head</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>commit_list_append</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>head</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_commit_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>list</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pop_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type> <name>commit_list_insert_by_date</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name> <init>= <expr><name>list</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>date</name></name> <operator>&lt;</operator> <name><name>item</name><operator>-&gt;</operator><name>date</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><call><name>commit_list_insert</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>commit_list_compare_by_date</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>timestamp_t</name></type> <name>a_date</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>commit_list</name> <operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name><name>item</name><operator>-&gt;</operator><name>date</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timestamp_t</name></type> <name>b_date</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>commit_list</name> <operator>*</operator><operator>)</operator><name>b</name><operator>)</operator><operator>-&gt;</operator><name><name>item</name><operator>-&gt;</operator><name>date</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a_date</name> <operator>&lt;</operator> <name>b_date</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a_date</name> <operator>&gt;</operator> <name>b_date</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>commit_list_get_next</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>commit_list</name> <operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>commit_list_set_next</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>next</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator>struct <name>commit_list</name> <operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>commit_list_sort_by_date</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <call><name>llist_mergesort</name><argument_list>(<argument><expr><operator>*</operator><name>list</name></expr></argument>, <argument><expr><name>commit_list_get_next</name></expr></argument>, <argument><expr><name>commit_list_set_next</name></expr></argument>,
<argument><expr><name>commit_list_compare_by_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>pop_most_recent_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>pop_commit</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name> <init>= <expr><name><name>ret</name><operator>-&gt;</operator><name>parents</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>parents</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>mark</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>mark</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>commit_list_insert_by_date</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_commit_marks_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>plist</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>commit</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mark</name> <operator>&amp;</operator> <name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mark</name></expr>;</expr_stmt>

<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parents</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>parents</name> <operator>=</operator> <name><name>parents</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>commit_list_insert</name><argument_list>(<argument><expr><name><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clear_commit_marks_many</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>nr</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>clear_commit_marks_1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><operator>*</operator><name>commit</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>commit</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name>list</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>clear_commit_marks_1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><call><name>pop_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clear_commit_marks</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>clear_commit_marks_many</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>pop_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>top</name> <init>= <expr><operator>*</operator><name>stack</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>item</name> <init>= <expr><ternary><condition><expr><name>top</name></expr> ?</condition><then> <expr><name><name>top</name><operator>-&gt;</operator><name>item</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>top</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>stack</name> <operator>=</operator> <name><name>top</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>






<expr_stmt><expr><call><name>define_commit_slab</name><argument_list>(<argument><expr><name>indegree_slab</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_commit_slab</name><argument_list>(<argument><expr><name>author_date_slab</name></expr></argument>, <argument><expr><name>timestamp_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>void</name></type> <name>record_author_date</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>author_date_slab</name></name> <modifier>*</modifier></type><name>author_date</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>get_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ident_split</name></name></type> <name>ident</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident_line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ident_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>date_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timestamp_t</name></type> <name>date</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ident_line</name> <operator>=</operator> <call><name>find_commit_header</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"author"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ident_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ident_line</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail_exit</name>;</goto></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><call><name>split_ident_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ident</name></expr></argument>, <argument><expr><name>ident_line</name></expr></argument>, <argument><expr><name>ident_len</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><name><name>ident</name><operator>.</operator><name>date_begin</name></name> <operator>||</operator> <operator>!</operator><name><name>ident</name><operator>.</operator><name>date_end</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail_exit</name>;</goto></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>parse_timestamp</name><argument_list>(<argument><expr><name><name>ident</name><operator>.</operator><name>date_begin</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>date_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>date_end</name> <operator>!=</operator> <name><name>ident</name><operator>.</operator><name>date_end</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail_exit</name>;</goto></block_content></block></if></if_stmt> 
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>author_date_slab_at</name><argument_list>(<argument><expr><name>author_date</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>date</name></expr>;</expr_stmt>

<label><name>fail_exit</name>:</label>
<expr_stmt><expr><call><name>unuse_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>compare_commits_by_author_date</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>a_</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>b_</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>author_date_slab</name></name> <modifier>*</modifier></type><name>author_date</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timestamp_t</name></type> <name>a_date</name> <init>= <expr><operator>*</operator><operator>(</operator><call><name>author_date_slab_at</name><argument_list>(<argument><expr><name>author_date</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timestamp_t</name></type> <name>b_date</name> <init>= <expr><operator>*</operator><operator>(</operator><call><name>author_date_slab_at</name><argument_list>(<argument><expr><name>author_date</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>a_date</name> <operator>&lt;</operator> <name>b_date</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>a_date</name> <operator>&gt;</operator> <name>b_date</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>compare_commits_by_gen_then_commit_date</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>a_</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>b_</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>generation</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>generation</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>generation</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>generation</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>date</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>date</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>date</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>date</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>compare_commits_by_commit_date</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>a_</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>b_</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>date</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>date</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>date</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>date</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>sort_in_topological_order</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>rev_sort_order</name></name></type> <name>sort_order</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>orig</name> <init>= <expr><operator>*</operator><name>list</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>indegree_slab</name></name></type> <name>indegree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>prio_queue</name></name></type> <name>queue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>author_date_slab</name></name></type> <name>author_date</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>orig</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_indegree_slab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indegree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>sort_order</name></expr>)</condition> <block>{<block_content>
<default>default:</default> 
<expr_stmt><expr><name><name>queue</name><operator>.</operator><name>compare</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>REV_SORT_BY_COMMIT_DATE</name></expr>:</case>
<expr_stmt><expr><name><name>queue</name><operator>.</operator><name>compare</name></name> <operator>=</operator> <name>compare_commits_by_commit_date</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>REV_SORT_BY_AUTHOR_DATE</name></expr>:</case>
<expr_stmt><expr><call><name>init_author_date_slab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>author_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>queue</name><operator>.</operator><name>compare</name></name> <operator>=</operator> <name>compare_commits_by_author_date</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>queue</name><operator>.</operator><name>cb_data</name></name> <operator>=</operator> <operator>&amp;</operator><name>author_date</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>


<for>for <control>(<init><expr><name>next</name> <operator>=</operator> <name>orig</name></expr>;</init> <condition><expr><name>next</name></expr>;</condition> <incr><expr><name>next</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>next</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>indegree_slab_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indegree</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sort_order</name> <operator>==</operator> <name>REV_SORT_BY_AUTHOR_DATE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>record_author_date</name><argument_list>(<argument><expr><operator>&amp;</operator><name>author_date</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>next</name> <operator>=</operator> <name>orig</name></expr>;</init> <condition><expr><name>next</name></expr>;</condition> <incr><expr><name>next</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name> <init>= <expr><name><name>next</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>parents</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>parents</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pi</name> <init>= <expr><call><name>indegree_slab_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indegree</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pi</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pi</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>








<for>for <control>(<init><expr><name>next</name> <operator>=</operator> <name>orig</name></expr>;</init> <condition><expr><name>next</name></expr>;</condition> <incr><expr><name>next</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>next</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><call><name>indegree_slab_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indegree</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>prio_queue_put</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>





<if_stmt><if>if <condition>(<expr><name>sort_order</name> <operator>==</operator> <name>REV_SORT_IN_GRAPH_ORDER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>prio_queue_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pptr</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>commit</name> <operator>=</operator> <call><name>prio_queue_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>parents</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>parents</name></expr> ;</condition> <incr><expr><name>parents</name> <operator>=</operator> <name><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pi</name> <init>= <expr><call><name>indegree_slab_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indegree</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>pi</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>--</operator><operator>(</operator><operator>*</operator><name>pi</name><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>prio_queue_put</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>




<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>indegree_slab_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indegree</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>pptr</name> <operator>=</operator> <operator>&amp;</operator><call><name>commit_list_insert</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>clear_indegree_slab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indegree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_prio_queue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sort_order</name> <operator>==</operator> <name>REV_SORT_BY_AUTHOR_DATE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>clear_author_date_slab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>author_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<struct>struct <name>rev_collect</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>initial</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_one_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rev_collect</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name> <operator>||</operator>
<operator>(</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>TMP_MARK</name><operator>)</operator> <operator>||</operator>
<call><name>parse_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>revs</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>, <argument><expr><name><name>revs</name><operator>-&gt;</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>revs</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>-&gt;</operator><name>commit</name><index>[<expr><name><name>revs</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>commit</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>TMP_MARK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>collect_one_reflog_ent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>ooid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>noid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl></parameter>, <parameter><decl><type><name>timestamp_t</name></type> <name>timestamp</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_collect</name></name> <modifier>*</modifier></type><name>revs</name> <init>= <expr><name>cbdata</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>revs</name><operator>-&gt;</operator><name>initial</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>revs</name><operator>-&gt;</operator><name>initial</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_one_commit</name><argument_list>(<argument><expr><name>ooid</name></expr></argument>, <argument><expr><name>revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>add_one_commit</name><argument_list>(<argument><expr><name>noid</name></expr></argument>, <argument><expr><name>revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>get_fork_point</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_collect</name></name></type> <name>revs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>bases</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>full_refname</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>dwim_ref</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>full_refname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"No such ref: '%s'"</literal></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<break>break;</break> 
<default>default:</default>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Ambiguous refname: '%s'"</literal></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>revs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>initial</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>for_each_reflog_ent</name><argument_list>(<argument><expr><name>full_refname</name></expr></argument>, <argument><expr><name>collect_one_reflog_ent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>revs</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_one_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>revs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>commit</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TMP_MARK</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>bases</name> <operator>=</operator> <call><name>get_merge_bases_many</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>revs</name><operator>.</operator><name>nr</name></name></expr></argument>, <argument><expr><name><name>revs</name><operator>.</operator><name>commit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bases</name> <operator>||</operator> <name><name>bases</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cleanup_return</name>;</goto></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>revs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>&amp;</operator><name><name>bases</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>revs</name><operator>.</operator><name>commit</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>object</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for> 
<if_stmt><if>if <condition>(<expr><name><name>revs</name><operator>.</operator><name>nr</name></name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cleanup_return</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>bases</name><operator>-&gt;</operator><name>item</name></name></expr>;</expr_stmt>

<label><name>cleanup_return</name>:</label>
<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name>bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>full_refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>




<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>gpg_sig_headers</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>NULL</name></expr>,
<expr><literal type="string">"gpgsig"</literal></expr>,
<expr><literal type="string">"gpgsig-sha256"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_sign_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sig</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>inspos</name></decl>, <decl><type ref="prev"/><name>copypos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eoh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gpg_sig_header</name> <init>= <expr><name><name>gpg_sig_headers</name><index>[<expr><call><name>hash_algo_by_ptr</name><argument_list>(<argument><expr><name>the_hash_algo</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gpg_sig_header_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>gpg_sig_header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>eoh</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eoh</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>inspos</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>inspos</name> <operator>=</operator> <name>eoh</name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keyid</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>keyid</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>keyid</name> <operator>=</operator> <call><name>get_signing_key</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sign_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig</name></expr></argument>, <argument><expr><name>keyid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>copypos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>sig</name><operator>.</operator><name>buf</name><index>[<expr><name>copypos</name></expr>]</index></name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bol</name> <init>= <expr><name><name>sig</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>copypos</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><call><name>strchrnul</name><argument_list>(<argument><expr><name>bol</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>eol</name> <operator>-</operator> <name>bol</name><operator>)</operator> <operator>+</operator> <operator>!</operator><operator>!</operator><operator>*</operator><name>eol</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>copypos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_insert</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>inspos</name></expr></argument>, <argument><expr><name>gpg_sig_header</name></expr></argument>, <argument><expr><name>gpg_sig_header_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>inspos</name> <operator>+=</operator> <name>gpg_sig_header_len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_insertstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>inspos</name><operator>++</operator></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_insert</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>inspos</name></expr></argument>, <argument><expr><name>bol</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>inspos</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>copypos</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>parse_signed_commit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>payload</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>signature</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>get_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_signature</name></decl>, <decl><type ref="prev"/><name>saw_signature</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gpg_sig_header</name> <init>= <expr><name><name>gpg_sig_headers</name><index>[<expr><call><name>hash_algo_by_ptr</name><argument_list>(<argument><expr><name>the_hash_algo</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gpg_sig_header_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>gpg_sig_header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_signature</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>saw_signature</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>line</name> <operator>&lt;</operator> <name>tail</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>tail</name> <operator>-</operator> <name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <ternary><condition><expr><name>next</name></expr> ?</condition><then> <expr><name>next</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>tail</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>in_signature</name> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>line</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>gpg_sig_header</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>line</name><index>[<expr><name>gpg_sig_header_len</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>gpg_sig_header_len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sig</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>signature</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>saw_signature</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>in_signature</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>line</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>payload</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in_signature</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>unuse_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>saw_signature</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>remove_signature</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_signature</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sig_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sig_end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>line</name> <operator>&lt;</operator> <name>tail</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>tail</name> <operator>-</operator> <name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <ternary><condition><expr><name>next</name></expr> ?</condition><then> <expr><name>next</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>tail</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>in_signature</name> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sig_end</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"gpgsig"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>GIT_HASH_NALGOS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>gpg_sig_headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sig_start</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sig_end</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_signature</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>line</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>in_signature</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>sig_start</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_remove</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sig_start</name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>sig_end</name> <operator>-</operator> <name>sig_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>sig_start</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_signed_tag</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_remote_desc</name></name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>mergetag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>merge_remote_util</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>desc</name> <operator>||</operator> <operator>!</operator><name><name>desc</name><operator>-&gt;</operator><name>obj</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <name>type</name> <operator>!=</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>free_return</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>parse_signature</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>free_return</name>;</goto></block_content></block></if></if_stmt>










<expr_stmt><expr><name>mergetag</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>mergetag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mergetag</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"mergetag"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mergetag</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mergetag</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>*</operator><name>tail</name> <operator>=</operator> <name>mergetag</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>mergetag</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<return>return;</return>

<label><name>free_return</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>check_commit_signature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>signature_check</name></name> <modifier>*</modifier></type><name>sigc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>payload</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>signature</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sigc</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_signed_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>payload</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>signature</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>check_signature</name><argument_list>(<argument><expr><name><name>payload</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>payload</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>signature</name><operator>.</operator><name>buf</name></name></expr></argument>,
<argument><expr><name><name>signature</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>sigc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out</name>:</label>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signature</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>verify_merge_signature</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>verbosity</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>check_trust</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>hex</name><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>signature_check</name></name></type> <name>signature_check</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signature_check</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>signature_check</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>check_commit_signature</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>signature_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_unique_abbrev_r</name><argument_list>(<argument><expr><name>hex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>signature_check</name><operator>.</operator><name>result</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'G'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>(</operator><name>check_trust</name> <operator>&amp;&amp;</operator> <name><name>signature_check</name><operator>.</operator><name>trust_level</name></name> <operator>&lt;</operator> <name>TRUST_MARGINAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Commit %s has an untrusted GPG signature, "</literal>
<literal type="string">"allegedly by %s."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hex</name></expr></argument>, <argument><expr><name><name>signature_check</name><operator>.</operator><name>signer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Commit %s has a bad GPG signature "</literal>
<literal type="string">"allegedly by %s."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hex</name></expr></argument>, <argument><expr><name><name>signature_check</name><operator>.</operator><name>signer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:</default> 
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Commit %s does not have a GPG signature."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>signature_check</name><operator>.</operator><name>result</name></name> <operator>==</operator> <literal type="char">'G'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Commit %s has a good GPG signature by %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>hex</name></expr></argument>, <argument><expr><name><name>signature_check</name><operator>.</operator><name>signer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>signature_check_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>signature_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>append_merge_tag_headers</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>parents</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>handle_signed_tag</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_extra_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_add_lines</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>read_commit_extra_headers</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>exclude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>get_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>read_commit_extra_header_lines</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unuse_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>extra</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>for_each_mergetag</name><parameter_list>(<parameter><decl><type><name>each_mergetag_fn</name></type> <name>fn</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>extra</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>to_free</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>to_free</name> <operator>=</operator> <call><name>read_commit_extra_headers</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>extra</name> <operator>=</operator> <name>to_free</name></expr>;</init> <condition><expr><operator>!</operator><name>res</name> <operator>&amp;&amp;</operator> <name>extra</name></expr>;</condition> <incr><expr><name>extra</name> <operator>=</operator> <name><name>extra</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"mergetag"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fn</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free_commit_extra_headers</name><argument_list>(<argument><expr><name>to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>standard_header_field</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"tree"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"parent"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"author"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"committer"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>excluded_header_field</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>exclude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exclude</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>exclude</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>xlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>exclude</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>xlen</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><operator>*</operator><name>exclude</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>exclude</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>read_commit_extra_header_lines</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>exclude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>extra</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eof</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eob</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>buffer</name></expr><operator>,</operator> <expr><name>eob</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>size</name></expr>;</init>
<condition><expr><name>line</name> <operator>&lt;</operator> <name>eob</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>line</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>;</condition>
<incr><expr><name>line</name> <operator>=</operator> <name>next</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>eob</name> <operator>-</operator> <name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <ternary><condition><expr><name>next</name></expr> ?</condition><then> <expr><name>next</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>eob</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>line</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>it</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>line</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <operator>(</operator><name>line</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>it</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>it</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>eof</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eof</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>eof</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>standard_header_field</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>eof</name> <operator>-</operator> <name>line</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>excluded_header_field</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>eof</name> <operator>-</operator> <name>line</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>eof</name><operator>-</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eof</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>next</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>eof</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <operator>(</operator><name>eof</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>it</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>extra</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_commit_extra_headers</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>extra</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>extra</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extra</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>commit_tree</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>msg_len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>ret</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>author</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sign_commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>extra</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>append_merge_tag_headers</name><argument_list>(<argument><expr><name>parents</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>commit_tree_extended</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>parents</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>,
<argument><expr><name>author</name></expr></argument>, <argument><expr><name>sign_commit</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_commit_extra_headers</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_invalid_utf8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name><name>max_codepoint</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="number">0x7f</literal></expr>, <expr><literal type="number">0x7ff</literal></expr>, <expr><literal type="number">0xffff</literal></expr>, <expr><literal type="number">0x10ffff</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>buf</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>, <decl><type ref="prev"/><name>bad_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>codepoint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>min_val</name></decl>, <decl><type ref="prev"/><name>max_val</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bad_offset</name> <operator>=</operator> <name>offset</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>





<expr_stmt><expr><name>bytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x40</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>





<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <literal type="number">3</literal> <operator>&lt;</operator> <name>bytes</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>bad_offset</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>bytes</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>bad_offset</name></expr>;</return></block_content></block></if></if_stmt>





<expr_stmt><expr><name>codepoint</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>min_val</name> <operator>=</operator> <name><name>max_codepoint</name><index>[<expr><name>bytes</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max_val</name> <operator>=</operator> <name><name>max_codepoint</name><index>[<expr><name>bytes</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>bytes</name></expr>;</expr_stmt>


<do>do <block>{<block_content>
<expr_stmt><expr><name>codepoint</name> <operator>&lt;&lt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>codepoint</name> <operator>|=</operator> <operator>*</operator><name>buf</name> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>buf</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>bad_offset</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>--</operator><name>bytes</name></expr>)</condition>;</do>


<if_stmt><if>if <condition>(<expr><name><name>codepoint</name> <argument_list type="generic">&lt; <argument><expr><name>min_val</name> <operator>||</operator> <name>codepoint</name></expr></argument> &gt;</argument_list></name> <name>max_val</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>bad_offset</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>codepoint</name> <operator>&amp;</operator> <literal type="number">0x1ff800</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xd800</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>bad_offset</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>codepoint</name> <operator>&amp;</operator> <literal type="number">0xfffe</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xfffe</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>bad_offset</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>codepoint</name> <operator>&gt;=</operator> <literal type="number">0xfdd0</literal> <operator>&amp;&amp;</operator> <name>codepoint</name> <operator>&lt;=</operator> <literal type="number">0xfdef</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>bad_offset</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type> <name>verify_utf8</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>replace</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>bad</name> <operator>=</operator> <call><name>find_invalid_utf8</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bad</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ok</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>bad</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_remove</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>replace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xc0</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>replace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_insert</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>commit_utf8_warn</name><index>[]</index></name> <init>=
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Warning: commit message did not conform to UTF-8.\n"</literal>
<literal type="string">"You may want to amend it after fixing the message, or set the config\n"</literal>
<literal type="string">"variable i18n.commitencoding to the encoding your project uses.\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>commit_tree_extended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>msg_len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>ret</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>author</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sign_commit</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_extra_header</name></name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>encoding_is_utf8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buffer</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert_oid_type</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>OBJ_TREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"a NUL byte in commit log message not allowed."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>encoding_is_utf8</name> <operator>=</operator> <call><name>is_encoding_utf8</name><argument_list>(<argument><expr><name>git_commit_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="number">8192</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"tree %s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<while>while <condition>(<expr><name>parents</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><call><name>pop_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parents</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"parent %s\n"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>author</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>author</name> <operator>=</operator> <call><name>git_author_info</name><argument_list>(<argument><expr><name>IDENT_STRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"author %s\n"</literal></expr></argument>, <argument><expr><name>author</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"committer %s\n"</literal></expr></argument>, <argument><expr><call><name>git_committer_info</name><argument_list>(<argument><expr><name>IDENT_STRICT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>encoding_is_utf8</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"encoding %s\n"</literal></expr></argument>, <argument><expr><name>git_commit_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>extra</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_extra_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>extra</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>encoding_is_utf8</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>verify_utf8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>commit_utf8_warn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sign_commit</name> <operator>&amp;&amp;</operator> <call><name>do_sign_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>sign_commit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>write_object_file</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>commit_type</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>define_commit_slab</name><argument_list>(<argument><expr><name>merge_desc_slab</name></expr></argument>, <argument><expr>struct <name>merge_remote_desc</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>merge_desc_slab</name></name></type> <name>merge_desc_slab</name> <init>= <expr><call><name>COMMIT_SLAB_INIT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>merge_desc_slab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><name><name>struct</name> <name>merge_remote_desc</name></name> <modifier>*</modifier></type><name>merge_remote_util</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>*</operator><call><name>merge_desc_slab_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_desc_slab</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_merge_remote_desc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_remote_desc</name></name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FLEX_ALLOC_STR</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><call><name>merge_desc_slab_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_desc_slab</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>get_merge_parent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>parse_object</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>commit</name> <operator>=</operator> <operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><call><name>peel_to_type</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>OBJ_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>commit</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>merge_remote_util</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_merge_remote_desc</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>commit</name></expr>;</return>
</block_content>}</block></function>


















<function><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>commit_list_append</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>next</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>new_commit</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>commit_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>new_commit</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <name>commit</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <name>new_commit</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_commit</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>&amp;</operator><name><name>new_commit</name><operator>-&gt;</operator><name>next</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>find_commit_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>out_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>key_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name>msg</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>line</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><call><name>strchrnul</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>eol</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>eol</name> <operator>-</operator> <name>line</name> <operator>&gt;</operator> <name>key_len</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>line</name><index>[<expr><name>key_len</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_len</name> <operator>=</operator> <name>eol</name> <operator>-</operator> <name>line</name> <operator>-</operator> <name>key_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>line</name> <operator>+</operator> <name>key_len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>eol</name></expr> ?</condition><then> <expr><name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>size_t</name></type> <name>ignore_non_trailer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>boc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_old_conflicts_block</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>cutoff</name> <init>= <expr><call><name>wt_status_locate_end</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>bol</name> <operator>&lt;</operator> <name>cutoff</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next_line</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>bol</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>bol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>next_line</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>next_line</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>next_line</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>bol</name></expr>]</index></name> <operator>==</operator> <name>comment_line_char</name> <operator>||</operator> <name><name>buf</name><index>[<expr><name>bol</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>boc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>boc</name> <operator>=</operator> <name>bol</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>bol</name></expr></argument>, <argument><expr><literal type="string">"Conflicts:\n"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in_old_conflicts_block</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>boc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>boc</name> <operator>=</operator> <name>bol</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>in_old_conflicts_block</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>bol</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition> <block>{<block_content>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>boc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>boc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>in_old_conflicts_block</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bol</name> <operator>=</operator> <name>next_line</name> <operator>-</operator> <name>buf</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><ternary><condition><expr><name>boc</name></expr> ?</condition><then> <expr><name>len</name> <operator>-</operator> <name>boc</name></expr> </then><else>: <expr><name>len</name> <operator>-</operator> <name>cutoff</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>run_commit_hook</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>editor_is_used</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index_file</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>hook_env</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>argv_array_pushf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hook_env</name></expr></argument>, <argument><expr><literal type="string">"GIT_INDEX_FILE=%s"</literal></expr></argument>, <argument><expr><name>index_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name>editor_is_used</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hook_env</name></expr></argument>, <argument><expr><literal type="string">"GIT_EDITOR=:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>run_hook_ve</name><argument_list>(<argument><expr><name><name>hook_env</name><operator>.</operator><name>argv</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hook_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
</unit>
