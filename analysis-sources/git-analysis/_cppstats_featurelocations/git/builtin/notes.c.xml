<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\builtin\notes.c">








<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"notes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blob.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pretty.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"exec-cmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parse-options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string-list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"notes-merge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"notes-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"worktree.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] [list [&lt;object&gt;]]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] add [-f] [--allow-empty] [-m &lt;msg&gt; | -F &lt;file&gt; | (-c | -C) &lt;object&gt;] [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] copy [-f] &lt;from-object&gt; &lt;to-object&gt;"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] append [--allow-empty] [-m &lt;msg&gt; | -F &lt;file&gt; | (-c | -C) &lt;object&gt;] [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] edit [--allow-empty] [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] show [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] merge [-v | -q] [-s &lt;strategy&gt;] &lt;notes-ref&gt;"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes merge --commit [-v | -q]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes merge --abort [-v | -q]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] remove [&lt;object&gt;...]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] prune [-n] [-v]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [--ref &lt;notes-ref&gt;] get-ref"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_list_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes [list [&lt;object&gt;]]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_add_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes add [&lt;options&gt;] [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_copy_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes copy [&lt;options&gt;] &lt;from-object&gt; &lt;to-object&gt;"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes copy --stdin [&lt;from-object&gt; &lt;to-object&gt;]..."</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_append_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes append [&lt;options&gt;] [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_edit_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes edit [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_show_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes show [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_merge_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes merge [&lt;options&gt;] &lt;notes-ref&gt;"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes merge --commit [&lt;options&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes merge --abort [&lt;options&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_remove_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes remove [&lt;object&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_prune_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes prune [&lt;options&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>git_notes_get_ref_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git notes get-ref"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>note_template</name><index>[]</index></name> <init>=
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Write/edit the notes for the following object:"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<struct>struct <name>note_data</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>given</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_editor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>edit_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_note_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>note_data</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>list_each_note</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>object_oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>note_oid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>note_path</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>note_oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>object_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_obj_to_fd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>read_object_file</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>write_or_die</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_commented_object</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>show_args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>=
<expr><block>{<expr><literal type="string">"show"</literal></expr>, <expr><literal type="string">"--stat"</literal></expr>, <expr><literal type="string">"--no-notes"</literal></expr>, <expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>show</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>cbuf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name><name>show</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name>show_args</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>show</name><operator>.</operator><name>no_stdin</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>show</name><operator>.</operator><name>out</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>show</name><operator>.</operator><name>err</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>show</name><operator>.</operator><name>git_cmd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>start_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>show</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to start 'show' for object '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strbuf_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>show</name><operator>.</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not read 'show' output"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_add_commented_lines</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cbuf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_or_die</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>cbuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>cbuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>finish_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>show</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to finish 'show' for object '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>prepare_note_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>note_data</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>old_note</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>use_editor</name></name> <operator>||</operator> <operator>!</operator><name><name>d</name><operator>-&gt;</operator><name>given</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name> <operator>=</operator> <call><name>git_pathdup</name><argument_list>(<argument><expr><literal type="string">"NOTES_EDITMSG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_WRONLY</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not create file '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>given</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>write_or_die</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>old_note</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_obj_to_fd</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>old_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add_commented_lines</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add_commented_lines</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>note_template</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>note_template</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_or_die</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_commented_object</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>launch_editor</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"please supply the note contents using either -m or -F option"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_stripspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_note_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>note_data</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>write_object_file</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>blob_type</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to write note object"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"the note contents have been left in %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>d</name><operator>-&gt;</operator><name>edit_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_msg_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>note_data</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_stripspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>given</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_file_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>note_data</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strbuf_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot read '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strbuf_read_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not open or read '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_stripspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>given</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_reuse_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>note_data</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>object</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to read object '%s'."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot read note data from non-blob object '%s'."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>given</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_reedit_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>note_data</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>use_editor</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><call><name>parse_reuse_arg</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>notes_copy_from_stdin</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rewrite_cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_rewrite_cfg</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"Notes added by 'git notes copy'"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rewrite_cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>init_copy_notes_for_rewrite</name><argument_list>(<argument><expr><name>rewrite_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>init_notes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NOTES_INIT_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>&amp;</operator><name>default_notes_tree</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><call><name>strbuf_getline_lf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>from_obj</name></decl>, <decl><type ref="prev"/><name>to_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>split</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name>split</name> <operator>=</operator> <call><name>strbuf_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"malformed input line: '%s'."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_rtrim</name><argument_list>(<argument><expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_rtrim</name><argument_list>(<argument><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>from_obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to_obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rewrite_cmd</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>copy_note_for_rewrite</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>from_obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>copy_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>from_obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to_obj</name></expr></argument>, <argument><expr><name>force</name></expr></argument>,
<argument><expr><name>combine_notes_overwrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to copy notes from '%s' to '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_list_free</name><argument_list>(<argument><expr><name>split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rewrite_cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>commit_notes</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>finish_copy_notes_for_rewrite</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>init_notes_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subcommand</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>init_notes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>&amp;</operator><name>default_notes_tree</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ref</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>NOTES_INIT_WRITABLE</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>t</name><operator>-&gt;</operator><name>update_ref</name></name></expr> </then><else>: <expr><name><name>t</name><operator>-&gt;</operator><name>ref</name></name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="string">"refs/notes/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>




<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"refusing to %s notes in %s (outside of refs/notes/)"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>subcommand</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>list</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>object</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>note</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
<argument><expr><name>git_notes_list_usage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_list_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>init_notes_check</name><argument_list>(<argument><expr><literal type="string">"list"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>note</name> <operator>=</operator> <call><name>get_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>note</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>note</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no note found for object %s."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>for_each_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>list_each_note</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>append_edit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>force</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>allow_empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>object</name></decl>, <decl><type ref="prev"/><name>new_note</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>note</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>note_data</name></name></type> <name>d</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>STRBUF_INIT</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><literal type="string">"message"</literal></expr>, <expr><operator>&amp;</operator><name>d</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"message"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"note contents as a string"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>parse_msg_arg</name></expr>}</block></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="string">"file"</literal></expr>, <expr><operator>&amp;</operator><name>d</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"note contents in a file"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>parse_file_arg</name></expr>}</block></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="string">"reedit-message"</literal></expr>, <expr><operator>&amp;</operator><name>d</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"reuse and edit specified note object"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>parse_reedit_arg</name></expr>}</block></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"reuse-message"</literal></expr>, <expr><operator>&amp;</operator><name>d</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"reuse specified note object"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>parse_reuse_arg</name></expr>}</block></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"allow-empty"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>allow_empty</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"allow storing empty note"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT__FORCE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>force</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"replace existing notes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PARSE_OPT_NOCOMPLETE</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>git_notes_add_usage</name></expr></argument>,
<argument><expr><name>PARSE_OPT_KEEP_ARGV0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_add_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>object_ref</name> <operator>=</operator> <ternary><condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"HEAD"</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>object_ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>object_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>init_notes_check</name><argument_list>(<argument><expr><literal type="string">"add"</literal></expr></argument>, <argument><expr><name>NOTES_INIT_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>note</name> <operator>=</operator> <call><name>get_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>note</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>given</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_note_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot add notes. "</literal>
<literal type="string">"Found existing notes for object %s. "</literal>
<literal type="string">"Use '-f' to overwrite existing notes"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>







<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"edit"</literal></expr>;</expr_stmt>
<return>return <expr><call><name>append_edit</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Overwriting existing notes for object %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>prepare_note_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>||</operator> <name>allow_empty</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>write_note_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_note</name></expr></argument>, <argument><expr><name>combine_notes_overwrite</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"combine_notes_overwrite failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>commit_notes</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>t</name></expr></argument>,
<argument><expr><literal type="string">"Notes added by 'git notes add'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Removing note for object %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>object</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>commit_notes</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>t</name></expr></argument>,
<argument><expr><literal type="string">"Notes removed by 'git notes add'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free_note_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>copy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>force</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>from_stdin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>from_note</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>note</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>object</name></decl>, <decl><type ref="prev"/><name>from_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rewrite_cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT__FORCE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>force</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"replace existing notes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PARSE_OPT_NOCOMPLETE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"stdin"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>from_stdin</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"read objects from stdin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"for-rewrite"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rewrite_cmd</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"load rewriting config for &lt;command&gt; (implies "</literal>
<literal type="string">"--stdin)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>git_notes_copy_usage</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>from_stdin</name> <operator>||</operator> <name>rewrite_cmd</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_copy_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>notes_copy_from_stdin</name><argument_list>(<argument><expr><name>force</name></expr></argument>, <argument><expr><name>rewrite_cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too few parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_copy_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_copy_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>from_obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>object_ref</name> <operator>=</operator> <ternary><condition><expr><literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"HEAD"</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>object_ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>object_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>init_notes_check</name><argument_list>(<argument><expr><literal type="string">"copy"</literal></expr></argument>, <argument><expr><name>NOTES_INIT_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>note</name> <operator>=</operator> <call><name>get_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>note</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot copy notes. Found existing "</literal>
<literal type="string">"notes for object %s. Use '-f' to "</literal>
<literal type="string">"overwrite existing notes"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Overwriting existing notes for object %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>from_note</name> <operator>=</operator> <call><name>get_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>from_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from_note</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"missing notes on source object %s. Cannot "</literal>
<literal type="string">"copy."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>from_obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>add_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>from_note</name></expr></argument>, <argument><expr><name>combine_notes_overwrite</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"combine_notes_overwrite failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>commit_notes</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>t</name></expr></argument>,
<argument><expr><literal type="string">"Notes added by 'git notes copy'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>append_edit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>allow_empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>object</name></decl>, <decl><type ref="prev"/><name>new_note</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>note</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>logmsg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>usage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>note_data</name></name></type> <name>d</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>STRBUF_INIT</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><literal type="string">"message"</literal></expr>, <expr><operator>&amp;</operator><name>d</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"message"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"note contents as a string"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>parse_msg_arg</name></expr>}</block></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="string">"file"</literal></expr>, <expr><operator>&amp;</operator><name>d</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"note contents in a file"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>parse_file_arg</name></expr>}</block></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="string">"reedit-message"</literal></expr>, <expr><operator>&amp;</operator><name>d</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"reuse and edit specified note object"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>parse_reedit_arg</name></expr>}</block></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"reuse-message"</literal></expr>, <expr><operator>&amp;</operator><name>d</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"reuse specified note object"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>parse_reuse_arg</name></expr>}</block></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"allow-empty"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>allow_empty</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"allow storing empty note"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>edit</name> <init>= <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"edit"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>usage</name> <operator>=</operator> <ternary><condition><expr><name>edit</name></expr> ?</condition><then> <expr><name>git_notes_edit_usage</name></expr> </then><else>: <expr><name>git_notes_append_usage</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>usage</name></expr></argument>,
<argument><expr><name>PARSE_OPT_KEEP_ARGV0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>given</name></name> <operator>&amp;&amp;</operator> <name>edit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The -m/-F/-c/-C options have been deprecated "</literal>
<literal type="string">"for the 'edit' subcommand.\n"</literal>
<literal type="string">"Please use 'git notes add -f -m/-F/-c/-C' instead.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>object_ref</name> <operator>=</operator> <ternary><condition><expr><literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"HEAD"</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>object_ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>object_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>init_notes_check</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NOTES_INIT_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>note</name> <operator>=</operator> <call><name>get_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>prepare_note_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><ternary><condition><expr><name>edit</name> <operator>&amp;&amp;</operator> <name>note</name></expr> ?</condition><then> <expr><name>note</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>note</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>edit</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prev_buf</name> <init>= <expr><call><name>read_object_file</name><argument_list>(<argument><expr><name>note</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name>prev_buf</name> <operator>&amp;&amp;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_insertstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>prev_buf</name> <operator>&amp;&amp;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>prev_buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prev_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>||</operator> <name>allow_empty</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>write_note_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_note</name></expr></argument>, <argument><expr><name>combine_notes_overwrite</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"combine_notes_overwrite failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>logmsg</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"Notes added by 'git notes %s'"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Removing note for object %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>object</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>logmsg</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"Notes removed by 'git notes %s'"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>commit_notes</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>logmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>logmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_note_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>show</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>object</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>note</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>git_notes_show_usage</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_show_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>object_ref</name> <operator>=</operator> <ternary><condition><expr><name>argc</name></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"HEAD"</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>object_ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>object_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>init_notes_check</name><argument_list>(<argument><expr><literal type="string">"show"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>note</name> <operator>=</operator> <call><name>get_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>note</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no note found for object %s."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>show_args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">"show"</literal></expr>, <expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>note</name></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>execv_git_cmd</name><argument_list>(<argument><expr><name>show_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_abort</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>notes_merge_options</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><call><name>delete_ref</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"NOTES_MERGE_PARTIAL"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>+=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to delete ref NOTES_MERGE_PARTIAL"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>delete_ref</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"NOTES_MERGE_REF"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>REF_NO_DEREF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>+=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to delete ref NOTES_MERGE_REF"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>notes_merge_abort</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>+=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to remove 'git notes merge' worktree"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>notes_merge_options</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>msg</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>, <decl><type ref="prev"/><name>parent_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>partial</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pretty_print_context</name></name></type> <name>pretty_ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>local_ref_to_free</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><literal type="string">"NOTES_MERGE_PARTIAL"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to read ref NOTES_MERGE_PARTIAL"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>partial</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not find commit from NOTES_MERGE_PARTIAL."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>parse_commit</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not parse commit from NOTES_MERGE_PARTIAL."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>partial</name><operator>-&gt;</operator><name>parents</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>partial</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>notes_tree</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"NOTES_MERGE_PARTIAL"</literal></expr></argument>, <argument><expr><name>combine_notes_overwrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>local_ref</name></name> <operator>=</operator> <name>local_ref_to_free</name> <operator>=</operator>
<call><name>resolve_refdup</name><argument_list>(<argument><expr><literal type="string">"NOTES_MERGE_REF"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>o</name><operator>-&gt;</operator><name>local_ref</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to resolve NOTES_MERGE_REF"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>notes_merge_commit</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>partial</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to finalize notes merge"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pretty_ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pretty_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>format_commit_message</name><argument_list>(<argument><expr><name>partial</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pretty_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_trim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_insertstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"notes: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_ref</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>local_ref</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>,
<argument><expr><ternary><condition><expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_oid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>parent_oid</name></expr></else></ternary></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>UPDATE_REFS_DIE_ON_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>merge_abort</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>local_ref_to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>git_config_get_notes_strategy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>notes_merge_strategy</name></name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_get_string</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_notes_merge_strategy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>git_die_config</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unknown notes merge strategy %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>remote_ref</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>, <decl><type ref="prev"/><name>msg</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>result_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_merge_options</name></name></type> <name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>do_merge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>do_commit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>do_abort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>verbosity</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strategy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"General options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT__VERBOSITY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>verbosity</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Merge options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="string">"strategy"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"strategy"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"resolve notes conflicts using the given strategy "</literal>
<literal type="string">"(manual/ours/theirs/union/cat_sort_uniq)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Committing unmerged notes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"commit"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>do_commit</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"finalize notes merge by committing unmerged notes"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>PARSE_OPT_NONEG</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Aborting notes merge resolution"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"abort"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>do_abort</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"abort notes merge"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>PARSE_OPT_NONEG</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
<argument><expr><name>git_notes_merge_usage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>||</operator> <name>do_commit</name> <operator>+</operator> <name>do_abort</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>do_merge</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>do_merge</name> <operator>+</operator> <name>do_commit</name> <operator>+</operator> <name>do_abort</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot mix --commit, --abort or -s/--strategy"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_merge_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_merge</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"must specify a notes ref to merge"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_merge_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>do_merge</name> <operator>&amp;&amp;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_merge_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>init_notes_merge_options</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>.</operator><name>verbosity</name></name> <operator>=</operator> <name>verbosity</name> <operator>+</operator> <name>NOTES_MERGE_VERBOSITY_DEFAULT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>do_abort</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>merge_abort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>do_commit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>merge_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>o</name><operator>.</operator><name>local_ref</name></name> <operator>=</operator> <call><name>default_notes_ref</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_ref</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expand_loose_notes_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>.</operator><name>remote_ref</name></name> <operator>=</operator> <name><name>remote_ref</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>init_notes_check</name><argument_list>(<argument><expr><literal type="string">"merge"</literal></expr></argument>, <argument><expr><name>NOTES_INIT_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>strategy</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>parse_notes_merge_strategy</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unknown -s/--strategy: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_merge_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>merge_key</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_ref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>o</name><operator>.</operator><name>local_ref</name></name></expr></argument>, <argument><expr><literal type="string">"refs/notes/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>short_ref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"local ref %s is outside of refs/notes/"</literal></expr></argument>,
<argument><expr><name><name>o</name><operator>.</operator><name>local_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_key</name></expr></argument>, <argument><expr><literal type="string">"notes.%s.mergeStrategy"</literal></expr></argument>, <argument><expr><name>short_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_get_notes_strategy</name><argument_list>(<argument><expr><name><name>merge_key</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>git_config_get_notes_strategy</name><argument_list>(<argument><expr><literal type="string">"notes.mergeStrategy"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"notes: Merged notes from %s into %s"</literal></expr></argument>,
<argument><expr><name><name>remote_ref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><call><name>default_notes_ref</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>o</name><operator>.</operator><name>commit_msg</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>notes_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>update_ref</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><call><name>default_notes_ref</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>UPDATE_REFS_DIE_ON_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content> 
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>worktree</name></name> <modifier>*</modifier></type><name>wt</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>update_ref</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"NOTES_MERGE_PARTIAL"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>UPDATE_REFS_DIE_ON_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wt</name> <operator>=</operator> <call><name>find_shared_symref</name><argument_list>(<argument><expr><literal type="string">"NOTES_MERGE_REF"</literal></expr></argument>, <argument><expr><call><name>default_notes_ref</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"a notes merge into %s is already in-progress at %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>default_notes_ref</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>wt</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>create_symref</name><argument_list>(<argument><expr><literal type="string">"NOTES_MERGE_REF"</literal></expr></argument>, <argument><expr><call><name>default_notes_ref</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to store link to current notes ref (%s)"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>default_notes_ref</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Automatic notes merge failed. Fix conflicts in %s "</literal>
<literal type="string">"and commit the result with 'git notes merge --commit', "</literal>
<literal type="string">"or abort the merge with 'git notes merge --abort'.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>git_path</name><argument_list>(<argument><expr><name>NOTES_MERGE_WORKTREE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return> 
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IGNORE_MISSING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>remove_one_note</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_oid</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to resolve '%s' as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>remove_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Object %s has no note\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Removing note for object %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>IGNORE_MISSING</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>status</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>remove_cmd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>from_stdin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ignore-missing"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"attempt to remove non-existent note is not an error"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>IGNORE_MISSING</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"stdin"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>from_stdin</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"read object names from the standard input"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
<argument><expr><name>git_notes_remove_usage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>init_notes_check</name><argument_list>(<argument><expr><literal type="string">"remove"</literal></expr></argument>, <argument><expr><name>NOTES_INIT_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>from_stdin</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>remove_one_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>argv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <call><name>remove_one_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>*</operator><name>argv</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>from_stdin</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>strbuf_getwholeline</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_rtrim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <call><name>remove_one_note</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>retval</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>commit_notes</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>t</name></expr></argument>,
<argument><expr><literal type="string">"Notes removed by 'git notes remove'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prune</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>notes_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>show_only</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>verbose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT__DRY_RUN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>show_only</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not remove, show only"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT__VERBOSE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>verbose</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"report pruned notes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>git_notes_prune_usage</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_prune_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>init_notes_check</name><argument_list>(<argument><expr><literal type="string">"prune"</literal></expr></argument>, <argument><expr><name>NOTES_INIT_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>prune_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><name>NOTES_PRUNE_VERBOSE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>show_only</name></expr> ?</condition><then> <expr><name>NOTES_PRUNE_VERBOSE</name><operator>|</operator><name>NOTES_PRUNE_DRYRUN</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>show_only</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>commit_notes</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>t</name></expr></argument>,
<argument><expr><literal type="string">"Notes removed by 'git notes prune'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free_notes</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_ref</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{ <macro><name>OPT_END</name><argument_list>()</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
<argument><expr><name>git_notes_get_ref_usage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parameters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_get_ref_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><call><name>default_notes_ref</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmd_notes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>override_notes_ref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>override_notes_ref</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"notes-ref"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use notes from &lt;notes-ref&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_default_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>git_notes_usage</name></expr></argument>,
<argument><expr><name>PARSE_OPT_STOP_AT_NON_OPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>override_notes_ref</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>override_notes_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expand_notes_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><literal type="string">"GIT_NOTES_REF"</literal></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"add"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>add</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"copy"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>copy</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"edit"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>append_edit</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"show"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>show</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"merge"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>merge</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"remove"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>remove_cmd</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"prune"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>prune</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"get-ref"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_ref</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unknown subcommand: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>git_notes_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><ternary><condition><expr><name>result</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
