<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\builtin\fast-export.c">




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refspec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diffcore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log-tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revision.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"decorate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string-list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parse-options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blob.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-slab.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>fast_export_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git fast-export [rev-list-opts]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>progress</name></decl>;</decl_stmt>
<enum><specifier>static</specifier> enum <block>{ <decl><name>SIGNED_TAG_ABORT</name></decl>, <decl><name>VERBATIM</name></decl>, <decl><name>WARN</name></decl>, <decl><name>WARN_STRIP</name></decl>, <decl><name>STRIP</name></decl> }</block> <decl><name>signed_tag_mode</name> <init>= <expr><name>SIGNED_TAG_ABORT</name></expr></init></decl>;</enum>
<enum><specifier>static</specifier> enum <block>{ <decl><name>TAG_FILTERING_ABORT</name></decl>, <decl><name>DROP</name></decl>, <decl><name>REWRITE</name></decl> }</block> <decl><name>tag_of_filtered_mode</name> <init>= <expr><name>TAG_FILTERING_ABORT</name></expr></init></decl>;</enum>
<enum><specifier>static</specifier> enum <block>{ <decl><name>REENCODE_ABORT</name></decl>, <decl><name>REENCODE_YES</name></decl>, <decl><name>REENCODE_NO</name></decl> }</block> <decl><name>reencode_mode</name> <init>= <expr><name>REENCODE_ABORT</name></expr></init></decl>;</enum>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>fake_missing_tagger</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>use_done_feature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>no_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>full_tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>reference_excluded_commits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>show_original_ids</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>mark_tags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>extra_refs</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>tag_refs</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>refspec</name></name></type> <name>refspecs</name> <init>= <expr><name>REFSPEC_INIT_FETCH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>anonymize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>revision_sources</name></name></type> <name>revision_sources</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_opt_signed_tag_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>unset</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"abort"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>signed_tag_mode</name> <operator>=</operator> <name>SIGNED_TAG_ABORT</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"verbatim"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"ignore"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>signed_tag_mode</name> <operator>=</operator> <name>VERBATIM</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"warn"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>signed_tag_mode</name> <operator>=</operator> <name>WARN</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"warn-strip"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>signed_tag_mode</name> <operator>=</operator> <name>WARN_STRIP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"strip"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>signed_tag_mode</name> <operator>=</operator> <name>STRIP</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Unknown signed-tags mode: %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_opt_tag_of_filtered_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>unset</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"abort"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tag_of_filtered_mode</name> <operator>=</operator> <name>TAG_FILTERING_ABORT</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"drop"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tag_of_filtered_mode</name> <operator>=</operator> <name>DROP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"rewrite"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tag_of_filtered_mode</name> <operator>=</operator> <name>REWRITE</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Unknown tag-of-filtered mode: %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_opt_reencode_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>unset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>reencode_mode</name> <operator>=</operator> <name>REENCODE_ABORT</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>git_parse_maybe_bool</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>reencode_mode</name> <operator>=</operator> <name>REENCODE_NO</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>reencode_mode</name> <operator>=</operator> <name>REENCODE_YES</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"abort"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>reencode_mode</name> <operator>=</operator> <name>REENCODE_ABORT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Unknown reencoding mode: %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>decoration</name></name></type> <name>idnums</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>last_idnum</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>has_unshown_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>parent</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>parent</name></expr>;</condition> <incr><expr><name>parent</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>SHOWN</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>anonymized_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>orig_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>anon</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>anon_len</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>anonymized_entry_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_cmp_data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>entry_or_key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_keydata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>anonymized_entry</name></name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>anonymized_entry</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>entry_or_key</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>anonymized_entry</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>orig_len</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>orig_len</name></name> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>orig</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>orig</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>orig_len</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>anonymize_mem</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>,
<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>generate</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>anonymized_entry</name></name></type> <name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>map</name><operator>-&gt;</operator><name>cmpfn</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>anonymized_entry_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><call><name>memhash</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><operator>*</operator><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>.</operator><name>orig</name></name> <operator>=</operator> <name>orig</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>.</operator><name>orig_len</name></name> <operator>=</operator> <operator>*</operator><name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hashmap_get_entry</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ret</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>hash</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>orig</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>orig_len</name></name> <operator>=</operator> <operator>*</operator><name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>anon</name></name> <operator>=</operator> <call><name>generate</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>anon_len</name></name> <operator>=</operator> <operator>*</operator><name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_put</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>ret</name><operator>-&gt;</operator><name>anon_len</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>ret</name><operator>-&gt;</operator><name>anon</name></name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>anonymize_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>,
<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>generate</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>path</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end_of_component</name> <init>= <expr><call><name>strchrnul</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>end_of_component</name> <operator>-</operator> <name>path</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>anonymize_mem</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>generate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <name>end_of_component</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>*</operator><name>path</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type><name>mark_to_ptr</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>mark</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32_t</name></type> <name>ptr_to_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>mark</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>mark_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>add_decoration</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idnums</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><call><name>mark_to_ptr</name><argument_list>(<argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>mark_next_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>mark_object</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><operator>++</operator><name>last_idnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_object_mark</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>decoration</name> <init>= <expr><call><name>lookup_decoration</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idnums</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>decoration</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>ptr_to_mark</name><argument_list>(<argument><expr><name>decoration</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>rewrite_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>parents</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>TREESAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>parents</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_progress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>counter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>++</operator><name>counter</name> <operator>%</operator> <name>progress</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"progress %d objects\n"</literal></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>anonymize_blob</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>counter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>out</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="string">"anonymous blob %d"</literal></expr></argument>, <argument><expr><name>counter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>export_blob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>eaten</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>no_data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>lookup_object</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>object</name> <operator>&amp;&amp;</operator> <name><name>object</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SHOWN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>anonymize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>anonymize_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>object</name> <operator>=</operator> <operator>(</operator>struct <name>object</name> <operator>*</operator><operator>)</operator><call><name>lookup_blob</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eaten</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"could not read blob %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>check_object_signature</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"oid mismatch in blob %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>parse_object_buffer</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
<argument><expr><name>size</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eaten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>object</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Could not read blob %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mark_next_object</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"blob\nmark :%"</literal><name>PRIu32</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>last_idnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>show_original_ids</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"original-oid %s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"data %"</literal><name>PRIuMAX</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"could not write blob '%s'"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>show_progress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SHOWN</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eaten</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>depth_first</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>diff_filepair</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>a_</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>diff_filepair</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>b_</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name_b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len_a</name></decl>, <decl><type ref="prev"/><name>len_b</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>name_a</name> <operator>=</operator> <ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>one</name></name></expr> ?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr> </then><else>: <expr><name><name>a</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>name_b</name> <operator>=</operator> <ternary><condition><expr><name><name>b</name><operator>-&gt;</operator><name>one</name></name></expr> ?</condition><then> <expr><name><name>b</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr> </then><else>: <expr><name><name>b</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>len_a</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len_b</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len_a</name> <operator>&lt;</operator> <name>len_b</name><operator>)</operator></expr> ?</condition><then> <expr><name>len_a</name></expr> </then><else>: <expr><name>len_b</name></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>name_a</name></expr></argument>, <argument><expr><name>name_b</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <name>len_b</name> <operator>-</operator> <name>len_a</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>





<return>return <expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <literal type="char">'R'</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <literal type="char">'R'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_path_1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>need_quote</name> <init>= <expr><call><name>quote_c_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>need_quote</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quote_c_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>anonymize_path_component</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>counter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>out</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="string">"path%d"</literal></expr></argument>, <argument><expr><name>counter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>anonymize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_path_1</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>hashmap</name></name></type> <name>paths</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>anon</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>anonymize_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anon</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paths</name></expr></argument>, <argument><expr><name>anonymize_path_component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_path_1</name><argument_list>(<argument><expr><name><name>anon</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>generate_fake_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>counter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hashsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><name>hashsz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_be32</name><argument_list>(<argument><expr><name>out</name> <operator>+</operator> <name>hashsz</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>counter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>anonymize_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>hashmap</name></name></type> <name>objs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>anonymize_mem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objs</name></expr></argument>, <argument><expr><name>generate_fake_oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_filemodify</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>diff_queue_struct</name></name> <modifier>*</modifier></type><name>q</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_options</name></name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>changed</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>nr</name></name></expr></argument>, <argument><expr><name>depth_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>q</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>ospec</name> <init>= <expr><name><name>q</name><operator>-&gt;</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>one</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><name><name>q</name><operator>-&gt;</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>two</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>status</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DIFF_STATUS_DELETED</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"D "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><name>changed</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DIFF_STATUS_COPIED</name></expr>:</case>
<case>case <expr><name>DIFF_STATUS_RENAMED</name></expr>:</case>







<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>string_list_has_string</name><argument_list>(<argument><expr><name>changed</name></expr></argument>, <argument><expr><name><name>ospec</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c "</literal></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name><name>ospec</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><name>changed</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ospec</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>ospec</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name><name>spec</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<case>case <expr><name>DIFF_STATUS_TYPE_CHANGED</name></expr>:</case>
<case>case <expr><name>DIFF_STATUS_MODIFIED</name></expr>:</case>
<case>case <expr><name>DIFF_STATUS_ADDED</name></expr>:</case>




<if_stmt><if>if <condition>(<expr><name>no_data</name> <operator>||</operator> <call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"M %06o %s "</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><ternary><condition><expr><name>anonymize</name></expr> ?</condition><then>
<expr><call><name>anonymize_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>oid</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>lookup_object</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"M %06o :%d "</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>,
<argument><expr><call><name>get_object_mark</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><name>changed</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unexpected comparison status '%c' for %s, %s"</literal></expr></argument>,
<argument><expr><name><name>q</name><operator>-&gt;</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>status</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>ospec</name><operator>-&gt;</operator><name>path</name></name></expr> ?</condition><then> <expr><name><name>ospec</name><operator>-&gt;</operator><name>path</name></name></expr> </then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>path</name></name></expr> ?</condition><then> <expr><name><name>spec</name><operator>-&gt;</operator><name>path</name></name></expr> </then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>find_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>begin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle</name> <init>= <expr><literal type="string">"\nencoding "</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bol</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bol</name> <operator>=</operator> <call><name>memmem</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><ternary><condition><expr><name>end</name></expr> ?</condition><then> <expr><name>end</name> <operator>-</operator> <name>begin</name></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
<argument><expr><name>needle</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bol</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bol</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>bol</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>bol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>anonymize_ref_component</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>counter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>out</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="string">"ref%d"</literal></expr></argument>, <argument><expr><name>counter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>anonymize_refname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>prefixes</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"refs/heads/"</literal></expr>,
<expr><literal type="string">"refs/tags/"</literal></expr>,
<expr><literal type="string">"refs/remotes/"</literal></expr>,
<expr><literal type="string">"refs/"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>hashmap</name></name></type> <name>refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>anon</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/master"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>refname</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>prefixes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>prefixes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anon</name></expr></argument>, <argument><expr><name><name>prefixes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>anonymize_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anon</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refs</name></expr></argument>, <argument><expr><name>anonymize_ref_component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>anon</name><operator>.</operator><name>buf</name></name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>anonymize_commit_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>counter</name></decl>;</decl_stmt>
<return>return <expr><call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"subject %d\n\nbody\n"</literal></expr></argument>, <argument><expr><name>counter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>hashmap</name></name></type> <name>idents</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>anonymize_ident</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>counter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>out</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="string">"User %d &lt;user%d@example.com&gt;"</literal></expr></argument>, <argument><expr><name>counter</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>counter</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>anonymize_ident_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>beg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name><name>buffers</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>STRBUF_INIT</name></expr>, <expr><name>STRBUF_INIT</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>which_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ident_split</name></name></type> <name>split</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end_of_header</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <operator>&amp;</operator><name><name>buffers</name><index>[<expr><name>which_buffer</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>which_buffer</name> <operator>%=</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>end_of_header</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>beg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end_of_header</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"malformed line fed to anonymize_ident_line: %.*s"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>end</name> <operator>-</operator> <operator>*</operator><name>beg</name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>end_of_header</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>*</operator><name>beg</name></expr></argument>, <argument><expr><name>end_of_header</name> <operator>-</operator> <operator>*</operator><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>split_ident_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>split</name></expr></argument>, <argument><expr><name>end_of_header</name></expr></argument>, <argument><expr><operator>*</operator><name>end</name> <operator>-</operator> <name>end_of_header</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>split</name><operator>.</operator><name>date_begin</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>split</name><operator>.</operator><name>mail_end</name></name> <operator>-</operator> <name><name>split</name><operator>.</operator><name>name_begin</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ident</name> <operator>=</operator> <call><name>anonymize_mem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idents</name></expr></argument>, <argument><expr><name>anonymize_ident</name></expr></argument>,
<argument><expr><name><name>split</name><operator>.</operator><name>name_begin</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>ident</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>split</name><operator>.</operator><name>date_begin</name></name></expr></argument>, <argument><expr><name><name>split</name><operator>.</operator><name>tz_end</name></name> <operator>-</operator> <name><name>split</name><operator>.</operator><name>date_begin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"Malformed Ident &lt;malformed@example.com&gt; 0 -0000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>beg</name> <operator>=</operator> <name><name>out</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>out</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>out</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>rev</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>paths_of_changed_objects</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>saved_output_format</name> <init>= <expr><name><name>rev</name><operator>-&gt;</operator><name>diffopt</name><operator>.</operator><name>output_format</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commit_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>author</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>author_end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>committer</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>committer_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reencoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>rev</name><operator>-&gt;</operator><name>diffopt</name><operator>.</operator><name>output_format</name></name> <operator>=</operator> <name>DIFF_FORMAT_CALLBACK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>parse_commit_or_die</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>commit_buffer</name> <operator>=</operator> <call><name>get_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>author</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>commit_buffer</name></expr></argument>, <argument><expr><literal type="string">"\nauthor "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>author</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"could not find author in commit %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>author</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>author_end</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>author</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>committer</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>author_end</name></expr></argument>, <argument><expr><literal type="string">"\ncommitter "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>committer</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"could not find committer in commit %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>committer</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>committer_end</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>committer</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>committer_end</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>find_encoding</name><argument_list>(<argument><expr><name>committer_end</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>message</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>message</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>commit</name><operator>-&gt;</operator><name>parents</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>get_object_mark</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<name>reference_excluded_commits</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><name>full_tree</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parse_commit_or_die</name><argument_list>(<argument><expr><name><name>commit</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_tree_oid</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name><name>commit</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rev</name><operator>-&gt;</operator><name>diffopt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>diff_root_tree_oid</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rev</name><operator>-&gt;</operator><name>diffopt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>diff_queued_diff</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>diff_queued_diff</name><operator>.</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>two</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>export_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>diff_queued_diff</name><operator>.</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>two</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>refname</name> <operator>=</operator> <operator>*</operator><call><name>revision_sources_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revision_sources</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>string_list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extra_refs</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>anonymize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>refname</name> <operator>=</operator> <call><name>anonymize_refname</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>anonymize_ident_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>committer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>committer_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>anonymize_ident_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>author</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>author_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mark_next_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>anonymize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>reencoded</name> <operator>=</operator> <call><name>anonymize_commit_message</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>reencode_mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>REENCODE_YES</name></expr>:</case>
<expr_stmt><expr><name>reencoded</name> <operator>=</operator> <call><name>reencode_string</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>REENCODE_NO</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>REENCODE_ABORT</name></expr>:</case>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Encountered commit-specific encoding %s in commit "</literal>
<literal type="string">"%s; use --reencode=[yes|no] to handle it"</literal></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"reset %s\n"</literal></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"commit %s\nmark :%"</literal><name>PRIu32</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>last_idnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>show_original_ids</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"original-oid %s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%.*s\n%.*s\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>author_end</name> <operator>-</operator> <name>author</name><operator>)</operator></expr></argument>, <argument><expr><name>author</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>committer_end</name> <operator>-</operator> <name>committer</name><operator>)</operator></expr></argument>, <argument><expr><name>committer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reencoded</name> <operator>&amp;&amp;</operator> <name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"encoding %s\n"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"data %u\n%s"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>reencoded</name></expr>
?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>reencoded</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><ternary><condition><expr><name>message</name></expr>
?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><ternary><condition><expr><name>reencoded</name></expr> ?</condition><then> <expr><name>reencoded</name></expr> </then><else>: <expr><ternary><condition><expr><name>message</name></expr> ?</condition><then> <expr><name>message</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reencoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unuse_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>commit_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mark</name> <init>= <expr><call><name>get_object_mark</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mark</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>reference_excluded_commits</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"from "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"merge "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mark</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">":%d\n"</literal></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><ternary><condition><expr><name>anonymize</name></expr> ?</condition><then>
<expr><call><name>anonymize_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>full_tree</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"deleteall\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>log_tree_diff_flush</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><name>paths_of_changed_objects</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rev</name><operator>-&gt;</operator><name>diffopt</name><operator>.</operator><name>output_format</name></name> <operator>=</operator> <name>saved_output_format</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>show_progress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>anonymize_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>counter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>out</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="string">"tag message %d"</literal></expr></argument>, <argument><expr><name>counter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_tail</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_array</name></name> <modifier>*</modifier></type><name>commits</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>paths_of_changed_objects</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>commits</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>commit</name> <operator>=</operator> <operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><call><name>object_array_pop</name><argument_list>(<argument><expr><name>commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>has_unshown_parent</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>add_object_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>handle_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>revs</name></expr></argument>, <argument><expr><name>paths_of_changed_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tagger</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tagger_end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>message_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>tagged</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tagged_mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>





<expr_stmt><expr><name>tagged</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>tagged</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>tagged</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TAG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tagged</name> <operator>=</operator> <operator>(</operator><operator>(</operator>struct <name>tag</name> <operator>*</operator><operator>)</operator><name>tagged</name><operator>)</operator><operator>-&gt;</operator><name>tagged</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>tagged</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TREE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"Omitting tag %s,\nsince tags of trees (or tags of tags of trees, etc.) are not supported."</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"could not read tag %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>memmem</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>message</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>message</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>message_size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tagger</name> <operator>=</operator> <call><name>memmem</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><name>message</name></expr> ?</condition><then> <expr><name>message</name> <operator>-</operator> <name>buf</name></expr> </then><else>: <expr><name>size</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="string">"\ntagger "</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tagger</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fake_missing_tagger</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tagger</name> <operator>=</operator> <literal type="string">"tagger Unspecified Tagger "</literal>
<literal type="string">"&lt;unspecified-tagger&gt; 0 +0000"</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tagger</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>tagger_end</name> <operator>=</operator> <name>tagger</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tagger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tagger</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>tagger_end</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>tagger</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>anonymize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>anonymize_ident_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tagger</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tagger_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>anonymize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>anonymize_refname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>message</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>hashmap</name></name></type> <name>tags</name></decl>;</decl_stmt>
<expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>anonymize_mem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tags</name></expr></argument>, <argument><expr><name>anonymize_tag</name></expr></argument>,
<argument><expr><name>message</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>message_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>message</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>signature</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>message</name></expr></argument>,
<argument><expr><literal type="string">"\n-----BEGIN PGP SIGNATURE-----\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>signature</name></expr>)</condition><block type="pseudo"><block_content>
<switch>switch<condition>(<expr><name>signed_tag_mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SIGNED_TAG_ABORT</name></expr>:</case>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"encountered signed tag %s; use "</literal>
<literal type="string">"--signed-tags=&lt;mode&gt; to handle it"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>WARN</name></expr>:</case>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"exporting signed tag %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>VERBATIM</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>WARN_STRIP</name></expr>:</case>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"stripping signature from tag %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>STRIP</name></expr>:</case>
<expr_stmt><expr><name>message_size</name> <operator>=</operator> <name>signature</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>message</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>tagged</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>tagged</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tagged_mark</name> <operator>=</operator> <call><name>get_object_mark</name><argument_list>(<argument><expr><name>tagged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tagged_mark</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>tag_of_filtered_mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TAG_FILTERING_ABORT</name></expr>:</case>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"tag %s tags unexported object; use "</literal>
<literal type="string">"--tag-of-filtered-object=&lt;mode&gt; to handle it"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>DROP</name></expr>:</case>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>REWRITE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>tagged</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TAG</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>mark_tags</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error: Cannot export nested tags unless --mark-tags is specified."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>tagged</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>rewrite_commit</name><argument_list>(<argument><expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>tagged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"reset %s\nfrom %s\n\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tagged_mark</name> <operator>=</operator> <call><name>get_object_mark</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>tagged_mark</name> <operator>=</operator> <call><name>get_object_mark</name><argument_list>(<argument><expr><name>tagged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tagged</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TAG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"reset %s\nfrom %s\n\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"tag %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mark_tags</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mark_next_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"mark :%"</literal><name>PRIu32</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>last_idnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tagged_mark</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"from :%d\n"</literal></expr></argument>, <argument><expr><name>tagged_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"from %s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tagged</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_original_ids</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"original-oid %s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%.*s%sdata %d\n%.*s\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>tagger_end</name> <operator>-</operator> <name>tagger</name><operator>)</operator></expr></argument>, <argument><expr><name>tagger</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>tagger</name> <operator>==</operator> <name>tagger_end</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"\n"</literal></expr></else></ternary></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>message_size</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>message_size</name></expr></argument>, <argument><expr><ternary><condition><expr><name>message</name></expr> ?</condition><then> <expr><name>message</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>get_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_cmdline_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>full_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OBJ_COMMIT</name></expr>:</case>
<return>return <expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>item</name></name></expr>;</return>
<case>case <expr><name>OBJ_TAG</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><operator>(</operator>struct <name>tag</name> <operator>*</operator><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>


<while>while <condition>(<expr><name>tag</name> <operator>&amp;&amp;</operator> <name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TAG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag_refs</name></expr></argument>, <argument><expr><name>full_name</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <operator>(</operator>struct <name>tag</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>tagged</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Tag %s points nowhere?"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>tag</name></expr>;</return>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_tags_and_duplicates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_cmdline_info</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_cmdline_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>rev</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>full_name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwim_ref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>full_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>refspecs</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>private</name></decl>;</decl_stmt>
<expr_stmt><expr><name>private</name> <operator>=</operator> <call><name>apply_refspecs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refspecs</name></expr></argument>, <argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>private</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>full_name</name> <operator>=</operator> <name>private</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>get_commit</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"%s: Unexpected object of type %s, skipping."</literal></expr></argument>,
<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OBJ_COMMIT</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>OBJ_BLOB</name></expr>:</case>
<expr_stmt><expr><call><name>export_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<default>default:</default> 
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"Tag points to object of unexpected type %s, skipping."</literal></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></switch>





<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extra_refs</name></expr></argument>, <argument><expr><name>full_name</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>commit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><call><name>revision_sources_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revision_sources</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name>revision_sources_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revision_sources</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>full_name</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>string_list_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extra_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_remove_duplicates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extra_refs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_tags_and_duplicates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>extras</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>extras</name><operator>-&gt;</operator><name>nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>extras</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name> <init>= <expr><name><name>extras</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mark</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OBJ_TAG</name></expr>:</case>
<expr_stmt><expr><call><name>handle_tag</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>tag</name> <operator>*</operator><operator>)</operator><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>OBJ_COMMIT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>anonymize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>anonymize_refname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>rewrite_commit</name><argument_list>(<argument><expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"reset %s\nfrom %s\n\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>get_object_mark</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mark</name></expr>)</condition> <block>{<block_content>










<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reference_excluded_commits</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"reset %s\nfrom %s\n\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"reset %s\nfrom %s\n\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"reset %s\nfrom :%d\n\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>show_progress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>export_marks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>decoration_entry</name></name> <modifier>*</modifier></type><name>deco</name> <init>= <expr><name><name>idnums</name><operator>.</operator><name>entries</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen_for_writing</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"Unable to open marks file %s for writing."</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>idnums</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>deco</name><operator>-&gt;</operator><name>base</name></name> <operator>&amp;&amp;</operator> <name><name>deco</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>ptr_to_mark</name><argument_list>(<argument><expr><name><name>deco</name><operator>-&gt;</operator><name>decoration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%"</literal><name>PRIu32</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>mark</name></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>deco</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>deco</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>e</name> <operator>|=</operator> <call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>|=</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Unable to write marks file %s."</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>import_marks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input_file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check_exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>check_exists</name> <operator>&amp;&amp;</operator> <call><name>stat</name><argument_list>(<argument><expr><name>input_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>xfopen</name><argument_list>(<argument><expr><name>input_file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line_end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mark_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><name>line_end</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal> <operator>||</operator> <operator>!</operator><name>line_end</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"corrupt mark line: %s"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>line_end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>strtoumax</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mark_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mark</name> <operator>||</operator> <name>mark_end</name> <operator>==</operator> <name>line</name> <operator>+</operator> <literal type="number">1</literal>
<operator>||</operator> <operator>*</operator><name>mark_end</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>||</operator> <call><name>get_oid_hex</name><argument_list>(<argument><expr><name>mark_end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"corrupt mark line: %s"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>last_idnum</name> <operator>&lt;</operator> <name>mark</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_idnum</name> <operator>=</operator> <name>mark</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"object not found: %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"not a commit? can't happen: %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>object</name> <operator>=</operator> <operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SHOWN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Object %s already has a mark"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mark_object</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SHOWN</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_deletes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>refspecs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>refspec_item</name></name> <modifier>*</modifier></type><name>refspec</name> <init>= <expr><operator>&amp;</operator><name><name>refspecs</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>refspec</name><operator>-&gt;</operator><name>src</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"reset %s\nfrom %s\n\n"</literal></expr></argument>,
<argument><expr><name><name>refspec</name><operator>-&gt;</operator><name>dst</name></name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmd_fast_export</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name></type> <name>revs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_array</name></name></type> <name>commits</name> <init>= <expr><name>OBJECT_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>export_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>import_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>import_filename_if_exists</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>lastimportid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>refspecs_list</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>paths_of_changed_objects</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"progress"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show progress after &lt;n&gt; objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_CALLBACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"signed-tags"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>signed_tag_mode</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"mode"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"select handling of signed tags"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>parse_opt_signed_tag_mode</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_CALLBACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"tag-of-filtered-object"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag_of_filtered_mode</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"mode"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"select handling of tags that tag filtered objects"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>parse_opt_tag_of_filtered_mode</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_CALLBACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"reencode"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>reencode_mode</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"mode"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"select handling of commit messages in an alternate encoding"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>parse_opt_reencode_mode</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"export-marks"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>export_filename</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Dump marks to this file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"import-marks"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>import_filename</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Import marks from this file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"import-marks-if-exists"</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>import_filename_if_exists</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Import marks from this file if it exists"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"fake-missing-tagger"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fake_missing_tagger</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Fake a tagger when tags lack one"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"full-tree"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>full_tree</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Output full tree for each commit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"use-done-feature"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_done_feature</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Use the done feature to terminate the stream"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"no-data"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_data</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Skip output of blob data"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING_LIST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"refspec"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>refspecs_list</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"refspec"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Apply refspec to exported refs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"anonymize"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>anonymize</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"anonymize output"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"reference-excluded-parents"</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>reference_excluded_commits</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Reference parents which are not in fast-export stream by object id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"show-original-ids"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>show_original_ids</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Show original object ids of blobs/commits"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"mark-tags"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mark_tags</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Label tags with mark ids"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage_with_options</name> <argument_list>(<argument><expr><name>fast_export_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_default_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>repo_init_revisions</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_revision_sources</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revision_sources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>topo_order</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>sources</name></name> <operator>=</operator> <operator>&amp;</operator><name>revision_sources</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>rewrite_parents</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>fast_export_usage</name></expr></argument>,
<argument><expr><name>PARSE_OPT_KEEP_ARGV0</name> <operator>|</operator> <name>PARSE_OPT_KEEP_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>setup_revisions</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage_with_options</name> <argument_list>(<argument><expr><name>fast_export_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>refspecs_list</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>refspecs_list</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>refspec_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refspecs</name></expr></argument>, <argument><expr><name><name>refspecs_list</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refspecs_list</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_done_feature</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"feature done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>import_filename</name> <operator>&amp;&amp;</operator> <name>import_filename_if_exists</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot pass both --import-marks and --import-marks-if-exists"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>import_filename</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>import_marks</name><argument_list>(<argument><expr><name>import_filename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>import_filename_if_exists</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>import_marks</name><argument_list>(<argument><expr><name>import_filename_if_exists</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lastimportid</name> <operator>=</operator> <name>last_idnum</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>import_filename</name> <operator>&amp;&amp;</operator> <name><name>revs</name><operator>.</operator><name>prune_data</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>full_tree</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>get_tags_and_duplicates</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>revs</name><operator>.</operator><name>cmdline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prepare_revision_walk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"revision walk setup failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>diffopt</name><operator>.</operator><name>format_callback</name></name> <operator>=</operator> <name>show_filemodify</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>diffopt</name><operator>.</operator><name>format_callback_data</name></name> <operator>=</operator> <operator>&amp;</operator><name>paths_of_changed_objects</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>diffopt</name><operator>.</operator><name>flags</name><operator>.</operator><name>recursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>commit</name> <operator>=</operator> <call><name>get_revision</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>has_unshown_parent</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_object_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>handle_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paths_of_changed_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>handle_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paths_of_changed_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>handle_tags_and_duplicates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extra_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>handle_tags_and_duplicates</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>handle_deletes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>export_filename</name> <operator>&amp;&amp;</operator> <name>lastimportid</name> <operator>!=</operator> <name>last_idnum</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>export_marks</name><argument_list>(<argument><expr><name>export_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_done_feature</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>refspec_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refspecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
