<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\builtin\update-index.c">




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_THE_INDEX_COMPATIBILITY_MACROS</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lockfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache-tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree-walk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"resolve-undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parse-options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pathspec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"split-index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fsmonitor.h"</cpp:file></cpp:include>








<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>allow_add</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>allow_remove</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>allow_replace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>info_only</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>force_remove</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>verbose</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>mark_valid_only</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>mark_skip_worktree_only</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>mark_fsmonitor_only</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ignore_skip_worktree_entries</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_FLAG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNMARK_FLAG</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>mtime_dir</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>


<enum>enum <name>uc_mode</name> <block>{
<decl><name>UC_UNSPECIFIED</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>UC_DISABLE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>UC_ENABLE</name></decl>,
<decl><name>UC_TEST</name></decl>,
<decl><name>UC_FORCE</name></decl>
}</block>;</enum>

<macro><name>__attribute__</name><argument_list>(<argument>(format (printf, <literal type="number">1</literal>, <literal type="number">2</literal>))</argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>void</name></type> <name>report</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>vp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>remove_test_directory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mtime_dir</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_dir_recursively</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mtime_dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_mtime_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>mtime_dir</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xmkdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>get_mtime_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0700</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to create directory %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>xstat_mtime_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name><name>mtime_dir</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to stat %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>mtime_dir</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>create_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>get_mtime_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_RDWR</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to create file %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xunlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>get_mtime_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to delete file %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xrmdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>get_mtime_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rmdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to delete directory %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>avoid_racy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>





<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>test_if_untracked_cache_is_supported</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat_data</name></name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cwd</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mtime_dir</name></expr></argument>, <argument><expr><literal type="string">"mtime-test-XXXXXX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mkdtemp</name><argument_list>(<argument><expr><name><name>mtime_dir</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"Could not make temporary directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cwd</name> <operator>=</operator> <call><name>xgetcwd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Testing mtime in '%s' "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>remove_test_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstat_mtime_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>avoid_racy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>create_file</name><argument_list>(<argument><expr><literal type="string">"newfile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstat_mtime_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"directory stat info does not "</literal>
<literal type="string">"change after adding a new file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>avoid_racy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xmkdir</name><argument_list>(<argument><expr><literal type="string">"new-dir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstat_mtime_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"directory stat info does not change "</literal>
<literal type="string">"after adding a new directory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>avoid_racy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_or_die</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"data"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstat_mtime_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>match_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"directory stat info changes "</literal>
<literal type="string">"after updating a file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>avoid_racy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>create_file</name><argument_list>(<argument><expr><literal type="string">"new-dir/new"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstat_mtime_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>match_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"directory stat info changes after "</literal>
<literal type="string">"adding a file inside subdirectory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>avoid_racy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xunlink</name><argument_list>(<argument><expr><literal type="string">"newfile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstat_mtime_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"directory stat info does not "</literal>
<literal type="string">"change after deleting a file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>avoid_racy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xunlink</name><argument_list>(<argument><expr><literal type="string">"new-dir/new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xrmdir</name><argument_list>(<argument><expr><literal type="string">"new-dir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstat_mtime_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"directory stat info does not "</literal>
<literal type="string">"change after deleting a directory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rmdir</name><argument_list>(<argument><expr><name><name>mtime_dir</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to delete directory %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>mtime_dir</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" OK"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mtime_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mark_ce_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>cache_name_pos</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mark_fsmonitor_invalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mark</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>|=</operator> <name>flag</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>&amp;=</operator> <operator>~</operator><name>flag</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>|=</operator> <name>CE_UPDATE_IN_BASE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cache_tree_invalidate_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>active_cache_changed</name> <operator>|=</operator> <name>CE_ENTRY_CHANGED</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>remove_one_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_remove</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: does not exist and --remove not passed"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>remove_file_from_cache</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: cannot remove from the index"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>process_lstat_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_missing_file_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>remove_one_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"lstat(\"%s\"): %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_one_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>old</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ce_stage</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ce_match_stat</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>=</operator> <call><name>create_ce_flags</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_stat_cache_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>ce_mode_from_stat</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>index_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>st</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>info_only</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>HASH_WRITE_OBJECT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>option</name> <operator>=</operator> <ternary><condition><expr><name>allow_add</name></expr> ?</condition><then> <expr><name>ADD_CACHE_OK_TO_ADD</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>option</name> <operator>|=</operator> <ternary><condition><expr><name>allow_replace</name></expr> ?</condition><then> <expr><name>ADD_CACHE_OK_TO_REPLACE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: cannot add to the index - missing --add option?"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
























<function><type><specifier>static</specifier> <name>int</name></type> <name>process_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>cache_name_pos</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>resolve_gitlink_ref</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>add_one_path</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>remove_one_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>active_nr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>active_cache</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: is a directory - add individual files instead"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>resolve_gitlink_ref</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>add_one_path</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: is a directory - add files inside instead"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>process_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stat_errno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>has_symlink_leading_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"'%s' is beyond a symbolic link"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>cache_name_pos</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <ternary><condition><expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ce</name> <operator>&amp;&amp;</operator> <call><name>ce_skip_worktree</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_skip_worktree_entries</name> <operator>&amp;&amp;</operator> <name>allow_remove</name> <operator>&amp;&amp;</operator>
<call><name>remove_file_from_cache</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: cannot remove from the index"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>stat_errno</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>process_lstat_error</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>stat_errno</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>process_directory</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>add_one_path</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_cacheinfo</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Invalid path '%s'"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>=</operator> <call><name>create_ce_flags</name><argument_list>(<argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>create_ce_mode</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>assume_unchanged</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>option</name> <operator>=</operator> <ternary><condition><expr><name>allow_add</name></expr> ?</condition><then> <expr><name>ADD_CACHE_OK_TO_ADD</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>option</name> <operator>|=</operator> <ternary><condition><expr><name>allow_replace</name></expr> ?</condition><then> <expr><name>ADD_CACHE_OK_TO_REPLACE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: cannot add to the index - missing --add option?"</literal></expr></argument>,
<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"add '%s'"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>chmod_path</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>flip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>cache_name_pos</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>chmod_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"chmod %cx '%s'"</literal></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"git update-index: cannot chmod %cx '%s'"</literal></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>update_one</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>stat_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mark_valid_only</name> <operator>||</operator> <name>mark_skip_worktree_only</name> <operator>||</operator> <name>force_remove</name> <operator>||</operator>
<name>mark_fsmonitor_only</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>stat_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Ignoring path %s\n"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mark_valid_only</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>mark_ce_flags</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CE_VALID</name></expr></argument>, <argument><expr><name>mark_valid_only</name> <operator>==</operator> <name>MARK_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unable to mark file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mark_skip_worktree_only</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>mark_ce_flags</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CE_SKIP_WORKTREE</name></expr></argument>, <argument><expr><name>mark_skip_worktree_only</name> <operator>==</operator> <name>MARK_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unable to mark file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mark_fsmonitor_only</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>mark_ce_flags</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CE_FSMONITOR_VALID</name></expr></argument>, <argument><expr><name>mark_fsmonitor_only</name> <operator>==</operator> <name>MARK_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unable to mark file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>force_remove</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>remove_file_from_cache</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"git update-index: unable to remove %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"remove '%s'"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>process_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>stat_errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unable to process path %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"add '%s'"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_index_info</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nul_term_line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>hexsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>uq</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>strbuf_getline_fn</name></type> <name>getline_fn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>getline_fn</name> <operator>=</operator> <ternary><condition><expr><name>nul_term_line</name></expr> ?</condition><then> <expr><name>strbuf_getline_nul</name></expr> </then><else>: <expr><name>strbuf_getline_lf</name></expr></else></ternary></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>getline_fn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stage</name></decl>;</decl_stmt>

















<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ul</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name><name>buf</name><operator>.</operator><name>buf</name></name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">' '</literal>
<operator>||</operator> <name>errno</name> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>ul</name> <operator>!=</operator> <name>ul</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_line</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <name>ul</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tab</name> <operator>||</operator> <name>tab</name> <operator>-</operator> <name>ptr</name> <operator>&lt;</operator> <name>hexsz</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_line</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tab</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <literal type="char">'0'</literal> <operator>&lt;=</operator> <name><name>tab</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>tab</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'3'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>stage</name> <operator>=</operator> <name><name>tab</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tab</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>tab</name> <operator>=</operator> <name>tab</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>stage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tab</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid_hex</name><argument_list>(<argument><expr><name>tab</name> <operator>-</operator> <name>hexsz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>||</operator>
<name><name>tab</name><index>[<expr><operator>-</operator><operator>(</operator><name>hexsz</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_line</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>path_name</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nul_term_line</name> <operator>&amp;&amp;</operator> <name><name>path_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unquote_c_style</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>, <argument><expr><name>path_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"git update-index: bad quoting of path name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>path_name</name> <operator>=</operator> <name><name>uq</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_path</name><argument_list>(<argument><expr><name>path_name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Ignoring path %s\n"</literal></expr></argument>, <argument><expr><name>path_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mode</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>remove_file_from_cache</name><argument_list>(<argument><expr><name>path_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"git update-index: unable to remove %s"</literal></expr></argument>,
<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>




<expr_stmt><expr><name><name>ptr</name><index>[<expr><operator>-</operator><operator>(</operator><name>hexsz</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_cacheinfo</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>path_name</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"git update-index: unable to update %s"</literal></expr></argument>,
<argument><expr><name>path_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<continue>continue;</continue>

<label><name>bad_line</name>:</label>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"malformed index info %s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>update_index_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git update-index [&lt;options&gt;] [--] [&lt;file&gt;...]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>object_id</name></name></type> <name>head_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>object_id</name></name></type> <name>merge_head_oid</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>read_one_ent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>which</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>ent</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_tree_entry</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>which</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: not in %s branch."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>S_IFDIR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>which</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: not a blob in %s branch."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>=</operator> <call><name>create_ce_flags</name><argument_list>(<argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>namelen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>create_ce_mode</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>unresolve_one</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce_2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ce_3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>cache_name_pos</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pos</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>unmerge_cache_entry_at</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>active_nr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>namelen</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>active_nr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>namelen</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: skipping still unmerged path.\n"</literal></expr></argument>,
<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>free_return</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>





<expr_stmt><expr><name>ce_2</name> <operator>=</operator> <call><name>read_one_ent</name><argument_list>(<argument><expr><literal type="string">"our"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce_3</name> <operator>=</operator> <call><name>read_one_ent</name><argument_list>(<argument><expr><literal type="string">"their"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>merge_head_oid</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ce_2</name> <operator>||</operator> <operator>!</operator><name>ce_3</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>free_return</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce_2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce_3</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>ce_2</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>==</operator> <name><name>ce_3</name><operator>-&gt;</operator><name>ce_mode</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: identical in both, skipping.\n"</literal></expr></argument>,
<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>free_return</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>remove_file_from_cache</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_cache_entry</name><argument_list>(<argument><expr><name>ce_2</name></expr></argument>, <argument><expr><name>ADD_CACHE_OK_TO_ADD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: cannot add our version to the index."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>free_return</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_cache_entry</name><argument_list>(<argument><expr><name>ce_3</name></expr></argument>, <argument><expr><name>ADD_CACHE_OK_TO_ADD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s: cannot add their version to the index."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<label><name>free_return</name>:</label>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_head_pointers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>read_ref</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"No HEAD -- no initial commit yet?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_ref</name><argument_list>(<argument><expr><literal type="string">"MERGE_HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>merge_head_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Not in the middle of a merge.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_unresolve</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ac</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>av</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefix_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><call><name>read_head_pointers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ac</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>av</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>prefix_path</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix_length</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>err</name> <operator>|=</operator> <call><name>unresolve_one</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_reupdate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ac</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>av</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_head</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pathspec</name></name></type> <name>pathspec</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>parse_pathspec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathspec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>PATHSPEC_PREFER_CWD</name></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>av</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_ref</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>



<expr_stmt><expr><name>has_head</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>redo</name>:</label>
<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>active_nr</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>active_cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>old</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ce_path_match</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathspec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>has_head</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>read_one_ent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>,
<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>old</name> <operator>&amp;&amp;</operator> <name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>==</operator> <name><name>old</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>&amp;&amp;</operator>
<call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>old</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue> 
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>save_nr</name> <operator>=</operator> <name>active_nr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_one</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>save_nr</name> <operator>!=</operator> <name>active_nr</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>redo</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>clear_pathspec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>refresh_params</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>has_errors</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>refresh</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>refresh_params</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>setup_work_tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name><name>o</name><operator>-&gt;</operator><name>has_errors</name></name> <operator>|=</operator> <call><name>refresh_cache</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>refresh_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>refresh</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>really_refresh_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>refresh</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>REFRESH_REALLY</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>chmod_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>flip</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>||</operator> <name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>arg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"option 'chmod' expects \"+x\" or \"-x\""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>flip</name> <operator>=</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>resolve_undo_clear_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>resolve_undo_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_new_style_cacheinfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ul</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>||</operator> <name>endp</name> <operator>==</operator> <name>arg</name> <operator>||</operator> <operator>*</operator><name>endp</name> <operator>!=</operator> <literal type="char">','</literal> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>ul</name> <operator>!=</operator> <name>ul</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><operator>*</operator><name>mode</name> <operator>=</operator> <name>ul</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endp</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_oid_hex</name><argument_list>(<argument><expr><name>endp</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>path</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>parse_opt_result</name></name></type> <name>cacheinfo_callback</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>parse_opt_ctx_t</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_new_style_cacheinfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>add_cacheinfo</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"git update-index: --cacheinfo cannot add %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"option 'cacheinfo' expects &lt;mode&gt;,&lt;sha1&gt;,&lt;path&gt;"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strtoul_ui</name><argument_list>(<argument><expr><operator>*</operator><operator>++</operator><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>get_oid_hex</name><argument_list>(<argument><expr><operator>*</operator><operator>++</operator><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>add_cacheinfo</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>*</operator><operator>++</operator><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"git update-index: --cacheinfo cannot add %s"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>parse_opt_result</name></name></type> <name>stdin_cacheinfo_callback</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>parse_opt_ctx_t</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>nul_term_line</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"option '%s' must be the last argument"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>allow_add</name> <operator>=</operator> <name>allow_replace</name> <operator>=</operator> <name>allow_remove</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_index_info</name><argument_list>(<argument><expr><operator>*</operator><name>nul_term_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>parse_opt_result</name></name></type> <name>stdin_callback</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>parse_opt_ctx_t</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>read_from_stdin</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"option '%s' must be the last argument"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>read_from_stdin</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>parse_opt_result</name></name></type> <name>unresolve_callback</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>parse_opt_ctx_t</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>has_errors</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><name><name>startup_info</name><operator>-&gt;</operator><name>prefix</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><operator>*</operator><name>has_errors</name> <operator>=</operator> <call><name>do_unresolve</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><ternary><condition><expr><name>prefix</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>has_errors</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>active_cache_changed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>parse_opt_result</name></name></type> <name>reupdate_callback</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>parse_opt_ctx_t</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>has_errors</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><name><name>startup_info</name><operator>-&gt;</operator><name>prefix</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BUG_ON_OPT_ARG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>setup_work_tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>has_errors</name> <operator>=</operator> <call><name>do_reupdate</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>has_errors</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>active_cache_changed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>argv</name></name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmd_update_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>newfd</name></decl>, <decl><type ref="prev"/><name>entries</name></decl>, <decl><type ref="prev"/><name>has_errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nul_term_line</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>uc_mode</name></name></type> <name>untracked_cache</name> <init>= <expr><name>UC_UNSPECIFIED</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>read_from_stdin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prefix_length</name> <init>= <expr><ternary><condition><expr><name>prefix</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>preferred_index_format</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>set_executable_bit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>refresh_params</name></name></type> <name>refresh_args</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><operator>&amp;</operator><name>has_errors</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lock_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>split_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>force_write</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fsmonitor</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>lock_file</name></name></type> <name>lock_file</name> <init>= <expr><name>LOCK_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>parse_opt_ctx_t</name></name></type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>strbuf_getline_fn</name></type> <name>getline_fn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parseopt_state</name> <init>= <expr><name>PARSE_OPT_UNKNOWN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>the_repository</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="char">'q'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>refresh_args</name><operator>.</operator><name>flags</name></name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"continue refresh even when index needs update"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>REFRESH_QUIET</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ignore-submodules"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>refresh_args</name><operator>.</operator><name>flags</name></name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"refresh: ignore submodules"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>REFRESH_IGNORE_SUBMODULES</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"add"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>allow_add</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not ignore new files"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>allow_replace</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"let files replace directories and vice-versa"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"remove"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>allow_remove</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"notice files missing from worktree"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"unmerged"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>refresh_args</name><operator>.</operator><name>flags</name></name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"refresh even if index contains unmerged entries"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>REFRESH_UNMERGED</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{<expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"refresh"</literal></expr>, <expr><operator>&amp;</operator><name>refresh_args</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"refresh stat information"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>,
<expr><name>refresh_callback</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"really-refresh"</literal></expr>, <expr><operator>&amp;</operator><name>refresh_args</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"like --refresh, but ignore assume-unchanged setting"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>,
<expr><name>really_refresh_callback</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_LOWLEVEL_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"cacheinfo"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"&lt;mode&gt;,&lt;object&gt;,&lt;path&gt;"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"add the specified entry to the index"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> 
<name>PARSE_OPT_NONEG</name> <operator>|</operator> <name>PARSE_OPT_LITERAL_ARGHELP</name></expr>,
<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>,
<expr><name>cacheinfo_callback</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"chmod"</literal></expr>, <expr><operator>&amp;</operator><name>set_executable_bit</name></expr>, <expr><literal type="string">"(+|-)x"</literal></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"override the executable bit of the listed files"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>chmod_callback</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_SET_INT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"assume-unchanged"</literal></expr>, <expr><operator>&amp;</operator><name>mark_valid_only</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"mark files as \"not changing\""</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>, <expr><name>NULL</name></expr>, <expr><name>MARK_FLAG</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_SET_INT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"no-assume-unchanged"</literal></expr>, <expr><operator>&amp;</operator><name>mark_valid_only</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"clear assumed-unchanged bit"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>, <expr><name>NULL</name></expr>, <expr><name>UNMARK_FLAG</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_SET_INT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"skip-worktree"</literal></expr>, <expr><operator>&amp;</operator><name>mark_skip_worktree_only</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"mark files as \"index-only\""</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>, <expr><name>NULL</name></expr>, <expr><name>MARK_FLAG</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_SET_INT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"no-skip-worktree"</literal></expr>, <expr><operator>&amp;</operator><name>mark_skip_worktree_only</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"clear skip-worktree bit"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>, <expr><name>NULL</name></expr>, <expr><name>UNMARK_FLAG</name></expr>}</block></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ignore-skip-worktree-entries"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignore_skip_worktree_entries</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not touch index-only entries"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"info-only"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info_only</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"add to index only; do not add content to object database"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"force-remove"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>force_remove</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"remove named paths even if present in worktree"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'z'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nul_term_line</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"with --stdin: input lines are terminated by null bytes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><block>{<expr><name>OPTION_LOWLEVEL_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"stdin"</literal></expr>, <expr><operator>&amp;</operator><name>read_from_stdin</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"read list of paths to be updated from standard input"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NONEG</name> <operator>|</operator> <name>PARSE_OPT_NOARG</name></expr>,
<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>stdin_callback</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_LOWLEVEL_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"index-info"</literal></expr>, <expr><operator>&amp;</operator><name>nul_term_line</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"add entries from standard input to the index"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NONEG</name> <operator>|</operator> <name>PARSE_OPT_NOARG</name></expr>,
<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>stdin_cacheinfo_callback</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_LOWLEVEL_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"unresolve"</literal></expr>, <expr><operator>&amp;</operator><name>has_errors</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"repopulate stages #2 and #3 for the listed paths"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NONEG</name> <operator>|</operator> <name>PARSE_OPT_NOARG</name></expr>,
<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>unresolve_callback</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_LOWLEVEL_CALLBACK</name></expr>, <expr><literal type="char">'g'</literal></expr>, <expr><literal type="string">"again"</literal></expr>, <expr><operator>&amp;</operator><name>has_errors</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"only update entries that differ from HEAD"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NONEG</name> <operator>|</operator> <name>PARSE_OPT_NOARG</name></expr>,
<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>reupdate_callback</name></expr>}</block></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ignore-missing"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>refresh_args</name><operator>.</operator><name>flags</name></name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"ignore files missing from worktree"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>REFRESH_IGNORE_MISSING</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"verbose"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>verbose</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"report actions to standard output"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><block>{<expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"clear-resolve-undo"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"(for porcelains) forget saved unresolved conflicts"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>,
<expr><name>resolve_undo_clear_callback</name></expr>}</block></expr>,
<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"index-version"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>preferred_index_format</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"write index in this format"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"split-index"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>split_index</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"enable or disable split index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"untracked-cache"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>untracked_cache</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"enable/disable untracked cache"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"test-untracked-cache"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>untracked_cache</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"test if the filesystem supports untracked cache"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>UC_TEST</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"force-untracked-cache"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>untracked_cache</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"enable untracked cache without testing the filesystem"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>UC_FORCE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"force-write-index"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>force_write</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"write out the index even if is not flagged as changed"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"fsmonitor"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsmonitor</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"enable or disable file system monitor"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><block>{<expr><name>OPTION_SET_INT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"fsmonitor-valid"</literal></expr>, <expr><operator>&amp;</operator><name>mark_fsmonitor_only</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"mark files as fsmonitor valid"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>, <expr><name>NULL</name></expr>, <expr><name>MARK_FLAG</name></expr>}</block></expr>,
<expr><block>{<expr><name>OPTION_SET_INT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"no-fsmonitor-valid"</literal></expr>, <expr><operator>&amp;</operator><name>mark_fsmonitor_only</name></expr>, <expr><name>NULL</name></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"clear fsmonitor valid bit"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NOARG</name> <operator>|</operator> <name>PARSE_OPT_NONEG</name></expr>, <expr><name>NULL</name></expr>, <expr><name>UNMARK_FLAG</name></expr>}</block></expr>,
<macro><name>OPT_END</name><argument_list>()</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>update_index_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_default_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>newfd</name> <operator>=</operator> <call><name>hold_locked_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_file</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lock_error</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>read_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entries</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"cache corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>the_index</name><operator>.</operator><name>updated_skipworktree</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>





<expr_stmt><expr><call><name>parse_options_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>,
<argument><expr><name>options</name></expr></argument>, <argument><expr><name>PARSE_OPT_STOP_AT_NON_OPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>ctx</name><operator>.</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parseopt_state</name> <operator>!=</operator> <name>PARSE_OPT_DONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>parseopt_state</name> <operator>=</operator> <call><name>parse_options_step</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
<argument><expr><name>update_index_usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>.</operator><name>argc</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>parseopt_state</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PARSE_OPT_HELP</name></expr>:</case>
<case>case <expr><name>PARSE_OPT_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">129</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>PARSE_OPT_COMPLETE</name></expr>:</case>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>PARSE_OPT_NON_OPTION</name></expr>:</case>
<case>case <expr><name>PARSE_OPT_DONE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>ctx</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_work_tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>prefix_path</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix_length</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_one</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>set_executable_bit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>chmod_path</name><argument_list>(<argument><expr><name>set_executable_bit</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>argc</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>argv</name></name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>PARSE_OPT_UNKNOWN</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"unknown option '%s'"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"unknown switch '%c'"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>.</operator><name>opt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>update_index_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>getline_fn</name> <operator>=</operator> <ternary><condition><expr><name>nul_term_line</name></expr> ?</condition><then> <expr><name>strbuf_getline_nul</name></expr> </then><else>: <expr><name>strbuf_getline_lf</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>preferred_index_format</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>preferred_index_format</name> <operator>&lt;</operator> <name>INDEX_FORMAT_LB</name> <operator>||</operator>
<name>INDEX_FORMAT_UB</name> <operator>&lt;</operator> <name>preferred_index_format</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"index-version %d not in range: %d..%d"</literal></expr></argument>,
<argument><expr><name>preferred_index_format</name></expr></argument>,
<argument><expr><name>INDEX_FORMAT_LB</name></expr></argument>, <argument><expr><name>INDEX_FORMAT_UB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>the_index</name><operator>.</operator><name>version</name></name> <operator>!=</operator> <name>preferred_index_format</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>active_cache_changed</name> <operator>|=</operator> <name>SOMETHING_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>the_index</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>preferred_index_format</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>read_from_stdin</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>unquoted</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_work_tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>getline_fn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nul_term_line</name> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unquoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unquote_c_style</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unquoted</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"line is badly quoted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_swap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unquoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>prefix_path</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix_length</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_one</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>set_executable_bit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>chmod_path</name><argument_list>(<argument><expr><name>set_executable_bit</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unquoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>split_index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>git_config_get_split_index</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"core.splitIndex is set to false; "</literal>
<literal type="string">"remove or change it, if you really want to "</literal>
<literal type="string">"enable split index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>the_index</name><operator>.</operator><name>split_index</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>the_index</name><operator>.</operator><name>cache_changed</name></name> <operator>|=</operator> <name>SPLIT_INDEX_ORDERED</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_split_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>split_index</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>git_config_get_split_index</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"core.splitIndex is set to true; "</literal>
<literal type="string">"remove or change it, if you really want to "</literal>
<literal type="string">"disable split index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>remove_split_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>prepare_repo_settings</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>untracked_cache</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UC_UNSPECIFIED</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>UC_DISABLE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>settings</name><operator>.</operator><name>core_untracked_cache</name></name> <operator>==</operator> <name>UNTRACKED_CACHE_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"core.untrackedCache is set to true; "</literal>
<literal type="string">"remove or change it, if you really want to "</literal>
<literal type="string">"disable the untracked cache"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>remove_untracked_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Untracked cache disabled"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UC_TEST</name></expr>:</case>
<expr_stmt><expr><call><name>setup_work_tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><call><name>test_if_untracked_cache_is_supported</name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>UC_ENABLE</name></expr>:</case>
<case>case <expr><name>UC_FORCE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>settings</name><operator>.</operator><name>core_untracked_cache</name></name> <operator>==</operator> <name>UNTRACKED_CACHE_REMOVE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"core.untrackedCache is set to false; "</literal>
<literal type="string">"remove or change it, if you really want to "</literal>
<literal type="string">"enable the untracked cache"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_untracked_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Untracked cache enabled for '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_git_work_tree</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"bad untracked_cache value: %d"</literal></expr></argument>, <argument><expr><name>untracked_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>fsmonitor</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>git_config_get_fsmonitor</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"core.fsmonitor is unset; "</literal>
<literal type="string">"set it if you really want to "</literal>
<literal type="string">"enable fsmonitor"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_fsmonitor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fsmonitor enabled"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>fsmonitor</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>git_config_get_fsmonitor</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"core.fsmonitor is set; "</literal>
<literal type="string">"remove it if you really want to "</literal>
<literal type="string">"disable fsmonitor"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>remove_fsmonitor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fsmonitor disabled"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>active_cache_changed</name> <operator>||</operator> <name>force_write</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>newfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refresh_args</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>REFRESH_QUIET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>unable_to_lock_die</name><argument_list>(<argument><expr><call><name>get_index_file</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lock_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>write_locked_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>the_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock_file</name></expr></argument>, <argument><expr><name>COMMIT_LOCK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unable to write new index file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rollback_lock_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>has_errors</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
