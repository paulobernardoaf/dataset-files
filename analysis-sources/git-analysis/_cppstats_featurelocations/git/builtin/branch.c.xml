<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\builtin\branch.c">






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"color.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parse-options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"branch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revision.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string-list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"column.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wt-status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ref-filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"worktree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"help.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>builtin_branch_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git branch [&lt;options&gt;] [-r | -a] [--merged | --no-merged]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git branch [&lt;options&gt;] [-l] [-f] &lt;branch-name&gt; [&lt;start-point&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git branch [&lt;options&gt;] [-r] (-d | -D) &lt;branch-name&gt;..."</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git branch [&lt;options&gt;] (-m | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git branch [&lt;options&gt;] (-c | -C) [&lt;old-branch&gt;] &lt;new-branch&gt;"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git branch [&lt;options&gt;] [-r | -a] [--points-at]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git branch [&lt;options&gt;] [-r | -a] [--format]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>object_id</name></name></type> <name>head_oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>branch_use_color</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>branch_colors</name><index>[]</index><index>[<expr><name>COLOR_MAXLEN</name></expr>]</index></name> <init>= <expr><block>{
<expr><name>GIT_COLOR_RESET</name></expr>,
<expr><name>GIT_COLOR_NORMAL</name></expr>, 
<expr><name>GIT_COLOR_RED</name></expr>, 
<expr><name>GIT_COLOR_NORMAL</name></expr>, 
<expr><name>GIT_COLOR_GREEN</name></expr>, 
<expr><name>GIT_COLOR_BLUE</name></expr>, 
<expr><name>GIT_COLOR_CYAN</name></expr>, 
}</block></expr></init></decl>;</decl_stmt>
<enum>enum <name>color_branch</name> <block>{
<decl><name>BRANCH_COLOR_RESET</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>BRANCH_COLOR_PLAIN</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>BRANCH_COLOR_REMOTE</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>BRANCH_COLOR_LOCAL</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
<decl><name>BRANCH_COLOR_CURRENT</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>BRANCH_COLOR_UPSTREAM</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>,
<decl><name>BRANCH_COLOR_WORKTREE</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>color_branch_slots</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>BRANCH_COLOR_RESET</name></expr>]</index> <operator>=</operator> <literal type="string">"reset"</literal></expr>,
<expr><index>[<expr><name>BRANCH_COLOR_PLAIN</name></expr>]</index> <operator>=</operator> <literal type="string">"plain"</literal></expr>,
<expr><index>[<expr><name>BRANCH_COLOR_REMOTE</name></expr>]</index> <operator>=</operator> <literal type="string">"remote"</literal></expr>,
<expr><index>[<expr><name>BRANCH_COLOR_LOCAL</name></expr>]</index> <operator>=</operator> <literal type="string">"local"</literal></expr>,
<expr><index>[<expr><name>BRANCH_COLOR_CURRENT</name></expr>]</index> <operator>=</operator> <literal type="string">"current"</literal></expr>,
<expr><index>[<expr><name>BRANCH_COLOR_UPSTREAM</name></expr>]</index> <operator>=</operator> <literal type="string">"upstream"</literal></expr>,
<expr><index>[<expr><name>BRANCH_COLOR_WORKTREE</name></expr>]</index> <operator>=</operator> <literal type="string">"worktree"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>output</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>colopts</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>define_list_config_array</name><argument_list>(<argument><expr><name>color_branch_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>git_branch_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slot_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>sorting_tail</name> <init>= <expr><operator>(</operator>struct <name>ref_sorting</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>cb</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"branch.sort"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>config_error_nonbool</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>parse_ref_sorting</name><argument_list>(<argument><expr><name>sorting_tail</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"column."</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>git_column_config</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"branch"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>colopts</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"color.branch"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>branch_use_color</name> <operator>=</operator> <call><name>git_config_colorbool</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"color.branch."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>slot_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>slot</name> <init>= <expr><call><name>LOOKUP_CONFIG</name><argument_list>(<argument><expr><name>color_branch_slots</name></expr></argument>, <argument><expr><name>slot_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>config_error_nonbool</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>color_parse</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>branch_colors</name><index>[<expr><name>slot</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>git_color_default_config</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch_get_color</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>color_branch</name></name></type> <name>ix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>want_color</name><argument_list>(<argument><expr><name>branch_use_color</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>branch_colors</name><index>[<expr><name>ix</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>branch_merged</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>rev</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>head_rev</name></decl></parameter>)</parameter_list>
<block>{<block_content>






<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>reference_rev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reference_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>reference_name_to_free</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>merged</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>FILTER_REFS_BRANCHES</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name> <init>= <expr><call><name>branch_get</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>upstream</name> <init>= <expr><call><name>branch_get_upstream</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>upstream</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>reference_name</name> <operator>=</operator> <name>reference_name_to_free</name> <operator>=</operator>
<call><name>resolve_refdup</name><argument_list>(<argument><expr><name>upstream</name></expr></argument>, <argument><expr><name>RESOLVE_REF_READING</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>reference_rev</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reference_rev</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>reference_rev</name> <operator>=</operator> <name>head_rev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>merged</name> <operator>=</operator> <call><name>in_merge_bases</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><name>reference_rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><operator>(</operator><name>head_rev</name> <operator>!=</operator> <name>reference_rev</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>in_merge_bases</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><name>head_rev</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>merged</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>merged</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"deleting branch '%s' that has been merged to\n"</literal>
<literal type="string">" '%s', but not yet merged to HEAD."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>reference_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"not deleting branch '%s' that is not yet merged to\n"</literal>
<literal type="string">" '%s', even though it is merged to HEAD."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>reference_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reference_name_to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>merged</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_branch_commit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branchname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>head_rev</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>kinds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>rev</name> <init>= <expr><call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rev</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Couldn't look up commit object for '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>branch_merged</name><argument_list>(<argument><expr><name>kinds</name></expr></argument>, <argument><expr><name>branchname</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>head_rev</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The branch '%s' is not fully merged.\n"</literal>
<literal type="string">"If you are sure you want to delete it, "</literal>
<literal type="string">"run 'git branch -D %s'."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>branchname</name></expr></argument>, <argument><expr><name>branchname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>delete_branch_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branchname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"branch.%s"</literal></expr></argument>, <argument><expr><name>branchname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>git_config_rename_section</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Update of config-file failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>delete_branches</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kinds</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>quiet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>head_rev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>remote_branch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>bname</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>allowed_interpret</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>kinds</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>FILTER_REFS_REMOTES</name></expr>:</case>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <literal type="string">"refs/remotes/%s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>remote_branch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>allowed_interpret</name> <operator>=</operator> <name>INTERPRET_BRANCH_REMOTE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>force</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FILTER_REFS_BRANCHES</name></expr>:</case>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <literal type="string">"refs/heads/%s"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>allowed_interpret</name> <operator>=</operator> <name>INTERPRET_BRANCH_LOCAL</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use -a with -d"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>head_rev</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head_rev</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Couldn't look up commit object for HEAD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bname</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_branchname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>allowed_interpret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>mkpathdup</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>bname</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kinds</name> <operator>==</operator> <name>FILTER_REFS_BRANCHES</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>worktree</name></name> <modifier>*</modifier></type><name>wt</name> <init>=
<expr><call><name>find_shared_symref</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>wt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot delete branch '%s' "</literal>
<literal type="string">"checked out at '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>bname</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>wt</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>resolve_refdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
<argument><expr><name>RESOLVE_REF_READING</name>
<operator>|</operator> <name>RESOLVE_REF_NO_RECURSE</name>
<operator>|</operator> <name>RESOLVE_REF_ALLOW_BAD_NAME</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><ternary><condition><expr><name>remote_branch</name></expr>
?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"remote-tracking branch '%s' not found."</literal></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"branch '%s' not found."</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name><name>bname</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>REF_ISSYMREF</name><operator>|</operator><name>REF_ISBROKEN</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>check_branch_commit</name><argument_list>(<argument><expr><name><name>bname</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>head_rev</name></expr></argument>, <argument><expr><name>kinds</name></expr></argument>,
<argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>next</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>delete_ref</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>oid</name></expr></else></ternary></expr></argument>,
<argument><expr><name>REF_NO_DEREF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><ternary><condition><expr><name>remote_branch</name></expr>
?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error deleting remote-tracking branch '%s'"</literal></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error deleting branch '%s'"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
<argument><expr><name><name>bname</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>next</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>quiet</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><name>remote_branch</name></expr>
?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Deleted remote-tracking branch %s (was %s).\n"</literal></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Deleted branch %s (was %s).\n"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
<argument><expr><name><name>bname</name><operator>.</operator><name>buf</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REF_ISBROKEN</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"broken"</literal></expr>
</then><else>: <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REF_ISSYMREF</name><operator>)</operator></expr> ?</condition><then> <expr><name>target</name></expr>
</then><else>: <expr><call><name>find_unique_abbrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>delete_branch_config</name><argument_list>(<argument><expr><name><name>bname</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>next</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>calc_maxwidth</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_array</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remote_bonus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>refs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ref_array_item</name></name> <modifier>*</modifier></type><name>it</name> <init>= <expr><name><name>refs</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>refname</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><literal type="string">"refs/remotes/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_DETACHED_HEAD</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>head_desc</name> <init>= <expr><call><name>get_head_description</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>utf8_strwidth</name><argument_list>(<argument><expr><name>head_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>head_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>utf8_strwidth</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>FILTER_REFS_REMOTES</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>w</name> <operator>+=</operator> <name>remote_bonus</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>max</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quote_literal_for_format</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><call><name>strchrnul</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>ep</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ep</name> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ep</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%%"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>ep</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>ep</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>build_format</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxwidth</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote_prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>fmt</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>local</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>remote</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><literal type="string">"%%(if)%%(HEAD)%%(then)* %s%%(else)%%(if)%%(worktreepath)%%(then)+ %s%%(else) %s%%(end)%%(end)"</literal></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_CURRENT</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_WORKTREE</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_LOCAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_REMOTE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>obname</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>abbrev</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obname</name></expr></argument>, <argument><expr><literal type="string">"%%(objectname:short)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>filter</name><operator>-&gt;</operator><name>abbrev</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obname</name></expr></argument>, <argument><expr><literal type="string">"%%(objectname)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obname</name></expr></argument>, <argument><expr><literal type="string">"%%(objectname:short=%d)"</literal></expr></argument>, <argument><expr><name><name>filter</name><operator>-&gt;</operator><name>abbrev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><literal type="string">"%%(align:%d,left)%%(refname:lstrip=2)%%(end)"</literal></expr></argument>, <argument><expr><name>maxwidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><name><name>obname</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>verbose</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><literal type="string">"%%(if:notequals=*)%%(HEAD)%%(then)%%(if)%%(worktreepath)%%(then)(%s%%(worktreepath)%s) %%(end)%%(end)"</literal></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_WORKTREE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><literal type="string">"%%(if)%%(upstream)%%(then)[%s%%(upstream:short)%s%%(if)%%(upstream:track)"</literal>
<literal type="string">"%%(then): %%(upstream:track,nobracket)%%(end)] %%(end)%%(contents:subject)"</literal></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_UPSTREAM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><literal type="string">"%%(if)%%(upstream:track)%%(then)%%(upstream:track) %%(end)%%(contents:subject)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote</name></expr></argument>, <argument><expr><literal type="string">"%%(align:%d,left)%s%%(refname:lstrip=2)%%(end)%s"</literal>
<literal type="string">"%%(if)%%(symref)%%(then) -&gt; %%(symref:short)"</literal>
<literal type="string">"%%(else) %s %%(contents:subject)%%(end)"</literal></expr></argument>,
<argument><expr><name>maxwidth</name></expr></argument>, <argument><expr><call><name>quote_literal_for_format</name><argument_list>(<argument><expr><name>remote_prefix</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>obname</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><literal type="string">"%%(refname:lstrip=2)%s%%(if)%%(symref)%%(then) -&gt; %%(symref:short)%%(end)"</literal></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote</name></expr></argument>, <argument><expr><literal type="string">"%s%%(refname:lstrip=2)%s%%(if)%%(symref)%%(then) -&gt; %%(symref:short)%%(end)"</literal></expr></argument>,
<argument><expr><call><name>quote_literal_for_format</name><argument_list>(<argument><expr><name>remote_prefix</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>branch_get_color</name><argument_list>(<argument><expr><name>BRANCH_COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"%%(if:notequals=refs/remotes)%%(refname:rstrip=-2)%%(then)%s%%(else)%s%%(end)"</literal></expr></argument>, <argument><expr><name><name>local</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>remote</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_ref_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ref_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier></type><name>sorting</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ref_format</name></name> <modifier>*</modifier></type><name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ref_array</name></name></type> <name>array</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maxwidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remote_prefix</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to_free</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>FILTER_REFS_REMOTES</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>remote_prefix</name> <operator>=</operator> <literal type="string">"remotes/"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>filter_refs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name><name>filter</name><operator>-&gt;</operator><name>kind</name></name> <operator>|</operator> <name>FILTER_REFS_INCLUDE_BROKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxwidth</name> <operator>=</operator> <call><name>calc_maxwidth</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>remote_prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>format</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>format</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>to_free</name> <operator>=</operator> <call><name>build_format</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>maxwidth</name></expr></argument>, <argument><expr><name>remote_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>format</name><operator>-&gt;</operator><name>use_color</name></name> <operator>=</operator> <name>branch_use_color</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>verify_ref_format</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to parse format string"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ref_array_sort</name><argument_list>(<argument><expr><name>sorting</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>out</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>format_ref_array_item</name><argument_list>(<argument><expr><name><name>array</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>column_active</name><argument_list>(<argument><expr><name>colopts</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>filter</name><operator>-&gt;</operator><name>verbose</name></name> <operator>&amp;&amp;</operator> <literal type="string">"--column and --verbose are incompatible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><name><name>out</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>out</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>out</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>ref_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_current_branch_name</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name> <init>= <expr><call><name>resolve_ref_unsafe</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shortname</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>refname</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not resolve HEAD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REF_ISSYMREF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>shortname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>shortname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HEAD (%s) points outside of refs/heads/"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>reject_rebase_or_bisect_branch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>worktree</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>worktrees</name> <init>= <expr><call><name>get_worktrees</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>worktrees</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>worktree</name></name> <modifier>*</modifier></type><name>wt</name> <init>= <expr><name><name>worktrees</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>wt</name><operator>-&gt;</operator><name>is_detached</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_worktree_being_rebased</name><argument_list>(<argument><expr><name>wt</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Branch %s is being rebased at %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>wt</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_worktree_being_bisected</name><argument_list>(<argument><expr><name>wt</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Branch %s is being bisected at %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>wt</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>free_worktrees</name><argument_list>(<argument><expr><name>worktrees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_or_rename_branch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>copy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>oldref</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>, <decl><type ref="prev"/><name>newref</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>, <decl><type ref="prev"/><name>logmsg</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>oldsection</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>, <decl><type ref="prev"/><name>newsection</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>interpreted_oldname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>interpreted_newname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>recovery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldname</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot copy the current branch while not on any."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot rename the current branch while not on any."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strbuf_check_branch_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldref</name></expr></argument>, <argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>ref_exists</name><argument_list>(<argument><expr><name><name>oldref</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>recovery</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Invalid branch name: '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>validate_branchname</name><argument_list>(<argument><expr><name>newname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>validate_new_branchname</name><argument_list>(<argument><expr><name>newname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newref</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>reject_rebase_or_bisect_branch</name><argument_list>(<argument><expr><name><name>oldref</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>oldref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>interpreted_oldname</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>newref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>interpreted_newname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"expected prefix missing for refs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logmsg</name></expr></argument>, <argument><expr><literal type="string">"Branch: copied %s to %s"</literal></expr></argument>,
<argument><expr><name><name>oldref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>newref</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logmsg</name></expr></argument>, <argument><expr><literal type="string">"Branch: renamed %s to %s"</literal></expr></argument>,
<argument><expr><name><name>oldref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>newref</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy</name> <operator>&amp;&amp;</operator> <call><name>rename_ref</name><argument_list>(<argument><expr><name><name>oldref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>newref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>logmsg</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Branch rename failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&amp;&amp;</operator> <call><name>copy_existing_ref</name><argument_list>(<argument><expr><name><name>oldref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>newref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>logmsg</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Branch copy failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>recovery</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Created a copy of a misnamed branch '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>interpreted_oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Renamed a misnamed branch '%s' away"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>interpreted_oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy</name> <operator>&amp;&amp;</operator>
<call><name>replace_each_worktree_head_symref</name><argument_list>(<argument><expr><name><name>oldref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>newref</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>logmsg</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Branch renamed to %s, but HEAD is not updated!"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldsection</name></expr></argument>, <argument><expr><literal type="string">"branch.%s"</literal></expr></argument>, <argument><expr><name>interpreted_oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newsection</name></expr></argument>, <argument><expr><literal type="string">"branch.%s"</literal></expr></argument>, <argument><expr><name>interpreted_newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy</name> <operator>&amp;&amp;</operator> <call><name>git_config_rename_section</name><argument_list>(<argument><expr><name><name>oldsection</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>newsection</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Branch is renamed, but update of config-file failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>git_config_copy_section</name><argument_list>(<argument><expr><name><name>oldsection</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>newsection</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Branch is copied, but update of config-file failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldsection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newsection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>edit_description</argument>, <argument><literal type="string">"EDIT_DESCRIPTION"</literal></argument>)</argument_list></macro>

<specifier>static</specifier> <name>int</name> <macro><name>edit_branch_description</name><argument_list>(<argument>const char *branch_name</argument>)</argument_list></macro>
<block>{
struct <expr><name>strbuf</name> <name>buf</name> <operator>=</operator> <name>STRBUF_INIT</name></expr>;
struct <expr><name>strbuf</name> <name>name</name> <operator>=</operator> <name>STRBUF_INIT</name></expr>;

<expr><call><name>read_branch_desc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>branch_name</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>||</operator> <name><name>buf</name><operator>.</operator><name>buf</name><index>[<expr><name><name>buf</name><operator>.</operator><name>len</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<call><name>strbuf_commented_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Please edit the description for the branch\n"</literal>
<literal type="string">" %s\n"</literal>
<literal type="string">"Lines starting with '%c' will be stripped.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>branch_name</name></expr></argument>, <argument><expr><name>comment_line_char</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_file_buf</name><argument_list>(<argument><expr><call><name>edit_description</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>launch_editor</name><argument_list>(<argument><expr><call><name>edit_description</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_stripspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"branch.%s.description"</literal></expr></argument>, <argument><expr><name>branch_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>git_config_set</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr> ?</condition><then> <expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
}

int <macro><name>cmd_branch</name><argument_list>(<argument>int argc</argument>, <argument>const char **argv</argument>, <argument>const char *prefix</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>delete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rename</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>copy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>force</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>list</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>show_current</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reflog</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>edit_description</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quiet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>unset_upstream</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_upstream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>branch_track</name></name></type> <name>track</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ref_filter</name></name></type> <name>filter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>icase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>ref_sorting</name></name> <modifier>*</modifier></type><name>sorting</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>sorting_tail</name> <init>= <expr><operator>&amp;</operator><name>sorting</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ref_format</name></name></type> <name>format</name> <init>= <expr><name>REF_FORMAT_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Generic options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT__VERBOSE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>verbose</name></name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show hash and subject, give twice for upstream branch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT__QUIET</name><argument_list>(<argument><expr><operator>&amp;</operator><name>quiet</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"suppress informational messages"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>, <argument><expr><literal type="string">"track"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>track</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"set up tracking mode (see git-pull(1))"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>BRANCH_TRACK_EXPLICIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"set-upstream"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>track</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not use"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>BRANCH_TRACK_OVERRIDE</name></expr></argument>, <argument><expr><name>PARSE_OPT_HIDDEN</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING</name><argument_list>(<argument><expr><literal type="char">'u'</literal></expr></argument>, <argument><expr><literal type="string">"set-upstream-to"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_upstream</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"upstream"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"change the upstream info"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"unset-upstream"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>unset_upstream</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"unset the upstream info"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT__COLOR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>branch_use_color</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use colored output"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"remotes"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>kind</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"act on remote-tracking branches"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>FILTER_REFS_REMOTES</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_CONTAINS</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>with_commit</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print only branches that contain the commit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_NO_CONTAINS</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>no_commit</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print only branches that don't contain the commit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_WITH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>with_commit</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print only branches that contain the commit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_WITHOUT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>no_commit</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print only branches that don't contain the commit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT__ABBREV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>abbrev</name></name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>OPT_GROUP</name><argument_list>(<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Specific git-branch actions:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>kind</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"list both remote-tracking and local branches"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>FILTER_REFS_REMOTES</name> <operator>|</operator> <name>FILTER_REFS_BRANCHES</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>delete</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"delete fully merged branch"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="char">'D'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>delete</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"delete branch (even if not merged)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="char">'m'</literal></expr></argument>, <argument><expr><literal type="string">"move"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rename</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"move/rename a branch and its reflog"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="char">'M'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rename</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"move/rename a branch, even if target exists"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><literal type="string">"copy"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"copy a branch and its reflog"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BIT</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"copy a branch, even if target exists"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'l'</literal></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"list branch names"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"show-current"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>show_current</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show current branch name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"create-reflog"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>reflog</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"create the branch's reflog"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"edit-description"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>edit_description</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"edit the description for the branch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT__FORCE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>force</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"force creation, move/rename, deletion"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PARSE_OPT_NOCOMPLETE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_MERGED</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print only branches that are merged"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_NO_MERGED</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print only branches that are not merged"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_COLUMN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"column"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>colopts</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"list branches in columns"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_REF_SORT</name><argument_list>(<argument><expr><name>sorting_tail</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{
<expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"points-at"</literal></expr>, <expr><operator>&amp;</operator><name><name>filter</name><operator>.</operator><name>points_at</name></name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"print only branches of the object"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>parse_opt_object_name</name></expr>
}</block></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><literal type="string">"ignore-case"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>icase</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"sorting and filtering are case insensitive"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> , <argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>format</name><operator>.</operator><name>format</name></name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"format to use for the output"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_END</name><argument_list>()</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_ref_filter_porcelain_msg</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>FILTER_REFS_BRANCHES</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>abbrev</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>builtin_branch_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_branch_config</name></expr></argument>, <argument><expr><name>sorting_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>track</name> <operator>=</operator> <name>git_branch_track</name></expr>;</expr_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>resolve_refdup</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to resolve HEAD as a valid ref."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>detached</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HEAD not found below refs/heads!"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>builtin_branch_usage</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>delete</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>rename</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>copy</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>edit_description</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>new_upstream</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name>show_current</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>unset_upstream</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>.</operator><name>with_commit</name></name> <operator>||</operator> <name><name>filter</name><operator>.</operator><name>merge</name></name> <operator>!=</operator> <name>REF_FILTER_MERGED_NONE</name> <operator>||</operator> <name><name>filter</name><operator>.</operator><name>points_at</name><operator>.</operator><name>nr</name></name> <operator>||</operator>
<name><name>filter</name><operator>.</operator><name>no_commit</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><name>delete</name> <operator>+</operator> <operator>!</operator><operator>!</operator><name>rename</name> <operator>+</operator> <operator>!</operator><operator>!</operator><name>copy</name> <operator>+</operator> <operator>!</operator><operator>!</operator><name>new_upstream</name> <operator>+</operator> <operator>!</operator><operator>!</operator><name>show_current</name> <operator>+</operator>
<name>list</name> <operator>+</operator> <name>unset_upstream</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>builtin_branch_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>.</operator><name>abbrev</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>abbrev</name></name> <operator>=</operator> <name>DEFAULT_ABBREV</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>ignore_case</name></name> <operator>=</operator> <name>icase</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>finalize_colopts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>colopts</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>.</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>explicitly_enable_column</name><argument_list>(<argument><expr><name>colopts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--column and --verbose are incompatible"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>colopts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>force</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>delete</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rename</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>copy</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setup_auto_pager</name><argument_list>(<argument><expr><literal type="string">"branch"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>delete</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"branch name required"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>delete_branches</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>delete</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>filter</name><operator>.</operator><name>kind</name></name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>show_current</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print_current_branch_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>filter</name><operator>.</operator><name>kind</name></name> <operator>&amp;</operator> <name>FILTER_REFS_BRANCHES</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>filter</name><operator>.</operator><name>detached</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>kind</name></name> <operator>|=</operator> <name>FILTER_REFS_DETACHED_HEAD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>name_patterns</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sorting</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sorting</name> <operator>=</operator> <call><name>ref_default_sorting</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sorting</name><operator>-&gt;</operator><name>ignore_case</name></name> <operator>=</operator> <name>icase</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_ref_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><name>sorting</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_columns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><name>colopts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>edit_description</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>branch_ref</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>.</operator><name>detached</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot give description to detached HEAD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>branch_name</name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>branch_name</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot edit description of more than one branch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>branch_ref</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/%s"</literal></expr></argument>, <argument><expr><name>branch_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ref_exists</name><argument_list>(<argument><expr><name><name>branch_ref</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>branch_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No commit on branch '%s' yet."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>branch_name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No branch named '%s'."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>branch_name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>branch_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>edit_branch_description</name><argument_list>(<argument><expr><name>branch_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"branch name required"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_or_rename_branch</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>copy</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_or_rename_branch</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>copy</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many branches for a copy operation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rename</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"branch name required"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_or_rename_branch</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rename</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_or_rename_branch</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rename</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many arguments for a rename operation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>new_upstream</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name> <init>= <expr><call><name>branch_get</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many arguments to set new upstream"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>branch</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not set upstream of HEAD to %s when "</literal>
<literal type="string">"it does not point to any branch."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>new_upstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no such branch '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ref_exists</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"branch '%s' does not exist"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><call><name>create_branch</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>new_upstream</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>quiet</name></expr></argument>, <argument><expr><name>BRANCH_TRACK_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>unset_upstream</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name> <init>= <expr><call><name>branch_get</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many arguments to unset upstream"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>branch</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not unset upstream of HEAD when "</literal>
<literal type="string">"it does not point to any branch."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no such branch '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>branch_has_merge_config</name><argument_list>(<argument><expr><name>branch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Branch '%s' has no upstream information"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"branch.%s.remote"</literal></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>git_config_set_multivar</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"branch.%s.merge"</literal></expr></argument>, <argument><expr><name><name>branch</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>git_config_set_multivar</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>.</operator><name>kind</name></name> <operator>!=</operator> <name>FILTER_REFS_BRANCHES</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The -a, and -r, options to 'git branch' do not take a branch name.\n"</literal>
<literal type="string">"Did you mean to use: -a|-r --list &lt;pattern&gt;?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>track</name> <operator>==</operator> <name>BRANCH_TRACK_OVERRIDE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"the '--set-upstream' option is no longer supported. Please use '--track' or '--set-upstream-to' instead."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>create_branch</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>argc</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>head</name></expr></else></ternary></expr></argument>,
<argument><expr><name>force</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reflog</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>, <argument><expr><name>track</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>builtin_branch_usage</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
</unit>
