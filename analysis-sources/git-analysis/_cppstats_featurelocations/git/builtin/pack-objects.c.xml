<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\builtin\pack-objects.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blob.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pack-revindex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"csum-file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree-walk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revision.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list-objects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list-objects-filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list-objects-filter-options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pack-objects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"streaming.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pack-bitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"delta-islands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reachable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sha1-array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"argv-array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"packfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"midx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trace2.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_PACK</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_in_pack(&amp;to_pack, obj)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_size(&amp;to_pack, obj)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_SIZE</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_set_size(&amp;to_pack, obj, size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTA_SIZE</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_delta_size(&amp;to_pack, obj)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTA</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_delta(&amp;to_pack, obj)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTA_CHILD</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_delta_child(&amp;to_pack, obj)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTA_SIBLING</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_delta_sibling(&amp;to_pack, obj)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_DELTA</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_set_delta(&amp;to_pack, obj, val)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_DELTA_EXT</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>oid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_set_delta_ext(&amp;to_pack, obj, oid)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_DELTA_SIZE</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_set_delta_size(&amp;to_pack, obj, val)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_DELTA_CHILD</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_set_delta_child(&amp;to_pack, obj, val)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_DELTA_SIBLING</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>oe_set_delta_sibling(&amp;to_pack, obj, val)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>pack_usage</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git pack-objects --stdout [&lt;options&gt;...] [&lt; &lt;ref-list&gt; | &lt; &lt;object-list&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"git pack-objects [&lt;options&gt;...] &lt;base-name&gt; [&lt; &lt;ref-list&gt; | &lt; &lt;object-list&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>packing_data</name></name></type> <name>to_pack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>pack_idx_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>written_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>nr_result</name></decl>, <decl><type ref="prev"/><name>nr_written</name></decl>, <decl><type ref="prev"/><name>nr_seen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>bitmap_index</name></name> <modifier>*</modifier></type><name>bitmap_git</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>write_layer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>non_empty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>reuse_delta</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>reuse_object</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>keep_unreachable</name></decl>, <decl><type ref="prev"/><name>unpack_unreachable</name></decl>, <decl><type ref="prev"/><name>include_tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>timestamp_t</name></type> <name>unpack_unreachable_expiration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>pack_loose_unreachable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>local</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>have_non_local_packs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>incremental</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ignore_packed_keep_on_disk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ignore_packed_keep_in_core</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>allow_ofs_delta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>pack_idx_option</name></name></type> <name>pack_idx_opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>progress</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>window</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>pack_size_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>delta_search_threads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>pack_to_stdout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sparse</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>thin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>num_preferred_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>progress</name></name> <modifier>*</modifier></type><name>progress_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>reuse_packfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>reuse_packfile_objects</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>bitmap</name></name> <modifier>*</modifier></type><name>reuse_packfile_bitmap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>use_bitmap_index_default</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>use_bitmap_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>allow_pack_reuse</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<enum><specifier>static</specifier> enum <block>{
<decl><name>WRITE_BITMAP_FALSE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>WRITE_BITMAP_QUIET</name></decl>,
<decl><name>WRITE_BITMAP_TRUE</name></decl>,
}</block> <decl><name>write_bitmap_index</name></decl>;</enum>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint16_t</name></type> <name>write_bitmap_options</name> <init>= <expr><name>BITMAP_OPT_HASH_CACHE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>exclude_promisor_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>use_delta_islands</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>delta_cache_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>max_delta_cache_size</name> <init>= <expr><name>DEFAULT_DELTA_CACHE_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>cache_max_small_delta_size</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>window_memory_limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>list_objects_filter_options</name></name></type> <name>filter_options</name></decl>;</decl_stmt>

<enum>enum <name>missing_action</name> <block>{
<decl><name>MA_ERROR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>MA_ALLOW_ANY</name></decl>, 
<decl><name>MA_ALLOW_PROMISOR</name></decl>, 
}</block>;</enum>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>enum</name> <name>missing_action</name></name></type> <name>arg_missing_action</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>show_object_fn</name></type> <name>fn_show_object</name></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>written</name></decl>, <decl><type ref="prev"/><name>written_delta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>reused</name></decl>, <decl><type ref="prev"/><name>reused_delta</name></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>indexed_commits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>indexed_commits_nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>indexed_commits_alloc</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>index_commit_for_bitmap</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>indexed_commits_nr</name> <operator>&gt;=</operator> <name>indexed_commits_alloc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>indexed_commits_alloc</name> <operator>=</operator> <operator>(</operator><name>indexed_commits_alloc</name> <operator>+</operator> <literal type="number">32</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REALLOC_ARRAY</name><argument_list>(<argument><expr><name>indexed_commits</name></expr></argument>, <argument><expr><name>indexed_commits_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>indexed_commits</name><index>[<expr><name>indexed_commits_nr</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>commit</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>get_delta</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>base_size</name></decl>, <decl><type ref="prev"/><name>delta_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base_buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>delta_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to read %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>base_buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>base_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>base_buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unable to read %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>delta_buf</name> <operator>=</operator> <call><name>diff_delta</name><argument_list>(<argument><expr><name>base_buf</name></expr></argument>, <argument><expr><name>base_size</name></expr></argument>,
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>delta_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name>delta_buf</name> <operator>||</operator> <name>delta_size</name> <operator>!=</operator> <call><name>DELTA_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"delta size changed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>base_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>delta_buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>do_compress</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>git_zstream</name></type> <name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>in</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>maxsize</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>git_deflate_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><name>pack_compression_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maxsize</name> <operator>=</operator> <call><name>git_deflate_bound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>in</name> <operator>=</operator> <operator>*</operator><name>pptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>maxsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pptr</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>maxsize</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>git_deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while> 
<expr_stmt><expr><call><name>git_deflate_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>stream</name><operator>.</operator><name>total_out</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>write_large_blob_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>git_istream</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>git_zstream</name></type> <name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ibuf</name><index>[<expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>obuf</name><index>[<expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>olen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>git_deflate_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><name>pack_compression_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>readlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>zret</name> <init>= <expr><name>Z_OK</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>readlen</name> <operator>=</operator> <call><name>read_istream</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>ibuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ibuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>readlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to read %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>ibuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>readlen</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name><name>stream</name><operator>.</operator><name>avail_in</name></name> <operator>||</operator> <name>readlen</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>zret</name> <operator>==</operator> <name>Z_OK</name> <operator>||</operator> <name>zret</name> <operator>==</operator> <name>Z_BUF_ERROR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>obuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>zret</name> <operator>=</operator> <call><name>git_deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><ternary><condition><expr><name>readlen</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>Z_FINISH</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>obuf</name></expr></argument>, <argument><expr><name><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>-</operator> <name>obuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>olen</name> <operator>+=</operator> <name><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>-</operator> <name>obuf</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>.</operator><name>avail_in</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"deflate error (%d)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>readlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>zret</name> <operator>!=</operator> <name>Z_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"deflate error (%d)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>git_deflate_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>olen</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>check_pack_inflate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pack_window</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>w_curs</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>expect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>git_zstream</name></type> <name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>fakebuf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>git_inflate_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>use_pack</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>w_curs</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stream</name><operator>.</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>fakebuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>fakebuf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>st</name> <operator>=</operator> <call><name>git_inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>stream</name><operator>.</operator><name>next_in</name></name> <operator>-</operator> <name>in</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>st</name> <operator>==</operator> <name>Z_OK</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>Z_BUF_ERROR</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>git_inflate_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>st</name> <operator>==</operator> <name>Z_STREAM_END</name> <operator>&amp;&amp;</operator>
<name><name>stream</name><operator>.</operator><name>total_out</name></name> <operator>==</operator> <name>expect</name> <operator>&amp;&amp;</operator>
<name><name>stream</name><operator>.</operator><name>total_in</name></name> <operator>==</operator> <name>len</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_pack_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pack_window</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>w_curs</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>avail</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>use_pack</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>w_curs</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>avail</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>avail</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>write_no_reuse_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>usable_delta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>datalen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>header</name><index>[<expr><name>MAX_PACK_OBJECT_HEADER</name></expr>]</index></name></decl>,
<decl><type ref="prev"/><name><name>dheader</name><index>[<expr><name>MAX_PACK_OBJECT_HEADER</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>hdrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>git_istream</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hashsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>usable_delta</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJ_BLOB</name> <operator>&amp;&amp;</operator>
<call><name>oe_size_greater_than</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>big_file_threshold</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>st</name> <operator>=</operator> <call><name>open_istream</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to read %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>




<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>delta_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>z_delta_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>delta_data</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>DELTA_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>delta_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>delta_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>allow_ofs_delta</name> <operator>&amp;&amp;</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>offset</name></name><operator>)</operator></expr> ?</condition><then>
<expr><name>OBJ_OFS_DELTA</name></expr> </then><else>: <expr><name>OBJ_REF_DELTA</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_delta</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>DELTA_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>allow_ofs_delta</name> <operator>&amp;&amp;</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>offset</name></name><operator>)</operator></expr> ?</condition><then>
<expr><name>OBJ_OFS_DELTA</name></expr> </then><else>: <expr><name>OBJ_REF_DELTA</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>st</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>datalen</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>z_delta_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>datalen</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>z_delta_size</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>datalen</name> <operator>=</operator> <call><name>do_compress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>





<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>encode_in_pack_object_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_OFS_DELTA</name></expr>)</condition> <block>{<block_content>





<decl_stmt><decl><type><name>off_t</name></type> <name>ofs</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>-</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>pos</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>dheader</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dheader</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>ofs</name> <operator>&amp;</operator> <literal type="number">127</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ofs</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dheader</name><index>[<expr><operator>--</operator><name>pos</name></expr>]</index></name> <operator>=</operator> <literal type="number">128</literal> <operator>|</operator> <operator>(</operator><operator>--</operator><name>ofs</name> <operator>&amp;</operator> <literal type="number">127</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <name>hdrlen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dheader</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>pos</name> <operator>+</operator> <name>datalen</name> <operator>+</operator> <name>hashsz</name> <operator>&gt;=</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>st</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>close_istream</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>dheader</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dheader</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdrlen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dheader</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_REF_DELTA</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <name>hdrlen</name> <operator>+</operator> <name>hashsz</name> <operator>+</operator> <name>datalen</name> <operator>+</operator> <name>hashsz</name> <operator>&gt;=</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>st</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>close_istream</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>hashsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdrlen</name> <operator>+=</operator> <name>hashsz</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <name>hdrlen</name> <operator>+</operator> <name>datalen</name> <operator>+</operator> <name>hashsz</name> <operator>&gt;=</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>st</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>close_istream</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>st</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>datalen</name> <operator>=</operator> <call><name>write_large_blob_data</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close_istream</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>hdrlen</name> <operator>+</operator> <name>datalen</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>off_t</name></type> <name>write_reuse_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>usable_delta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>IN_PACK</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pack_window</name></name> <modifier>*</modifier></type><name>w_curs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>revindex_entry</name></name> <modifier>*</modifier></type><name>revidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name> <init>= <expr><call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>datalen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>header</name><index>[<expr><name>MAX_PACK_OBJECT_HEADER</name></expr>]</index></name></decl>,
<decl><type ref="prev"/><name><name>dheader</name><index>[<expr><name>MAX_PACK_OBJECT_HEADER</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>hdrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hashsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>entry_size</name> <init>= <expr><call><name>SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>allow_ofs_delta</name> <operator>&amp;&amp;</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>offset</name></name><operator>)</operator></expr> ?</condition><then>
<expr><name>OBJ_OFS_DELTA</name></expr> </then><else>: <expr><name>OBJ_REF_DELTA</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>encode_in_pack_object_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>type</name></expr></argument>, <argument><expr><name>entry_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>revidx</name> <operator>=</operator> <call><name>find_pack_revindex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>datalen</name> <operator>=</operator> <name><name>revidx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>index_version</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<call><name>check_pack_crc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>revidx</name><operator>-&gt;</operator><name>nr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad packed object CRC for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>write_no_reuse_object</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>usable_delta</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>entry</name><operator>-&gt;</operator><name>in_pack_header_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>datalen</name> <operator>-=</operator> <name><name>entry</name><operator>-&gt;</operator><name>in_pack_header_size</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>index_version</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<call><name>check_pack_inflate</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name>entry_size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"corrupt packed object for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>write_no_reuse_object</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>usable_delta</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_OFS_DELTA</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>off_t</name></type> <name>ofs</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>-</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>pos</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>dheader</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dheader</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>ofs</name> <operator>&amp;</operator> <literal type="number">127</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ofs</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dheader</name><index>[<expr><operator>--</operator><name>pos</name></expr>]</index></name> <operator>=</operator> <literal type="number">128</literal> <operator>|</operator> <operator>(</operator><operator>--</operator><name>ofs</name> <operator>&amp;</operator> <literal type="number">127</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <name>hdrlen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dheader</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>pos</name> <operator>+</operator> <name>datalen</name> <operator>+</operator> <name>hashsz</name> <operator>&gt;=</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>dheader</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dheader</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdrlen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dheader</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reused_delta</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_REF_DELTA</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <name>hdrlen</name> <operator>+</operator> <name>hashsz</name> <operator>+</operator> <name>datalen</name> <operator>+</operator> <name>hashsz</name> <operator>&gt;=</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>hashsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdrlen</name> <operator>+=</operator> <name>hashsz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reused_delta</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <name>hdrlen</name> <operator>+</operator> <name>datalen</name> <operator>+</operator> <name>hashsz</name> <operator>&gt;=</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>copy_pack_data</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reused</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>hdrlen</name> <operator>+</operator> <name>datalen</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>off_t</name></type> <name>write_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>write_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>usable_delta</name></decl>, <decl><type ref="prev"/><name>to_reuse</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>crc32_begin</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_size_limit</name> <operator>||</operator> <operator>!</operator><name>nr_written</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>limit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>pack_size_limit</name> <operator>&lt;=</operator> <name>write_offset</name></expr>)</condition><block type="pseudo"><block_content>




<expr_stmt><expr><name>limit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>limit</name> <operator>=</operator> <name>pack_size_limit</name> <operator>-</operator> <name>write_offset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>usable_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>pack_size_limit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>usable_delta</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>offset</name></name> <operator>==</operator> <operator>(</operator><name>off_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>usable_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>idx</name><operator>.</operator><name>offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>usable_delta</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>usable_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reuse_object</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>to_reuse</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IN_PACK</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>to_reuse</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJ_REF_DELTA</name> <operator>||</operator>
<call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJ_OFS_DELTA</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>to_reuse</name> <operator>=</operator> <name>usable_delta</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>in_pack_type</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>to_reuse</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>to_reuse</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>to_reuse</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> 



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>to_reuse</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>write_no_reuse_object</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>usable_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>write_reuse_object</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>usable_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>usable_delta</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>written_delta</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>written</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>crc32</name></name> <operator>=</operator> <call><name>crc32_end</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>write_one_status</name> <block>{
<decl><name>WRITE_ONE_SKIP</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, 
<decl><name>WRITE_ONE_BREAK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>WRITE_ONE_WRITTEN</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, 
<decl><name>WRITE_ONE_RECURSIVE</name> <init>= <expr><literal type="number">2</literal></expr></init></decl> 
}</block>;</enum>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>write_one_status</name></name></type> <name>write_one</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>,
<parameter><decl><type><name>off_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>off_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>recursing</name></decl>;</decl_stmt>






<expr_stmt><expr><name>recursing</name> <operator>=</operator> <operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"recursive delta detected for object %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>WRITE_ONE_RECURSIVE</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>WRITE_ONE_SKIP</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<switch>switch <condition>(<expr><call><name>write_one</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>DELTA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>WRITE_ONE_RECURSIVE</name></expr>:</case>

<expr_stmt><expr><call><name>SET_DELTA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
<case>case <expr><name>WRITE_ONE_BREAK</name></expr>:</case>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>recursing</name></expr>;</expr_stmt>
<return>return <expr><name>WRITE_ONE_BREAK</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <operator>*</operator><name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>write_object</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>*</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>recursing</name></expr>;</expr_stmt>
<return>return <expr><name>WRITE_ONE_BREAK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>written_list</name><index>[<expr><name>nr_written</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>signed_add_overflows</name><argument_list>(<argument><expr><operator>*</operator><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pack too large for current definition of off_t"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<return>return <expr><name>WRITE_ONE_WRITTEN</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mark_tagged</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>peeled</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>packlist_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tagged</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>peel_ref</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peeled</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>packlist_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peeled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tagged</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>add_to_write_order</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>wo</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>filled</name></name> <operator>||</operator> <call><name>oe_layer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>write_layer</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>wo</name><index>[<expr><operator>(</operator><operator>*</operator><name>endp</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>filled</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_descendants_to_write_order</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>wo</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>add_to_order</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>add_to_order</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>add_to_write_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <call><name>DELTA_SIBLING</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>s</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <call><name>DELTA_SIBLING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>add_to_write_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DELTA_CHILD</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>add_to_order</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>DELTA_CHILD</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>add_to_order</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DELTA_SIBLING</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>DELTA_SIBLING</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>DELTA_SIBLING</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>DELTA_SIBLING</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_family_to_write_order</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>wo</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>root</name> <operator>=</operator> <name>e</name></expr>;</init> <condition><expr><call><name>DELTA</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>root</name> <operator>=</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for> 
<expr_stmt><expr><call><name>add_descendants_to_write_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compute_layer_order</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>wo</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>wo_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>last_untagged</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>objects</name> <init>= <expr><name><name>to_pack</name><operator>.</operator><name>objects</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tagged</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_to_write_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name>wo_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>last_untagged</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>




<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tagged</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_to_write_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name>wo_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>last_untagged</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OBJ_COMMIT</name> <operator>&amp;&amp;</operator>
<call><name>oe_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_to_write_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name>wo_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>last_untagged</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OBJ_TREE</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_to_write_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name>wo_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>last_untagged</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>filled</name> <operator>&amp;&amp;</operator> <call><name>oe_layer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>write_layer</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_family_to_write_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name>wo_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>compute_write_order</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>max_layers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>wo_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>wo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>objects</name> <init>= <expr><name><name>to_pack</name><operator>.</operator><name>objects</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tagged</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>filled</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_DELTA_CHILD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_DELTA_SIBLING</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>






<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DELTA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>delta_sibling_idx</name></name> <operator>=</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>delta_child_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_DELTA_CHILD</name><argument_list>(<argument><expr><call><name>DELTA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>




<expr_stmt><expr><call><name>for_each_tag_ref</name><argument_list>(<argument><expr><name>mark_tagged</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_delta_islands</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_layers</name> <operator>=</operator> <call><name>compute_pack_layers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wo_end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>write_layer</name> <operator>&lt;</operator> <name>max_layers</name></expr>;</condition> <incr><expr><operator>++</operator><name>write_layer</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>compute_layer_order</name><argument_list>(<argument><expr><name>wo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wo_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>wo_end</name> <operator>!=</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ordered %u objects, expected %"</literal><name>PRIu32</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>wo_end</name></expr></argument>, <argument><expr><name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>wo</name></expr>;</return>
</block_content>}</block></function>








<struct><specifier>static</specifier> struct <name>reused_chunk</name> <block>{


<decl_stmt><decl><type><name>off_t</name></type> <name>original</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>off_t</name></type> <name>difference</name></decl>;</decl_stmt>
}</block> <decl><modifier>*</modifier><name>reused_chunks</name></decl>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>reused_chunks_nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>reused_chunks_alloc</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>record_reused_object</name><parameter_list>(<parameter><decl><type><name>off_t</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reused_chunks_nr</name> <operator>&amp;&amp;</operator> <name><name>reused_chunks</name><index>[<expr><name>reused_chunks_nr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>difference</name> <operator>==</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name>reused_chunks</name></expr></argument>, <argument><expr><name>reused_chunks_nr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>reused_chunks_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reused_chunks</name><index>[<expr><name>reused_chunks_nr</name></expr>]</index></name><operator>.</operator><name>original</name> <operator>=</operator> <name>where</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reused_chunks</name><index>[<expr><name>reused_chunks_nr</name></expr>]</index></name><operator>.</operator><name>difference</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reused_chunks_nr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>off_t</name></type> <name>find_reused_offset</name><parameter_list>(<parameter><decl><type><name>off_t</name></type> <name>where</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>hi</name> <init>= <expr><name>reused_chunks_nr</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mi</name> <init>= <expr><name>lo</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>hi</name> <operator>-</operator> <name>lo</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name><name>reused_chunks</name><index>[<expr><name>mi</name></expr>]</index></name><operator>.</operator><name>original</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>reused_chunks</name><index>[<expr><name>mi</name></expr>]</index></name><operator>.</operator><name>difference</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>where</name> <operator>&lt;</operator> <name><name>reused_chunks</name><index>[<expr><name>mi</name></expr>]</index></name><operator>.</operator><name>original</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mi</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mi</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>





<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>reused_chunks</name><index>[<expr><name>lo</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>difference</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_reused_pack_one</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pack_window</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>w_curs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>next</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>reuse_packfile</name><operator>-&gt;</operator><name>revindex</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>reuse_packfile</name><operator>-&gt;</operator><name>revindex</name><index>[<expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>record_reused_object</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>offset</name> <operator>-</operator> <call><name>hashfile_total</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>unpack_object_header</name><argument_list>(<argument><expr><name>reuse_packfile</name></expr></argument>, <argument><expr><name>w_curs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_OFS_DELTA</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>off_t</name></type> <name>base_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>fixup</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>header</name><index>[<expr><name>MAX_PACK_OBJECT_HEADER</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>base_offset</name> <operator>=</operator> <call><name>get_delta_base</name><argument_list>(<argument><expr><name>reuse_packfile</name></expr></argument>, <argument><expr><name>w_curs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base_offset</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_ofs_delta</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>base_pos</name> <init>= <expr><call><name>find_revindex_position</name><argument_list>(<argument><expr><name>reuse_packfile</name></expr></argument>, <argument><expr><name>base_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>base_oid</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_oid</name></expr></argument>, <argument><expr><name>reuse_packfile</name></expr></argument>,
<argument><expr><name><name>reuse_packfile</name><operator>-&gt;</operator><name>revindex</name><index>[<expr><name>base_pos</name></expr>]</index></name><operator>.</operator><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>encode_in_pack_object_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>OBJ_REF_DELTA</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>base_oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_pack_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>reuse_packfile</name></expr></argument>, <argument><expr><name>w_curs</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>fixup</name> <operator>=</operator> <call><name>find_reused_offset</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>-</operator>
<call><name>find_reused_offset</name><argument_list>(<argument><expr><name>base_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fixup</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ofs_header</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ofs_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>ofs</name> <init>= <expr><name>offset</name> <operator>-</operator> <name>base_offset</name> <operator>-</operator> <name>fixup</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>encode_in_pack_object_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>OBJ_OFS_DELTA</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ofs_header</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ofs_header</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ofs</name> <operator>&amp;</operator> <literal type="number">127</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ofs</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ofs_header</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">128</literal> <operator>|</operator> <operator>(</operator><operator>--</operator><name>ofs</name> <operator>&amp;</operator> <literal type="number">127</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>ofs_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ofs_header</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>ofs_header</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ofs_header</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>ofs_len</name></expr></argument>, <argument><expr><name>ofs_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_pack_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>reuse_packfile</name></expr></argument>, <argument><expr><name>w_curs</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>copy_pack_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>reuse_packfile</name></expr></argument>, <argument><expr><name>w_curs</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>write_reused_pack_verbatim</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pack_window</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>w_curs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>reuse_packfile_bitmap</name><operator>-&gt;</operator><name>word_alloc</name></name> <operator>&amp;&amp;</operator>
<name><name>reuse_packfile_bitmap</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <operator>(</operator><name>eword_t</name><operator>)</operator><operator>~</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>pos</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>off_t</name></type> <name>to_write</name></decl>;</decl_stmt>

<expr_stmt><expr><name>written</name> <operator>=</operator> <operator>(</operator><name>pos</name> <operator>*</operator> <name>BITS_IN_EWORD</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>to_write</name> <operator>=</operator> <name><name>reuse_packfile</name><operator>-&gt;</operator><name>revindex</name><index>[<expr><name>written</name></expr>]</index></name><operator>.</operator><name>offset</name>
<operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pack_header</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>


<expr_stmt><expr><call><name>record_reused_object</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pack_header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashflush</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_pack_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>reuse_packfile</name></expr></argument>, <argument><expr><name>w_curs</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pack_header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>to_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress_state</name></expr></argument>, <argument><expr><name>written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>pos</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_reused_pack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pack_window</name></name> <modifier>*</modifier></type><name>w_curs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>allow_ofs_delta</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>write_reused_pack_verbatim</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>reuse_packfile_bitmap</name><operator>-&gt;</operator><name>word_alloc</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>eword_t</name></type> <name>word</name> <init>= <expr><name><name>reuse_packfile_bitmap</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><operator>(</operator><name>i</name> <operator>*</operator> <name>BITS_IN_EWORD</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>offset</name> <operator>&lt;</operator> <name>BITS_IN_EWORD</name></expr>;</condition> <incr><expr><operator>++</operator><name>offset</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>word</name> <operator>&gt;&gt;</operator> <name>offset</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>ewah_bit_ctz64</name><argument_list>(<argument><expr><name>word</name> <operator>&gt;&gt;</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_reused_pack_one</name><argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress_state</name></expr></argument>, <argument><expr><operator>++</operator><name>written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>no_split_warning</name><index>[]</index></name> <init>= <expr><call><name>N_</name><argument_list>(
<argument><expr><literal type="string">"disabling bitmap writing, packs are split due to pack.packSizeLimit"</literal></expr></argument>
)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_pack_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nr_remaining</name> <init>= <expr><name>nr_result</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>last_mtime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>write_order</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&gt;</operator> <name>pack_to_stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>progress_state</name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Writing objects"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nr_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>written_list</name></expr></argument>, <argument><expr><name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>write_order</name> <operator>=</operator> <call><name>compute_write_order</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pack_tmp_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pack_to_stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>hashfd_throughput</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"&lt;stdout&gt;"</literal></expr></argument>, <argument><expr><name>progress_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>create_tmp_packfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pack_tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>write_pack_header</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>nr_remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>reuse_packfile</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pack_to_stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_reused_pack</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>hashfile_total</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nr_written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>write_order</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>write_one</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>WRITE_ONE_BREAK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress_state</name></expr></argument>, <argument><expr><name>written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>





<if_stmt><if>if <condition>(<expr><name>pack_to_stdout</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>finalize_hashfile</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>CSUM_HASH_IN_STREAM</name> <operator>|</operator> <name>CSUM_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nr_written</name> <operator>==</operator> <name>nr_remaining</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>finalize_hashfile</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>CSUM_HASH_IN_STREAM</name> <operator>|</operator> <name>CSUM_FSYNC</name> <operator>|</operator> <name>CSUM_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>finalize_hashfile</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fixup_pack_header_footer</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>pack_tmp_name</name></expr></argument>,
<argument><expr><name>nr_written</name></expr></argument>, <argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>write_bitmap_index</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>write_bitmap_index</name> <operator>!=</operator> <name>WRITE_BITMAP_QUIET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>no_split_warning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>write_bitmap_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>tmpname</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>pack_tmp_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to stat %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pack_tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>last_mtime</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_mtime</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>utimbuf</name></name></type> <name>utb</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>utb</name><operator>.</operator><name>actime</name></name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_atime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>utb</name><operator>.</operator><name>modtime</name></name> <operator>=</operator> <operator>--</operator><name>last_mtime</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>utime</name><argument_list>(<argument><expr><name>pack_tmp_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>utb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed utime() on %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pack_tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpname</name></expr></argument>, <argument><expr><literal type="string">"%s-"</literal></expr></argument>, <argument><expr><name>base_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>write_bitmap_index</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bitmap_writer_set_checksum</name><argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bitmap_writer_build_type_index</name><argument_list>(
<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>written_list</name></expr></argument>, <argument><expr><name>nr_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>finish_tmp_packfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpname</name></expr></argument>, <argument><expr><name>pack_tmp_name</name></expr></argument>,
<argument><expr><name>written_list</name></expr></argument>, <argument><expr><name>nr_written</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>pack_idx_opts</name></expr></argument>, <argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>write_bitmap_index</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpname</name></expr></argument>, <argument><expr><literal type="string">"%s.bitmap"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bitmap_writer_show_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bitmap_writer_reuse_bitmaps</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bitmap_writer_select_commits</name><argument_list>(<argument><expr><name>indexed_commits</name></expr></argument>, <argument><expr><name>indexed_commits_nr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bitmap_writer_build</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bitmap_writer_finish</name><argument_list>(<argument><expr><name>written_list</name></expr></argument>, <argument><expr><name>nr_written</name></expr></argument>,
<argument><expr><name><name>tmpname</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>write_bitmap_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>write_bitmap_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pack_tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nr_written</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>written_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>offset</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>nr_remaining</name> <operator>-=</operator> <name>nr_written</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>nr_remaining</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>written_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>write_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <name>nr_result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrote %"</literal><name>PRIu32</name><literal type="string">" objects while expecting %"</literal><name>PRIu32</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>written</name></expr></argument>, <argument><expr><name>nr_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>trace2_data_intmax</name><argument_list>(<argument><expr><literal type="string">"pack-objects"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><literal type="string">"write_pack_file/wrote"</literal></expr></argument>, <argument><expr><name>nr_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>no_try_delta</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>attr_check</name></name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>check</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>check</name> <operator>=</operator> <call><name>attr_check_initl</name><argument_list>(<argument><expr><literal type="string">"delta"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>git_check_attr</name><argument_list>(<argument><expr><name><name>the_repository</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ATTR_FALSE</name><argument_list>(<argument><expr><name><name>check</name><operator>-&gt;</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>have_duplicate_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reuse_packfile_bitmap</name> <operator>&amp;&amp;</operator>
<call><name>bitmap_walk_contains</name><argument_list>(<argument><expr><name>bitmap_git</name></expr></argument>, <argument><expr><name>reuse_packfile_bitmap</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>packlist_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exclude</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr_result</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>preferred_base</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>want_found_object</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>exclude</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>incremental</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>















<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_packed_keep_on_disk</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ignore_packed_keep_in_core</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><name>local</name> <operator>||</operator> <operator>!</operator><name>have_non_local_packs</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>local</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pack_local</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pack_local</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name>ignore_packed_keep_on_disk</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_keep</name></name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>ignore_packed_keep_in_core</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_keep_in_core</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type> <name>want_object_in_pack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>found_pack</name></decl></parameter>,
<parameter><decl><type><name>off_t</name> <modifier>*</modifier></type><name>found_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>want</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exclude</name> <operator>&amp;&amp;</operator> <name>local</name> <operator>&amp;&amp;</operator> <call><name>has_loose_object_nonlocal</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>*</operator><name>found_pack</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>want</name> <operator>=</operator> <call><name>want_found_object</name><argument_list>(<argument><expr><name>exclude</name></expr></argument>, <argument><expr><operator>*</operator><name>found_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>want</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>want</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <call><name>get_multi_pack_index</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>m</name></expr>;</condition> <incr><expr><name>m</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pack_entry</name></name></type> <name>e</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fill_midx_entry</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>e</name><operator>.</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <operator>*</operator><name>found_pack</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>*</operator><name>found_offset</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>find_pack_entry_one</name><argument_list>(<argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>found_pack</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_pack_valid</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>found_offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>found_pack</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>want</name> <operator>=</operator> <call><name>want_found_object</name><argument_list>(<argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>want</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>want</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<macro><name>list_for_each</name><argument_list>(<argument>pos</argument>, <argument>get_packed_git_mru(the_repository)</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>list_entry</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr>struct <name>packed_git</name></expr></argument>, <argument><expr><name>mru</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <operator>*</operator><name>found_pack</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>*</operator><name>found_offset</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>find_pack_entry_one</name><argument_list>(<argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>found_pack</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_pack_valid</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>found_offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>found_pack</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>want</name> <operator>=</operator> <call><name>want_found_object</name><argument_list>(<argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exclude</name> <operator>&amp;&amp;</operator> <name>want</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>list_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>mru</name></name></expr></argument>,
<argument><expr><call><name>get_packed_git_mru</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>want</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>want</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_object_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>hash</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>no_try_delta</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>found_pack</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>found_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>packlist_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oe_set_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>exclude</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>preferred_base</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>nr_result</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_pack</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oe_set_in_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>found_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name> <operator>=</operator> <name>found_offset</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>no_try_delta</name></name> <operator>=</operator> <name>no_try_delta</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>no_closure_warning</name><index>[]</index></name> <init>= <expr><call><name>N_</name><argument_list>(
<argument><expr><literal type="string">"disabling bitmap writing, as some objects are not being packed"</literal></expr></argument>
)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_object_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>found_pack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>found_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress_state</name></expr></argument>, <argument><expr><operator>++</operator><name>nr_seen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>have_duplicate_entry</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>want_object_in_pack</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_pack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_offset</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>write_bitmap_index</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>write_bitmap_index</name> <operator>!=</operator> <name>WRITE_BITMAP_QUIET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>no_closure_warning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>write_bitmap_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>create_object_entry</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>pack_name_hash</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>name</name> <operator>&amp;&amp;</operator> <call><name>no_try_delta</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>found_pack</name></expr></argument>, <argument><expr><name>found_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_object_entry_from_bitmap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>name_hash</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>pack</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress_state</name></expr></argument>, <argument><expr><operator>++</operator><name>nr_seen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>have_duplicate_entry</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>want_object_in_pack</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>create_object_entry</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pack</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>pbase_tree_cache</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temporary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>tree_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>tree_size</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>pbase_tree_cache</name></name> <modifier>*</modifier></type>(<name>pbase_tree_cache</name>[256]</function_decl>)<empty_stmt>;</empty_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pbase_tree_cache_ix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>%</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>pbase_tree_cache</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pbase_tree_cache_ix_incr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>ix</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>pbase_tree_cache</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct <name>pbase_tree</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>pbase_tree</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name><name>struct</name> <name>pbase_tree_cache</name></name></type> <name>pcache</name></decl>;</decl_stmt>
}</block> <decl><modifier>*</modifier><name>pbase_tree</name></decl>;</struct>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>pbase_tree_cache</name></name> <modifier>*</modifier></type><name>pbase_tree_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pbase_tree_cache</name></name> <modifier>*</modifier></type><name>ent</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>neigh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>my_ix</name> <init>= <expr><call><name>pbase_tree_cache_ix</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>available_ix</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>





<for>for <control>(<init><expr><name>neigh</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>neigh</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>neigh</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ent</name> <operator>=</operator> <name><name>pbase_tree_cache</name><index>[<expr><name>my_ix</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ent</name> <operator>&amp;&amp;</operator> <call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>ref</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>ent</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>available_ix</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>ent</name> <operator>||</operator> <operator>!</operator><name><name>ent</name><operator>-&gt;</operator><name>ref</name></name><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><literal type="number">0</literal> <operator>&lt;=</operator> <name>available_ix</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><name>ent</name> <operator>&amp;&amp;</operator> <name><name>pbase_tree_cache</name><index>[<expr><name>available_ix</name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>available_ix</name> <operator>=</operator> <name>my_ix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>my_ix</name> <operator>=</operator> <call><name>pbase_tree_cache_ix_incr</name><argument_list>(<argument><expr><name>my_ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>




<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_TREE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>available_ix</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ent</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ent</name> <operator>=</operator> <name><name>pbase_tree_cache</name><index>[<expr><name>available_ix</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>my_ix</name> <operator>=</operator> <name>available_ix</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nent</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nent</name><operator>-&gt;</operator><name>temporary</name></name> <operator>=</operator> <operator>(</operator><name>available_ix</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>tree_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nent</name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nent</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nent</name><operator>-&gt;</operator><name>tree_data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nent</name><operator>-&gt;</operator><name>tree_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nent</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nent</name><operator>-&gt;</operator><name>temporary</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pbase_tree_cache</name><index>[<expr><name>my_ix</name></expr>]</index></name> <operator>=</operator> <name>nent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>nent</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pbase_tree_put</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pbase_tree_cache</name></name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cache</name><operator>-&gt;</operator><name>temporary</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>ref</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>tree_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>name_cmp_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_pbase_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_desc</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>cmplen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fullname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>name_entry</name></name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>tree_entry</name><argument_list>(<argument><expr><name>tree</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <ternary><condition><expr><call><name>tree_entry_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cmplen</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>:
<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name>cmplen</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>cmplen</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_object_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><call><name>object_type</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fullname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_desc</name></name></type> <name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pbase_tree_cache</name></name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>down</name> <init>= <expr><name>name</name><operator>+</operator><name>cmplen</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>downlen</name> <init>= <expr><call><name>name_cmp_len</name><argument_list>(<argument><expr><name>down</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tree</name> <operator>=</operator> <call><name>pbase_tree_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tree</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>init_tree_desc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>, <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>tree_data</name></name></expr></argument>, <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>tree_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_pbase_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>, <argument><expr><name>down</name></expr></argument>, <argument><expr><name>downlen</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pbase_tree_put</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <modifier>*</modifier></type><name>done_pbase_paths</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>done_pbase_paths_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>done_pbase_paths_alloc</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>done_pbase_path_pos</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hi</name> <init>= <expr><name>done_pbase_paths_num</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mi</name> <init>= <expr><name>lo</name> <operator>+</operator> <operator>(</operator><name>hi</name> <operator>-</operator> <name>lo</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>done_pbase_paths</name><index>[<expr><name>mi</name></expr>]</index></name> <operator>==</operator> <name>hash</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>mi</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>done_pbase_paths</name><index>[<expr><name>mi</name></expr>]</index></name> <operator>&lt;</operator> <name>hash</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mi</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mi</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>-</operator><name>lo</name><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_pbase_path</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>done_pbase_path_pos</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name>done_pbase_paths</name></expr></argument>,
<argument><expr><name>done_pbase_paths_num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>done_pbase_paths_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>done_pbase_paths_num</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>done_pbase_paths_num</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MOVE_ARRAY</name><argument_list>(<argument><expr><name>done_pbase_paths</name> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>done_pbase_paths</name> <operator>+</operator> <name>pos</name></expr></argument>,
<argument><expr><name>done_pbase_paths_num</name> <operator>-</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>done_pbase_paths</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_preferred_base_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pbase_tree</name></name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmplen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>hash</name> <init>= <expr><call><name>pack_name_hash</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num_preferred_base</name> <operator>||</operator> <call><name>check_pbase_path</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cmplen</name> <operator>=</operator> <call><name>name_cmp_len</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>it</name> <operator>=</operator> <name>pbase_tree</name></expr>;</init> <condition><expr><name>it</name></expr>;</condition> <incr><expr><name>it</name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cmplen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_object_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>pcache</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>OBJ_TREE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_desc</name></name></type> <name>tree</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>init_tree_desc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>pcache</name><operator>.</operator><name>tree_data</name></name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>pcache</name><operator>.</operator><name>tree_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_pbase_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>cmplen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_preferred_base</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pbase_tree</name></name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>tree_oid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>window</name> <operator>&lt;=</operator> <name>num_preferred_base</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>read_object_with_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>,
<argument><expr><name>tree_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>it</name> <operator>=</operator> <name>pbase_tree</name></expr>;</init> <condition><expr><name>it</name></expr>;</condition> <incr><expr><name>it</name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>pcache</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>pbase_tree</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pbase_tree</name> <operator>=</operator> <name>it</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>pcache</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>pcache</name><operator>.</operator><name>tree_data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>pcache</name><operator>.</operator><name>tree_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_preferred_base</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pbase_tree</name></name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <name>pbase_tree</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pbase_tree</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>it</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pbase_tree</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>it</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>it</name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>pcache</name><operator>.</operator><name>tree_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>pbase_tree_cache</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pbase_tree_cache</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pbase_tree_cache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tree_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>pbase_tree_cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name>done_pbase_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>done_pbase_paths_num</name> <operator>=</operator> <name>done_pbase_paths_alloc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>int</name></type> <name>can_reuse_delta</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>base_oid</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>delta</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>base_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>





<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>packlist_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>base_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_same_island</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>delta</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>base_out</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name>thin</name> <operator>&amp;&amp;</operator> <call><name>bitmap_has_oid_in_uninteresting</name><argument_list>(<argument><expr><name>bitmap_git</name></expr></argument>, <argument><expr><name>base_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>use_delta_islands</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_same_island</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>delta</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>base_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>base_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>canonical_size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IN_PACK</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>IN_PACK</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pack_window</name></name> <modifier>*</modifier></type><name>w_curs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>have_base</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>base_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>base_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>used</name></decl>, <decl><type ref="prev"/><name>used_0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>avail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>ofs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>in_pack_size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>use_pack</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>used</name> <operator>=</operator> <call><name>unpack_object_header_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>in_pack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>used</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>give_up</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"invalid type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>






<switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_type</name></name></expr>)</condition> <block>{<block_content>
<default>default:</default>

<expr_stmt><expr><call><name>oe_set_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>in_pack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_header_size</name></name> <operator>=</operator> <name>used</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>OBJ_COMMIT</name> <operator>||</operator> <call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>OBJ_BLOB</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>give_up</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>OBJ_REF_DELTA</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>reuse_delta</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_ref</name></expr></argument>,
<argument><expr><call><name>use_pack</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name> <operator>+</operator> <name>used</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>have_base</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_header_size</name></name> <operator>=</operator> <name>used</name> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>OBJ_OFS_DELTA</name></expr>:</case>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>use_pack</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name> <operator>+</operator> <name>used</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>used_0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>used_0</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ofs</name> <operator>=</operator> <name>c</name> <operator>&amp;</operator> <literal type="number">127</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">128</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ofs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ofs</name> <operator>||</operator> <call><name>MSB</name><argument_list>(<argument><expr><name>ofs</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"delta base offset overflow in pack for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>give_up</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>used_0</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ofs</name> <operator>=</operator> <operator>(</operator><name>ofs</name> <operator>&lt;&lt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">127</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>ofs</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name> <operator>-</operator> <name>ofs</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ofs</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ofs</name> <operator>&gt;=</operator> <name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"delta base offset out of bound for %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>give_up</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reuse_delta</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>revindex_entry</name></name> <modifier>*</modifier></type><name>revidx</name></decl>;</decl_stmt>
<expr_stmt><expr><name>revidx</name> <operator>=</operator> <call><name>find_pack_revindex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>revidx</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>give_up</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_ref</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>revidx</name><operator>-&gt;</operator><name>nr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>have_base</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_header_size</name></name> <operator>=</operator> <name>used</name> <operator>+</operator> <name>used_0</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>have_base</name> <operator>&amp;&amp;</operator>
<call><name>can_reuse_delta</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_ref</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oe_set_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>in_pack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>SET_DELTA_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>in_pack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>base_entry</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>base_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>delta_sibling_idx</name></name> <operator>=</operator> <name><name>base_entry</name><operator>-&gt;</operator><name>delta_child_idx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_DELTA_CHILD</name><argument_list>(<argument><expr><name>base_entry</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>SET_DELTA_EXT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>off_t</name></type> <name>delta_pos</name></decl>;</decl_stmt>






<expr_stmt><expr><name>delta_pos</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>in_pack_header_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>canonical_size</name> <operator>=</operator> <call><name>get_size_from_delta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>, <argument><expr><name>delta_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>canonical_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>give_up</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>SET_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>canonical_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>






<label><name>give_up</name>:</label>
<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>oe_set_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,
<argument><expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>canonical_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>canonical_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>






</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pack_offset_sort</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>object_entry</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>object_entry</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>a_in_pack</name> <init>= <expr><call><name>IN_PACK</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>b_in_pack</name> <init>= <expr><call><name>IN_PACK</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a_in_pack</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>b_in_pack</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>oidcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>a_in_pack</name> <operator>&lt;</operator> <name>b_in_pack</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a_in_pack</name> <operator>&gt;</operator> <name>b_in_pack</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>in_pack_offset</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>in_pack_offset</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
<expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>in_pack_offset</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>in_pack_offset</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>void</name></type> <name>drop_reused_delta</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>idx</name> <init>= <expr><operator>&amp;</operator><name><name>to_pack</name><operator>.</operator><name>objects</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>delta_idx</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>delta_child_idx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_info</name></name></type> <name>oi</name> <init>= <expr><name>OBJECT_INFO_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>idx</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><operator>&amp;</operator><name><name>to_pack</name><operator>.</operator><name>objects</name><index>[<expr><operator>*</operator><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>oe</name> <operator>==</operator> <name>entry</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>idx</name> <operator>=</operator> <name><name>oe</name><operator>-&gt;</operator><name>delta_sibling_idx</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>delta_sibling_idx</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>SET_DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>sizep</name></name> <operator>=</operator> <operator>&amp;</operator><name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oi</name><operator>.</operator><name>typep</name></name> <operator>=</operator> <operator>&amp;</operator><name>type</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>packed_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><call><name>IN_PACK</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>in_pack_offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oi</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>oe_set_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,
<argument><expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>oe_set_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>SET_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>break_delta_chains</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>






<decl_stmt><decl><type><name>uint32_t</name></type> <name>total_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>cur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>entry</name></expr><operator>,</operator> <expr><name>total_depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
<condition><expr><name>cur</name></expr>;</condition>
<incr><expr><name>cur</name> <operator>=</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>total_depth</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name> <operator>==</operator> <name>DFS_DONE</name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name>total_depth</name> <operator>+=</operator> <name><name>cur</name><operator>-&gt;</operator><name>depth</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name> <operator>!=</operator> <name>DFS_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"confusing delta dfs state in first pass: %d"</literal></expr></argument>,
<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DELTA</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name> <operator>=</operator> <name>DFS_DONE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


















<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name> <operator>=</operator> <name>DFS_ACTIVE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>dfs_state</name> <operator>==</operator> <name>DFS_ACTIVE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>drop_reused_delta</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name> <operator>=</operator> <name>DFS_DONE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>








<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>entry</name></expr>;</init> <condition><expr><name>cur</name></expr>;</condition> <incr><expr><name>cur</name> <operator>=</operator> <name>next</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>DELTA</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name> <operator>==</operator> <name>DFS_DONE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name> <operator>!=</operator> <name>DFS_ACTIVE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"confusing delta dfs state in second pass: %d"</literal></expr></argument>,
<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



















<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <operator>(</operator><name>total_depth</name><operator>--</operator><operator>)</operator> <operator>%</operator> <operator>(</operator><name>depth</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur</name><operator>-&gt;</operator><name>depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>drop_reused_delta</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>dfs_state</name></name> <operator>=</operator> <name>DFS_DONE</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_object_details</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>sorted_by_offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>progress_state</name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Counting objects"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sorted_by_offset</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>object_entry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sorted_by_offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>to_pack</name><operator>.</operator><name>objects</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name>sorted_by_offset</name></expr></argument>, <argument><expr><name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr></argument>, <argument><expr><name>pack_offset_sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>sorted_by_offset</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_object</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type_valid</name></name> <operator>&amp;&amp;</operator>
<call><name>oe_size_greater_than</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>big_file_threshold</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>no_try_delta</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress_state</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>break_delta_chains</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to_pack</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sorted_by_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type> <name>type_size_sort</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>object_entry</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>object_entry</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>object_type</name></name></type> <name>a_type</name> <init>= <expr><call><name>oe_type</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>object_type</name></name></type> <name>b_type</name> <init>= <expr><call><name>oe_type</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>long</name></type> <name>a_size</name> <init>= <expr><call><name>SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>long</name></type> <name>b_size</name> <init>= <expr><call><name>SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>a_type</name> <operator>&gt;</operator> <name>b_type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a_type</name> <operator>&lt;</operator> <name>b_type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>hash</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>hash</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>hash</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>hash</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>preferred_base</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>preferred_base</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>use_delta_islands</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>island_cmp</name> <init>= <expr><call><name>island_delta_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>island_cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>island_cmp</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a_size</name> <operator>&gt;</operator> <name>b_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a_size</name> <operator>&lt;</operator> <name>b_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>a</name> <operator>&gt;</operator> <name>b</name><operator>)</operator></expr></else></ternary></expr>;</return> 
</block_content>}</block></function>

<struct>struct <name>unpacked</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>delta_index</name></name> <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>depth</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>delta_cacheable</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>src_size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>trg_size</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>delta_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>max_delta_cache_size</name> <operator>&amp;&amp;</operator> <name>delta_cache_size</name> <operator>+</operator> <name>delta_size</name> <operator>&gt;</operator> <name>max_delta_cache_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>delta_size</name> <operator>&lt;</operator> <name>cache_max_small_delta_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>src_size</name> <operator>&gt;&gt;</operator> <literal type="number">20</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>trg_size</name> <operator>&gt;&gt;</operator> <literal type="number">21</literal><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>delta_size</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>cache_mutex</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cache_lock</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>pthread_mutex_lock(&amp;cache_mutex)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cache_unlock</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>pthread_mutex_unlock(&amp;cache_mutex)</cpp:value></cpp:define>





<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>progress_mutex</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>progress_lock</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>pthread_mutex_lock(&amp;progress_mutex)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>progress_unlock</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>pthread_mutex_unlock(&amp;progress_mutex)</cpp:value></cpp:define>













<function><type><name>unsigned</name> <name>long</name></type> <name>oe_get_size_slow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>packing_data</name></name> <modifier>*</modifier></type><name>pack</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pack_window</name></name> <modifier>*</modifier></type><name>w_curs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>used</name></decl>, <decl><type ref="prev"/><name>avail</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>type_</name></name> <operator>!=</operator> <name>OBJ_OFS_DELTA</name> <operator>&amp;&amp;</operator> <name><name>e</name><operator>-&gt;</operator><name>type_</name></name> <operator>!=</operator> <name>OBJ_REF_DELTA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>packing_data_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to get size of %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>packing_data_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>oe_in_pack</name><argument_list>(<argument><expr><name>pack</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"when e-&gt;type is a delta, it must belong to a pack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>packing_data_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>w_curs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>use_pack</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>in_pack_offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>used</name> <operator>=</operator> <call><name>unpack_object_header_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>used</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to parse object header of %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>unuse_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w_curs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>packing_data_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>try_delta</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>unpacked</name></name> <modifier>*</modifier></type><name>trg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>unpacked</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>max_depth</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>mem_usage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>trg_entry</name> <init>= <expr><name><name>trg</name><operator>-&gt;</operator><name>entry</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>src_entry</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>entry</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>trg_size</name></decl>, <decl><type ref="prev"/><name>src_size</name></decl>, <decl><type ref="prev"/><name>delta_size</name></decl>, <decl><type ref="prev"/><name>sizediff</name></decl>, <decl><type ref="prev"/><name>max_size</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ref_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>delta_buf</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>oe_type</name><argument_list>(<argument><expr><name>src_entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>









<if_stmt><if>if <condition>(<expr><name>reuse_delta</name> <operator>&amp;&amp;</operator> <call><name>IN_PACK</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>IN_PACK</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>IN_PACK</name><argument_list>(<argument><expr><name>src_entry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>src_entry</name><operator>-&gt;</operator><name>preferred_base</name></name> <operator>&amp;&amp;</operator>
<name><name>trg_entry</name><operator>-&gt;</operator><name>in_pack_type</name></name> <operator>!=</operator> <name>OBJ_REF_DELTA</name> <operator>&amp;&amp;</operator>
<name><name>trg_entry</name><operator>-&gt;</operator><name>in_pack_type</name></name> <operator>!=</operator> <name>OBJ_OFS_DELTA</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>depth</name></name> <operator>&gt;=</operator> <name>max_depth</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>trg_size</name> <operator>=</operator> <call><name>SIZE</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DELTA</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max_size</name> <operator>=</operator> <name>trg_size</name><operator>/</operator><literal type="number">2</literal> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ref_depth</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>max_size</name> <operator>=</operator> <call><name>DELTA_SIZE</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ref_depth</name> <operator>=</operator> <name><name>trg</name><operator>-&gt;</operator><name>depth</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>max_size</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>max_size</name> <operator>*</operator> <operator>(</operator><name>max_depth</name> <operator>-</operator> <name><name>src</name><operator>-&gt;</operator><name>depth</name></name><operator>)</operator> <operator>/</operator>
<operator>(</operator><name>max_depth</name> <operator>-</operator> <name>ref_depth</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>max_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>src_size</name> <operator>=</operator> <call><name>SIZE</name><argument_list>(<argument><expr><name>src_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sizediff</name> <operator>=</operator> <ternary><condition><expr><name>src_size</name> <operator>&lt;</operator> <name>trg_size</name></expr> ?</condition><then> <expr><name>trg_size</name> <operator>-</operator> <name>src_size</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sizediff</name> <operator>&gt;=</operator> <name>max_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>trg_size</name> <operator>&lt;</operator> <name>src_size</name> <operator>/</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_same_island</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trg</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trg</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>packing_data_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trg</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trg_entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>packing_data_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trg</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"object %s cannot be read"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trg_entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>!=</operator> <name>trg_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"object %s inconsistent object length (%"</literal><name>PRIuMAX</name><literal type="string">" vs %"</literal><name>PRIuMAX</name><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trg_entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>sz</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>trg_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>mem_usage</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>src</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>packing_data_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src_entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>packing_data_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>src</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>src_entry</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>warned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>warned</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"object %s cannot be read"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src_entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"object %s cannot be read"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src_entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>!=</operator> <name>src_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"object %s inconsistent object length (%"</literal><name>PRIuMAX</name><literal type="string">" vs %"</literal><name>PRIuMAX</name><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src_entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>sz</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>mem_usage</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>src</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <call><name>create_delta_index</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>src_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>src</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>warned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>warned</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"suboptimal pack - out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>mem_usage</name> <operator>+=</operator> <call><name>sizeof_delta_index</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>delta_buf</name> <operator>=</operator> <call><name>create_delta</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>trg</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>trg_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>delta_size</name></expr></argument>, <argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>delta_buf</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>delta_size</name> <operator>==</operator> <call><name>DELTA_SIZE</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>src</name><operator>-&gt;</operator><name>depth</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>trg</name><operator>-&gt;</operator><name>depth</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>delta_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>trg_entry</name><operator>-&gt;</operator><name>delta_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cache_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>trg_entry</name><operator>-&gt;</operator><name>delta_data</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>delta_cache_size</name> <operator>-=</operator> <call><name>DELTA_SIZE</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trg_entry</name><operator>-&gt;</operator><name>delta_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>delta_cacheable</name><argument_list>(<argument><expr><name>src_size</name></expr></argument>, <argument><expr><name>trg_size</name></expr></argument>, <argument><expr><name>delta_size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>delta_cache_size</name> <operator>+=</operator> <name>delta_size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cache_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trg_entry</name><operator>-&gt;</operator><name>delta_data</name></name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(<argument><expr><name>delta_buf</name></expr></argument>, <argument><expr><name>delta_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>cache_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>delta_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>SET_DELTA</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>, <argument><expr><name>src_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_DELTA_SIZE</name><argument_list>(<argument><expr><name>trg_entry</name></expr></argument>, <argument><expr><name>delta_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trg</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>check_delta_limit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>DELTA_CHILD</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>m</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><call><name>check_delta_limit</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>DELTA_SIBLING</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>free_unpacked</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>unpacked</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>freed_mem</name> <init>= <expr><call><name>sizeof_delta_index</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free_delta_index</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>freed_mem</name> <operator>+=</operator> <call><name>SIZE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>freed_mem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_deltas</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>list_size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>window</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>unpacked</name></name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>mem_usage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>unpacked</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>unpacked</name></name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>array</name> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>max_depth</name></decl>, <decl><type ref="prev"/><name>best_base</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>progress_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>list_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>progress_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>*</operator><name>list</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>list_size</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>processed</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress_state</name></expr></argument>, <argument><expr><operator>*</operator><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>progress_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_usage</name> <operator>-=</operator> <call><name>free_unpacked</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>window_memory_limit</name> <operator>&amp;&amp;</operator>
<name>mem_usage</name> <operator>&gt;</operator> <name>window_memory_limit</name> <operator>&amp;&amp;</operator>
<name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>tail</name> <init>= <expr><operator>(</operator><name>idx</name> <operator>+</operator> <name>window</name> <operator>-</operator> <name>count</name><operator>)</operator> <operator>%</operator> <name>window</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>mem_usage</name> <operator>-=</operator> <call><name>free_unpacked</name><argument_list>(<argument><expr><name>array</name> <operator>+</operator> <name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>




<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>






<expr_stmt><expr><name>max_depth</name> <operator>=</operator> <name>depth</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DELTA_CHILD</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max_depth</name> <operator>-=</operator> <call><name>check_delta_limit</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <name>window</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>--</operator><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>other_idx</name> <init>= <expr><name>idx</name> <operator>+</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>unpacked</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>other_idx</name> <operator>&gt;=</operator> <name>window</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>other_idx</name> <operator>-=</operator> <name>window</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>m</name> <operator>=</operator> <name>array</name> <operator>+</operator> <name>other_idx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>m</name><operator>-&gt;</operator><name>entry</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_delta</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>max_depth</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem_usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>best_base</name> <operator>=</operator> <name>other_idx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>















<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>delta_data</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pack_to_stdout</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>do_compress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>delta_data</name></name></expr></argument>, <argument><expr><call><name>DELTA_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>OE_Z_DELTA_BITS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>z_delta_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cache_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>delta_cache_size</name> <operator>-=</operator> <call><name>DELTA_SIZE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>delta_cache_size</name> <operator>+=</operator> <name><name>entry</name><operator>-&gt;</operator><name>z_delta_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cache_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>delta_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>z_delta_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>max_depth</name> <operator>&lt;=</operator> <name><name>n</name><operator>-&gt;</operator><name>depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>unpacked</name></name></type> <name>swap</name> <init>= <expr><name><name>array</name><index>[<expr><name>best_base</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dist</name> <init>= <expr><operator>(</operator><name>window</name> <operator>+</operator> <name>idx</name> <operator>-</operator> <name>best_base</name><operator>)</operator> <operator>%</operator> <name>window</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dst</name> <init>= <expr><name>best_base</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>dist</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>src</name> <init>= <expr><operator>(</operator><name>dst</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>window</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>array</name><index>[<expr><name>dst</name></expr>]</index></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>src</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>array</name><index>[<expr><name>dst</name></expr>]</index></name> <operator>=</operator> <name>swap</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>next</name>:</label>
<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>window</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>window</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>window</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>free_delta_index</name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

















<struct>struct <name>thread_params</name> <block>{
<decl_stmt><decl><type><name>pthread_t</name></type> <name>thread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>list_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>remaining</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>window</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>working</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>data_ready</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>mutex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pthread_cond_t</name></type> <name>cond</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>processed</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_cond_t</name></type> <name>progress_cond</name></decl>;</decl_stmt>




<function><type><specifier>static</specifier> <name>void</name></type> <name>init_threaded_search</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cache_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_cond</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_threaded_search</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cache_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>threaded_find_deltas</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>thread_params</name></name> <modifier>*</modifier></type><name>me</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>progress_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>remaining</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>progress_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_deltas</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>me</name><operator>-&gt;</operator><name>remaining</name></name></expr></argument>,
<argument><expr><name><name>me</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>depth</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>progress_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>me</name><operator>-&gt;</operator><name>working</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>progress_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>me</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name><name>me</name><operator>-&gt;</operator><name>data_ready</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>me</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>me</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>me</name><operator>-&gt;</operator><name>data_ready</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>me</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>progress_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>progress_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ll_find_deltas</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>list_size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>window</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>thread_params</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>active_threads</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_threaded_search</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>delta_search_threads</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>find_deltas</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list_size</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_threaded_search</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&gt;</operator> <name>pack_to_stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Delta compression using up to %d threads"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>delta_search_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>delta_search_threads</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>delta_search_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>sub_size</name> <init>= <expr><name>list_size</name> <operator>/</operator> <operator>(</operator><name>delta_search_threads</name> <operator>-</operator> <name>i</name><operator>)</operator></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>sub_size</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>window</name> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>delta_search_threads</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sub_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>window</name> <operator>=</operator> <name>window</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>depth</name> <operator>=</operator> <name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>processed</name> <operator>=</operator> <name>processed</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>working</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data_ready</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<while>while <condition>(<expr><name>sub_size</name> <operator>&amp;&amp;</operator> <name>sub_size</name> <operator>&lt;</operator> <name>list_size</name> <operator>&amp;&amp;</operator>
<name><name>list</name><index>[<expr><name>sub_size</name></expr>]</index></name><operator>-&gt;</operator><name>hash</name> <operator>&amp;&amp;</operator>
<name><name>list</name><index>[<expr><name>sub_size</name></expr>]</index></name><operator>-&gt;</operator><name>hash</name> <operator>==</operator> <name><name>list</name><index>[<expr><name>sub_size</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>hash</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sub_size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>list</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>list_size</name> <operator>=</operator> <name>sub_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>remaining</name> <operator>=</operator> <name>sub_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>+=</operator> <name>sub_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>list_size</name> <operator>-=</operator> <name>sub_size</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>delta_search_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>list_size</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cond</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>threaded_find_deltas</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to create thread: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>active_threads</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>









<while>while <condition>(<expr><name>active_threads</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>thread_params</name></name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>thread_params</name></name> <modifier>*</modifier></type><name>victim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>sub_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>progress_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name>target</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>delta_search_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>working</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_cond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>progress_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>delta_search_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>remaining</name> <operator>&gt;</operator> <literal type="number">2</literal><operator>*</operator><name>window</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><name>victim</name> <operator>||</operator> <name><name>victim</name><operator>-&gt;</operator><name>remaining</name></name> <operator>&lt;</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>remaining</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>victim</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>victim</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sub_size</name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>remaining</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>list</name></name> <operator>+</operator> <name><name>victim</name><operator>-&gt;</operator><name>list_size</name></name> <operator>-</operator> <name>sub_size</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>sub_size</name> <operator>&amp;&amp;</operator> <name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>hash</name> <operator>&amp;&amp;</operator>
<name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>hash</name> <operator>==</operator> <name><name>list</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>hash</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>list</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sub_size</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub_size</name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><name>sub_size</name> <operator>=</operator> <name><name>victim</name><operator>-&gt;</operator><name>remaining</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> <operator>-=</operator> <name>sub_size</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>list_size</name></name> <operator>-=</operator> <name>sub_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>victim</name><operator>-&gt;</operator><name>remaining</name></name> <operator>-=</operator> <name>sub_size</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>list_size</name></name> <operator>=</operator> <name>sub_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>remaining</name></name> <operator>=</operator> <name>sub_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>working</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>progress_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>data_ready</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>active_threads</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>cleanup_threaded_search</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>obj_is_packed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>packlist_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><name>reuse_packfile_bitmap</name> <operator>&amp;&amp;</operator>
<call><name>bitmap_walk_contains</name><argument_list>(<argument><expr><name>bitmap_git</name></expr></argument>, <argument><expr><name>reuse_packfile_bitmap</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_tag_chain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><call><name>obj_is_packed</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>lookup_tag</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tag</name> <operator>||</operator> <call><name>parse_tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>tag</name><operator>-&gt;</operator><name>tagged</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to pack objects reachable from tag %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_object_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tag</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>OBJ_TAG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tag</name><operator>-&gt;</operator><name>tagged</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tag</name> <operator>=</operator> <operator>(</operator>struct <name>tag</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>tagged</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_ref_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>peeled</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> 
<operator>!</operator><call><name>peel_ref</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peeled</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> 
<call><name>obj_is_packed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peeled</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><call><name>add_tag_chain</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>prepare_pack</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>window</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>delta_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nr_deltas</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>use_delta_islands</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>resolve_tree_islands</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>get_object_details</name><argument_list>()</argument_list></call></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>do_check_packed_object_crc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name> <operator>||</operator> <operator>!</operator><name>window</name> <operator>||</operator> <operator>!</operator><name>depth</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>delta_list</name></expr></argument>, <argument><expr><name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nr_deltas</name> <operator>=</operator> <name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_pack</name><operator>.</operator><name>nr_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>to_pack</name><operator>.</operator><name>objects</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DELTA</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>



<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>type_valid</name></name> <operator>||</operator>
<call><name>oe_size_less_than</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>no_try_delta</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>preferred_base</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nr_deltas</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to get type of object %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>oe_type</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>delta_list</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>nr_deltas</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>nr_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>progress_state</name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Compressing objects"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>nr_deltas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name>delta_list</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>type_size_sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ll_find_deltas</name><argument_list>(<argument><expr><name>delta_list</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>window</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nr_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nr_done</name> <operator>!=</operator> <name>nr_deltas</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"inconsistency with delta count"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>delta_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>git_pack_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.window"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>window</name> <operator>=</operator> <call><name>git_config_int</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.windowmemory"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>window_memory_limit</name> <operator>=</operator> <call><name>git_config_ulong</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.depth"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>depth</name> <operator>=</operator> <call><name>git_config_int</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.deltacachesize"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max_delta_cache_size</name> <operator>=</operator> <call><name>git_config_int</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.deltacachelimit"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cache_max_small_delta_size</name> <operator>=</operator> <call><name>git_config_int</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.writebitmaphashcache"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>git_config_bool</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>write_bitmap_options</name> <operator>|=</operator> <name>BITMAP_OPT_HASH_CACHE</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>write_bitmap_options</name> <operator>&amp;=</operator> <operator>~</operator><name>BITMAP_OPT_HASH_CACHE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.usebitmaps"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_bitmap_index_default</name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.allowpackreuse"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>allow_pack_reuse</name> <operator>=</operator> <call><name>git_config_bool</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.threads"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>delta_search_threads</name> <operator>=</operator> <call><name>git_config_int</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>delta_search_threads</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid number of threads specified (%d)"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>delta_search_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAVE_THREADS</name> <operator>&amp;&amp;</operator> <name>delta_search_threads</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no threads support, ignoring %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>delta_search_threads</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"pack.indexversion"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pack_idx_opts</name><operator>.</operator><name>version</name></name> <operator>=</operator> <call><name>git_config_int</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pack_idx_opts</name><operator>.</operator><name>version</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad pack.indexversion=%"</literal><name>PRIu32</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>pack_idx_opts</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>git_default_config</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_object_list_from_stdin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>PATH_MAX</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ferror</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"BUG: fgets returned NULL, not EOF, not error!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"fgets"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>get_oid_hex</name><argument_list>(<argument><expr><name>line</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"expected edge object ID, got garbage:\n %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_preferred_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_oid_hex</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"expected object ID, got garbage:\n %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_preferred_base_object</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_object_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>OBJ_NONE</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_ADDED</name></cpp:macro> <cpp:value>(1u&lt;&lt;20)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>add_object_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>OBJ_COMMIT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>OBJECT_ADDED</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>write_bitmap_index</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>index_commit_for_bitmap</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_delta_islands</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>propagate_island_marks</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>add_preferred_base_object</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_object_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OBJECT_ADDED</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_delta_islands</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>


<expr_stmt><expr><name>depth</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>name</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>packlist_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ent</name> <operator>&amp;&amp;</operator> <name>depth</name> <operator>&gt;</operator> <call><name>oe_tree_depth</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oe_set_tree_depth</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_object__ma_allow_any</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg_missing_action</name> <operator>==</operator> <name>MA_ALLOW_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>show_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_object__ma_allow_promisor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg_missing_action</name> <operator>==</operator> <name>MA_ALLOW_PROMISOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_promisor_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>show_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>option_parse_missing_action</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg_missing_action</name> <operator>=</operator> <name>MA_ERROR</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fn_show_object</name> <operator>=</operator> <name>show_object</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"allow-any"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg_missing_action</name> <operator>=</operator> <name>MA_ALLOW_ANY</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fetch_if_missing</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fn_show_object</name> <operator>=</operator> <name>show_object__ma_allow_any</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"allow-promisor"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg_missing_action</name> <operator>=</operator> <name>MA_ALLOW_PROMISOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fetch_if_missing</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fn_show_object</name> <operator>=</operator> <name>show_object__ma_allow_promisor</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid value for --missing"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_edge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>add_preferred_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>in_pack_object</name> <block>{
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>in_pack</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>in_pack_object</name></name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mark_in_pack_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>in_pack</name></name> <modifier>*</modifier></type><name>in_pack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>in_pack</name><operator>-&gt;</operator><name>array</name><index>[<expr><name><name>in_pack</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>find_pack_entry_one</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>in_pack</name><operator>-&gt;</operator><name>array</name><index>[<expr><name><name>in_pack</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>object</name> <operator>=</operator> <name>object</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>in_pack</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>ofscmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>in_pack_object</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>in_pack_object</name> <operator>*</operator><operator>)</operator><name>a_</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>in_pack_object</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator>struct <name>in_pack_object</name> <operator>*</operator><operator>)</operator><name>b_</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>oidcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_objects_in_unpacked_packs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>in_pack</name></name></type> <name>in_pack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in_pack</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>in_pack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pack_local</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_keep</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_keep_in_core</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>open_pack_index</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot open pack index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>in_pack</name><operator>.</operator><name>array</name></name></expr></argument>,
<argument><expr><name><name>in_pack</name><operator>.</operator><name>nr</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr></argument>,
<argument><expr><name><name>in_pack</name><operator>.</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookup_unknown_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>o</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OBJECT_ADDED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mark_in_pack_object</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>in_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OBJECT_ADDED</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>in_pack</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name><name>in_pack</name><operator>.</operator><name>array</name></name></expr></argument>, <argument><expr><name><name>in_pack</name><operator>.</operator><name>nr</name></name></expr></argument>, <argument><expr><name>ofscmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in_pack</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>in_pack</name><operator>.</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>object</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>add_object_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>in_pack</name><operator>.</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_loose_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"loose object at %s could not be examined"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>add_object_entry</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>add_unreachable_loose_objects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>for_each_loose_file_in_objdir</name><argument_list>(<argument><expr><call><name>get_object_directory</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>add_loose_object</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>has_sha1_pack_kept_or_nonlocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>last_found</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>last_found</name> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>last_found</name></expr> </then><else>:
<expr><call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pack_local</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_keep</name></name> <operator>||</operator>
<name><name>p</name><operator>-&gt;</operator><name>pack_keep_in_core</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>find_pack_entry_one</name><argument_list>(<argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_found</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>last_found</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>last_found</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>








<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>oid_array</name></name></type> <name>recent_objects</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>loosened_object_can_be_discarded</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>timestamp_t</name></type> <name>mtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unpack_unreachable_expiration</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mtime</name> <operator>&gt;</operator> <name>unpack_unreachable_expiration</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oid_array_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recent_objects</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>loosen_unused_packed_objects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pack_local</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_keep</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_keep_in_core</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>open_pack_index</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot open pack index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>packlist_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>has_sha1_pack_kept_or_nonlocal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>loosened_object_can_be_discarded</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mtime</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>force_object_loose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mtime</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to force loose object"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type> <name>pack_options_allow_reuse</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>allow_pack_reuse</name> <operator>&amp;&amp;</operator>
<name>pack_to_stdout</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ignore_packed_keep_on_disk</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ignore_packed_keep_in_core</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><name>local</name> <operator>||</operator> <operator>!</operator><name>have_non_local_packs</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><name>incremental</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_object_list_from_bitmap</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>bitmap_git</name> <operator>=</operator> <call><name>prepare_bitmap_walk</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter_options</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pack_options_allow_reuse</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>reuse_partial_packfile_from_bitmap</name><argument_list>(
<argument><expr><name>bitmap_git</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>reuse_packfile</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>reuse_packfile_objects</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>reuse_packfile_bitmap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>reuse_packfile_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nr_result</name> <operator>+=</operator> <name>reuse_packfile_objects</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress_state</name></expr></argument>, <argument><expr><name>nr_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>traverse_bitmap_commit_list</name><argument_list>(<argument><expr><name>bitmap_git</name></expr></argument>, <argument><expr><name>revs</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>add_object_entry_from_bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>record_recent_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>oid_array_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recent_objects</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>record_recent_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>oid_array_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recent_objects</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_object_list</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ac</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>av</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name></type> <name>revs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>setup_revision_opt</name></name></type> <name>s_r_opt</name> <init>= <expr><block>{
<expr><operator>.</operator><name>allow_exclude_promisor_objects</name> <operator>=</operator> <literal type="number">1</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_warning</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>repo_init_revisions</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>save_commit_buffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_revisions</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s_r_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>is_repository_shallow</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>save_warning</name> <operator>=</operator> <name>warn_on_object_refname_ambiguity</name></expr>;</expr_stmt>
<expr_stmt><expr><name>warn_on_object_refname_ambiguity</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>line</name><index>[<expr><operator>--</operator><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>line</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"--not"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>^=</operator> <name>UNINTERESTING</name></expr>;</expr_stmt>
<expr_stmt><expr><name>write_bitmap_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"--shallow "</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_oid_hex</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"not an SHA-1 '%s'"</literal></expr></argument>, <argument><expr><name>line</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>register_shallow</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>use_bitmap_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"not a rev '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>handle_revision_arg</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>REVARG_CANNOT_BE_FILENAME</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad revision '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>warn_on_object_refname_ambiguity</name> <operator>=</operator> <name>save_warning</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_bitmap_index</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_object_list_from_bitmap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_delta_islands</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_delta_islands</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prepare_revision_walk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"revision walk setup failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>mark_edges_uninteresting</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>show_edge</name></expr></argument>, <argument><expr><name>sparse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fn_show_object</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fn_show_object</name> <operator>=</operator> <name>show_object</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>traverse_commit_list_filtered</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>,
<argument><expr><name>show_commit</name></expr></argument>, <argument><expr><name>fn_show_object</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>unpack_unreachable_expiration</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>ignore_missing_links</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_unseen_recent_objects_to_traversal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>,
<argument><expr><name>unpack_unreachable_expiration</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to add recent objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>prepare_revision_walk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"revision walk setup failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>traverse_commit_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>record_recent_commit</name></expr></argument>,
<argument><expr><name>record_recent_object</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>keep_unreachable</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_objects_in_unpacked_packs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pack_loose_unreachable</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_unreachable_loose_objects</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>unpack_unreachable</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>loosen_unused_packed_objects</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>oid_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recent_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_extra_kept_packs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>names</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>basename</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pack_local</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>names</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fspathcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>names</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>names</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pack_keep_in_core</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ignore_packed_keep_in_core</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>option_parse_index_version</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUG_ON_OPT_NEG</name><argument_list>(<argument><expr><name>unset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_idx_opts</name><operator>.</operator><name>version</name></name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pack_idx_opts</name><operator>.</operator><name>version</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unsupported index version %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pack_idx_opts</name><operator>.</operator><name>off32_limit</name></name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>c</name> <operator>||</operator> <name><name>pack_idx_opts</name><operator>.</operator><name>off32_limit</name></name> <operator>&amp;</operator> <literal type="number">0x80000000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad index version '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>option_parse_unpack_unreachable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>unset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>unpack_unreachable</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>unpack_unreachable_expiration</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>unpack_unreachable</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>unpack_unreachable_expiration</name> <operator>=</operator> <call><name>approxidate</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmd_pack_objects</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>use_internal_rev_list</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shallow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>all_progress_implied</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>rp</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rev_list_unpacked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rev_list_all</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rev_list_reflog</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rev_list_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>keep_pack_list</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>pack_objects_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="char">'q'</literal></expr></argument>, <argument><expr><literal type="string">"quiet"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not show progress meter"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"progress"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show progress meter"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"all-progress"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"show progress meter during object writing phase"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"all-progress-implied"</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>all_progress_implied</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"similar to --all-progress when progress meter is shown"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"index-version"</literal></expr>, <expr><name>NULL</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"&lt;version&gt;[,&lt;offset&gt;]"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"write the pack index file in the specified idx format version"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_NONEG</name></expr>, <expr><name>option_parse_index_version</name></expr> }</block></expr>,
<expr><call><name>OPT_MAGNITUDE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"max-pack-size"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pack_size_limit</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"maximum size of each output pack file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"local"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>local</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"ignore borrowed objects from alternate object store"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"incremental"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>incremental</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"ignore packed objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"window"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>window</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"limit pack window by objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_MAGNITUDE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"window-memory"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>window_memory_limit</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"limit pack window by memory in addition to object limit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"depth"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"maximum length of delta chain allowed in the resulting pack"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"reuse-delta"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>reuse_delta</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"reuse existing deltas"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"reuse-object"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>reuse_object</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"reuse existing objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"delta-base-offset"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>allow_ofs_delta</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use OFS_DELTA objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"threads"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>delta_search_threads</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use threads when searching for best delta matches"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"non-empty"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>non_empty</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not create an empty pack output"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"revs"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_internal_rev_list</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"read revision arguments from standard input"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"unpacked"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rev_list_unpacked</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"limit the objects to those that are not yet packed"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>PARSE_OPT_NONEG</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rev_list_all</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"include objects reachable from any reference"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>PARSE_OPT_NONEG</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"reflog"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rev_list_reflog</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"include objects referred by reflog entries"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>PARSE_OPT_NONEG</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"indexed-objects"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rev_list_index</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"include objects referred to by the index"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>PARSE_OPT_NONEG</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"stdout"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pack_to_stdout</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"output pack to stdout"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"include-tag"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>include_tag</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"include tag objects that refer to objects to be packed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"keep-unreachable"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>keep_unreachable</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"keep unreachable objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"pack-loose-unreachable"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pack_loose_unreachable</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"pack loose unreachable objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"unpack-unreachable"</literal></expr>, <expr><name>NULL</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"time"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"unpack unreachable objects newer than &lt;time&gt;"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>PARSE_OPT_OPTARG</name></expr>, <expr><name>option_parse_unpack_unreachable</name></expr> }</block></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"sparse"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sparse</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use the sparse reachability algorithm"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"thin"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>thin</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"create thin packs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"shallow"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>shallow</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"create packs suitable for shallow fetches"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"honor-pack-keep"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignore_packed_keep_on_disk</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"ignore packs that have companion .keep file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_STRING_LIST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"keep-pack"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>keep_pack_list</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"ignore this pack"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_INTEGER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"compression"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pack_compression_level</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"pack compression level"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"keep-true-parents"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>grafts_replace_parents</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not hide commits by grafts"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"use-bitmap-index"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_bitmap_index</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"use a bitmap index if available to speed up counting objects"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"write-bitmap-index"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>write_bitmap_index</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"write a bitmap index together with the pack index"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>WRITE_BITMAP_TRUE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_SET_INT_F</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"write-bitmap-index-quiet"</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>write_bitmap_index</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"write a bitmap index if possible"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>WRITE_BITMAP_QUIET</name></expr></argument>, <argument><expr><name>PARSE_OPT_HIDDEN</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_PARSE_LIST_OBJECTS_FILTER</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter_options</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><name>OPTION_CALLBACK</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"missing"</literal></expr>, <expr><name>NULL</name></expr>, <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"action"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"handling for missing objects"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>PARSE_OPT_NONEG</name></expr>,
<expr><name>option_parse_missing_action</name></expr> }</block></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"exclude-promisor-objects"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exclude_promisor_objects</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"do not pack objects in promisor packfiles"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"delta-islands"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_delta_islands</name></expr></argument>,
<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"respect islands during delta compression"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OPT_END</name><argument_list>()</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>DFS_NUM_STATES</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>OE_DFS_STATE_BITS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"too many dfs states, increase OE_DFS_STATE_BITS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>read_replace_refs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>sparse</name> <operator>=</operator> <call><name>git_env_bool</name><argument_list>(<argument><expr><literal type="string">"GIT_TEST_PACK_SPARSE"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prepare_repo_settings</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sparse</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sparse</name> <operator>=</operator> <name><name>the_repository</name><operator>-&gt;</operator><name>settings</name><operator>.</operator><name>pack_use_sparse</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>reset_pack_idx_option</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pack_idx_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_pack_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>isatty</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pack_objects_options</name></expr></argument>,
<argument><expr><name>pack_usage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>base_name</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pack_to_stdout</name> <operator>!=</operator> <operator>!</operator><name>base_name</name> <operator>||</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage_with_options</name><argument_list>(<argument><expr><name>pack_usage</name></expr></argument>, <argument><expr><name>pack_objects_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>OE_DEPTH_BITS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"delta chain depth %d is too deep, forcing %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>depth</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>OE_DEPTH_BITS</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>depth</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>OE_DEPTH_BITS</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cache_max_small_delta_size</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>OE_Z_DELTA_BITS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pack.deltaCacheLimit is too high, forcing %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>OE_Z_DELTA_BITS</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cache_max_small_delta_size</name> <operator>=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>OE_Z_DELTA_BITS</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><literal type="string">"pack-objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>thin</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_internal_rev_list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>shallow</name></expr>
?</condition><then> <expr><literal type="string">"--objects-edge-aggressive"</literal></expr>
</then><else>: <expr><literal type="string">"--objects-edge"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><literal type="string">"--objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rev_list_all</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_internal_rev_list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><literal type="string">"--all"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rev_list_reflog</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_internal_rev_list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><literal type="string">"--reflog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rev_list_index</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_internal_rev_list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><literal type="string">"--indexed-objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rev_list_unpacked</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_internal_rev_list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><literal type="string">"--unpacked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exclude_promisor_objects</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_internal_rev_list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fetch_if_missing</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><literal type="string">"--exclude-promisor-objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>unpack_unreachable</name> <operator>||</operator> <name>keep_unreachable</name> <operator>||</operator> <name>pack_loose_unreachable</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>use_internal_rev_list</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reuse_object</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>reuse_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pack_compression_level</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pack_compression_level</name> <operator>=</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>pack_compression_level</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>pack_compression_level</name></expr></argument> &gt;</argument_list></name> <name>Z_BEST_COMPRESSION</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad pack compression level %d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pack_compression_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>delta_search_threads</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>delta_search_threads</name> <operator>=</operator> <call><name>online_cpus</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAVE_THREADS</name> <operator>&amp;&amp;</operator> <name>delta_search_threads</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no threads support, ignoring --threads"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pack_size_limit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pack_size_limit</name> <operator>=</operator> <name>pack_size_limit_cfg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pack_to_stdout</name> <operator>&amp;&amp;</operator> <name>pack_size_limit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--max-pack-size cannot be used to build a pack for transfer"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pack_size_limit</name> <operator>&amp;&amp;</operator> <name>pack_size_limit</name> <operator>&lt;</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"minimum pack size limit is 1 MiB"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_size_limit</name> <operator>=</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name> <operator>&amp;&amp;</operator> <name>thin</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--thin cannot be used to build an indexable pack"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>keep_unreachable</name> <operator>&amp;&amp;</operator> <name>unpack_unreachable</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--keep-unreachable and --unpack-unreachable are incompatible"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rev_list_all</name> <operator>||</operator> <operator>!</operator><name>rev_list_reflog</name> <operator>||</operator> <operator>!</operator><name>rev_list_index</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>unpack_unreachable_expiration</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>filter_options</name><operator>.</operator><name>choice</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use --filter without --stdout"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>










<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pack_to_stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>use_bitmap_index_default</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_bitmap_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>use_bitmap_index</name> <operator>=</operator> <name>use_bitmap_index_default</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_internal_rev_list</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>pack_to_stdout</name> <operator>&amp;&amp;</operator> <name>write_bitmap_index</name><operator>)</operator> <operator>||</operator> <call><name>is_repository_shallow</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>use_bitmap_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pack_to_stdout</name> <operator>||</operator> <operator>!</operator><name>rev_list_all</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>write_bitmap_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_delta_islands</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><literal type="string">"--topo-order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <name>all_progress_implied</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>progress</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_extra_kept_packs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>keep_pack_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_packed_keep_on_disk</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pack_local</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_keep</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>ignore_packed_keep_on_disk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>local</name></expr>)</condition> <block>{<block_content>





<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pack_local</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>have_non_local_packs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>trace2_region_enter</name><argument_list>(<argument><expr><literal type="string">"pack-objects"</literal></expr></argument>, <argument><expr><literal type="string">"enumerate-objects"</literal></expr></argument>,
<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prepare_packing_data</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to_pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>progress_state</name> <operator>=</operator> <call><name>start_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Enumerating objects"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_internal_rev_list</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>read_object_list_from_stdin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>get_object_list</name><argument_list>(<argument><expr><name><name>rp</name><operator>.</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>.</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>cleanup_preferred_base</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>include_tag</name> <operator>&amp;&amp;</operator> <name>nr_result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>for_each_ref</name><argument_list>(<argument><expr><name>add_ref_tag</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_region_leave</name><argument_list>(<argument><expr><literal type="string">"pack-objects"</literal></expr></argument>, <argument><expr><literal type="string">"enumerate-objects"</literal></expr></argument>,
<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>non_empty</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>nr_result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nr_result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>trace2_region_enter</name><argument_list>(<argument><expr><literal type="string">"pack-objects"</literal></expr></argument>, <argument><expr><literal type="string">"prepare-pack"</literal></expr></argument>,
<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prepare_pack</name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_region_leave</name><argument_list>(<argument><expr><literal type="string">"pack-objects"</literal></expr></argument>, <argument><expr><literal type="string">"prepare-pack"</literal></expr></argument>,
<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>trace2_region_enter</name><argument_list>(<argument><expr><literal type="string">"pack-objects"</literal></expr></argument>, <argument><expr><literal type="string">"write-pack-file"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_pack_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_region_leave</name><argument_list>(<argument><expr><literal type="string">"pack-objects"</literal></expr></argument>, <argument><expr><literal type="string">"write-pack-file"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Total %"</literal><name>PRIu32</name><literal type="string">" (delta %"</literal><name>PRIu32</name><literal type="string">"),"</literal>
<literal type="string">" reused %"</literal><name>PRIu32</name><literal type="string">" (delta %"</literal><name>PRIu32</name><literal type="string">"),"</literal>
<literal type="string">" pack-reused %"</literal><name>PRIu32</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>written</name></expr></argument>, <argument><expr><name>written_delta</name></expr></argument>, <argument><expr><name>reused</name></expr></argument>, <argument><expr><name>reused_delta</name></expr></argument>,
<argument><expr><name>reuse_packfile_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
