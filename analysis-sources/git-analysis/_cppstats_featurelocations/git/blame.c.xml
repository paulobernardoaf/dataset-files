<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\blame.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache-tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mergesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diffcore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"alloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-slab.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>define_commit_slab</name><argument_list>(<argument><expr><name>blame_suspects</name></expr></argument>, <argument><expr>struct <name>blame_origin</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>blame_suspects</name></name></type> <name>blame_suspects</name></decl>;</decl_stmt>

<function><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>get_blame_suspects</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>blame_suspects_peek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blame_suspects</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>result</name></expr> ?</condition><then> <expr><operator>*</operator><name>result</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_blame_suspects</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>origin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><call><name>blame_suspects_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blame_suspects</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>origin</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>blame_origin_decref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>&amp;&amp;</operator> <operator>--</operator><name><name>o</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>previous</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>previous</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>get_blame_suspects</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name>p</name></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>o</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_blame_suspects</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"internal error in blame_origin_decref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>make_origin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FLEX_ALLOC_STR</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>commit</name></name> <operator>=</operator> <name>commit</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>get_blame_suspects</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_blame_suspects</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>get_origin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>o</name> <operator>=</operator> <call><name>get_blame_suspects</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>l</name> <operator>=</operator> <name>NULL</name></expr>;</init> <condition><expr><name>o</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name>o</name></expr><operator>,</operator> <expr><name>o</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>l</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>get_blame_suspects</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_blame_suspects</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>make_origin</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>verify_working_tree_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>work_tree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>parents</name> <operator>=</operator> <name><name>work_tree</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>parents</name></expr>;</condition> <incr><expr><name>parents</name> <operator>=</operator> <name><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>commit_oid</name> <init>= <expr><operator>&amp;</operator><name><name>parents</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>blob_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>mode</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_tree_entry</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>commit_oid</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>oid_object_info</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blob_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJ_BLOB</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>pos</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache</name><index>[<expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"no such path '%s' in HEAD"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>append_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parent</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"no such commit %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>&amp;</operator><call><name>commit_list_insert</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>append_merge_parents</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>merge_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>line</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>merge_head</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><call><name>git_path_merge_head</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>merge_head</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"cannot open '%s' for reading"</literal></expr></argument>,
<argument><expr><call><name>git_path_merge_head</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>strbuf_getwholeline_fd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><name>merge_head</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_oid_hex</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unknown line in '%s': %s"</literal></expr></argument>,
<argument><expr><call><name>git_path_merge_head</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>line</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <call><name>append_parent</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>merge_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>set_commit_buffer_from_strbuf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>set_commit_buffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>fake_working_tree_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contents_from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>origin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>parent_tail</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>head_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>now</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>msg</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>repo_read_index</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>alloc_commit_node</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>parsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>date</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parent_tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>resolve_ref_unsafe</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><name>RESOLVE_REF_READING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"no such ref: HEAD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>parent_tail</name> <operator>=</operator> <call><name>append_parent</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>parent_tail</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>append_merge_parents</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>parent_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verify_working_tree_path</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>origin</name> <operator>=</operator> <call><name>make_origin</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ident</name> <operator>=</operator> <call><name>fmt_ident</name><argument_list>(<argument><expr><literal type="string">"Not Committed Yet"</literal></expr></argument>, <argument><expr><literal type="string">"not.committed.yet"</literal></expr></argument>,
<argument><expr><name>WANT_BLANK_IDENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"tree 0000000000000000000000000000000000000000\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>parent</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>parent</name></expr>;</condition> <incr><expr><name>parent</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"parent %s\n"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>,
<argument><expr><literal type="string">"author %s\n"</literal>
<literal type="string">"committer %s\n\n"</literal>
<literal type="string">"Version of %s from %s\n"</literal></expr></argument>,
<argument><expr><name>ident</name></expr></argument>, <argument><expr><name>ident</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><operator>!</operator><name>contents_from</name></expr> ?</condition><then> <expr><name>path</name></expr> </then><else>:
<expr><operator>(</operator><ternary><condition><expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>contents_from</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"standard input"</literal></expr> </then><else>: <expr><name>contents_from</name></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_commit_buffer_from_strbuf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>contents_from</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>contents_from</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>read_from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>buf_len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>contents_from</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>contents_from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"Cannot stat '%s'"</literal></expr></argument>, <argument><expr><name>contents_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>read_from</name> <operator>=</operator> <name>contents_from</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"Cannot lstat '%s'"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>read_from</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>canon_mode</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IFMT</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>S_IFREG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>allow_textconv</name></name> <operator>&amp;&amp;</operator>
<call><name>textconv_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>read_from</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_attach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><name>buf_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strbuf_read_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>read_from</name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"cannot open or read '%s'"</literal></expr></argument>, <argument><expr><name>read_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>S_IFLNK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>strbuf_readlink</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>read_from</name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"cannot readlink '%s'"</literal></expr></argument>, <argument><expr><name>read_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unsupported file type %s"</literal></expr></argument>, <argument><expr><name>read_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strbuf_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"failed to read from stdin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>convert_to_git</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>origin</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>origin</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pretend_object_file</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>OBJ_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><call><name>discard_index</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>repo_read_index</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mode</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>index_name_pos</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>ce_mode</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <name>S_IFREG</name> <operator>|</operator> <literal type="number">0644</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>=</operator> <call><name>create_ce_flags</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>create_ce_mode</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_index_entry</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>ce</name></expr></argument>,
<argument><expr><name>ADD_CACHE_OK_TO_ADD</name> <operator>|</operator> <name>ADD_CACHE_OK_TO_REPLACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cache_tree_invalidate_path</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>commit</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>diff_hunks</name><parameter_list>(<parameter><decl><type><name>mmfile_t</name> <modifier>*</modifier></type><name>file_a</name></decl></parameter>, <parameter><decl><type><name>mmfile_t</name> <modifier>*</modifier></type><name>file_b</name></decl></parameter>,
<parameter><decl><type><name>xdl_emit_hunk_consume_func_t</name></type> <name>hunk_func</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xdl_opts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>xpparam_t</name></type> <name>xpp</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xdemitconf_t</name></type> <name>xecfg</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xdemitcb_t</name></type> <name>ecb</name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>xpp</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>xdl_opts</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>xecfg</name><operator>.</operator><name>hunk_func</name></name> <operator>=</operator> <name>hunk_func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecb</name><operator>.</operator><name>priv</name></name> <operator>=</operator> <name>cb_data</name></expr>;</expr_stmt>
<return>return <expr><call><name>xdi_diff</name><argument_list>(<argument><expr><name>file_a</name></expr></argument>, <argument><expr><name>file_b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xpp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xecfg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ecb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_next_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>nl</name></expr> ?</condition><then> <expr><name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>end</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_line_starts</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>line_starts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <call><name>get_next_line</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><operator>*</operator><name>line_starts</name></expr></argument>, <argument><expr><name>num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lineno</name> <operator>=</operator> <operator>*</operator><name>line_starts</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <call><name>get_next_line</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>lineno</name><operator>++</operator> <operator>=</operator> <name>p</name> <operator>-</operator> <name>buf</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><operator>*</operator><name>lineno</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<struct_decl>struct <name>fingerprint_entry</name>;</struct_decl>




















<struct>struct <name>fingerprint</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name></type> <name>map</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>struct</name> <name>fingerprint_entry</name></name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
}</block>;</struct>




<struct>struct <name>fingerprint_entry</name> <block>{



<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>entry</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
}</block>;</struct>







<function><type><specifier>static</specifier> <name>void</name></type> <name>get_fingerprint</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line_begin</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>c0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>c1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_map_entry_count</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>line_end</name> <operator>-</operator> <name>line_begin</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>fingerprint_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><name>max_map_entry_count</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>fingerprint_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>fingerprint_entry</name></name> <modifier>*</modifier></type><name>found_entry</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>max_map_entry_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>line_begin</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;=</operator> <name>line_end</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr><operator>,</operator> <expr><name>c0</name> <operator>=</operator> <name>c1</name></expr></incr>)</control> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>==</operator> <name>line_end</name><operator>)</operator> <operator>||</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <name>c0</name> <operator>|</operator> <operator>(</operator><name>c1</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hash</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>found_entry</name> <operator>=</operator> <call><name>hashmap_get_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>found_entry</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>found_entry</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>entry</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_fingerprint</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hashmap_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>fingerprint_similarity</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>intersection</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>fingerprint_entry</name></name> <modifier>*</modifier></type><name>entry_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>entry_b</name></decl>;</decl_stmt>

<macro><name>hashmap_for_each_entry</name><argument_list>(<argument>&amp;b-&gt;map</argument>, <argument>&amp;iter</argument>, <argument>entry_b</argument>,
<argument>entry</argument> )</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>entry_a</name> <operator>=</operator> <call><name>hashmap_get_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><name>entry_b</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_a</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>intersection</name> <operator>+=</operator> <ternary><condition><expr><name><name>entry_a</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <name><name>entry_b</name><operator>-&gt;</operator><name>count</name></name></expr> ?</condition><then>
<expr><name><name>entry_a</name><operator>-&gt;</operator><name>count</name></name></expr> </then><else>: <expr><name><name>entry_b</name><operator>-&gt;</operator><name>count</name></name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>intersection</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>fingerprint_subtract</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>fingerprint_entry</name></name> <modifier>*</modifier></type><name>entry_a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>fingerprint_entry</name></name> <modifier>*</modifier></type><name>entry_b</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hashmap_iter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>hashmap_for_each_entry</name><argument_list>(<argument>&amp;b-&gt;map</argument>, <argument>&amp;iter</argument>, <argument>entry_b</argument>,
<argument>entry</argument> )</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>entry_a</name> <operator>=</operator> <call><name>hashmap_get_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><name>entry_b</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_a</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>entry_a</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;=</operator> <name><name>entry_b</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>hashmap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry_b</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry_a</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name><name>entry_b</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>get_line_fingerprints</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>fingerprints</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>line_starts</name></decl></parameter>,
<parameter><decl><type><name>long</name></type> <name>first_line</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>line_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linestart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lineend</name></decl>;</decl_stmt>

<expr_stmt><expr><name>line_starts</name> <operator>+=</operator> <name>first_line</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>line_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>linestart</name> <operator>=</operator> <name>content</name> <operator>+</operator> <name><name>line_starts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lineend</name> <operator>=</operator> <name>content</name> <operator>+</operator> <name><name>line_starts</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_fingerprint</name><argument_list>(<argument><expr><name>fingerprints</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>linestart</name></expr></argument>, <argument><expr><name>lineend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_line_fingerprints</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>fingerprints</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>nr_fingerprints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr_fingerprints</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free_fingerprint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fingerprints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>





<struct>struct <name>line_number_mapping</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>destination_start</name></decl>, <decl><type ref="prev"/><name>destination_length</name></decl>,
<decl><type ref="prev"/><name>source_start</name></decl>, <decl><type ref="prev"/><name>source_length</name></decl>;</decl_stmt>
}</block>;</struct>














<function><type><specifier>static</specifier> <name>int</name></type> <name>map_line_number</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>line_number</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>line_number_mapping</name></name> <modifier>*</modifier></type><name>mapping</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>line_number</name> <operator>-</operator> <name><name>mapping</name><operator>-&gt;</operator><name>source_start</name></name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<name><name>mapping</name><operator>-&gt;</operator><name>destination_length</name></name> <operator>/</operator>
<operator>(</operator><name><name>mapping</name><operator>-&gt;</operator><name>source_length</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator>
<name><name>mapping</name><operator>-&gt;</operator><name>destination_start</name></name></expr>;</return>
</block_content>}</block></function>






































<function><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>get_similarity</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>similarities</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>line_a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local_line_b</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>closest_line_a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_search_distance_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>line_a</name> <operator>-</operator> <name>closest_line_a</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
<name>max_search_distance_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>similarities</name> <operator>+</operator> <name>line_a</name> <operator>-</operator> <name>closest_line_a</name> <operator>+</operator>
<name>max_search_distance_a</name> <operator>+</operator>
<name>local_line_b</name> <operator>*</operator> <operator>(</operator><name>max_search_distance_a</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CERTAIN_NOTHING_MATCHES</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CERTAINTY_NOT_CALCULATED</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

























<function><type><specifier>static</specifier> <name>void</name></type> <name>find_best_line_matches</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>start_a</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>length_a</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>start_b</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>local_line_b</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>fingerprints_a</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>fingerprints_b</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>similarities</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>certainties</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>second_best_result</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_search_distance_a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>line_number_mapping</name></name> <modifier>*</modifier></type><name>map_line_number_in_b_to_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>search_start</name></decl>, <decl><type ref="prev"/><name>search_end</name></decl>, <decl><type ref="prev"/><name>closest_local_line_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>similarity</name></decl>,
<decl><type ref="prev"/><name>best_similarity</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>second_best_similarity</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><type ref="prev"/><name>best_similarity_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>second_best_similarity_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>certainties</name><index>[<expr><name>local_line_b</name></expr>]</index></name> <operator>!=</operator> <name>CERTAINTY_NOT_CALCULATED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>closest_local_line_a</name> <operator>=</operator> <call><name>map_line_number</name><argument_list>(
<argument><expr><name>local_line_b</name> <operator>+</operator> <name>start_b</name></expr></argument>, <argument><expr><name>map_line_number_in_b_to_a</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start_a</name></expr>;</expr_stmt>

<expr_stmt><expr><name>search_start</name> <operator>=</operator> <name>closest_local_line_a</name> <operator>-</operator> <name>max_search_distance_a</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>search_start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>search_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>search_end</name> <operator>=</operator> <name>closest_local_line_a</name> <operator>+</operator> <name>max_search_distance_a</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>search_end</name> <operator>&gt;</operator> <name>length_a</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>search_end</name> <operator>=</operator> <name>length_a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>search_start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>search_end</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>similarity</name> <operator>=</operator> <call><name>get_similarity</name><argument_list>(<argument><expr><name>similarities</name></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name>local_line_b</name></expr></argument>,
<argument><expr><name>closest_local_line_a</name></expr></argument>,
<argument><expr><name>max_search_distance_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>similarity</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>closest_local_line_a</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><operator>*</operator><name>similarity</name> <operator>=</operator> <call><name>fingerprint_similarity</name><argument_list>(
<argument><expr><name>fingerprints_b</name> <operator>+</operator> <name>local_line_b</name></expr></argument>,
<argument><expr><name>fingerprints_a</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call> <operator>*</operator>
<operator>(</operator><literal type="number">1000</literal> <operator>-</operator> <call><name>abs</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>closest_local_line_a</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>similarity</name> <operator>&gt;</operator> <name>best_similarity</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>second_best_similarity</name> <operator>=</operator> <name>best_similarity</name></expr>;</expr_stmt>
<expr_stmt><expr><name>second_best_similarity_index</name> <operator>=</operator> <name>best_similarity_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_similarity</name> <operator>=</operator> <operator>*</operator><name>similarity</name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_similarity_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>similarity</name> <operator>&gt;</operator> <name>second_best_similarity</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>second_best_similarity</name> <operator>=</operator> <operator>*</operator><name>similarity</name></expr>;</expr_stmt>
<expr_stmt><expr><name>second_best_similarity_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>best_similarity</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>certainties</name><index>[<expr><name>local_line_b</name></expr>]</index></name> <operator>=</operator> <name>CERTAIN_NOTHING_MATCHES</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>local_line_b</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>












<expr_stmt><expr><name><name>certainties</name><index>[<expr><name>local_line_b</name></expr>]</index></name> <operator>=</operator> <name>best_similarity</name> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator>
<name>second_best_similarity</name></expr>;</expr_stmt>





<expr_stmt><expr><name><name>result</name><index>[<expr><name>local_line_b</name></expr>]</index></name> <operator>=</operator> <name>start_a</name> <operator>+</operator> <name>best_similarity_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>second_best_result</name><index>[<expr><name>local_line_b</name></expr>]</index></name> <operator>=</operator>
<name>start_a</name> <operator>+</operator> <name>second_best_similarity_index</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

































<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzy_find_matching_lines_recurse</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>start_a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_b</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>length_a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length_b</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>fingerprints_a</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>fingerprints_b</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>similarities</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>certainties</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>second_best_result</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>max_search_distance_a</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>max_search_distance_b</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>line_number_mapping</name></name> <modifier>*</modifier></type><name>map_line_number_in_b_to_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>invalidate_min</name></decl>, <decl><type ref="prev"/><name>invalidate_max</name></decl>, <decl><type ref="prev"/><name>offset_b</name></decl>,
<decl><type ref="prev"/><name>second_half_start_a</name></decl>, <decl><type ref="prev"/><name>second_half_start_b</name></decl>,
<decl><type ref="prev"/><name>second_half_length_a</name></decl>, <decl><type ref="prev"/><name>second_half_length_b</name></decl>,
<decl><type ref="prev"/><name>most_certain_line_a</name></decl>, <decl><type ref="prev"/><name>most_certain_local_line_b</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><type ref="prev"/><name>most_certain_line_certainty</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><type ref="prev"/><name>closest_local_line_a</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length_b</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>find_best_line_matches</name><argument_list>(<argument><expr><name>start_a</name></expr></argument>,
<argument><expr><name>length_a</name></expr></argument>,
<argument><expr><name>start_b</name></expr></argument>,
<argument><expr><name>i</name></expr></argument>,
<argument><expr><name>fingerprints_a</name></expr></argument>,
<argument><expr><name>fingerprints_b</name></expr></argument>,
<argument><expr><name>similarities</name></expr></argument>,
<argument><expr><name>certainties</name></expr></argument>,
<argument><expr><name>second_best_result</name></expr></argument>,
<argument><expr><name>result</name></expr></argument>,
<argument><expr><name>max_search_distance_a</name></expr></argument>,
<argument><expr><name>map_line_number_in_b_to_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>certainties</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>most_certain_line_certainty</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>most_certain_line_certainty</name> <operator>=</operator> <name><name>certainties</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>most_certain_local_line_b</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>most_certain_local_line_b</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>most_certain_line_a</name> <operator>=</operator> <name><name>result</name><index>[<expr><name>most_certain_local_line_b</name></expr>]</index></name></expr>;</expr_stmt>






<expr_stmt><expr><call><name>fingerprint_subtract</name><argument_list>(<argument><expr><name>fingerprints_a</name> <operator>+</operator> <name>most_certain_line_a</name> <operator>-</operator> <name>start_a</name></expr></argument>,
<argument><expr><name>fingerprints_b</name> <operator>+</operator> <name>most_certain_local_line_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>invalidate_min</name> <operator>=</operator> <name>most_certain_local_line_b</name> <operator>-</operator> <name>max_search_distance_b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>invalidate_max</name> <operator>=</operator> <name>most_certain_local_line_b</name> <operator>+</operator> <name>max_search_distance_b</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>invalidate_min</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>invalidate_min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>invalidate_max</name> <operator>&gt;</operator> <name>length_b</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>invalidate_max</name> <operator>=</operator> <name>length_b</name></expr>;</expr_stmt></block_content></block></if></if_stmt>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>invalidate_min</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>invalidate_max</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>closest_local_line_a</name> <operator>=</operator> <call><name>map_line_number</name><argument_list>(
<argument><expr><name>i</name> <operator>+</operator> <name>start_b</name></expr></argument>, <argument><expr><name>map_line_number_in_b_to_a</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start_a</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>most_certain_line_a</name> <operator>-</operator> <name>start_a</name> <operator>-</operator> <name>closest_local_line_a</name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
<name>max_search_distance_a</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><call><name>get_similarity</name><argument_list>(<argument><expr><name>similarities</name></expr></argument>, <argument><expr><name>most_certain_line_a</name> <operator>-</operator> <name>start_a</name></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name>closest_local_line_a</name></expr></argument>,
<argument><expr><name>max_search_distance_a</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>







<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>most_certain_local_line_b</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>invalidate_min</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>certainties</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>most_certain_line_a</name> <operator>||</operator>
<name><name>second_best_result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>most_certain_line_a</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>certainties</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>CERTAINTY_NOT_CALCULATED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>most_certain_local_line_b</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>invalidate_max</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>certainties</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>most_certain_line_a</name> <operator>||</operator>
<name><name>second_best_result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>most_certain_line_a</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>certainties</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>CERTAINTY_NOT_CALCULATED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name>most_certain_local_line_b</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fuzzy_find_matching_lines_recurse</name><argument_list>(
<argument><expr><name>start_a</name></expr></argument>, <argument><expr><name>start_b</name></expr></argument>,
<argument><expr><name>most_certain_line_a</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>start_a</name></expr></argument>,
<argument><expr><name>most_certain_local_line_b</name></expr></argument>,
<argument><expr><name>fingerprints_a</name></expr></argument>, <argument><expr><name>fingerprints_b</name></expr></argument>, <argument><expr><name>similarities</name></expr></argument>,
<argument><expr><name>certainties</name></expr></argument>, <argument><expr><name>second_best_result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>,
<argument><expr><name>max_search_distance_a</name></expr></argument>,
<argument><expr><name>max_search_distance_b</name></expr></argument>,
<argument><expr><name>map_line_number_in_b_to_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>most_certain_local_line_b</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>length_b</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>second_half_start_a</name> <operator>=</operator> <name>most_certain_line_a</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset_b</name> <operator>=</operator> <name>most_certain_local_line_b</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>second_half_start_b</name> <operator>=</operator> <name>start_b</name> <operator>+</operator> <name>offset_b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>second_half_length_a</name> <operator>=</operator>
<name>length_a</name> <operator>+</operator> <name>start_a</name> <operator>-</operator> <name>second_half_start_a</name></expr>;</expr_stmt>
<expr_stmt><expr><name>second_half_length_b</name> <operator>=</operator>
<name>length_b</name> <operator>+</operator> <name>start_b</name> <operator>-</operator> <name>second_half_start_b</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fuzzy_find_matching_lines_recurse</name><argument_list>(
<argument><expr><name>second_half_start_a</name></expr></argument>, <argument><expr><name>second_half_start_b</name></expr></argument>,
<argument><expr><name>second_half_length_a</name></expr></argument>, <argument><expr><name>second_half_length_b</name></expr></argument>,
<argument><expr><name>fingerprints_a</name> <operator>+</operator> <name>second_half_start_a</name> <operator>-</operator> <name>start_a</name></expr></argument>,
<argument><expr><name>fingerprints_b</name> <operator>+</operator> <name>offset_b</name></expr></argument>,
<argument><expr><name>similarities</name> <operator>+</operator>
<name>offset_b</name> <operator>*</operator> <operator>(</operator><name>max_search_distance_a</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
<argument><expr><name>certainties</name> <operator>+</operator> <name>offset_b</name></expr></argument>,
<argument><expr><name>second_best_result</name> <operator>+</operator> <name>offset_b</name></expr></argument>, <argument><expr><name>result</name> <operator>+</operator> <name>offset_b</name></expr></argument>,
<argument><expr><name>max_search_distance_a</name></expr></argument>,
<argument><expr><name>max_search_distance_b</name></expr></argument>,
<argument><expr><name>map_line_number_in_b_to_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>fuzzy_find_matching_lines</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>tlno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parent_slno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>same</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>parent_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<decl_stmt><decl><type><name>int</name></type> <name>start_a</name> <init>= <expr><name>parent_slno</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length_a</name> <init>= <expr><name>parent_len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>start_b</name> <init>= <expr><name>tlno</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length_b</name> <init>= <expr><name>same</name> <operator>-</operator> <name>tlno</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>line_number_mapping</name></name></type> <name>map_line_number_in_b_to_a</name> <init>= <expr><block>{
<expr><name>start_a</name></expr>, <expr><name>length_a</name></expr>, <expr><name>start_b</name></expr>, <expr><name>length_b</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>fingerprints_a</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>fingerprints</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>fingerprints_b</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>fingerprints</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>second_best_result</name></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>certainties</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>similarities</name></decl>, <decl><type ref="prev"/><name>similarity_count</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>int</name></type> <name>max_search_distance_a</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>, <decl><type ref="prev"/><name>max_search_distance_b</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>length_a</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_search_distance_a</name> <operator>&gt;=</operator> <name>length_a</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_search_distance_a</name> <operator>=</operator> <ternary><condition><expr><name>length_a</name></expr> ?</condition><then> <expr><name>length_a</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>max_search_distance_b</name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>max_search_distance_a</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>length_b</name>
<operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>length_a</name></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>length_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>second_best_result</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>length_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>certainties</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>length_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>similarity_count</name> <operator>=</operator> <name>length_b</name> <operator>*</operator> <operator>(</operator><name>max_search_distance_a</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>similarities</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>similarity_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length_b</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>second_best_result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>certainties</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>CERTAINTY_NOT_CALCULATED</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>similarity_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>similarities</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fuzzy_find_matching_lines_recurse</name><argument_list>(<argument><expr><name>start_a</name></expr></argument>, <argument><expr><name>start_b</name></expr></argument>,
<argument><expr><name>length_a</name></expr></argument>, <argument><expr><name>length_b</name></expr></argument>,
<argument><expr><name>fingerprints_a</name> <operator>+</operator> <name>start_a</name></expr></argument>,
<argument><expr><name>fingerprints_b</name> <operator>+</operator> <name>start_b</name></expr></argument>,
<argument><expr><name>similarities</name></expr></argument>,
<argument><expr><name>certainties</name></expr></argument>,
<argument><expr><name>second_best_result</name></expr></argument>,
<argument><expr><name>result</name></expr></argument>,
<argument><expr><name>max_search_distance_a</name></expr></argument>,
<argument><expr><name>max_search_distance_b</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>map_line_number_in_b_to_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>similarities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>certainties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>second_best_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_origin_fingerprints</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>line_starts</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>fingerprints</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>=</operator> <call><name>find_line_starts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_starts</name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name></expr></argument>,
<argument><expr><name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>fingerprints</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>fingerprint</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>num_lines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_line_fingerprints</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>fingerprints</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>line_starts</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>num_lines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>line_starts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>drop_origin_fingerprints</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>fingerprints</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_line_fingerprints</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>fingerprints</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>num_lines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>fingerprints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_origin_blob</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>diff_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>mmfile_t</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_read_blob</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fill_fingerprints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>file_size</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_read_blob</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>allow_textconv</name></name> <operator>&amp;&amp;</operator>
<call><name>textconv_object</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>file</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>file_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>file_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>file</name><operator>-&gt;</operator><name>ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Cannot read blob %s for path %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <operator>*</operator><name>file</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>file</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fill_fingerprints</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fill_origin_fingerprints</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>drop_origin_blob</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>drop_origin_fingerprints</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>blame_merge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>list1</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>list1</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name> <init>= <expr><name>list2</name></expr></init></decl>,
<decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>list1</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p1</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>p2</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>p1</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&lt;=</operator> <name><name>p2</name><operator>-&gt;</operator><name>s_lno</name></name></expr>)</condition> <block>{<block_content>
<do>do <block>{<block_content>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p1</name> <operator>=</operator> <operator>*</operator><name>tail</name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
<return>return <expr><name>list1</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&lt;=</operator> <name><name>p2</name><operator>-&gt;</operator><name>s_lno</name></name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p2</name> <operator>=</operator> <operator>*</operator><name>tail</name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
<return>return <expr><name>list1</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&gt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>s_lno</name></name></expr>)</condition>;</do>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p1</name> <operator>=</operator> <operator>*</operator><name>tail</name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
<return>return <expr><name>list1</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&lt;=</operator> <name><name>p2</name><operator>-&gt;</operator><name>s_lno</name></name></expr>)</condition>;</do>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>get_next_blame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator>struct <name>blame_entry</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_next_blame</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator>struct <name>blame_entry</name> <operator>*</operator><operator>)</operator><name>p1</name><operator>)</operator><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_blame_final</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><operator>(</operator>struct <name>blame_entry</name> <operator>*</operator><operator>)</operator><name>p1</name><operator>)</operator><operator>-&gt;</operator><name>lno</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator>struct <name>blame_entry</name> <operator>*</operator><operator>)</operator><name>p2</name><operator>)</operator><operator>-&gt;</operator><name>lno</name></expr>
?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_blame_suspect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><name>p1</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name> <init>= <expr><name>p2</name></expr></init></decl>;</decl_stmt>







<if_stmt><if>if <condition>(<expr><name><name>s1</name><operator>-&gt;</operator><name>suspect</name></name> <operator>!=</operator> <name><name>s2</name><operator>-&gt;</operator><name>suspect</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>intptr_t</name><operator>)</operator><name><name>s1</name><operator>-&gt;</operator><name>suspect</name></name> <operator>&gt;</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator><name><name>s2</name><operator>-&gt;</operator><name>suspect</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s1</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>==</operator> <name><name>s2</name><operator>-&gt;</operator><name>s_lno</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name><name>s1</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&gt;</operator> <name><name>s2</name><operator>-&gt;</operator><name>s_lno</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>blame_sort_final</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>ent</name></name> <operator>=</operator> <call><name>llist_mergesort</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>, <argument><expr><name>get_next_blame</name></expr></argument>, <argument><expr><name>set_next_blame</name></expr></argument>,
<argument><expr><name>compare_blame_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_commits_by_reverse_commit_date</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>-</operator><call><name>compare_commits_by_commit_date</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>sanity_check_refcnt</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>baa</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ent</name> <operator>=</operator> <name><name>sb</name><operator>-&gt;</operator><name>ent</name></name></expr>;</init> <condition><expr><name>ent</name></expr>;</condition> <incr><expr><name>ent</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>suspect</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s in %s has negative refcnt %d\n"</literal></expr></argument>,
<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>suspect</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>suspect</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>suspect</name><operator>-&gt;</operator><name>refcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>baa</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>baa</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>sb</name><operator>-&gt;</operator><name>on_sanity_fail</name></name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>baa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>blame_coalesce</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ent</name> <operator>=</operator> <name><name>sb</name><operator>-&gt;</operator><name>ent</name></name></expr>;</init> <condition><expr><name>ent</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>next</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr>;</condition> <incr><expr><name>ent</name> <operator>=</operator> <name>next</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>suspect</name></name> <operator>==</operator> <name><name>next</name><operator>-&gt;</operator><name>suspect</name></name> <operator>&amp;&amp;</operator>
<name><name>ent</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+</operator> <name><name>ent</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>==</operator> <name><name>next</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&amp;&amp;</operator>
<name><name>ent</name><operator>-&gt;</operator><name>ignored</name></name> <operator>==</operator> <name><name>next</name><operator>-&gt;</operator><name>ignored</name></name> <operator>&amp;&amp;</operator>
<name><name>ent</name><operator>-&gt;</operator><name>unblamable</name></name> <operator>==</operator> <name><name>next</name><operator>-&gt;</operator><name>unblamable</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>+=</operator> <name><name>next</name><operator>-&gt;</operator><name>num_lines</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><call><name>sanity_check_refcnt</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>queue_blames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>sorted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>porigin</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>porigin</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <call><name>blame_merge</name><argument_list>(<argument><expr><name><name>porigin</name><operator>-&gt;</operator><name>suspects</name></name></expr></argument>, <argument><expr><name>sorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>o</name> <operator>=</operator> <call><name>get_blame_suspects</name><argument_list>(<argument><expr><name><name>porigin</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>o</name></expr>;</condition> <incr><expr><name>o</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>porigin</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <name>sorted</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>porigin</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <name>sorted</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prio_queue_put</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>commits</name></name></expr></argument>, <argument><expr><name><name>porigin</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type> <name>fill_blob_sha1_and_mode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>origin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_tree_entry</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>origin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>error_out</name>:</label>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>origin</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>S_IFINVALID</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>find_origin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>origin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_options</name></name></type> <name>diff_opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>paths</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>porigin</name> <operator>=</operator> <call><name>get_blame_suspects</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>porigin</name></expr>;</condition> <incr><expr><name>porigin</name> <operator>=</operator> <name><name>porigin</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>porigin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>origin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>




<return>return <expr><call><name>blame_origin_incref</name> <argument_list>(<argument><expr><name>porigin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt></block_content></block></for>





<expr_stmt><expr><call><name>repo_diff_setup</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>flags</name><operator>.</operator><name>recursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>detect_rename</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>output_format</name></name> <operator>=</operator> <name>DIFF_FORMAT_NO_OUTPUT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>paths</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>origin</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>paths</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>parse_pathspec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>diff_opts</name><operator>.</operator><name>pathspec</name></name></expr></argument>,
<argument><expr><name>PATHSPEC_ALL_MAGIC</name> <operator>&amp;</operator> <operator>~</operator><name>PATHSPEC_LITERAL</name></expr></argument>,
<argument><expr><name>PATHSPEC_LITERAL_PATH</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_setup_done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>do_diff_cache</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>diff_tree_oid</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name><name>origin</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>diffcore_std</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>diff_queued_diff</name><operator>.</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>porigin</name> <operator>=</operator> <call><name>get_origin</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>origin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>porigin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>porigin</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>origin</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>






<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>diff_queued_diff</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>diff_queued_diff</name><operator>.</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>origin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"internal error in blame::find_origin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"internal error in blame::find_origin (%c)"</literal></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="char">'M'</literal></expr>:</case>
<expr_stmt><expr><name>porigin</name> <operator>=</operator> <call><name>get_origin</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>origin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>porigin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>porigin</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<case>case <expr><literal type="char">'T'</literal></expr>:</case>

<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>diff_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_pathspec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>diff_opts</name><operator>.</operator><name>pathspec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>porigin</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>find_rename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>origin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_options</name></name></type> <name>diff_opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>repo_diff_setup</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>flags</name><operator>.</operator><name>recursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>detect_rename</name></name> <operator>=</operator> <name>DIFF_DETECT_RENAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>output_format</name></name> <operator>=</operator> <name>DIFF_FORMAT_NO_OUTPUT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>single_follow</name></name> <operator>=</operator> <name><name>origin</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_setup_done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>do_diff_cache</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>diff_tree_oid</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name><name>origin</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>diffcore_std</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>diff_queued_diff</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>diff_queued_diff</name><operator>.</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <literal type="char">'R'</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <literal type="char">'C'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>origin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>porigin</name> <operator>=</operator> <call><name>get_origin</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>porigin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>porigin</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>diff_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_pathspec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>diff_opts</name><operator>.</operator><name>pathspec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>porigin</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>add_blame_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>queue</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>e</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>e</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>queue</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>*</operator><name>queue</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>queue</name> <operator>=</operator> <operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>dup_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>queue</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>src</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>queue</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>*</operator><name>queue</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>queue</name> <operator>=</operator> <operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>blame_nth_line</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>lno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>sb</name><operator>-&gt;</operator><name>final_buf</name></name> <operator>+</operator> <name><name>sb</name><operator>-&gt;</operator><name>lineno</name><index>[<expr><name>lno</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>void</name></type> <name>split_overlap</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>split</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>tlno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>same</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>chunk_end_lno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>split</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name><name>blame_entry</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>split</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ignored</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>ignored</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unblamable</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>unblamable</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&lt;</operator> <name>tlno</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>suspect</name> <operator>=</operator> <call><name>blame_origin_incref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lno</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>lno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>s_lno</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>num_lines</name> <operator>=</operator> <name>tlno</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>lno</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>lno</name></name> <operator>+</operator> <name>tlno</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>s_lno</name> <operator>=</operator> <name>plno</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>lno</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>lno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>s_lno</name> <operator>=</operator> <name>plno</name> <operator>+</operator> <operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>-</operator> <name>tlno</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>same</name> <operator>&lt;</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>suspect</name> <operator>=</operator> <call><name>blame_origin_incref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>lno</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>lno</name></name> <operator>+</operator> <operator>(</operator><name>same</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>s_lno</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+</operator> <operator>(</operator><name>same</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>num_lines</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>-</operator> <name>same</name></expr>;</expr_stmt>
<expr_stmt><expr><name>chunk_end_lno</name> <operator>=</operator> <name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>lno</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>chunk_end_lno</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>lno</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>num_lines</name> <operator>=</operator> <name>chunk_end_lno</name> <operator>-</operator> <name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>lno</name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>num_lines</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>suspect</name> <operator>=</operator> <call><name>blame_origin_incref</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>split_blame</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>blamed</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>unblamed</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>split</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>suspect</name> <operator>&amp;&amp;</operator> <name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>suspect</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dup_entry</name><argument_list>(<argument><expr><name>unblamed</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>add_blame_entry</name><argument_list>(<argument><expr><name>unblamed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>add_blame_entry</name><argument_list>(<argument><expr><name>blamed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>suspect</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>suspect</name></expr>)</condition><block type="pseudo"><block_content>




<expr_stmt><expr><call><name>dup_entry</name><argument_list>(<argument><expr><name>blamed</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>suspect</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dup_entry</name><argument_list>(<argument><expr><name>unblamed</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_blame_entry</name><argument_list>(<argument><expr><name>blamed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>dup_entry</name><argument_list>(<argument><expr><name>blamed</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_blame_entry</name><argument_list>(<argument><expr><name>unblamed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>decref_split</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>split</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name><name>split</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>suspect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>reverse_blame</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>head</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
<expr_stmt><expr><name>head</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>tail</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>split_blame_at</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>new_suspect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>blame_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>suspect</name></name> <operator>=</operator> <name>new_suspect</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ignored</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>ignored</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>unblamable</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>unblamable</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>lno</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>lno</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>blame_line_tracker</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>is_parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s_lno</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>are_lines_adjacent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_line_tracker</name></name> <modifier>*</modifier></type><name>first</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_line_tracker</name></name> <modifier>*</modifier></type><name>second</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>first</name><operator>-&gt;</operator><name>is_parent</name></name> <operator>==</operator> <name><name>second</name><operator>-&gt;</operator><name>is_parent</name></name> <operator>&amp;&amp;</operator>
<name><name>first</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>second</name><operator>-&gt;</operator><name>s_lno</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>scan_parent_range</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>p_fps</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>fingerprint</name></name> <modifier>*</modifier></type><name>t_fps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t_idx</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr_lines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sim</name></decl>, <decl><type ref="prev"/><name>p_idx</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINGERPRINT_FILE_THRESHOLD</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>best_sim_val</name> <init>= <expr><name>FINGERPRINT_FILE_THRESHOLD</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>best_sim_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p_idx</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>p_idx</name> <operator>&lt;</operator> <name>from</name> <operator>+</operator> <name>nr_lines</name></expr>;</condition> <incr><expr><name>p_idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>sim</name> <operator>=</operator> <call><name>fingerprint_similarity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t_fps</name><index>[<expr><name>t_idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p_fps</name><index>[<expr><name>p_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sim</name> <operator>&lt;</operator> <name>best_sim_val</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sim</name> <operator>==</operator> <name>best_sim_val</name> <operator>&amp;&amp;</operator> <name>best_sim_idx</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<call><name>abs</name><argument_list>(<argument><expr><name>best_sim_idx</name> <operator>-</operator> <name>t_idx</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>abs</name><argument_list>(<argument><expr><name>p_idx</name> <operator>-</operator> <name>t_idx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>best_sim_val</name> <operator>=</operator> <name>sim</name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_sim_idx</name> <operator>=</operator> <name>p_idx</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>best_sim_idx</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>guess_line_blames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>tlno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>same</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parent_len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_line_tracker</name></name> <modifier>*</modifier></type><name>line_blames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>best_idx</name></decl>, <decl><type ref="prev"/><name>target_idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parent_slno</name> <init>= <expr><name>tlno</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>fuzzy_matches</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fuzzy_matches</name> <operator>=</operator> <call><name>fuzzy_find_matching_lines</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
<argument><expr><name>tlno</name></expr></argument>, <argument><expr><name>parent_slno</name></expr></argument>, <argument><expr><name>same</name></expr></argument>,
<argument><expr><name>parent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>same</name> <operator>-</operator> <name>tlno</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>target_idx</name> <operator>=</operator> <name>tlno</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fuzzy_matches</name> <operator>&amp;&amp;</operator> <name><name>fuzzy_matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>best_idx</name> <operator>=</operator> <name><name>fuzzy_matches</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>best_idx</name> <operator>=</operator> <call><name>scan_parent_range</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>fingerprints</name></name></expr></argument>,
<argument><expr><name><name>target</name><operator>-&gt;</operator><name>fingerprints</name></name></expr></argument>,
<argument><expr><name>target_idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>num_lines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>best_idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>line_blames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_parent</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>line_blames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>s_lno</name> <operator>=</operator> <name>best_idx</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>line_blames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_parent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>line_blames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>s_lno</name> <operator>=</operator> <name>target_idx</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fuzzy_matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>ignore_blame_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>diffp</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ignoredp</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_line_tracker</name></name> <modifier>*</modifier></type><name>line_blames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>entry_len</name></decl>, <decl><type ref="prev"/><name>nr_lines</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>






<expr_stmt><expr><name>entry_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nr_lines</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name></expr>;</expr_stmt> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr_lines</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nr_lines</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>are_lines_adjacent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>line_blames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>line_blames</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entry_len</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>split_blame_at</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>entry_len</name></expr></argument>,
<argument><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>line_blames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_parent</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>ignored</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name> <operator>=</operator> <call><name>blame_origin_incref</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>=</operator> <name><name>line_blames</name><index>[<expr><name>i</name> <operator>-</operator> <name>entry_len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>s_lno</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>ignoredp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ignoredp</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>unblamable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>diffp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>diffp</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>==</operator> <name>entry_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entry_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>void</name></type> <name>blame_chunk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>dstq</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>srcq</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>tlno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>same</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parent_len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_diffs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>*</operator><operator>*</operator><name>srcq</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>samep</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>diffp</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ignoredp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_line_tracker</name></name> <modifier>*</modifier></type><name>line_blames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&lt;</operator> <name>tlno</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>&gt;</operator> <name>tlno</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>split_blame_at</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>tlno</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>diffp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>diffp</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name> <operator>=</operator> <call><name>blame_origin_incref</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>samep</name></expr>;</expr_stmt>
<expr_stmt><expr><name>samep</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>






<if_stmt><if>if <condition>(<expr><name>samep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>*</operator><name>dstq</name> <operator>=</operator> <call><name>reverse_blame</name><argument_list>(<argument><expr><name>samep</name></expr></argument>, <argument><expr><operator>*</operator><operator>*</operator><name>dstq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dstq</name> <operator>=</operator> <operator>&amp;</operator><name><name>samep</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>reverse_blame</name><argument_list>(<argument><expr><name>diffp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>samep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>diffp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ignore_diffs</name> <operator>&amp;&amp;</operator> <name>same</name> <operator>-</operator> <name>tlno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>line_blames</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>blame_line_tracker</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>same</name> <operator>-</operator> <name>tlno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>guess_line_blames</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>tlno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>same</name></expr></argument>,
<argument><expr><name>parent_len</name></expr></argument>, <argument><expr><name>line_blames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>&lt;</operator> <name>same</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>&gt;</operator> <name>same</name></expr>)</condition> <block>{<block_content>




<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>split_blame_at</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>same</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name></expr></argument>,
<argument><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>samep</name></expr>;</expr_stmt>
<expr_stmt><expr><name>samep</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_diffs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ignore_blame_entry</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diffp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignoredp</name></expr></argument>,
<argument><expr><name>line_blames</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>-</operator> <name>tlno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>diffp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>diffp</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>line_blames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ignoredp</name></expr>)</condition> <block>{<block_content>









<expr_stmt><expr><operator>*</operator><operator>*</operator><name>dstq</name> <operator>=</operator> <call><name>reverse_blame</name><argument_list>(<argument><expr><name>ignoredp</name></expr></argument>, <argument><expr><operator>*</operator><operator>*</operator><name>dstq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dstq</name> <operator>=</operator> <operator>&amp;</operator><name><name>ignoredp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>*</operator><name>srcq</name> <operator>=</operator> <call><name>reverse_blame</name><argument_list>(<argument><expr><name>diffp</name></expr></argument>, <argument><expr><call><name>reverse_blame</name><argument_list>(<argument><expr><name>samep</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>diffp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>srcq</name> <operator>=</operator> <operator>&amp;</operator><name><name>diffp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<struct>struct <name>blame_chunk_cb_data</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_diffs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>dstq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>srcq</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>int</name></type> <name>blame_chunk_cb</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>start_a</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count_a</name></decl></parameter>,
<parameter><decl><type><name>long</name></type> <name>start_b</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count_b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_chunk_cb_data</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>start_a</name> <operator>-</operator> <name>start_b</name> <operator>!=</operator> <name><name>d</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"internal error in blame::blame_chunk_cb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>blame_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dstq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>srcq</name></name></expr></argument>, <argument><expr><name>start_b</name></expr></argument>, <argument><expr><name>start_a</name> <operator>-</operator> <name>start_b</name></expr></argument>,
<argument><expr><name>start_b</name> <operator>+</operator> <name>count_b</name></expr></argument>, <argument><expr><name>count_a</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
<argument><expr><name><name>d</name><operator>-&gt;</operator><name>ignore_diffs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>start_a</name> <operator>+</operator> <name>count_a</name> <operator>-</operator> <operator>(</operator><name>start_b</name> <operator>+</operator> <name>count_b</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>pass_blame_to_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_diffs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mmfile_t</name></type> <name>file_p</name></decl>, <decl><type ref="prev"/><name>file_o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_chunk_cb_data</name></name></type> <name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>newdest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>target</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name><name>d</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>.</operator><name>target</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>.</operator><name>ignore_diffs</name></name> <operator>=</operator> <name>ignore_diffs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>.</operator><name>dstq</name></name> <operator>=</operator> <operator>&amp;</operator><name>newdest</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>d</name><operator>.</operator><name>srcq</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>suspects</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_origin_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>diffopt</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_p</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>num_read_blob</name></name></expr></argument>, <argument><expr><name>ignore_diffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_origin_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>diffopt</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_o</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>num_read_blob</name></name></expr></argument>, <argument><expr><name>ignore_diffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>num_get_patch</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>diff_hunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>file_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_o</name></expr></argument>, <argument><expr><name>blame_chunk_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>xdl_opts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unable to generate diff (%s -&gt; %s)"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>blame_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>dstq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>srcq</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name><name>d</name><operator>.</operator><name>dstq</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_diffs</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newdest</name> <operator>=</operator> <call><name>llist_mergesort</name><argument_list>(<argument><expr><name>newdest</name></expr></argument>, <argument><expr><name>get_next_blame</name></expr></argument>,
<argument><expr><name>set_next_blame</name></expr></argument>,
<argument><expr><name>compare_blame_suspect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>queue_blames</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>newdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>
</block_content>}</block></function>










<function><type><name>unsigned</name></type> <name>blame_entry_score</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>score</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>score</name></name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>blame_nth_line</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>lno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>blame_nth_line</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>lno</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>num_lines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>ep</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ch</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>cp</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<return>return <expr><name>score</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_split_if_better</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>best_so_far</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>potential</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>potential</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>suspect</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>best_so_far</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>suspect</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>blame_entry_score</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>potential</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
<call><name>blame_entry_score</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_so_far</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name><name>potential</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>suspect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>decref_split</name><argument_list>(<argument><expr><name>best_so_far</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>best_so_far</name></expr></argument>, <argument><expr><name>potential</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name><name>blame_entry</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_split</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>tlno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>same</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>split</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>&lt;=</operator> <name>tlno</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tlno</name> <operator>&lt;</operator> <name>same</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name></type> <name><name>potential</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>tlno</name> <operator>+=</operator> <name><name>ent</name><operator>-&gt;</operator><name>s_lno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>same</name> <operator>+=</operator> <name><name>ent</name><operator>-&gt;</operator><name>s_lno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>split_overlap</name><argument_list>(<argument><expr><name>potential</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>tlno</name></expr></argument>, <argument><expr><name>plno</name></expr></argument>, <argument><expr><name>same</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_split_if_better</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>split</name></expr></argument>, <argument><expr><name>potential</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decref_split</name><argument_list>(<argument><expr><name>potential</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<struct>struct <name>handle_split_cb_data</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>split</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>plno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>tlno</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_split_cb</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>start_a</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count_a</name></decl></parameter>,
<parameter><decl><type><name>long</name></type> <name>start_b</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count_b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>handle_split_cb_data</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>handle_split</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>tlno</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>plno</name></name></expr></argument>, <argument><expr><name>start_b</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
<argument><expr><name><name>d</name><operator>-&gt;</operator><name>split</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>plno</name></name> <operator>=</operator> <name>start_a</name> <operator>+</operator> <name>count_a</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>tlno</name></name> <operator>=</operator> <name>start_b</name> <operator>+</operator> <name>count_b</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>find_copy_in_blob</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>split</name></decl></parameter>,
<parameter><decl><type><name>mmfile_t</name> <modifier>*</modifier></type><name>file_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mmfile_t</name></type> <name>file_o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>handle_split_cb_data</name></name></type> <name>d</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>.</operator><name>sb</name></name> <operator>=</operator> <name>sb</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>d</name><operator>.</operator><name>ent</name></name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>d</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>d</name><operator>.</operator><name>split</name></name> <operator>=</operator> <name>split</name></expr>;</expr_stmt>



<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>blame_nth_line</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>lno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>file_o</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>cp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>file_o</name><operator>.</operator><name>size</name></name> <operator>=</operator> <call><name>blame_nth_line</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>lno</name></name> <operator>+</operator> <name><name>ent</name><operator>-&gt;</operator><name>num_lines</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>cp</name></expr>;</expr_stmt>





<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>split</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name><name>blame_entry</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>diff_hunks</name><argument_list>(<argument><expr><name>file_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_o</name></expr></argument>, <argument><expr><name>handle_split_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>xdl_opts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unable to generate diff (%s)"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>handle_split</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>tlno</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>plno</name></name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>num_lines</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>filter_small</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>small</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>source</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>score_min</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>source</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>oldsmall</name> <init>= <expr><operator>*</operator><name>small</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>blame_entry_score</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>score_min</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>small</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>small</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>small</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>source</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>source</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>small</name> <operator>=</operator> <name>oldsmall</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>source</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>small</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>find_move_in_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>blamed</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>toosmall</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"/><name><name>split</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>unblamed</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>suspects</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>leftover</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mmfile_t</name></type> <name>file_p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unblamed</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>fill_origin_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>diffopt</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_p</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>num_read_blob</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>file_p</name><operator>.</operator><name>ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>






<do>do <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>unblamedtail</name> <init>= <expr><operator>&amp;</operator><name>unblamed</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>unblamed</name></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name>next</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_copy_in_blob</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>split</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>suspect</name> <operator>&amp;&amp;</operator>
<name><name>sb</name><operator>-&gt;</operator><name>move_score</name></name> <operator>&lt;</operator> <call><name>blame_entry_score</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>split_blame</name><argument_list>(<argument><expr><name>blamed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unblamedtail</name></expr></argument>, <argument><expr><name>split</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>leftover</name></expr>;</expr_stmt>
<expr_stmt><expr><name>leftover</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>decref_split</name><argument_list>(<argument><expr><name>split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>unblamedtail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>toosmall</name> <operator>=</operator> <call><name>filter_small</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>toosmall</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unblamed</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>move_score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>unblamed</name></expr>)</condition>;</do>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <call><name>reverse_blame</name><argument_list>(<argument><expr><name>leftover</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>blame_list</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name></type> <name><name>split</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>blame_list</name></name> <modifier>*</modifier></type><name>setup_blame_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>unblamed</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_ents_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_ents</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_list</name></name> <modifier>*</modifier></type><name>blame_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>unblamed</name></expr><operator>,</operator> <expr><name>num_ents</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>num_ents</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>num_ents</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>blame_list</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>num_ents</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>blame_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>unblamed</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>blame_list</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>ent</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>num_ents_p</name> <operator>=</operator> <name>num_ents</name></expr>;</expr_stmt>
<return>return <expr><name>blame_list</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>find_copy_in_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>blamed</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>toosmall</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_options</name></name></type> <name>diff_opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_list</name></name> <modifier>*</modifier></type><name>blame_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_ents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>unblamed</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>suspects</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>leftover</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unblamed</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>repo_diff_setup</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>flags</name><operator>.</operator><name>recursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>output_format</name></name> <operator>=</operator> <name>DIFF_FORMAT_NO_OUTPUT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>diff_setup_done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>PICKAXE_BLAME_COPY_HARDEST</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>PICKAXE_BLAME_COPY_HARDER</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>porigin</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>porigin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>diff_opts</name><operator>.</operator><name>flags</name><operator>.</operator><name>find_copies_harder</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>do_diff_cache</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>diff_tree_oid</name><argument_list>(<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>get_commit_tree_oid</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>diff_opts</name><operator>.</operator><name>flags</name><operator>.</operator><name>find_copies_harder</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>diffcore_std</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>unblamedtail</name> <init>= <expr><operator>&amp;</operator><name>unblamed</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>blame_list</name> <operator>=</operator> <call><name>setup_blame_list</name><argument_list>(<argument><expr><name>unblamed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_ents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>diff_queued_diff</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>diff_queued_diff</name><operator>.</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>norigin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mmfile_t</name></type> <name>file_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name></type> <name><name>potential</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DIFF_FILE_VALID</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>one</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>porigin</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>porigin</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>norigin</name> <operator>=</operator> <call><name>get_origin</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>norigin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>norigin</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_origin_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>diffopt</name></name></expr></argument>, <argument><expr><name>norigin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_p</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>num_read_blob</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>file_p</name><operator>.</operator><name>ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_ents</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>find_copy_in_blob</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>blame_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>ent</name></expr></argument>,
<argument><expr><name>norigin</name></expr></argument>, <argument><expr><name>potential</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_split_if_better</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>blame_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>split</name></expr></argument>,
<argument><expr><name>potential</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decref_split</name><argument_list>(<argument><expr><name>potential</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name>norigin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_ents</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>split</name> <init>= <expr><name><name>blame_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>split</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>suspect</name> <operator>&amp;&amp;</operator>
<name><name>sb</name><operator>-&gt;</operator><name>copy_score</name></name> <operator>&lt;</operator> <call><name>blame_entry_score</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>split_blame</name><argument_list>(<argument><expr><name>blamed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unblamedtail</name></expr></argument>, <argument><expr><name>split</name></expr></argument>,
<argument><expr><name><name>blame_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>blame_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>ent</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>leftover</name></expr>;</expr_stmt>
<expr_stmt><expr><name>leftover</name> <operator>=</operator> <name><name>blame_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>ent</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>decref_split</name><argument_list>(<argument><expr><name>split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>blame_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>unblamedtail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>toosmall</name> <operator>=</operator> <call><name>filter_small</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>toosmall</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unblamed</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>copy_score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>unblamed</name></expr>)</condition>;</do>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <call><name>reverse_blame</name><argument_list>(<argument><expr><name>leftover</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diff_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_pathspec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>diff_opts</name><operator>.</operator><name>pathspec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>pass_whole_blame</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>origin</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>suspects</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>porigin</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>origin</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>porigin</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name><name>origin</name><operator>-&gt;</operator><name>file</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>origin</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>suspects</name> <operator>=</operator> <name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>suspects</name></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name>porigin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>suspect</name></name> <operator>=</operator> <name>porigin</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>queue_blames</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>porigin</name></expr></argument>, <argument><expr><name>suspects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>first_scapegoat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reverse</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>revs</name><operator>-&gt;</operator><name>first_parent_only</name></name> <operator>&amp;&amp;</operator>
<name><name>commit</name><operator>-&gt;</operator><name>parents</name></name> <operator>&amp;&amp;</operator>
<name><name>commit</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name><name>commit</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>lookup_decoration</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>revs</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>num_scapegoats</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>first_scapegoat</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>commit_list_count</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>distribute_blame</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>blamed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>blamed</name> <operator>=</operator> <call><name>llist_mergesort</name><argument_list>(<argument><expr><name>blamed</name></expr></argument>, <argument><expr><name>get_next_blame</name></expr></argument>, <argument><expr><name>set_next_blame</name></expr></argument>,
<argument><expr><name>compare_blame_suspect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>blamed</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name> <init>= <expr><name><name>blamed</name><operator>-&gt;</operator><name>suspect</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>suspects</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>blamed</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>blamed</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>suspects</name></expr>;</expr_stmt>
<expr_stmt><expr><name>suspects</name> <operator>=</operator> <name>blamed</name></expr>;</expr_stmt>
<expr_stmt><expr><name>blamed</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>blamed</name> <operator>&amp;&amp;</operator> <name><name>blamed</name><operator>-&gt;</operator><name>suspect</name></name> <operator>==</operator> <name>porigin</name></expr>)</condition>;</do>
<expr_stmt><expr><name>suspects</name> <operator>=</operator> <call><name>reverse_blame</name><argument_list>(<argument><expr><name>suspects</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>queue_blames</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>porigin</name></expr></argument>, <argument><expr><name>suspects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXSG</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pass_blame</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>origin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name> <init>= <expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pass</name></decl>, <decl><type ref="prev"/><name>num_sg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>origin</name><operator>-&gt;</operator><name>commit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>sg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name><name>sg_buf</name><index>[<expr><name>MAXSG</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>sg_origin</name> <init>= <expr><name>sg_buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>toosmall</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>blames</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>blametail</name> <init>= <expr><operator>&amp;</operator><name>blames</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>num_sg</name> <operator>=</operator> <call><name>num_scapegoats</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num_sg</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>finish</name>;</goto></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>num_sg</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>sg_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sg_buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sg_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>sg_origin</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>num_sg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sg_origin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>





<for>for <control>(<init><expr><name>pass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>-</operator> <name><name>sb</name><operator>-&gt;</operator><name>no_whole_file_rename</name></name></expr>;</condition> <incr><expr><name>pass</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><argument_list>(<argument><expr><operator>*</operator><name>find</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <name>repository</name> <operator>*</operator></expr></argument>, <argument><expr>struct <name>commit</name> <operator>*</operator></expr></argument>, <argument><expr>struct <name>blame_origin</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>find</name> <operator>=</operator> <ternary><condition><expr><name>pass</name></expr> ?</condition><then> <expr><name>find_rename</name></expr> </then><else>: <expr><name>find_origin</name></expr></else></ternary></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sg</name> <operator>=</operator> <call><name>first_scapegoat</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>i</name> <operator>&lt;</operator> <name>num_sg</name> <operator>&amp;&amp;</operator> <name>sg</name></expr>;</condition>
<incr><expr><name>sg</name> <operator>=</operator> <name><name>sg</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>sg</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>same</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_commit</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>porigin</name> <operator>=</operator> <call><name>find</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>porigin</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>porigin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pass_whole_blame</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>, <argument><expr><name>porigin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name>porigin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finish</name>;</goto>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>same</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>sg_origin</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator>
<call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sg_origin</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>blob_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>porigin</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>same</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>same</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>porigin</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name>porigin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>num_commits</name></name><operator>++</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sg</name> <operator>=</operator> <call><name>first_scapegoat</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>i</name> <operator>&lt;</operator> <name>num_sg</name> <operator>&amp;&amp;</operator> <name>sg</name></expr>;</condition>
<incr><expr><name>sg</name> <operator>=</operator> <name><name>sg</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name> <init>= <expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>porigin</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>origin</name><operator>-&gt;</operator><name>previous</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name>porigin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>origin</name><operator>-&gt;</operator><name>previous</name></name> <operator>=</operator> <name>porigin</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pass_blame_to_parent</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>, <argument><expr><name>porigin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>finish</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>




<if_stmt><if>if <condition>(<expr><call><name>oidset_contains</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sg</name> <operator>=</operator> <call><name>first_scapegoat</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>i</name> <operator>&lt;</operator> <name>num_sg</name> <operator>&amp;&amp;</operator> <name>sg</name></expr>;</condition>
<incr><expr><name>sg</name> <operator>=</operator> <name><name>sg</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name> <init>= <expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>porigin</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pass_blame_to_parent</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>, <argument><expr><name>porigin</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>drop_origin_blob</name><argument_list>(<argument><expr><name>porigin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>finish</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>&amp;</operator> <name>PICKAXE_BLAME_MOVE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>filter_small</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toosmall</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>move_score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sg</name> <operator>=</operator> <call><name>first_scapegoat</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>i</name> <operator>&lt;</operator> <name>num_sg</name> <operator>&amp;&amp;</operator> <name>sg</name></expr>;</condition>
<incr><expr><name>sg</name> <operator>=</operator> <name><name>sg</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name> <init>= <expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>porigin</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>find_move_in_parent</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blametail</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toosmall</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>, <argument><expr><name>porigin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>&amp;</operator> <name>PICKAXE_BLAME_COPY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>copy_score</name></name> <operator>&gt;</operator> <name><name>sb</name><operator>-&gt;</operator><name>move_score</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>filter_small</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toosmall</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>copy_score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>copy_score</name></name> <operator>&lt;</operator> <name><name>sb</name><operator>-&gt;</operator><name>move_score</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <call><name>blame_merge</name><argument_list>(<argument><expr><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr></argument>, <argument><expr><name>toosmall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>toosmall</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>filter_small</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toosmall</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>copy_score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>finish</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sg</name> <operator>=</operator> <call><name>first_scapegoat</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>i</name> <operator>&lt;</operator> <name>num_sg</name> <operator>&amp;&amp;</operator> <name>sg</name></expr>;</condition>
<incr><expr><name>sg</name> <operator>=</operator> <name><name>sg</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>porigin</name> <init>= <expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>find_copy_in_parent</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blametail</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toosmall</name></expr></argument>,
<argument><expr><name>origin</name></expr></argument>, <argument><expr><name><name>sg</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>porigin</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>finish</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<label><name>finish</name>:</label>
<expr_stmt><expr><operator>*</operator><name>blametail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>distribute_blame</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>blames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name>toosmall</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>toosmall</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>tail</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>origin</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <name>toosmall</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_sg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>suspects</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>drop_origin_blob</name><argument_list>(<argument><expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name><name>sg_origin</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>drop_origin_blob</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sg_buf</name> <operator>!=</operator> <name>sg_origin</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sg_origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>assign_blame</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name> <init>= <expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><call><name>prio_queue_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>commits</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>commit</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>suspect</name> <init>= <expr><call><name>get_blame_suspects</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<while>while <condition>(<expr><name>suspect</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>suspect</name><operator>-&gt;</operator><name>suspects</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>suspect</name> <operator>=</operator> <name><name>suspect</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>suspect</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>prio_queue_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>commits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>commit</name> <operator>==</operator> <name><name>suspect</name><operator>-&gt;</operator><name>commit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name>suspect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name> <operator>||</operator>
<operator>(</operator><operator>!</operator><operator>(</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>revs</name><operator>-&gt;</operator><name>max_age</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>commit</name><operator>-&gt;</operator><name>date</name></name> <operator>&lt;</operator> <name><name>revs</name><operator>-&gt;</operator><name>max_age</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pass_blame</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>suspect</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UNINTERESTING</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>parsed</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mark_parents_uninteresting</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>commit</name><operator>-&gt;</operator><name>parents</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sb</name><operator>-&gt;</operator><name>show_root</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UNINTERESTING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ent</name> <operator>=</operator> <name><name>suspect</name><operator>-&gt;</operator><name>suspects</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ent</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>suspect</name><operator>-&gt;</operator><name>guilty</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>ent</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>found_guilty_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>sb</name><operator>-&gt;</operator><name>found_guilty_entry</name></name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>found_guilty_entry_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ent</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>sb</name><operator>-&gt;</operator><name>ent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>ent</name></name> <operator>=</operator> <name><name>suspect</name><operator>-&gt;</operator><name>suspects</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suspect</name><operator>-&gt;</operator><name>suspects</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>blame_origin_decref</name><argument_list>(<argument><expr><name>suspect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><call><name>sanity_check_refcnt</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_lines</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>=</operator> <call><name>find_line_starts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>final_buf</name></name></expr></argument>,
<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>final_buf_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>sb</name><operator>-&gt;</operator><name>num_lines</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>find_single_final</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>item</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name><name>revs</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Non commit %s?"</literal></expr></argument>, <argument><expr><name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"More than one commit to dig from %s and %s?"</literal></expr></argument>,
<argument><expr><name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>name_p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>name_p</name> <operator>=</operator> <call><name>xstrdup_or_null</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>dwim_reverse_initial</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>





<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>head_commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>head_oid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>nr</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>obj</name> <operator>=</operator> <name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name><name>revs</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>resolve_ref_unsafe</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><name>RESOLVE_REF_READING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>head_commit</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name><name>revs</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>head_oid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head_commit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UNINTERESTING</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_pending_object</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>head_commit</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name_p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>name_p</name> <operator>=</operator> <name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>find_single_initial</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>item</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name><name>revs</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Non commit %s?"</literal></expr></argument>, <argument><expr><name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"More than one commit to dig up from, %s and %s?"</literal></expr></argument>,
<argument><expr><name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>revs</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>dwim_reverse_initial</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"No commit to dig up from?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>name_p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>name_p</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>init_scoreboard</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>blame_scoreboard</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>move_score</name></name> <operator>=</operator> <name>BLAME_DEFAULT_MOVE_SCORE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>copy_score</name></name> <operator>=</operator> <name>BLAME_DEFAULT_COPY_SCORE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setup_scoreboard</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_scoreboard</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>final_commit_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>final_commit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_blame_suspects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blame_suspects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>-&gt;</operator><name>contents_from</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--contents and --reverse do not blend well."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sb</name><operator>-&gt;</operator><name>repo</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"repo is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>final</name></name> <operator>=</operator> <call><name>find_single_final</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>final_commit_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>commits</name><operator>.</operator><name>compare</name></name> <operator>=</operator> <name>compare_commits_by_commit_date</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>final</name></name> <operator>=</operator> <call><name>find_single_initial</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>final_commit_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>commits</name><operator>.</operator><name>compare</name></name> <operator>=</operator> <name>compare_commits_by_reverse_commit_date</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>final</name></name> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>-&gt;</operator><name>contents_from</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use --contents with final commit object name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>first_parent_only</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>children</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sb</name><operator>-&gt;</operator><name>final</name></name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>setup_work_tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>final</name></name> <operator>=</operator> <call><name>fake_working_tree_commit</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>diffopt</name></name></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>contents_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_pending_object</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sb</name><operator>-&gt;</operator><name>final</name><operator>-&gt;</operator><name>object</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>first_parent_only</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>final_commit</name> <operator>=</operator> <call><name>find_single_final</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>final_commit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--reverse and --first-parent together require specified latest commit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><call><name>prepare_revision_walk</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"revision walk setup failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>reverse</name></name> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>first_parent_only</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name>final_commit</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>children</name><operator>.</operator><name>name</name></name> <operator>=</operator> <literal type="string">"children"</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>parents</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>final</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>l</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_decoration</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>children</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"not unique item in first-parent chain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>final</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"--reverse --first-parent together require range along first-parent chain"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>final</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>get_blame_suspects</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>final</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>final_buf</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>final_buf_size</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>get_origin</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>final</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fill_blob_sha1_and_mode</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no such path %s in %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>final_commit_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>revs</name><operator>-&gt;</operator><name>diffopt</name><operator>.</operator><name>flags</name><operator>.</operator><name>allow_textconv</name></name> <operator>&amp;&amp;</operator>
<call><name>textconv_object</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>final_buf</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>final_buf_size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>final_buf</name></name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>final_buf_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sb</name><operator>-&gt;</operator><name>final_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot read blob %s for path %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>blob_oid</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>num_read_blob</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prepare_lines</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>orig</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>orig</name> <operator>=</operator> <name>o</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>final_commit_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>blame_entry_prepend</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,
<parameter><decl><type><name>long</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>blame_origin</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>blame_entry</name></name> <modifier>*</modifier></type><name>new_head</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>blame_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>lno</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>num_lines</name></name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>suspect</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>s_lno</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>blame_origin_incref</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>new_head</name></expr>;</return>
</block_content>}</block></function>
</unit>
