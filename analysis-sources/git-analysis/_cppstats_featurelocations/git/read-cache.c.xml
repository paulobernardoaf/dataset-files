<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\read-cache.c">




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diffcore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tempfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lockfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache-tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blob.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"resolve-undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"strbuf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"varint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"split-index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fsmonitor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"progress.h"</cpp:file></cpp:include>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CE_NAMEMASK</name></cpp:macro> <cpp:value>(0x0fff)</cpp:value></cpp:define>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_EXT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( (s[0]&lt;&lt;24)|(s[1]&lt;&lt;16)|(s[2]&lt;&lt;8)|(s[3]) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_EXT_TREE</name></cpp:macro> <cpp:value>0x54524545</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_EXT_RESOLVE_UNDO</name></cpp:macro> <cpp:value>0x52455543</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_EXT_LINK</name></cpp:macro> <cpp:value>0x6c696e6b</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_EXT_UNTRACKED</name></cpp:macro> <cpp:value>0x554E5452</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_EXT_FSMONITOR</name></cpp:macro> <cpp:value>0x46534D4E</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_EXT_ENDOFINDEXENTRIES</name></cpp:macro> <cpp:value>0x454F4945</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_EXT_INDEXENTRYOFFSETTABLE</name></cpp:macro> <cpp:value>0x49454F54</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTMASK</name></cpp:macro> <cpp:value>(RESOLVE_UNDO_CHANGED | CACHE_TREE_CHANGED | CE_ENTRY_ADDED | CE_ENTRY_REMOVED | CE_ENTRY_CHANGED | SPLIT_INDEX_ORDERED | UNTRACKED_CHANGED | FSMONITOR_CHANGED)</cpp:value></cpp:define>












<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_ENTRY_PATH_LENGTH</name></cpp:macro> <cpp:value>80</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>mem_pool__ce_alloc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mem_pool</name></name> <modifier>*</modifier></type><name>mem_pool</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>mem_pool_alloc</name><argument_list>(<argument><expr><name>mem_pool</name></expr></argument>, <argument><expr><call><name>cache_entry_size</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>mem_pool_allocated</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>mem_pool__ce_calloc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mem_pool</name></name> <modifier>*</modifier></type><name>mem_pool</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type> <name>ce</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>mem_pool_calloc</name><argument_list>(<argument><expr><name>mem_pool</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>cache_entry_size</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>mem_pool_allocated</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>mem_pool</name></name> <modifier>*</modifier></type><name>find_mem_pool</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>mem_pool</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pool_ptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>split_index</name></name> <operator>&amp;&amp;</operator> <name><name>istate</name><operator>-&gt;</operator><name>split_index</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pool_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>split_index</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>pool_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>pool_ptr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mem_pool_init</name><argument_list>(<argument><expr><name>pool_ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>*</operator><name>pool_ptr</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alternate_index_output</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_index_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>nr</name></expr>]</index></name> <operator>=</operator> <name>ce</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_name_hash</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>replace_index_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>old</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>nr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>replace_index_entry_in_base</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_name_hash</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CE_HASHED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_UPDATE_IN_BASE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mark_fsmonitor_invalid</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>CE_ENTRY_CHANGED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rename_index_entry_at</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>old_entry</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>nr</name></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>new_entry</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_cache_entry</name><argument_list>(<argument><expr><name>new_entry</name></expr></argument>, <argument><expr><name>old_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_entry</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CE_HASHED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_entry</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>namelen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_entry</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new_entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>, <argument><expr><name>namelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cache_tree_invalidate_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>old_entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>untracked_cache_remove_from_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>old_entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_index_entry_at</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>new_entry</name></expr></argument>, <argument><expr><name>ADD_CACHE_OK_TO_ADD</name><operator>|</operator><name>ADD_CACHE_OK_TO_REPLACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>fill_stat_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>stat_data</name></name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>st</name><operator>-&gt;</operator><name>st_ctime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>st</name><operator>-&gt;</operator><name>st_mtime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>ST_CTIME_NSEC</name><argument_list>(<argument><expr><operator>*</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>ST_MTIME_NSEC</name><argument_list>(<argument><expr><operator>*</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_dev</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_dev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_ino</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_ino</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_uid</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_uid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_gid</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_gid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>sd_size</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_size</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>match_stat_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat_data</name></name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>changed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sd</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>st</name><operator>-&gt;</operator><name>st_mtime</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>MTIME_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>trust_ctime</name> <operator>&amp;&amp;</operator> <name>check_stat</name> <operator>&amp;&amp;</operator>
<name><name>sd</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>sec</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>st</name><operator>-&gt;</operator><name>st_ctime</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>CTIME_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NSEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>check_stat</name> <operator>&amp;&amp;</operator> <name><name>sd</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name> <operator>!=</operator> <call><name>ST_MTIME_NSEC</name><argument_list>(<argument><expr><operator>*</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>MTIME_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>trust_ctime</name> <operator>&amp;&amp;</operator> <name>check_stat</name> <operator>&amp;&amp;</operator>
<name><name>sd</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>nsec</name></name> <operator>!=</operator> <call><name>ST_CTIME_NSEC</name><argument_list>(<argument><expr><operator>*</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>CTIME_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>check_stat</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sd</name><operator>-&gt;</operator><name>sd_uid</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>st</name><operator>-&gt;</operator><name>st_uid</name></name> <operator>||</operator>
<name><name>sd</name><operator>-&gt;</operator><name>sd_gid</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>st</name><operator>-&gt;</operator><name>st_gid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>OWNER_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sd</name><operator>-&gt;</operator><name>sd_ino</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>st</name><operator>-&gt;</operator><name>st_ino</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>INODE_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_STDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>





<if_stmt><if>if <condition>(<expr><name>check_stat</name> <operator>&amp;&amp;</operator> <name><name>sd</name><operator>-&gt;</operator><name>sd_dev</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>st</name><operator>-&gt;</operator><name>st_dev</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>INODE_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>sd</name><operator>-&gt;</operator><name>sd_size</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>st</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>DATA_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>changed</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>fill_stat_cache_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name></name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>assume_unchanged</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ce_mark_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mark_fsmonitor_valid</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_compare_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>git_open_cloexec</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>index_fd</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>OBJ_BLOB</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>match</name> <operator>=</operator> <operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>
<return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_compare_link</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>expected_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strbuf_readlink</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>expected_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <name><name>sb</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_compare_gitlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>









<if_stmt><if>if <condition>(<expr><call><name>resolve_gitlink_ref</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_modified_check_fs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IFMT</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>S_IFREG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>ce_compare_data</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DATA_CHANGED</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>S_IFLNK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>ce_compare_link</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><call><name>xsize_t</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DATA_CHANGED</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>S_IFDIR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><call><name>ce_compare_gitlink</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DATA_CHANGED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<default>default:</default>
<return>return <expr><name>TYPE_CHANGED</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_match_stat_basic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>changed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_REMOVE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MODE_CHANGED</name> <operator>|</operator> <name>DATA_CHANGED</name> <operator>|</operator> <name>TYPE_CHANGED</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>&amp;</operator> <name>S_IFMT</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>S_IFREG</name></expr>:</case>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <ternary><condition><expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TYPE_CHANGED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>trust_executable_bit</name> <operator>&amp;&amp;</operator>
<operator>(</operator><literal type="number">0100</literal> <operator>&amp;</operator> <operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>^</operator> <name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>MODE_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>S_IFLNK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>has_symlinks</name> <operator>||</operator> <operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>TYPE_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>S_IFGITLINK</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>TYPE_CHANGED</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>ce_compare_gitlink</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>DATA_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>changed</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unsupported ce_mode: %o"</literal></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><name>changed</name> <operator>|=</operator> <call><name>match_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name></name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_size</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_empty_blob_sha1</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>DATA_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>changed</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_racy_stat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat_data</name></name> <modifier>*</modifier></type><name>sd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name> <operator>&amp;&amp;</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NSEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<operator>(</operator><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name> <operator>&lt;</operator> <name><name>sd</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name> <operator>||</operator>
<operator>(</operator><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name> <operator>==</operator> <name><name>sd</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name> <operator>&amp;&amp;</operator>
<name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>nsec</name></name> <operator>&lt;=</operator> <name><name>sd</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name><operator>)</operator><operator>)</operator>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name> <operator>&lt;=</operator> <name><name>sd</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_racy_timestamp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>!</operator><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>is_racy_stat</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>match_stat_data_racy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat_data</name></name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_racy_stat</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MTIME_CHANGED</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>match_stat_data</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>ie_match_stat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>changed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_valid</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_IGNORE_VALID</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_skip_worktree</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_IGNORE_SKIP_WORKTREE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>assume_racy_is_modified</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_RACY_IS_DIRTY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_fsmonitor</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_IGNORE_FSMONITOR</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_fsmonitor</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>refresh_fsmonitor</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_skip_worktree</name> <operator>&amp;&amp;</operator> <call><name>ce_skip_worktree</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_valid</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_fsmonitor</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_FSMONITOR_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><call><name>ce_intent_to_add</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DATA_CHANGED</name> <operator>|</operator> <name>TYPE_CHANGED</name> <operator>|</operator> <name>MODE_CHANGED</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>changed</name> <operator>=</operator> <call><name>ce_match_stat_basic</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

















<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed</name> <operator>&amp;&amp;</operator> <call><name>is_racy_timestamp</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>assume_racy_is_modified</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <name>DATA_CHANGED</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>changed</name> <operator>|=</operator> <call><name>ce_modified_check_fs</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>changed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>ie_modified</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>changed</name></decl>, <decl><type ref="prev"/><name>changed_fs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>changed</name> <operator>=</operator> <call><name>ie_match_stat</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>changed</name> <operator>&amp;</operator> <operator>(</operator><name>MODE_CHANGED</name> <operator>|</operator> <name>TYPE_CHANGED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>changed</name></expr>;</return></block_content></block></if></if_stmt>















<if_stmt><if>if <condition>(<expr><operator>(</operator><name>changed</name> <operator>&amp;</operator> <name>DATA_CHANGED</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_size</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>changed</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>changed_fs</name> <operator>=</operator> <call><name>ce_modified_check_fs</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>changed_fs</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>changed</name> <operator>|</operator> <name>changed_fs</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>base_name_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>len1</name> <operator>&lt;</operator> <name>len2</name></expr> ?</condition><then> <expr><name>len1</name></expr> </then><else>: <expr><name>len2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <name><name>name1</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>name2</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c1</name> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c2</name> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>c1</name> <operator>&lt;</operator> <name>c2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>c1</name> <operator>&gt;</operator> <name>c2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>











<function><type><name>int</name></type> <name>df_name_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>len1</name> <operator>&lt;</operator> <name>len2</name></expr> ?</condition><then> <expr><name>len1</name></expr> </then><else>: <expr><name>len2</name></expr></else></ternary></expr></init></decl>, <decl><type ref="prev"/><name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <name><name>name1</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c1</name> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>name2</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c2</name> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>c2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>c1</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>c1</name> <operator>-</operator> <name>c2</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>name_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name1</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>min_len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>len1</name> <operator>&lt;</operator> <name>len2</name><operator>)</operator></expr> ?</condition><then> <expr><name>len1</name></expr> </then><else>: <expr><name>len2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>min_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&lt;</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>cache_name_stage_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>name_compare</name><argument_list>(<argument><expr><name>name1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>stage1</name> <operator>&lt;</operator> <name>stage2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stage1</name> <operator>&gt;</operator> <name>stage2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>index_name_stage_pos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>

<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>last</name> <operator>&gt;</operator> <name>first</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>next</name> <init>= <expr><name>first</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>last</name> <operator>-</operator> <name>first</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>next</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>cache_name_stage_compare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>next</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>next</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>-</operator><name>first</name><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>index_name_pos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>index_name_stage_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>remove_index_entry_at</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>record_resolve_undo</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_name_hash</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>save_or_free_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>CE_ENTRY_REMOVED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>MOVE_ARRAY</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>remove_marked_cache_entries</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>invalidate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ce_array</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ce_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>&amp;</operator> <name>CE_REMOVE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>invalidate</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cache_tree_invalidate_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>,
<argument><expr><name><name>ce_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>untracked_cache_remove_from_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>,
<argument><expr><name><name>ce_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>remove_name_hash</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>save_or_free_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ce_array</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>ce_array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>CE_ENTRY_REMOVED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>remove_file_from_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>cache_tree_invalidate_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>untracked_cache_remove_from_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_index_entry_at</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>namelen</name> <operator>!=</operator> <call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>index_name_pos_also_unmerged</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>pos</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>||</operator>
<call><name>compare_name</name><argument_list>(<argument><expr><operator>(</operator><name>ce</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator>
<call><name>ce_stage</name><argument_list>(<argument><expr><operator>(</operator><name>ce</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>compare_name</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>pos</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>different_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>create_alias_ce</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>new_entry</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>alias</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_ADDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"will not add file alias '%s' ('%s' already exists in index)"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ce_namelen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_entry</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new_entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_cache_entry</name><argument_list>(<argument><expr><name>new_entry</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>save_or_free_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>new_entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_object_name_for_intent_to_add_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>write_object_file</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>blob_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot create an empty blob in the object database"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>add_to_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>namelen</name></decl>, <decl><type ref="prev"/><name>was_same</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mode_t</name></type> <name>st_mode</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>alias</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ce_option</name> <init>= <expr><name>CE_MATCH_IGNORE_VALID</name><operator>|</operator><name>CE_MATCH_IGNORE_SKIP_WORKTREE</name><operator>|</operator><name>CE_MATCH_RACY_IS_DIRTY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>verbose</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>ADD_CACHE_VERBOSE</name> <operator>|</operator> <name>ADD_CACHE_PRETEND</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pretend</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>ADD_CACHE_PRETEND</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>intent_only</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>ADD_CACHE_INTENT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>add_option</name> <init>= <expr><operator>(</operator><name>ADD_CACHE_OK_TO_ADD</name><operator>|</operator><name>ADD_CACHE_OK_TO_REPLACE</name><operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>intent_only</name></expr> ?</condition><then> <expr><name>ADD_CACHE_NEW_ONLY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hash_flags</name> <init>= <expr><name>HASH_WRITE_OBJECT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ADD_CACHE_RENORMALIZE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hash_flags</name> <operator>|=</operator> <name>HASH_RENORMALIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name>st_mode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>st_mode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: can only add regular files, symbolic links or git-directories"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>namelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>resolve_gitlink_ref</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"'%s' does not have a commit checked out"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>namelen</name> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><name>namelen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>namelen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>namelen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>intent_only</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fill_stat_cache_info</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_INTENT_TO_ADD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>trust_executable_bit</name> <operator>&amp;&amp;</operator> <name>has_symlinks</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>create_ce_mode</name><argument_list>(<argument><expr><name>st_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>index_name_pos_also_unmerged</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ent</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><literal type="number">0</literal> <operator>&lt;=</operator> <name>pos</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>ce_mode_from_stat</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><name>st_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>






<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>adjust_dirname_case</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ADD_CACHE_RENORMALIZE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>index_file_exists</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ignore_case</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>alias</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ce_stage</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ie_match_stat</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>ce_option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>alias</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ce_mark_uptodate</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>alias</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_ADDED</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>intent_only</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>index_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to index file '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_object_name_for_intent_to_add_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ignore_case</name> <operator>&amp;&amp;</operator> <name>alias</name> <operator>&amp;&amp;</operator> <call><name>different_name</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>create_alias_ce</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_ADDED</name></expr>;</expr_stmt>


<expr_stmt><expr><name>was_same</name> <operator>=</operator> <operator>(</operator><name>alias</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ce_stage</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>alias</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>==</operator> <name><name>alias</name><operator>-&gt;</operator><name>ce_mode</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pretend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>add_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>add_option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to add '%s' to index"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>was_same</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"add '%s'\n"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>add_file_to_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to stat '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>add_to_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>make_empty_cache_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>mem_pool__ce_calloc</name><argument_list>(<argument><expr><call><name>find_mem_pool</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>make_empty_transient_cache_entry</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>cache_entry_size</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>make_cache_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mode</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>refresh_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid path '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>=</operator> <call><name>create_ce_flags</name><argument_list>(<argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>create_ce_mode</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>refresh_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>refresh_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ce</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>discard_cache_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>make_transient_cache_entry</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid path '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>make_empty_transient_cache_entry</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>=</operator> <call><name>create_ce_flags</name><argument_list>(<argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>create_ce_mode</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>int</name></type> <name>chmod_index_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name>char</name></type> <name>flip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>flip</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>|=</operator> <literal type="number">0111</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">0111</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>cache_tree_invalidate_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_UPDATE_IN_BASE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mark_fsmonitor_invalid</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>CE_ENTRY_CHANGED</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>ce_same_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>int</name></type> <name>verify_dotfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>







<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rest</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>is_dir_sep</name><argument_list>(<argument><expr><operator>*</operator><name>rest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>rest</name></expr>)</condition> <block>{<block_content>









<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<case>case <expr><literal type="char">'G'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>rest</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <name><name>rest</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'I'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rest</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>rest</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'T'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rest</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>is_dir_sep</name><argument_list>(<argument><expr><name><name>rest</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rest</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_iprefix</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><literal type="string">"modules"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>*</operator><name>rest</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>is_dir_sep</name><argument_list>(<argument><expr><operator>*</operator><name>rest</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>rest</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>is_dir_sep</name><argument_list>(<argument><expr><name><name>rest</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></switch>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>verify_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>has_dos_drive_prefix</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_valid_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<goto>goto <name>inside</name>;</goto>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_dir_sep</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<label><name>inside</name>:</label>
<if_stmt><if>if <condition>(<expr><name>protect_hfs</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_hfs_dotgit</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_hfs_dotgitmodules</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>protect_ntfs</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GIT_WINDOWS_NATIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><call><name>is_ntfs_dotgit</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_ntfs_dotgitmodules</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>path</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>verify_dotfile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<call><name>is_dir_sep</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>protect_ntfs</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_ntfs_dotgit</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_ntfs_dotgitmodules</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>path</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>has_file_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ok_to_replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stage</name> <init>= <expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <call><name>ce_namelen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>stage</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_REMOVE</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok_to_replace</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>remove_index_entry_at</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>--</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type> <name>strcmp_offset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>first_change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>k</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_change</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>s1</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name><name>s2</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s1</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><operator>*</operator><name>first_change</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>s1</name><index>[<expr><name>k</name></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>s2</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>has_dir_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ok_to_replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stage</name> <init>= <expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash</name> <init>= <expr><name>name</name> <operator>+</operator> <call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len_eq_last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp_last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>











<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmp_last</name> <operator>=</operator> <call><name>strcmp_offset</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>len_eq_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp_last</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len_eq_last</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>






</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmp_last</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>






</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>--</operator><name>slash</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>slash</name> <operator>&lt;=</operator> <name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>retval</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>slash</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmp_last</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>








<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>len_eq_last</name></expr>)</condition> <block>{<block_content>












<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>len_eq_last</name></expr>)</condition> <block>{<block_content>









<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>ce_namelen</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>









<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></if></if_stmt>








</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_stage_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>








<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>&amp;</operator> <name>CE_REMOVE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok_to_replace</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>remove_index_entry_at</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>






<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ce_namelen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>len</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>stage</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_REMOVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>






<return>return <expr><name>retval</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type> <name>check_file_directory_conflict</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ok_to_replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_REMOVE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>






<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>has_file_name</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>ok_to_replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<return>return <expr><name>retval</name> <operator>+</operator> <call><name>has_dir_name</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>ok_to_replace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_index_entry_with_check</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok_to_add</name> <init>= <expr><name>option</name> <operator>&amp;</operator> <name>ADD_CACHE_OK_TO_ADD</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok_to_replace</name> <init>= <expr><name>option</name> <operator>&amp;</operator> <name>ADD_CACHE_OK_TO_REPLACE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>skip_df_check</name> <init>= <expr><name>option</name> <operator>&amp;</operator> <name>ADD_CACHE_SKIP_DFCHECK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_only</name> <init>= <expr><name>option</name> <operator>&amp;</operator> <name>ADD_CACHE_NEW_ONLY</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>option</name> <operator>&amp;</operator> <name>ADD_CACHE_KEEP_CACHE_TREE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>cache_tree_invalidate_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_pos_to_insert_pos</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_stage_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_only</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>replace_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>option</name> <operator>&amp;</operator> <name>ADD_CACHE_KEEP_CACHE_TREE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>untracked_cache_add_to_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator> <call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><call><name>ce_same_name</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ok_to_add</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remove_index_entry_at</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok_to_add</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_path</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid path '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_df_check</name> <operator>&amp;&amp;</operator>
<call><name>check_file_directory_conflict</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>ok_to_replace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok_to_replace</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"'%s' appears as both a file and as a directory"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_stage_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>add_index_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>option</name> <operator>&amp;</operator> <name>ADD_CACHE_JUST_APPEND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>add_index_entry_with_check</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>ret</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&gt;</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MOVE_ARRAY</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name> <operator>+</operator> <name>pos</name></expr></argument>,
<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>-</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>set_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>CE_ENTRY_ADDED</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>refresh_cache_ent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>err</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>changed_ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>updated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>changed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>refresh</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_REFRESH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_valid</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_IGNORE_VALID</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_skip_worktree</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_IGNORE_SKIP_WORKTREE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_missing</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_IGNORE_MISSING</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_fsmonitor</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>CE_MATCH_IGNORE_FSMONITOR</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>refresh</name> <operator>||</operator> <call><name>ce_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ce</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_fsmonitor</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>refresh_fsmonitor</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_skip_worktree</name> <operator>&amp;&amp;</operator> <call><name>ce_skip_worktree</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ce_mark_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_valid</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_VALID</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ce_mark_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_fsmonitor</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_FSMONITOR_VALID</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ce_mark_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>has_symlink_leading_path</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ignore_missing</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ce</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ignore_missing</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ce</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>changed</name> <operator>=</operator> <call><name>ie_match_stat</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>changed_ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>changed_ret</name> <operator>=</operator> <name>changed</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed</name></expr>)</condition> <block>{<block_content>







<if_stmt><if>if <condition>(<expr><name>ignore_valid</name> <operator>&amp;&amp;</operator> <name>assume_unchanged</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if> 
<else>else <block>{<block_content>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ce_mark_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mark_fsmonitor_valid</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ie_modified</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>updated</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_cache_entry</name><argument_list>(<argument><expr><name>updated</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>updated</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_stat_cache_info</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>updated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_valid</name> <operator>&amp;&amp;</operator> <name>assume_unchanged</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>updated</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<return>return <expr><name>updated</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_porcelain</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type> <name>first</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>header_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>in_porcelain</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>first</name> <operator>&amp;&amp;</operator> <name>header_msg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>header_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_refresh_and_write_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>refresh_flags</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>write_flags</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>gentle</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>seen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>header_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>lock_file</name></name></type> <name>lock_file</name> <init>= <expr><name>LOCK_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>repo_hold_locked_index</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock_file</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gentle</name> <operator>&amp;&amp;</operator> <name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>refresh_index</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>refresh_flags</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name>header_msg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>fd</name> <operator>&amp;&amp;</operator> <call><name>write_locked_index</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock_file</name></expr></argument>, <argument><expr><name>COMMIT_LOCK</name> <operator>|</operator> <name>write_flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>refresh_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>seen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>header_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>really</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REFRESH_REALLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>allow_unmerged</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REFRESH_UNMERGED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quiet</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REFRESH_QUIET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>not_new</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REFRESH_IGNORE_MISSING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ignore_submodules</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REFRESH_IGNORE_SUBMODULES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_porcelain</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REFRESH_IN_PORCELAIN</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>options</name> <init>= <expr><operator>(</operator><name>CE_MATCH_REFRESH</name> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>really</name></expr> ?</condition><then> <expr><name>CE_MATCH_IGNORE_VALID</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>not_new</name></expr> ?</condition><then> <expr><name>CE_MATCH_IGNORE_MISSING</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modified_fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>deleted_fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typechange_fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>added_fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unmerged_fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>progress</name></name> <modifier>*</modifier></type><name>progress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REFRESH_PROGRESS</name> <operator>&amp;&amp;</operator> <call><name>isatty</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>start_delayed_progress</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Refresh index"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>trace_performance_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>modified_fmt</name> <operator>=</operator> <ternary><condition><expr><name>in_porcelain</name></expr> ?</condition><then> <expr><literal type="string">"M\t%s\n"</literal></expr> </then><else>: <expr><literal type="string">"%s: needs update\n"</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>deleted_fmt</name> <operator>=</operator> <ternary><condition><expr><name>in_porcelain</name></expr> ?</condition><then> <expr><literal type="string">"D\t%s\n"</literal></expr> </then><else>: <expr><literal type="string">"%s: needs update\n"</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>typechange_fmt</name> <operator>=</operator> <ternary><condition><expr><name>in_porcelain</name></expr> ?</condition><then> <expr><literal type="string">"T\t%s\n"</literal></expr> </then><else>: <expr><literal type="string">"%s: needs update\n"</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>added_fmt</name> <operator>=</operator> <ternary><condition><expr><name>in_porcelain</name></expr> ?</condition><then> <expr><literal type="string">"A\t%s\n"</literal></expr> </then><else>: <expr><literal type="string">"%s: needs update\n"</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>unmerged_fmt</name> <operator>=</operator> <ternary><condition><expr><name>in_porcelain</name></expr> ?</condition><then> <expr><literal type="string">"U\t%s\n"</literal></expr> </then><else>: <expr><literal type="string">"%s: needs merge\n"</literal></expr></else></ternary></expr>;</expr_stmt>





<expr_stmt><expr><call><name>preload_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cache_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>changed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>filtered</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_submodules</name> <operator>&amp;&amp;</operator> <call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pathspec</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ce_path_match</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>filtered</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>allow_unmerged</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filtered</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>show_file</name><argument_list>(<argument><expr><name>unmerged_fmt</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>in_porcelain</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>first</name></expr></argument>, <argument><expr><name>header_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>has_errors</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filtered</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>new_entry</name> <operator>=</operator> <call><name>refresh_cache_ent</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cache_errno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_entry</name> <operator>==</operator> <name>ce</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_entry</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>really</name> <operator>&amp;&amp;</operator> <name>cache_errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CE_VALID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_UPDATE_IN_BASE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mark_fsmonitor_invalid</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>CE_ENTRY_CHANGED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cache_errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>deleted_fmt</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>ce_intent_to_add</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>added_fmt</name></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><name>changed</name> <operator>&amp;</operator> <name>TYPE_CHANGED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>typechange_fmt</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>modified_fmt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>show_file</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>,
<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>in_porcelain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>, <argument><expr><name>header_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>has_errors</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>replace_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>new_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>display_progress</name><argument_list>(<argument><expr><name>progress</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stop_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>trace_performance_leave</name><argument_list>(<argument><expr><literal type="string">"refresh index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>has_errors</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>refresh_cache_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>refresh_cache_ent</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX_FORMAT_DEFAULT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>get_index_format_default</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>envversion</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"GIT_INDEX_VERSION"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>version</name> <init>= <expr><name>INDEX_FORMAT_DEFAULT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>envversion</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prepare_repo_settings</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>settings</name><operator>.</operator><name>index_version</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>version</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>settings</name><operator>.</operator><name>index_version</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>version</name> <operator>&lt;</operator> <name>INDEX_FORMAT_LB</name> <operator>||</operator> <name>INDEX_FORMAT_UB</name> <operator>&lt;</operator> <name>version</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"index.version set, but the value is invalid.\n"</literal>
<literal type="string">"Using version %i"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INDEX_FORMAT_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>INDEX_FORMAT_DEFAULT</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>version</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>envversion</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name> <operator>||</operator>
<name>version</name> <operator>&lt;</operator> <name>INDEX_FORMAT_LB</name> <operator>||</operator> <name>INDEX_FORMAT_UB</name> <operator>&lt;</operator> <name>version</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"GIT_INDEX_VERSION set, but the value is invalid.\n"</literal>
<literal type="string">"Using version %i"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INDEX_FORMAT_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>version</name> <operator>=</operator> <name>INDEX_FORMAT_DEFAULT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>version</name></expr>;</return>
</block_content>}</block></function>









<struct>struct <name>ondisk_cache_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>cache_time</name></name></type> <name>ctime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_time</name></name></type> <name>mtime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>dev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ino</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>gid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>size</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>data</name><index>[<expr><name>GIT_MAX_RAWSZ</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>FLEX_ARRAY</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>align_padding_size</name><parameter_list>(<parameter><type><name>size</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size + (len) + 8) &amp; ~7) - (size + len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>align_flex_name</name><parameter_list>(<parameter><type><name>STRUCT</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((offsetof(struct STRUCT,data) + (len) + 8) &amp; ~7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ondisk_cache_entry_size</name><parameter_list>(<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>align_flex_name(ondisk_cache_entry,len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ondisk_data_size</name><parameter_list>(<parameter><type><name>flags</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(the_hash_algo-&gt;rawsz + ((flags &amp; CE_EXTENDED) ? 2 : 1) * sizeof(uint16_t) + len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ondisk_data_size_max</name><parameter_list>(<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ondisk_data_size(CE_EXTENDED, len))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ondisk_ce_size</name><parameter_list>(<parameter><type><name>ce</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ondisk_cache_entry_size(ondisk_data_size((ce)-&gt;ce_flags, ce_namelen(ce))))</cpp:value></cpp:define>


<decl_stmt><decl><type><name>int</name></type> <name>verify_index_checksum</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>verify_ce_order</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>verify_hdr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_header</name></name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>git_hash_ctx</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hash</name><index>[<expr><name>GIT_MAX_RAWSZ</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hdr_version</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>hdr_signature</name></name> <operator>!=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>CACHE_SIGNATURE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad signature 0x%08x"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>hdr_signature</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hdr_version</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>hdr_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>hdr_version</name> <operator>&lt;</operator> <name>INDEX_FORMAT_LB</name> <operator>||</operator> <name>INDEX_FORMAT_UB</name> <operator>&lt;</operator> <name>hdr_version</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad index version %d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hdr_version</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>verify_index_checksum</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>init_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>final_fn</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasheq</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>hdr</name> <operator>+</operator> <name>size</name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad index file sha1 signature"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_index_extension</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ext</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><call><name>CACHE_EXT</name><argument_list>(<argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CACHE_EXT_TREE</name></expr>:</case>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_tree</name></name> <operator>=</operator> <call><name>cache_tree_read</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CACHE_EXT_RESOLVE_UNDO</name></expr>:</case>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>resolve_undo</name></name> <operator>=</operator> <call><name>resolve_undo_read</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CACHE_EXT_LINK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>read_link_extension</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>CACHE_EXT_UNTRACKED</name></expr>:</case>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name> <operator>=</operator> <call><name>read_untracked_extension</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CACHE_EXT_FSMONITOR</name></expr>:</case>
<expr_stmt><expr><call><name>read_fsmonitor_extension</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CACHE_EXT_ENDOFINDEXENTRIES</name></expr>:</case>
<case>case <expr><name>CACHE_EXT_INDEXENTRYOFFSETTABLE</name></expr>:</case>

<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ext</name> <operator>&lt;</operator> <literal type="char">'A'</literal> <operator>||</operator> <literal type="char">'Z'</literal> <operator>&lt;</operator> <operator>*</operator><name>ext</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"index uses %.4s extension, which we do not understand"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf_ln</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ignoring %.4s extension"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>create_from_disk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mem_pool</name></name> <modifier>*</modifier></type><name>ce_mem_pool</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>version</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ondisk_cache_entry</name></name> <modifier>*</modifier></type><name>ondisk</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>ent_size</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>previous_ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hashsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>flagsp</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ondisk</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>hashsz</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>copy_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>







<decl_stmt><decl><type><name>int</name></type> <name>expand_name_field</name> <init>= <expr><name>version</name> <operator>==</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>get_be16</name><argument_list>(<argument><expr><name>flagsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>flags</name> <operator>&amp;</operator> <name>CE_NAMEMASK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CE_EXTENDED</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>extended_flags</name></decl>;</decl_stmt>
<expr_stmt><expr><name>extended_flags</name> <operator>=</operator> <call><name>get_be16</name><argument_list>(<argument><expr><name>flagsp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>extended_flags</name> <operator>&amp;</operator> <operator>~</operator><name>CE_EXTENDED_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unknown index entry format 0x%08x"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extended_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>extended_flags</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>flagsp</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>flagsp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>expand_name_field</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>strip_len</name></decl>, <decl><type ref="prev"/><name>previous_len</name></decl>;</decl_stmt>


<expr_stmt><expr><name>strip_len</name> <operator>=</operator> <call><name>decode_varint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>previous_ce</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>previous_len</name> <operator>=</operator> <name><name>previous_ce</name><operator>-&gt;</operator><name>ce_namelen</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>previous_len</name> <operator>&lt;</operator> <name>strip_len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"malformed name field in the index, near path '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>previous_ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>copy_len</name> <operator>=</operator> <name>previous_len</name> <operator>-</operator> <name>strip_len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>cp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>CE_NAMEMASK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>expand_name_field</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>copy_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>mem_pool__ce_alloc</name><argument_list>(<argument><expr><name>ce_mem_pool</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_ctime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>ctime</name><operator>.</operator><name>sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>mtime</name><operator>.</operator><name>sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_ctime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>ctime</name><operator>.</operator><name>nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>mtime</name><operator>.</operator><name>nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_dev</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>dev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_ino</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>ino</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_uid</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_gid</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_size</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>=</operator> <name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>CE_NAMEMASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>expand_name_field</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>copy_len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>previous_ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <name>copy_len</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>copy_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ent_size</name> <operator>=</operator> <operator>(</operator><name>name</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ondisk</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>copy_len</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ent_size</name> <operator>=</operator> <call><name>ondisk_ce_size</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ce</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_ce_order</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>verify_ce_order</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>next_ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_compare</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>next_ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>name_compare</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unordered stage entries in index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name_compare</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multiple stage entries for merged file '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ce_stage</name><argument_list>(<argument><expr><name>next_ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unordered stage entries for '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tweak_untracked_cache</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>the_repository</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>prepare_repo_settings</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>settings</name><operator>.</operator><name>core_untracked_cache</name></name> <operator>==</operator> <name>UNTRACKED_CACHE_REMOVE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>remove_untracked_cache</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>settings</name><operator>.</operator><name>core_untracked_cache</name></name> <operator>==</operator> <name>UNTRACKED_CACHE_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_untracked_cache</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tweak_split_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><call><name>git_config_get_split_index</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> 
<break>break;</break>
<case>case <expr><literal type="number">0</literal></expr>:</case> 
<expr_stmt><expr><call><name>remove_split_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case> 
<expr_stmt><expr><call><name>add_split_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default> 
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>post_read_index_from</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>check_ce_order</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tweak_untracked_cache</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tweak_split_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tweak_fsmonitor</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>estimate_cache_size_from_compressed</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>entries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>entries</name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>cache_entry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>CACHE_ENTRY_PATH_LENGTH</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>estimate_cache_size</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>ondisk_size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>entries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>per_entry</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>cache_entry</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>ondisk_cache_entry</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><name>per_entry</name> <operator>+=</operator> <call><name>align_padding_size</name><argument_list>(<argument><expr><name>per_entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ondisk_size</name> <operator>+</operator> <name>entries</name> <operator>*</operator> <name>per_entry</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>index_entry_offset</name>
<block>{

<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>nr</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>index_entry_offset_table</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_entry_offset</name></name></type> <name><name>entries</name><index>[<expr><name>FLEX_ARRAY</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>read_ieot_extension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mmap_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_ieot_extension</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>ieot</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>read_eoie_extension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mmap_size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_eoie_extension</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>git_hash_ctx</name> <modifier>*</modifier></type><name>eoie_context</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>load_index_extensions</name>
<block>{
<decl_stmt><decl><type><name>pthread_t</name></type> <name>pthread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>mmap_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>src_offset</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>load_index_extensions</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>load_index_extensions</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>_data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>src_offset</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>src_offset</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>src_offset</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>mmap_size</name></name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name> <operator>-</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>






<decl_stmt><decl><type><name>uint32_t</name></type> <name>extsize</name> <init>= <expr><call><name>get_be32</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>mmap</name></name> <operator>+</operator> <name>src_offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_index_extension</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>istate</name></name></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>mmap</name></name> <operator>+</operator> <name>src_offset</name></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>mmap</name></name> <operator>+</operator> <name>src_offset</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><name>extsize</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>mmap</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mmap_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"index file corrupt"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <name>extsize</name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>load_cache_entry_block</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>mem_pool</name></name> <modifier>*</modifier></type><name>ce_mem_pool</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>start_offset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>previous_ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>src_offset</name> <init>= <expr><name>start_offset</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>offset</name> <operator>+</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ondisk_cache_entry</name></name> <modifier>*</modifier></type><name>disk_ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>consumed</name></decl>;</decl_stmt>

<expr_stmt><expr><name>disk_ce</name> <operator>=</operator> <operator>(</operator>struct <name>ondisk_cache_entry</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>mmap</name> <operator>+</operator> <name>src_offset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>create_from_disk</name><argument_list>(<argument><expr><name>ce_mem_pool</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name>disk_ce</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consumed</name></expr></argument>, <argument><expr><name>previous_ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <name>consumed</name></expr>;</expr_stmt>
<expr_stmt><expr><name>previous_ce</name> <operator>=</operator> <name>ce</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>src_offset</name> <operator>-</operator> <name>start_offset</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>load_all_cache_entries</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mmap_size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>src_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>consumed</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mem_pool_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>,
<argument><expr><call><name>estimate_cache_size_from_compressed</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>mem_pool_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>,
<argument><expr><call><name>estimate_cache_size</name><argument_list>(<argument><expr><name>mmap_size</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>consumed</name> <operator>=</operator> <call><name>load_cache_entry_block</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>, <argument><expr><name>mmap</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>consumed</name></expr>;</return>
</block_content>}</block></function>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THREAD_COST</name></cpp:macro> <cpp:value>(10000)</cpp:value></cpp:define>

<struct>struct <name>load_cache_entries_thread_data</name>
<block>{
<decl_stmt><decl><type><name>pthread_t</name></type> <name>pthread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>mem_pool</name></name> <modifier>*</modifier></type><name>ce_mem_pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>ieot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ieot_start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ieot_blocks</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>consumed</name></decl>;</decl_stmt> 
}</block>;</struct>





<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>load_cache_entries_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>load_cache_entries_thread_data</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>_data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ieot_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>ieot_start</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>ieot_blocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>consumed</name></name> <operator>+=</operator> <call><name>load_cache_entry_block</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>istate</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nr</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mmap</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nr</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>load_cache_entries_threaded</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mmap_size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>nr_threads</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>ieot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>, <decl><type ref="prev"/><name>ieot_blocks</name></decl>, <decl><type ref="prev"/><name>ieot_start</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>load_cache_entries_thread_data</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>consumed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>name_hash_initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"the name hash isn't thread safe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mem_pool_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>nr_threads</name> <operator>&gt;</operator> <name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr_threads</name> <operator>=</operator> <name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>nr_threads</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>ieot_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ieot_blocks</name> <operator>=</operator> <call><name>DIV_ROUND_UP</name><argument_list>(<argument><expr><name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr></argument>, <argument><expr><name>nr_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>load_cache_entries_thread_data</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ieot_start</name> <operator>+</operator> <name>ieot_blocks</name> <operator>&gt;</operator> <name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ieot_blocks</name> <operator>=</operator> <name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name> <operator>-</operator> <name>ieot_start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>istate</name></name> <operator>=</operator> <name>istate</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mmap</name></name> <operator>=</operator> <name>mmap</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ieot</name></name> <operator>=</operator> <name>ieot</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ieot_start</name></name> <operator>=</operator> <name>ieot_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ieot_blocks</name></name> <operator>=</operator> <name>ieot_blocks</name></expr>;</expr_stmt>


<expr_stmt><expr><name>nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ieot_start</name></name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>ieot_start</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>ieot_blocks</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nr</name></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mem_pool_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>,
<argument><expr><call><name>estimate_cache_size_from_compressed</name><argument_list>(<argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>mem_pool_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>,
<argument><expr><call><name>estimate_cache_size</name><argument_list>(<argument><expr><name>mmap_size</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pthread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>load_cache_entries_thread</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to create load_cache_entries thread: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ieot_blocks</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>ieot_start</name> <operator>+</operator> <name>j</name></expr>]</index></name><operator>.</operator><name>nr</name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>ieot_start</name> <operator>+=</operator> <name>ieot_blocks</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr_threads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>load_cache_entries_thread_data</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_join</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pthread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to join load_cache_entries thread: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>mem_pool_combine</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>consumed</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>consumed</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>consumed</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>do_read_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>must_exist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>src_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_header</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>mmap_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>load_index_extensions</name></name></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>extension_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr_threads</name></decl>, <decl><type ref="prev"/><name>cpus</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>ieot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>must_exist</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: index file open failed"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot stat the open index"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mmap_size</name> <operator>=</operator> <call><name>xsize_t</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mmap_size</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>cache_header</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: index file smaller than expected"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mmap</name> <operator>=</operator> <call><name>xmmap_gently</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mmap_size</name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_PRIVATE</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mmap</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unable to map index file"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> struct <name>cache_header</name> <operator>*</operator><operator>)</operator><name>mmap</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>verify_hdr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>mmap_size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>unmap</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>hdr</name> <operator>+</operator> <name>mmap_size</name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>hdr_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>hdr_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_alloc</name></name> <operator>=</operator> <call><name>alloc_nr</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_alloc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>.</operator><name>istate</name></name> <operator>=</operator> <name>istate</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>.</operator><name>mmap</name></name> <operator>=</operator> <name>mmap</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>.</operator><name>mmap_size</name></name> <operator>=</operator> <name>mmap_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>src_offset</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_config_get_index_threads</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nr_threads</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr_threads</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nr_threads</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nr_threads</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>/</operator> <name>THREAD_COST</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cpus</name> <operator>=</operator> <call><name>online_cpus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nr_threads</name> <operator>&gt;</operator> <name>cpus</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr_threads</name> <operator>=</operator> <name>cpus</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAVE_THREADS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr_threads</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nr_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>extension_offset</name> <operator>=</operator> <call><name>read_eoie_extension</name><argument_list>(<argument><expr><name>mmap</name></expr></argument>, <argument><expr><name>mmap_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>extension_offset</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>.</operator><name>src_offset</name></name> <operator>=</operator> <name>extension_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>.</operator><name>pthread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>load_index_extensions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to create load_index_extensions thread: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nr_threads</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>extension_offset</name> <operator>&amp;&amp;</operator> <name>nr_threads</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ieot</name> <operator>=</operator> <call><name>read_ieot_extension</name><argument_list>(<argument><expr><name>mmap</name></expr></argument>, <argument><expr><name>mmap_size</name></expr></argument>, <argument><expr><name>extension_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ieot</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <call><name>load_cache_entries_threaded</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>mmap</name></expr></argument>, <argument><expr><name>mmap_size</name></expr></argument>, <argument><expr><name>nr_threads</name></expr></argument>, <argument><expr><name>ieot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ieot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <call><name>load_all_cache_entries</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>mmap</name></expr></argument>, <argument><expr><name>mmap_size</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>ST_MTIME_NSEC</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>extension_offset</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>pthread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to join load_index_extensions thread: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>.</operator><name>src_offset</name></name> <operator>=</operator> <name>src_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>load_index_extensions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>mmap</name></expr></argument>, <argument><expr><name>mmap_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>trace2_data_intmax</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"read/version"</literal></expr></argument>,
<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_data_intmax</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"read/cache_nr"</literal></expr></argument>,
<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</return>

<label><name>unmap</name>:</label>
<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>mmap</name></expr></argument>, <argument><expr><name>mmap_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"index file corrupt"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>freshen_shared_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shared_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>warn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_and_freshen_file</name><argument_list>(<argument><expr><name>shared_index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>warn</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not freshen shared index '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>shared_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>read_index_from</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gitdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>split_index</name></name> <modifier>*</modifier></type><name>split_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base_oid_hex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base_path</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</return></block_content></block></if></if_stmt>





<expr_stmt><expr><call><name>trace2_region_enter_printf</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="string">"do_read_index"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace_performance_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_read_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace_performance_leave</name><argument_list>(<argument><expr><literal type="string">"read cache %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_region_leave_printf</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="string">"do_read_index"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>split_index</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>split_index</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>split_index</name> <operator>||</operator> <call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>split_index</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>post_read_index_from</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>trace_performance_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>split_index</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>discard_index</name><argument_list>(<argument><expr><name><name>split_index</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>split_index</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>split_index</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>base_oid_hex</name> <operator>=</operator> <call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>split_index</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base_path</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%s/sharedindex.%s"</literal></expr></argument>, <argument><expr><name>gitdir</name></expr></argument>, <argument><expr><name>base_oid_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_region_enter_printf</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="string">"shared/do_read_index"</literal></expr></argument>,
<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>base_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_read_index</name><argument_list>(<argument><expr><name><name>split_index</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_region_leave_printf</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="string">"shared/do_read_index"</literal></expr></argument>,
<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>base_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>split_index</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>split_index</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"broken index, expect %s in %s, got %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>base_oid_hex</name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>split_index</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>freshen_shared_index</name><argument_list>(<argument><expr><name>base_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>merge_base_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>post_read_index_from</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace_performance_leave</name><argument_list>(<argument><expr><literal type="string">"read cache %s"</literal></expr></argument>, <argument><expr><name>base_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>base_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_index_unborn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>discard_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>







<expr_stmt><expr><call><name>validate_cache_entries</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>resolve_undo_clear_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_name_hash</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cache_tree_free</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>istate</name><operator>-&gt;</operator><name>cache_tree</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>fsmonitor_has_run_once</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_alloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>discard_split_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_untracked_cache</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mem_pool_discard</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>, <argument><expr><call><name>should_validate_cache_entries</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>validate_cache_entries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>should_validate_cache_entries</name><argument_list>()</argument_list></call> <operator>||</operator><operator>!</operator><name>istate</name> <operator>||</operator> <operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>istate</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"cache entry is not allocated from expected memory pool"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name> <operator>||</operator>
<operator>!</operator><call><name>mem_pool_contains</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>split_index</name></name> <operator>||</operator>
<operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>split_index</name><operator>-&gt;</operator><name>base</name></name> <operator>||</operator>
<operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>split_index</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>ce_mem_pool</name></name> <operator>||</operator>
<operator>!</operator><call><name>mem_pool_contains</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>split_index</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>ce_mem_pool</name></name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"cache entry is not allocated from expected memory pool"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>split_index</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>validate_cache_entries</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>split_index</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>unmerged_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_index_has_changes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tree</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tree</name> <operator>||</operator> <operator>!</operator><call><name>get_oid_tree</name><argument_list>(<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_options</name></name></type> <name>opt</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>repo_diff_setup</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>flags</name><operator>.</operator><name>exit_with_status</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sb</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>flags</name><operator>.</operator><name>quick</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>do_diff_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diffcore_std</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sb</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>diff_queued_diff</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>diff_queued_diff</name><operator>.</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>diff_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>opt</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_changes</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sb</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><operator>!</operator><operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BUFFER_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>write_buffer</name><index>[<expr><name>WRITE_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>write_buffer_len</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_write_flush</name><parameter_list>(<parameter><decl><type><name>git_hash_ctx</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>buffered</name> <init>= <expr><name>write_buffer_len</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buffered</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>write_buffer</name></expr></argument>, <argument><expr><name>buffered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>write_in_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>write_buffer</name></expr></argument>, <argument><expr><name>buffered</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>write_buffer_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_write</name><parameter_list>(<parameter><decl><type><name>git_hash_ctx</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>buffered</name> <init>= <expr><name>write_buffer_len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>partial</name> <init>= <expr><name>WRITE_BUFFER_SIZE</name> <operator>-</operator> <name>buffered</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>partial</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>partial</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>write_buffer</name> <operator>+</operator> <name>buffered</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffered</name> <operator>+=</operator> <name>partial</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffered</name> <operator>==</operator> <name>WRITE_BUFFER_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>write_buffer_len</name> <operator>=</operator> <name>buffered</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_write_flush</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buffered</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>write_buffer_len</name> <operator>=</operator> <name>buffered</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>partial</name></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <name>partial</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>write_index_ext_header</name><parameter_list>(<parameter><decl><type><name>git_hash_ctx</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>git_hash_ctx</name> <modifier>*</modifier></type><name>eoie_context</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ext</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>ext</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eoie_context</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><name>eoie_context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ext</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><name>eoie_context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><call><name>ce_write</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ext</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>ce_write</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_flush</name><parameter_list>(<parameter><decl><type><name>git_hash_ctx</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>left</name> <init>= <expr><name>write_buffer_len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>left</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>write_buffer_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>write_buffer</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>left</name> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name> <operator>&gt;</operator> <name>WRITE_BUFFER_SIZE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>write_in_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>write_buffer</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>final_fn</name></name><argument_list>(<argument><expr><name>write_buffer</name> <operator>+</operator> <name>left</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>write_buffer</name> <operator>+</operator> <name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> <operator>+=</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>write_in_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>write_buffer</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ce_smudge_racily_clean_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>











<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_match_stat_basic</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_modified_check_fs</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

























<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_cache_entry_to_ondisk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ondisk_cache_entry</name></name> <modifier>*</modifier></type><name>ondisk</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>short</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hashsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>flagsp</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ondisk</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>hashsz</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>ctime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_ctime</name><operator>.</operator><name>sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>mtime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>ctime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_ctime</name><operator>.</operator><name>nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>mtime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>dev</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_dev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>ino</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_ino</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>uid</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>gid</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_stat_data</name><operator>.</operator><name>sd_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>CE_NAMEMASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>CE_NAMEMASK</name></expr> ?</condition><then> <expr><name>CE_NAMEMASK</name></expr> </then><else>: <expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>flagsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_EXTENDED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>flagsp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_EXTENDED_FLAGS</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ce_write_entry</name><parameter_list>(<parameter><decl><type><name>git_hash_ctx</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>previous_name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ondisk_cache_entry</name></name> <modifier>*</modifier></type><name>ondisk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>saved_namelen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stripped_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>padding</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x00</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_STRIP_NAME</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>saved_namelen</name> <operator>=</operator> <call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>stripped_name</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr>struct <name>ondisk_cache_entry</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ondisk_data_size</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>previous_name</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>copy_cache_entry_to_ondisk</name><argument_list>(<argument><expr><name>ondisk</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ce_write</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ondisk</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ce_write</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ce_write</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><call><name>align_padding_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>common</name></decl>, <decl><type ref="prev"/><name>to_remove</name></decl>, <decl><type ref="prev"/><name>prefix_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>to_remove_vi</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>common</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
<condition><expr><operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>common</name></expr>]</index></name> <operator>&amp;&amp;</operator>
<name>common</name> <operator>&lt;</operator> <name><name>previous_name</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator>
<name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>common</name></expr>]</index></name> <operator>==</operator> <name><name>previous_name</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>common</name></expr>]</index></name><operator>)</operator></expr>;</condition>
<incr><expr><name>common</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for> 
<expr_stmt><expr><name>to_remove</name> <operator>=</operator> <name><name>previous_name</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>common</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prefix_size</name> <operator>=</operator> <call><name>encode_varint</name><argument_list>(<argument><expr><name>to_remove</name></expr></argument>, <argument><expr><name>to_remove_vi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>copy_cache_entry_to_ondisk</name><argument_list>(<argument><expr><name>ondisk</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ce_write</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ondisk</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ce_write</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>to_remove_vi</name></expr></argument>, <argument><expr><name>prefix_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ce_write</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <name>common</name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ce_write</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_splice</name><argument_list>(<argument><expr><name>previous_name</name></expr></argument>, <argument><expr><name>common</name></expr></argument>, <argument><expr><name>to_remove</name></expr></argument>,
<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <name>common</name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stripped_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>saved_namelen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CE_STRIP_NAME</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>verify_index_from</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hash</name><index>[<expr><name>GIT_MAX_RAWSZ</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>cache_header</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pread_in_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasheq</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>out</name>:</label>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>repo_verify_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>verify_index_from</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index_file</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>has_racy_timestamp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>entries</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_racy_timestamp</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>repo_update_index_if_able</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>lock_file</name></name> <modifier>*</modifier></type><name>lockfile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>||</operator>
<call><name>has_racy_timestamp</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>repo_verify_index</name><argument_list>(<argument><expr><name>repo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>write_locked_index</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>lockfile</name></expr></argument>, <argument><expr><name>COMMIT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rollback_lock_file</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>record_eoie</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_bool</name><argument_list>(<argument><expr><literal type="string">"index.recordendofindexentries"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>val</name></expr>;</return></block_content></block></if></if_stmt>






<return>return <expr><operator>!</operator><call><name>git_config_get_index_threads</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>val</name> <operator>!=</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>record_ieot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_bool</name><argument_list>(<argument><expr><literal type="string">"index.recordoffsettable"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>val</name></expr>;</return></block_content></block></if></if_stmt>






<return>return <expr><operator>!</operator><call><name>git_config_get_index_threads</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>val</name> <operator>!=</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>do_write_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tempfile</name></name> <modifier>*</modifier></type><name>tempfile</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>strip_extensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>start</name> <init>= <expr><call><name>getnanotime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newfd</name> <init>= <expr><name><name>tempfile</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>git_hash_ctx</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>eoie_c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_header</name></name></type> <name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>removed</name></decl>, <decl><type ref="prev"/><name>extended</name></decl>, <decl><type ref="prev"/><name>hdr_version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>cache</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>entries</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ondisk_cache_entry</name></name></type> <name>ondisk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>previous_name_buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>previous_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>drop_cache_tree</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>drop_cache_tree</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ieot_entries</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>ieot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>, <decl><type ref="prev"/><name>nr_threads</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>removed</name> <operator>=</operator> <name>extended</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>&amp;</operator> <name>CE_REMOVE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>removed</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>&amp;=</operator> <operator>~</operator><name>CE_EXTENDED</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>&amp;</operator> <name>CE_EXTENDED_FLAGS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>extended</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ce_flags</name> <operator>|=</operator> <name>CE_EXTENDED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>version</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <call><name>get_index_format_default</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>git_env_bool</name><argument_list>(<argument><expr><literal type="string">"GIT_TEST_SPLIT_INDEX"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>init_split_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>||</operator> <name><name>istate</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <ternary><condition><expr><name>extended</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hdr_version</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>version</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>hdr_signature</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>CACHE_SIGNATURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>hdr_version</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>hdr_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>hdr_entries</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>entries</name> <operator>-</operator> <name>removed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>init_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAVE_THREADS</name> <operator>||</operator> <call><name>git_config_get_index_threads</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nr_threads</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr_threads</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nr_threads</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>record_ieot</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ieot_blocks</name></decl>, <decl><type ref="prev"/><name>cpus</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nr_threads</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ieot_blocks</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>/</operator> <name>THREAD_COST</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cpus</name> <operator>=</operator> <call><name>online_cpus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ieot_blocks</name> <operator>&gt;</operator> <name>cpus</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ieot_blocks</name> <operator>=</operator> <name>cpus</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ieot_blocks</name> <operator>=</operator> <name>nr_threads</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ieot_blocks</name> <operator>&gt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ieot_blocks</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>





<if_stmt><if>if <condition>(<expr><name>ieot_blocks</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ieot</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>index_entry_offset_table</name></expr></argument>)</argument_list></sizeof>
<operator>+</operator> <operator>(</operator><name>ieot_blocks</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>index_entry_offset</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ieot_entries</name> <operator>=</operator> <call><name>DIV_ROUND_UP</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>ieot_blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ieot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>write_buffer_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>previous_name</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>hdr_version</name> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>previous_name_buf</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>&amp;</operator> <name>CE_REMOVE</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ce_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_racy_timestamp</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ce_smudge_racily_clean_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>msg</name><index>[]</index></name> <init>= <expr><literal type="string">"cache entry has null sha1: %s"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>allow</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>allow</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>allow</name> <operator>=</operator> <call><name>git_env_bool</name><argument_list>(<argument><expr><literal type="string">"GIT_ALLOW_NULL_SHA1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>allow</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>error</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>drop_cache_tree</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ieot</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>%</operator> <name>ieot_entries</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>nr</name> <operator>=</operator> <name>nr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>previous_name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>previous_name</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ieot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>write_buffer_len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_write_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>previous_name</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>ondisk_cache_entry</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ondisk</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>ieot</name> <operator>&amp;&amp;</operator> <name>nr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>nr</name> <operator>=</operator> <name>nr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>previous_name_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ieot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ieot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>write_buffer_len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>init_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>eoie_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><name>ieot</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>write_ieot_extension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>ieot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write_index_ext_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eoie_c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>CACHE_EXT_INDEXENTRYOFFSETTABLE</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>ce_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ieot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strip_extensions</name> <operator>&amp;&amp;</operator> <name><name>istate</name><operator>-&gt;</operator><name>split_index</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>split_index</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write_link_extension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>write_index_ext_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eoie_c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>CACHE_EXT_LINK</name></expr></argument>,
<argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>ce_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strip_extensions</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>drop_cache_tree</name> <operator>&amp;&amp;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_tree</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cache_tree_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write_index_ext_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eoie_c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>CACHE_EXT_TREE</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>ce_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strip_extensions</name> <operator>&amp;&amp;</operator> <name><name>istate</name><operator>-&gt;</operator><name>resolve_undo</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>resolve_undo_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>resolve_undo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write_index_ext_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eoie_c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>CACHE_EXT_RESOLVE_UNDO</name></expr></argument>,
<argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>ce_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strip_extensions</name> <operator>&amp;&amp;</operator> <name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>write_untracked_extension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write_index_ext_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eoie_c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>CACHE_EXT_UNTRACKED</name></expr></argument>,
<argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>ce_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strip_extensions</name> <operator>&amp;&amp;</operator> <name><name>istate</name><operator>-&gt;</operator><name>fsmonitor_last_update</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>write_fsmonitor_extension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write_index_ext_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eoie_c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>CACHE_EXT_FSMONITOR</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>ce_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&amp;&amp;</operator> <call><name>record_eoie</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>write_eoie_extension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eoie_c</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write_index_ext_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>CACHE_EXT_ENDOFINDEXENTRIES</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>ce_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ce_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>close_tempfile_gently</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not close '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tempfile</name><operator>-&gt;</operator><name>filename</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name><name>tempfile</name><operator>-&gt;</operator><name>filename</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>timestamp</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>ST_MTIME_NSEC</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace_performance_since</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="string">"write index, changed mask = %x"</literal></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>trace2_data_intmax</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"write/version"</literal></expr></argument>,
<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_data_intmax</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"write/cache_nr"</literal></expr></argument>,
<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_alternate_index_output</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>alternate_index_output</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>commit_locked_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lock_file</name></name> <modifier>*</modifier></type><name>lk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>alternate_index_output</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>commit_lock_file_to</name><argument_list>(<argument><expr><name>lk</name></expr></argument>, <argument><expr><name>alternate_index_output</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>commit_lock_file</name><argument_list>(<argument><expr><name>lk</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_write_locked_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lock_file</name></name> <modifier>*</modifier></type><name>lock</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>





<expr_stmt><expr><call><name>trace2_region_enter_printf</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="string">"do_write_index"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tempfile</name><operator>-&gt;</operator><name>filename</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_write_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tempfile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_region_leave_printf</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="string">"do_write_index"</literal></expr></argument>, <argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tempfile</name><operator>-&gt;</operator><name>filename</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>COMMIT_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>commit_locked_index</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>close_lock_file_gently</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>run_hook_le</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"post-index-change"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>istate</name><operator>-&gt;</operator><name>updated_workdir</name></name></expr> ?</condition><then> <expr><literal type="string">"1"</literal></expr> </then><else>: <expr><literal type="string">"0"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>istate</name><operator>-&gt;</operator><name>updated_skipworktree</name></name></expr> ?</condition><then> <expr><literal type="string">"1"</literal></expr> </then><else>: <expr><literal type="string">"0"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>updated_workdir</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>updated_skipworktree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>write_split_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>lock_file</name></name> <modifier>*</modifier></type><name>lock</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>prepare_to_write_split_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_write_locked_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>finish_writing_split_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shared_index_expire</name> <init>= <expr><literal type="string">"2.weeks.ago"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>get_shared_index_expire_date</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>shared_index_expire_date</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>shared_index_expire_date_prepared</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shared_index_expire_date_prepared</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>git_config_get_expiry</name><argument_list>(<argument><expr><literal type="string">"splitindex.sharedindexexpire"</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>shared_index_expire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shared_index_expire_date</name> <operator>=</operator> <call><name>approxidate</name><argument_list>(<argument><expr><name>shared_index_expire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shared_index_expire_date_prepared</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>shared_index_expire_date</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>should_delete_shared_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shared_index_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>expiration</name></decl>;</decl_stmt>


<expr_stmt><expr><name>expiration</name> <operator>=</operator> <call><name>get_shared_index_expire_date</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expiration</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>shared_index_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not stat '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>shared_index_path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_mtime</name></name> <operator>&gt;</operator> <name>expiration</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>clean_shared_index_files</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>current_hex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>opendir</name><argument_list>(<argument><expr><call><name>get_git_dir</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to open git dir: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_git_dir</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sha1_hex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shared_index_path</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"sharedindex."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sha1_hex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>sha1_hex</name></expr></argument>, <argument><expr><name>current_hex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>shared_index_path</name> <operator>=</operator> <call><name>git_path</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>should_delete_shared_index</name><argument_list>(<argument><expr><name>shared_index_path</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>unlink</name><argument_list>(<argument><expr><name>shared_index_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unable to unlink: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>shared_index_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>write_shared_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tempfile</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>temp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>split_index</name></name> <modifier>*</modifier></type><name>si</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>split_index</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>move_cache_to_base_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace2_region_enter_printf</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="string">"shared/do_write_index"</literal></expr></argument>,
<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>temp</name><operator>)</operator><operator>-&gt;</operator><name><name>filename</name><operator>.</operator><name>buf</name></name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_write_index</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>*</operator><name>temp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trace2_region_leave_printf</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="string">"shared/do_write_index"</literal></expr></argument>,
<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>temp</name><operator>)</operator><operator>-&gt;</operator><name><name>filename</name><operator>.</operator><name>buf</name></name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>adjust_shared_perm</name><argument_list>(<argument><expr><call><name>get_tempfile_path</name><argument_list>(<argument><expr><operator>*</operator><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot fix permission bits on '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_tempfile_path</name><argument_list>(<argument><expr><operator>*</operator><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rename_tempfile</name><argument_list>(<argument><expr><name>temp</name></expr></argument>,
<argument><expr><call><name>git_path</name><argument_list>(<argument><expr><literal type="string">"sharedindex.%s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clean_shared_index_files</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>base</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>default_max_percent_split_change</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>too_many_not_shared_entries</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>not_shared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_split</name> <init>= <expr><call><name>git_config_get_max_percent_split_change</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>max_split</name></expr>)</condition> <block>{<block_content>
<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>max_split</name> <operator>=</operator> <name>default_max_percent_split_change</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return> 
<case>case <expr><literal type="number">100</literal></expr>:</case>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
<default>default:</default>
<break>break;</break> 
</block_content>}</block></switch>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ce</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>not_shared</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>*</operator> <name>max_split</name> <operator>&lt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>not_shared</name> <operator>*</operator> <literal type="number">100</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>write_locked_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lock_file</name></name> <modifier>*</modifier></type><name>lock</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>new_shared_index</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>split_index</name></name> <modifier>*</modifier></type><name>si</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>split_index</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_env_bool</name><argument_list>(<argument><expr><literal type="string">"GIT_TEST_CHECK_CACHE_TREE"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>cache_tree_verify</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SKIP_IF_UNCHANGED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>COMMIT_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rollback_lock_file</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>fsmonitor_last_update</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fill_fsmonitor_bitmap</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>si</name> <operator>||</operator> <name>alternate_index_output</name> <operator>||</operator>
<operator>(</operator><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>&amp;</operator> <operator>~</operator><name>EXTMASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>si</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_write_locked_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>git_env_bool</name><argument_list>(<argument><expr><literal type="string">"GIT_TEST_SPLIT_INDEX"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><name><name>si</name><operator>-&gt;</operator><name>base_oid</name><operator>.</operator><name>hash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>SPLIT_INDEX_ORDERED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>too_many_not_shared_entries</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>SPLIT_INDEX_ORDERED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>new_shared_index</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>&amp;</operator> <name>SPLIT_INDEX_ORDERED</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>new_shared_index</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tempfile</name></name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>saved_errno</name></decl>;</decl_stmt>


<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>mks_tempfile_sm</name><argument_list>(<argument><expr><call><name>git_path</name><argument_list>(<argument><expr><literal type="string">"sharedindex_XXXXXX"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0666</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_write_locked_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write_shared_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>saved_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_tempfile_active</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>delete_tempfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>saved_errno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write_split_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>new_shared_index</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shared_index</name> <init>= <expr><call><name>git_path</name><argument_list>(<argument><expr><literal type="string">"sharedindex.%s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>base_oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>freshen_shared_index</name><argument_list>(<argument><expr><name>shared_index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>out</name>:</label>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>COMMIT_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rollback_lock_file</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>int</name></type> <name>repo_read_index_unmerged</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>unmerged</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>repo_read_index</name><argument_list>(<argument><expr><name>repo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>istate</name> <operator>=</operator> <name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>new_ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>unmerged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_ce</name> <operator>=</operator> <call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new_ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>=</operator> <call><name>create_ce_flags</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>|</operator> <name>CE_CONFLICTED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_ce</name><operator>-&gt;</operator><name>ce_namelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>new_ce</name></expr></argument>, <argument><expr><name>ADD_CACHE_SKIP_DFCHECK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot drop to stage #0"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>new_ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>unmerged</name></expr>;</return>
</block_content>}</block></function>










<function><type><name>int</name></type> <name>index_name_is_other</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><name>namelen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>namelen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>namelen</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>read_blob_data_from_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>-</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init>
<condition><expr><operator>(</operator><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name> <operator>||</operator> <name>type</name> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>stat_validity_clear</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>stat_validity</name></name> <modifier>*</modifier></type><name>sv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>sv</name><operator>-&gt;</operator><name>sd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>stat_validity_check</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>stat_validity</name></name> <modifier>*</modifier></type><name>sv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>sv</name><operator>-&gt;</operator><name>sd</name></name> <operator>==</operator> <name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sv</name><operator>-&gt;</operator><name>sd</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>match_stat_data</name><argument_list>(<argument><expr><name><name>sv</name><operator>-&gt;</operator><name>sd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>stat_validity_update</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>stat_validity</name></name> <modifier>*</modifier></type><name>sv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>stat_validity_clear</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sv</name><operator>-&gt;</operator><name>sd</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>sd</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>stat_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><name><name>sv</name><operator>-&gt;</operator><name>sd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>move_index_extensions</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>untracked</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>untracked</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>untracked</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>cache_tree</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>cache_tree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>cache_tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>dup_cache_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><call><name>ce_size</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mem_pool_allocated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>new_entry</name> <init>= <expr><call><name>make_empty_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>mem_pool_allocated</name> <operator>=</operator> <name><name>new_entry</name><operator>-&gt;</operator><name>mem_pool_allocated</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_entry</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_entry</name><operator>-&gt;</operator><name>mem_pool_allocated</name></name> <operator>=</operator> <name>mem_pool_allocated</name></expr>;</expr_stmt>
<return>return <expr><name>new_entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>discard_cache_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ce</name> <operator>&amp;&amp;</operator> <call><name>should_validate_cache_entries</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><literal type="number">0xCD</literal></expr></argument>, <argument><expr><call><name>cache_entry_size</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_namelen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ce</name> <operator>&amp;&amp;</operator> <name><name>ce</name><operator>-&gt;</operator><name>mem_pool_allocated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>should_validate_cache_entries</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>validate_index_cache_entries</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>validate_index_cache_entries</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"GIT_TEST_VALIDATE_INDEX_CACHE_ENTRIES"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>validate_index_cache_entries</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>validate_index_cache_entries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>validate_index_cache_entries</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOIE_SIZE</name></cpp:macro> <cpp:value>(4 + GIT_SHA1_RAWSZ)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOIE_SIZE_WITH_HEADER</name></cpp:macro> <cpp:value>(4 + 4 + EOIE_SIZE)</cpp:value></cpp:define> 

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>read_eoie_extension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mmap_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>









<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eoie</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>extsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>src_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hash</name><index>[<expr><name>GIT_MAX_RAWSZ</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>git_hash_ctx</name></type> <name>c</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>mmap_size</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>cache_header</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>EOIE_SIZE_WITH_HEADER</name> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>index</name> <operator>=</operator> <name>eoie</name> <operator>=</operator> <name>mmap</name> <operator>+</operator> <name>mmap_size</name> <operator>-</operator> <name>EOIE_SIZE_WITH_HEADER</name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CACHE_EXT</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CACHE_EXT_ENDOFINDEXENTRIES</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>index</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>


<expr_stmt><expr><name>extsize</name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>extsize</name> <operator>!=</operator> <name>EOIE_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>index</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>





<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mmap</name> <operator>+</operator> <name>offset</name> <operator>&lt;</operator> <name>mmap</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>cache_header</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mmap</name> <operator>+</operator> <name>offset</name> <operator>&gt;=</operator> <name>eoie</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>index</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>










<expr_stmt><expr><name>src_offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>init_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>src_offset</name> <operator>&lt;</operator> <name>mmap_size</name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name> <operator>-</operator> <name>EOIE_SIZE_WITH_HEADER</name></expr>)</condition> <block>{<block_content>






<decl_stmt><decl><type><name>uint32_t</name></type> <name>extsize</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extsize</name></expr></argument>, <argument><expr><name>mmap</name> <operator>+</operator> <name>src_offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extsize</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>extsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>src_offset</name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <name>extsize</name> <operator>&lt;</operator> <name>src_offset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>mmap</name> <operator>+</operator> <name>src_offset</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <name>extsize</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>final_fn</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasheq</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>src_offset</name> <operator>!=</operator> <name>mmap_size</name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name> <operator>-</operator> <name>EOIE_SIZE_WITH_HEADER</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_eoie_extension</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>git_hash_ctx</name> <modifier>*</modifier></type><name>eoie_context</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hash</name><index>[<expr><name>GIT_MAX_RAWSZ</name></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>put_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>final_fn</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>eoie_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IEOT_VERSION</name></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>read_ieot_extension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mmap_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>extsize</name></decl>, <decl><type ref="prev"/><name>ext_version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>ieot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nr</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>offset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>offset</name> <operator>&lt;=</operator> <name>mmap_size</name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name> <operator>-</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>extsize</name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name>mmap</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CACHE_EXT</name><argument_list>(<argument><expr><operator>(</operator><name>mmap</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>CACHE_EXT_INDEXENTRYOFFSETTABLE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name>mmap</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>extsize</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>index</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ext_version</name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_version</name> <operator>!=</operator> <name>IEOT_VERSION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"invalid IEOT version %d"</literal></expr></argument>, <argument><expr><name>ext_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>index</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>


<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>extsize</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>/</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"invalid number of IEOT entries %d"</literal></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ieot</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>index_entry_offset_table</name></expr></argument>)</argument_list></sizeof>
<operator>+</operator> <operator>(</operator><name>nr</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>index_entry_offset</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name> <operator>=</operator> <name>nr</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nr</name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>ieot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_ieot_extension</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_entry_offset_table</name></name> <modifier>*</modifier></type><name>ieot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>put_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>IEOT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ieot</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>


<expr_stmt><expr><call><name>put_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>ieot</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
</unit>
