
























#ifndef __AC_KHASH_H
#define __AC_KHASH_H

#include "cache.h"
#include "hashmap.h"

#define AC_VERSION_KHASH_H "0.2.8"

typedef uint32_t khint32_t;
typedef uint64_t khint64_t;

typedef khint32_t khint_t;
typedef khint_t khiter_t;

#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)
#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)
#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)
#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))
#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))
#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))
#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=1ul<<((i&0xfU)<<1))

#define __ac_fsize(m) ((m) < 16? 1 : (m)>>4)

#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

static inline khint_t __ac_X31_hash_string(const char *s)
{
	khint_t h = (khint_t)*s;
	if (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;
	return h;
}

#define kh_str_hash_func(key) __ac_X31_hash_string(key)
#define kh_str_hash_equal(a, b) (strcmp(a, b) == 0)

static const double __ac_HASH_UPPER = 0.77;

#define __KHASH_TYPE(name, khkey_t, khval_t) typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; khkey_t *keys; khval_t *vals; } kh_##name##_t;







#define __KHASH_PROTOTYPES(name, khkey_t, khval_t)	 			kh_##name##_t *kh_init_##name(void);						void kh_destroy_##name(kh_##name##_t *h);					void kh_clear_##name(kh_##name##_t *h);						khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key); int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets); khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret); void kh_del_##name(kh_##name##_t *h, khint_t x);








#define __KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) SCOPE kh_##name##_t *kh_init_##name(void) {							return (kh_##name##_t*)xcalloc(1, sizeof(kh_##name##_t));		}																	SCOPE void kh_release_##name(kh_##name##_t *h)						{																	free(h->flags);													free((void *)h->keys);											free((void *)h->vals);											}																	SCOPE void kh_destroy_##name(kh_##name##_t *h)						{																	if (h) {														kh_release_##name(h);										free(h);													}																}																	SCOPE void kh_clear_##name(kh_##name##_t *h)						{																	if (h && h->flags) {											memset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t)); h->size = h->n_occupied = 0;								}																}																	SCOPE khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key) 	{																	if (h->n_buckets) {												khint_t k, i, last, mask, step = 0; mask = h->n_buckets - 1;									k = __hash_func(key); i = k & mask;							last = i; while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { i = (i + (++step)) & mask; if (i == last) return h->n_buckets;						}															return __ac_iseither(h->flags, i)? h->n_buckets : i;		} else return 0;												}																	SCOPE int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets) {  khint32_t *new_flags = NULL;										khint_t j = 1;													{																kroundup32(new_n_buckets); 									if (new_n_buckets < 4) new_n_buckets = 4;					if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;	 else {  ALLOC_ARRAY(new_flags, __ac_fsize(new_n_buckets)); if (!new_flags) return -1;								memset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); if (h->n_buckets < new_n_buckets) {			REALLOC_ARRAY(h->keys, new_n_buckets); if (kh_is_map) {									REALLOC_ARRAY(h->vals, new_n_buckets); }													} 								}															}																if (j) { 								for (j = 0; j != h->n_buckets; ++j) {						if (__ac_iseither(h->flags, j) == 0) {					khkey_t key = h->keys[j];							khval_t val;										khint_t new_mask;									new_mask = new_n_buckets - 1; 						if (kh_is_map) val = h->vals[j];					__ac_set_isdel_true(h->flags, j);					while (1) {  khint_t k, i, step = 0; k = __hash_func(key);							i = k & new_mask;								while (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; __ac_set_isempty_false(new_flags, i);			if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) {  { khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } if (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } __ac_set_isdel_true(h->flags, i);  } else {  h->keys[i] = key;							if (kh_is_map) h->vals[i] = val;			break;										}												}													}														}															if (h->n_buckets > new_n_buckets) {  REALLOC_ARRAY(h->keys, new_n_buckets); if (kh_is_map) REALLOC_ARRAY(h->vals, new_n_buckets); }															free(h->flags); 				h->flags = new_flags;										h->n_buckets = new_n_buckets;								h->n_occupied = h->size;									h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); }																return 0;														}																	SCOPE khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret) {																	khint_t x;														if (h->n_occupied >= h->upper_bound) {  if (h->n_buckets > (h->size<<1)) {							if (kh_resize_##name(h, h->n_buckets - 1) < 0) {  *ret = -1; return h->n_buckets;						}														} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) {  *ret = -1; return h->n_buckets;							}															}  {																khint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; x = site = h->n_buckets; k = __hash_func(key); i = k & mask; if (__ac_isempty(h->flags, i)) x = i; 	else {														last = i; while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { if (__ac_isdel(h->flags, i)) site = i;				i = (i + (++step)) & mask; if (i == last) { x = site; break; }					}														if (x == h->n_buckets) {								if (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; else x = i;											}														}															}																if (__ac_isempty(h->flags, x)) { 		h->keys[x] = key;											__ac_set_isboth_false(h->flags, x);							++h->size; ++h->n_occupied;									*ret = 1;													} else if (__ac_isdel(h->flags, x)) { 				h->keys[x] = key;											__ac_set_isboth_false(h->flags, x);							++h->size;													*ret = 2;													} else *ret = 0;  return x;														}																	SCOPE void kh_del_##name(kh_##name##_t *h, khint_t x)				{																	if (x != h->n_buckets && !__ac_iseither(h->flags, x)) {			__ac_set_isdel_true(h->flags, x);							--h->size;													}																}


















































































































































#define KHASH_DECLARE(name, khkey_t, khval_t)		 					__KHASH_TYPE(name, khkey_t, khval_t) 								__KHASH_PROTOTYPES(name, khkey_t, khval_t)



#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) __KHASH_TYPE(name, khkey_t, khval_t) 								__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)



#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) KHASH_INIT2(name, MAYBE_UNUSED static inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)










#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))







#define kh_key(h, x) ((h)->keys[x])








#define kh_val(h, x) ((h)->vals[x])




#define kh_value(h, x) ((h)->vals[x])






#define kh_begin(h) (khint_t)(0)






#define kh_end(h) ((h)->n_buckets)






#define kh_size(h) ((h)->size)






#define kh_n_buckets(h) ((h)->n_buckets)








#define kh_foreach(h, kvar, vvar, code) { khint_t __i;		for (__i = kh_begin(h); __i != kh_end(h); ++__i) {		if (!kh_exist(h,__i)) continue;						(kvar) = kh_key(h,__i);								(vvar) = kh_val(h,__i);								code;												} }













#define kh_foreach_value(h, vvar, code) { khint_t __i;		for (__i = kh_begin(h); __i != kh_end(h); ++__i) {		if (!kh_exist(h,__i)) continue;						(vvar) = kh_val(h,__i);								code;												} }






static inline unsigned int oidhash_by_value(struct object_id oid)
{
	return oidhash(&oid);
}

static inline int oideq_by_value(struct object_id a, struct object_id b)
{
	return oideq(&a, &b);
}

KHASH_INIT(oid_set, struct object_id, int, 0, oidhash_by_value, oideq_by_value)

KHASH_INIT(oid_map, struct object_id, void *, 1, oidhash_by_value, oideq_by_value)

KHASH_INIT(oid_pos, struct object_id, int, 1, oidhash_by_value, oideq_by_value)

#endif 
