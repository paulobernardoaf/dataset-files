<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\sha1-name.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blob.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree-walk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"remote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sha1-array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"packfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"submodule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"midx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_oid_oneline</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>disambiguate_hint_fn</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>disambiguate_state</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name><name>hex_pfx</name><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>bin_pfx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>disambiguate_hint_fn</name></type> <name>fn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>candidate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>candidate_exists</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>candidate_checked</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>candidate_ok</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>disambiguate_fn_used</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ambiguous</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>always_call_fn</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>update_candidates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>disambiguate_state</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>always_call_fn</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name> <operator>=</operator> <ternary><condition><expr><call><name><name>ds</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>cb_data</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate_exists</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate</name></name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>candidate_exists</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate</name></name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>fn</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate_checked</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>candidate_ok</name></name> <operator>=</operator> <call><name><name>ds</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>cb_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>disambiguate_fn_used</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>candidate_checked</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate_ok</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate</name></name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>candidate_checked</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>ds</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>cb_data</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>candidate_ok</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>match_sha</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_short_object_filename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>disambiguate_state</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_directory</name></name> <modifier>*</modifier></type><name>odb</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>odb</name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>objects</name><operator>-&gt;</operator><name>odb</name></name></expr>;</init> <condition><expr><name>odb</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name></expr>;</condition> <incr><expr><name>odb</name> <operator>=</operator> <name><name>odb</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>oid_array</name></name> <modifier>*</modifier></type><name>loose_objects</name></decl>;</decl_stmt>

<expr_stmt><expr><name>loose_objects</name> <operator>=</operator> <call><name>odb_loose_cache</name><argument_list>(<argument><expr><name>odb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>bin_pfx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>oid_array_lookup</name><argument_list>(<argument><expr><name>loose_objects</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>bin_pfx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <name><name>loose_objects</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>
<expr_stmt><expr><name>oid</name> <operator>=</operator> <name><name>loose_objects</name><operator>-&gt;</operator><name>oid</name></name> <operator>+</operator> <name>pos</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_sha</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>bin_pfx</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>update_candidates</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_sha</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>a</name> <operator>!=</operator> <operator>*</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>a</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>a</name> <operator>^</operator> <operator>*</operator><name>b</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xf0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unique_in_midx</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>disambiguate_state</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>current</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bsearch_midx</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>bin_pfx</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_sha</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>bin_pfx</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>update_candidates</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unique_in_pack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>disambiguate_state</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>multi_pack_index</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>open_pack_index</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bsearch_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>bin_pfx</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_sha</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>bin_pfx</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>update_candidates</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_short_packed_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>disambiguate_state</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <call><name>get_multi_pack_index</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>m</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name></expr>;</condition>
<incr><expr><name>m</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>unique_in_midx</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>get_packed_git</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name></expr>;</condition>
<incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>unique_in_pack</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>finish_object_disambiguation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>disambiguate_state</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>ambiguous</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SHORT_NAME_AMBIGUOUS</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MISSING_OBJECT</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate_checked</name></name></expr>)</condition><block type="pseudo"><block_content>














<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>candidate_ok</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>disambiguate_fn_used</name></name> <operator>||</operator>
<call><name><name>ds</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>cb_data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SHORT_NAME_AMBIGUOUS</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>candidate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>disambiguate_commit_only</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data_unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>kind</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>kind</name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>disambiguate_committish_only</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data_unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>kind</name></decl>;</decl_stmt>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>oid_object_info</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>disambiguate_tree_only</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data_unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>kind</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>kind</name> <operator>==</operator> <name>OBJ_TREE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>disambiguate_treeish_only</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data_unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>kind</name></decl>;</decl_stmt>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>oid_object_info</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>OBJ_TREE</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TREE</name> <operator>||</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_COMMIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>disambiguate_blob_only</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data_unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>kind</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>kind</name> <operator>==</operator> <name>OBJ_BLOB</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>disambiguate_hint_fn</name></type> <name>default_disambiguate_hint</name></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>set_disambiguate_hint_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>disambiguate_hint_fn</name></type> <name>fn</name></decl>;</decl_stmt>
}</block> <decl><name><name>hints</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"none"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"commit"</literal></expr>, <expr><name>disambiguate_commit_only</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"committish"</literal></expr>, <expr><name>disambiguate_committish_only</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"tree"</literal></expr>, <expr><name>disambiguate_tree_only</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"treeish"</literal></expr>, <expr><name>disambiguate_treeish_only</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"blob"</literal></expr>, <expr><name>disambiguate_blob_only</name></expr> }</block></expr>
}</block></expr></init></decl>;</struct>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>config_error_nonbool</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>hints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>default_disambiguate_hint</name> <operator>=</operator> <name><name>hints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"unknown hint type for '%s': %s"</literal></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>init_object_disambiguation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>disambiguate_state</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>len</name> <argument_list type="generic">&lt; <argument><expr><name>MINIMUM_ABBREV</name> <operator>||</operator> <name>len</name></expr></argument> &gt;</argument_list></name> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ds</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr> ;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>val</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator><literal type="char">'F'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'A'</literal> <operator>-</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>hex_pfx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>bin_pfx</name><operator>.</operator><name>hash</name><index>[<expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>hex_pfx</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prepare_alt_odb</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>show_ambiguous_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>disambiguate_state</name></name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>desc</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>fn</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>ds</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>cb_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>oid_object_info</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><call><name>lookup_commit</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>commit</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pretty_print_context</name></name></type> <name>pp</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pp</name><operator>.</operator><name>date_mode</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>DATE_SHORT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>format_commit_message</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><literal type="string">" %ad - %s"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OBJ_TAG</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>lookup_tag</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>tag</name><operator>-&gt;</operator><name>tag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><literal type="string">" %s %s%s"</literal></expr></argument>,
<argument><expr><call><name>repo_find_unique_abbrev</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"unknown type"</literal></expr></else></ternary></expr></argument>,
<argument><expr><name><name>desc</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>collect_ambiguous</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>oid_array_append</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>repo_collect_ambiguous</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>collect_ambiguous</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sort_ambiguous</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>sort_ambiguous_repo</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a_type</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>sort_ambiguous_repo</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_type</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>sort_ambiguous_repo</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a_type_sort</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_type_sort</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name>a_type</name> <operator>==</operator> <name>b_type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>oidcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>










<expr_stmt><expr><name>a_type_sort</name> <operator>=</operator> <name>a_type</name> <operator>%</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b_type_sort</name> <operator>=</operator> <name>b_type</name> <operator>%</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>a_type_sort</name> <operator>&gt;</operator> <name>b_type_sort</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sort_ambiguous_oid_array</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>oid_array</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>QSORT_S</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>nr</name></name></expr></argument>, <argument><expr><name>sort_ambiguous</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>get_oid_result</name></name></type> <name>get_short_oid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>disambiguate_state</name></name></type> <name>ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quietly</name> <init>= <expr><operator>!</operator><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GET_OID_QUIETLY</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>init_object_disambiguation</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>HAS_MULTI_BITS</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_DISAMBIGUATORS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"multiple get_short_oid disambiguator flags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>disambiguate_commit_only</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_COMMITTISH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>disambiguate_committish_only</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_TREE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>disambiguate_tree_only</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_TREEISH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>disambiguate_treeish_only</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_BLOB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>disambiguate_blob_only</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>default_disambiguate_hint</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>find_short_object_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_short_packed_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>finish_object_disambiguation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>MISSING_OBJECT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>reprepare_packed_git</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_short_object_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_short_packed_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>finish_object_disambiguation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>quietly</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>status</name> <operator>==</operator> <name>SHORT_NAME_AMBIGUOUS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>oid_array</name></name></type> <name>collect</name> <init>= <expr><name>OID_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"short SHA1 %s is ambiguous"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ds</name><operator>.</operator><name>hex_pfx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>.</operator><name>ambiguous</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>advise</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The candidates are:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>repo_for_each_abbrev</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>ds</name><operator>.</operator><name>hex_pfx</name></name></expr></argument>, <argument><expr><name>collect_ambiguous</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sort_ambiguous_oid_array</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oid_array_for_each</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collect</name></expr></argument>, <argument><expr><name>show_ambiguous_object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"show_ambiguous_object shouldn't return non-zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oid_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_for_each_abbrev</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><name>each_abbrev_fn</name></type> <name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>oid_array</name></name></type> <name>collect</name> <init>= <expr><name>OID_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>disambiguate_state</name></name></type> <name>ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>init_object_disambiguation</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>always_call_fn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>repo_collect_ambiguous</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>cb_data</name></name> <operator>=</operator> <operator>&amp;</operator><name>collect</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_short_object_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_short_packed_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>oid_array_for_each_unique</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collect</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>cb_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oid_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>msb</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>val</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>min_abbrev_data</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>init_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cur_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name></type> <name>get_hex_char_from_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>hex</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>hex</name><index>[<expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name><index>[<expr><name>pos</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name><name>hex</name><index>[<expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name><index>[<expr><name>pos</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf</literal></expr>]</index></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>extend_abbrev_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>min_abbrev_data</name></name> <modifier>*</modifier></type><name>mad</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><name><name>mad</name><operator>-&gt;</operator><name>init_len</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>mad</name><operator>-&gt;</operator><name>hex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>mad</name><operator>-&gt;</operator><name>hex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <call><name>get_hex_char_from_oid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>GIT_MAX_RAWSZ</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <name><name>mad</name><operator>-&gt;</operator><name>cur_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mad</name><operator>-&gt;</operator><name>cur_len</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>repo_extend_abbrev_len</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>extend_abbrev_len</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>cb_data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_abbrev_len_for_midx</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>min_abbrev_data</name></name> <modifier>*</modifier></type><name>mad</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>mad_oid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mad_oid</name> <operator>=</operator> <name><name>mad</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>bsearch_midx</name><argument_list>(<argument><expr><name>mad_oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name><name>mad</name><operator>-&gt;</operator><name>init_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>extend_abbrev_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>first</name> <operator>&lt;</operator> <name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>first</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>extend_abbrev_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>nth_midxed_object_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>first</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>extend_abbrev_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>mad</name><operator>-&gt;</operator><name>init_len</name></name> <operator>=</operator> <name><name>mad</name><operator>-&gt;</operator><name>cur_len</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_abbrev_len_for_pack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>min_abbrev_data</name></name> <modifier>*</modifier></type><name>mad</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>mad_oid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>multi_pack_index</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>open_pack_index</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>num_objects</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mad_oid</name> <operator>=</operator> <name><name>mad</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>bsearch_pack</name><argument_list>(<argument><expr><name>mad_oid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name><name>mad</name><operator>-&gt;</operator><name>init_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>extend_abbrev_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>first</name> <operator>&lt;</operator> <name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>first</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>extend_abbrev_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>nth_packed_object_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>first</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>extend_abbrev_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>mad</name><operator>-&gt;</operator><name>init_len</name></name> <operator>=</operator> <name><name>mad</name><operator>-&gt;</operator><name>cur_len</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_abbrev_len_packed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>min_abbrev_data</name></name> <modifier>*</modifier></type><name>mad</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>multi_pack_index</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <call><name>get_multi_pack_index</name><argument_list>(<argument><expr><name><name>mad</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>m</name></expr>;</condition> <incr><expr><name>m</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>find_abbrev_len_for_midx</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <call><name>get_packed_git</name><argument_list>(<argument><expr><name><name>mad</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>find_abbrev_len_for_pack</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_find_unique_abbrev_r</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hex</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>disambiguate_state</name></name></type> <name>ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>min_abbrev_data</name></name></type> <name>mad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid_ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hexsz</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>count</name> <init>= <expr><call><name>repo_approximate_object_count</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>msb</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>






<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>DIV_ROUND_UP</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>FALLBACK_DEFAULT_ABBREV</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>FALLBACK_DEFAULT_ABBREV</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>oid_to_hex_r</name><argument_list>(<argument><expr><name>hex</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>hexsz</name> <operator>||</operator> <operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>hexsz</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mad</name><operator>.</operator><name>repo</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mad</name><operator>.</operator><name>init_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mad</name><operator>.</operator><name>cur_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mad</name><operator>.</operator><name>hex</name></name> <operator>=</operator> <name>hex</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mad</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <name>oid</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_abbrev_len_packed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>init_object_disambiguation</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>, <argument><expr><name><name>mad</name><operator>.</operator><name>cur_len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>repo_extend_abbrev_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>always_call_fn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>cb_data</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>mad</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_short_object_filename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>finish_object_disambiguation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hex</name><index>[<expr><name><name>mad</name><operator>.</operator><name>cur_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name><name>mad</name><operator>.</operator><name>cur_len</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>repo_find_unique_abbrev</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bufno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>hexbuffer</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hex</name> <init>= <expr><name><name>hexbuffer</name><index>[<expr><name>bufno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bufno</name> <operator>=</operator> <operator>(</operator><name>bufno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>hexbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>repo_find_unique_abbrev_r</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ambiguous_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>slash</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>path</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<break>break;</break>
<case>case <expr><literal type="char">'/'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>slash</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>slash</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>
<continue>continue;</continue>
<default>default:</default>
<expr_stmt><expr><name>slash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></switch>
<break>break;</break>
</block_content>}</block></for>
<return>return <expr><name>slash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>at_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>suffix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>suffix_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>suffix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>suffix_len</name> <operator>&lt;=</operator> <name>len</name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>suffix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>suffix_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>suffix_len</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>upstream_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>suffix</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"@{upstream}"</literal></expr>, <expr><literal type="string">"@{u}"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>at_mark</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>push_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>suffix</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"@{push}"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>at_mark</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>get_oid_result</name></name></type> <name>get_oid_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>lookup_flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>interpret_nth_prior_checkout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_oid_basic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>warn_msg</name> <init>= <expr><literal type="string">"refname '%.*s' is ambiguous."</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_name_msg</name> <init>= <expr><call><name>N_</name><argument_list>(
<argument><expr><literal type="string">"Git normally never creates a ref that ends with 40 hex characters\n"</literal>
<literal type="string">"because it will be ignored when you just specify 40-hex. These refs\n"</literal>
<literal type="string">"may be created by mistake. For example,\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">" git switch -c $br $(git rev-parse ...)\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"where \"$br\" is somehow empty and a 40-hex ref is created. Please\n"</literal>
<literal type="string">"examine these refs and maybe delete them. Turn this message off by\n"</literal>
<literal type="string">"running \"git config advice.objectNameWarning false\""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>tmp_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>real_ref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>refs_found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>at</name></decl>, <decl><type ref="prev"/><name>reflog_len</name></decl>, <decl><type ref="prev"/><name>nth_prior</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name><name>r</name><operator>-&gt;</operator><name>hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_oid_hex</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>warn_ambiguous_refs</name> <operator>&amp;&amp;</operator> <name>warn_on_object_refname_ambiguity</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>refs_found</name> <operator>=</operator> <call><name>repo_dwim_ref</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>real_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>refs_found</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><name>warn_msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>advice_object_name_warning</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>object_name_msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>real_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>reflog_len</name> <operator>=</operator> <name>at</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name>len</name><operator>-</operator><literal type="number">4</literal></expr>;</init> <condition><expr><name>at</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>at</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>at</name></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>at</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>at</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>at</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nth_prior</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>upstream_mark</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>at</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>at</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>push_mark</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>at</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>at</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>reflog_len</name> <operator>=</operator> <operator>(</operator><name>len</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>at</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <call><name>ambiguous_path</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nth_prior</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>detached</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>interpret_nth_prior_checkout</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>detached</name> <operator>=</operator> <operator>(</operator><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name><name>r</name><operator>-&gt;</operator><name>hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_oid_hex</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>detached</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name> <operator>&amp;&amp;</operator> <name>reflog_len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>refs_found</name> <operator>=</operator> <call><name>repo_dwim_ref</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>real_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>reflog_len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>refs_found</name> <operator>=</operator> <call><name>repo_dwim_log</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>real_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>refs_found</name> <operator>=</operator> <call><name>repo_dwim_ref</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>real_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>refs_found</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>warn_ambiguous_refs</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GET_OID_QUIETLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>refs_found</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
<operator>!</operator><call><name>get_short_oid</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_oid</name></expr></argument>, <argument><expr><name>GET_OID_QUIETLY</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><name>warn_msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>reflog_len</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nth</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timestamp_t</name></type> <name>at_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timestamp_t</name></type> <name>co_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>co_tz</name></decl>, <decl><type ref="prev"/><name>co_cnt</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>nth</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>reflog_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><name><name>str</name><index>[<expr><name>at</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>ch</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nth</name> <operator>=</operator> <name>nth</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name>ch</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>nth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><literal type="number">100000000</literal> <operator>&lt;=</operator> <name>nth</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>at_time</name> <operator>=</operator> <name>nth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>nth</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>at_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>xstrndup</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>at</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>reflog_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>at_time</name> <operator>=</operator> <call><name>approxidate_careful</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errors</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>real_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_ref_at</name><argument_list>(<argument><expr><call><name>get_main_ref_store</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>real_ref</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>at_time</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>co_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>co_tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>co_cnt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name>real_ref</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">"HEAD"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>at_time</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GET_OID_QUIETLY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"log for '%.*s' only goes back to %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>len</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,
<argument><expr><call><name>show_date</name><argument_list>(<argument><expr><name>co_time</name></expr></argument>, <argument><expr><name>co_tz</name></expr></argument>, <argument><expr><call><name>DATE_MODE</name><argument_list>(<argument><expr><name>RFC2822</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_QUIETLY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"log for '%.*s' only has %d entries"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>len</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>co_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>real_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>get_oid_result</name></name></type> <name>get_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>get_oid_result</name></name></type> <name>ret</name> <init>= <expr><call><name>get_oid_1</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>,
<argument><expr><name>GET_OID_COMMITTISH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MISSING_OBJECT</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FOUND</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>--</operator><name>idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FOUND</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>MISSING_OBJECT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>get_oid_result</name></name></type> <name>get_nth_ancestor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>generation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_oid_1</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>GET_OID_COMMITTISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MISSING_OBJECT</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>generation</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>parse_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MISSING_OBJECT</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>commit</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name><operator>-&gt;</operator><name>item</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FOUND</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>repo_peel_to_type</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>expected_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>namelen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>namelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>o</name><operator>-&gt;</operator><name>parsed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>parse_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>expected_type</name> <operator>==</operator> <name>OBJ_ANY</name> <operator>||</operator> <name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>expected_type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>o</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>o</name> <operator>=</operator> <operator>(</operator><operator>(</operator>struct <name>tag</name><operator>*</operator><operator>)</operator> <name>o</name><operator>)</operator><operator>-&gt;</operator><name>tagged</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>o</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>repo_get_commit_tree</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>o</name><operator>)</operator></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>object</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%.*s: expected %s type, but the object "</literal>
<literal type="string">"dereferences to %s type"</literal></expr></argument>,
<argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>expected_type</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>peel_onion</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>lookup_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>outer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>expected_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>









<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>||</operator> <name><name>name</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>name</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>name</name> <operator>&lt;=</operator> <name>sp</name></expr>;</condition> <incr><expr><name>sp</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>sp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <name>name</name> <operator>&lt;</operator> <name>sp</name> <operator>&amp;&amp;</operator> <name><name>sp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&lt;=</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="string">"commit}"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expected_type</name> <operator>=</operator> <name>OBJ_COMMIT</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="string">"tag}"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expected_type</name> <operator>=</operator> <name>OBJ_TAG</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="string">"tree}"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expected_type</name> <operator>=</operator> <name>OBJ_TREE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="string">"blob}"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expected_type</name> <operator>=</operator> <name>OBJ_BLOB</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="string">"object}"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expected_type</name> <operator>=</operator> <name>OBJ_ANY</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expected_type</name> <operator>=</operator> <name>OBJ_NONE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expected_type</name> <operator>=</operator> <name>OBJ_COMMIT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>

<expr_stmt><expr><name>lookup_flags</name> <operator>&amp;=</operator> <operator>~</operator><name>GET_OID_DISAMBIGUATORS</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>expected_type</name> <operator>==</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lookup_flags</name> <operator>|=</operator> <name>GET_OID_COMMITTISH</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>expected_type</name> <operator>==</operator> <name>OBJ_TREE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lookup_flags</name> <operator>|=</operator> <name>GET_OID_TREEISH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_oid_1</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>sp</name> <operator>-</operator> <name>name</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer</name></expr></argument>, <argument><expr><name>lookup_flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>parse_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expected_type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>sp</name> <operator>-</operator> <name>name</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>o</name><operator>-&gt;</operator><name>parsed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>parse_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>repo_peel_to_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>expected_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>xstrndup</name><argument_list>(<argument><expr><name>sp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>sp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>commit_list_insert</name><argument_list>(<argument><expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_oid_oneline</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_describe_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><name>GET_OID_QUIETLY</name> <operator>|</operator> <name>GET_OID_COMMIT</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>name</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>name</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>cp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isxdigit</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'g'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>cp</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>
<return>return <expr><call><name>get_short_oid</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>get_oid_result</name></name></type> <name>get_oid_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>lookup_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>has_suffix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>




<expr_stmt><expr><name>has_suffix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>name</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>name</name> <operator>&lt;=</operator> <name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>cp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>ch</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'~'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>has_suffix</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>has_suffix</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len1</name> <init>= <expr><name>cp</name> <operator>-</operator> <name>name</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>name</name> <operator>+</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>digit</name> <init>= <expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unsigned_mult_overflows</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MISSING_OBJECT</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unsigned_add_overflows</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>digit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MISSING_OBJECT</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>+=</operator> <name>digit</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num</name> <operator>&amp;&amp;</operator> <name>len1</name> <operator>==</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MISSING_OBJECT</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>has_suffix</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>get_parent</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>get_nth_ancestor</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>peel_onion</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>lookup_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FOUND</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_oid_basic</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>lookup_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FOUND</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_describe_name</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FOUND</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>get_short_oid</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>lookup_flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONELINE_SEEN</name></cpp:macro> <cpp:value>(1u&lt;&lt;20)</cpp:value></cpp:define>

<struct>struct <name>handle_one_ref_cb</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_one_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>handle_one_ref_cb</name></name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>list</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>parse_object</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>object</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TAG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>object</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>commit_list_insert</name><argument_list>(<argument><expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>object</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_oid_oneline</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>backup</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>negative</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>regex_t</name></type> <name>regex</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prefix</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prefix</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>negative</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>REG_EXTENDED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>ONELINE_SEEN</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>commit_list_insert</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>matches</name></decl>;</decl_stmt>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>pop_most_recent_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><name>ONELINE_SEEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_object</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>matches</name> <operator>=</operator> <name>negative</name> <operator>^</operator> <operator>(</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unuse_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>matches</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>backup</name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>clear_commit_marks</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>ONELINE_SEEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name>backup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>grab_nth_branch_switch_cbdata</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>remaining</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grab_nth_branch_switch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>ooid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>noid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>email</name></decl></parameter>, <parameter><decl><type><name>timestamp_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grab_nth_branch_switch_cbdata</name></name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="string">"checkout: moving from "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="string">" to "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name> <operator>||</operator> <operator>!</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>--</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>remaining</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>target</name> <operator>-</operator> <name>match</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>interpret_nth_prior_checkout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>nth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grab_nth_branch_switch_cbdata</name></name></type> <name>cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>brace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>num_end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'@'</literal> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'{'</literal> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>brace</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>brace</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nth</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num_end</name> <operator>!=</operator> <name>brace</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>remaining</name></name> <operator>=</operator> <name>nth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>sb</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>refs_for_each_reflog_ent_reverse</name><argument_list>(<argument><expr><call><name>get_main_ref_store</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><name>grab_nth_branch_switch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>retval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>brace</name> <operator>-</operator> <name>name</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_get_oid_mb</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>one</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>two</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>mbs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid_tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dots</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dots</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dots</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>repo_get_oid</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dots</name> <operator>==</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>st</name> <operator>=</operator> <call><name>repo_get_oid</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>dots</name> <operator>-</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>dots</name> <operator>-</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>st</name> <operator>=</operator> <call><name>repo_get_oid_committish</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>st</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>st</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>one</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid_tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>one</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>repo_get_oid_committish</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>dots</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr> ?</condition><then> <expr><operator>(</operator><name>dots</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr> </then><else>: <expr><literal type="string">"HEAD"</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid_tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>two</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid_tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>two</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mbs</name> <operator>=</operator> <call><name>repo_get_merge_bases</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>two</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mbs</name> <operator>||</operator> <name><name>mbs</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>st</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>st</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mbs</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name>mbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>st</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>interpret_empty_at</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>, <argument><expr><name>namelen</name> <operator>-</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>next</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>name</name> <operator>+</operator> <name>namelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>!=</operator> <name>name</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>reinterpret</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>allowed</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>tmp</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>used</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>namelen</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>repo_interpret_branch_name</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>allowed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name> <operator>-</operator> <name>used</name> <operator>+</operator> <name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_shortened_ref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>refs_shorten_unambiguous_ref</name><argument_list>(<argument><expr><call><name>get_main_ref_store</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>branch_interpret_allowed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>allowed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowed</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>allowed</name> <operator>&amp;</operator> <name>INTERPRET_BRANCH_LOCAL</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>starts_with</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>allowed</name> <operator>&amp;</operator> <name>INTERPRET_BRANCH_REMOTE</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>starts_with</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"refs/remotes/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>interpret_branch_mark</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>get_mark</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>get_data</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>allowed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>branch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>get_mark</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>at</name></expr></argument>, <argument><expr><name>namelen</name> <operator>-</operator> <name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>at</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_str</name> <init>= <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>branch</name> <operator>=</operator> <call><name>branch_get</name><argument_list>(<argument><expr><name>name_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>branch</name> <operator>=</operator> <call><name>branch_get</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>get_data</name><argument_list>(<argument><expr><name>branch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>branch_interpret_allowed</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>allowed</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>set_shortened_ref</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>len</name> <operator>+</operator> <name>at</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_interpret_branch_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>allowed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>namelen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>namelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowed</name> <operator>||</operator> <operator>(</operator><name>allowed</name> <operator>&amp;</operator> <name>INTERPRET_BRANCH_LOCAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>interpret_nth_prior_checkout</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>len</name></expr>;</return> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>namelen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>len</name></expr>;</return></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>reinterpret</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>allowed</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>start</name> <operator>=</operator> <name>name</name></expr>;</init>
<condition><expr><operator>(</operator><name>at</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>, <argument><expr><name>namelen</name> <operator>-</operator> <operator>(</operator><name>start</name> <operator>-</operator> <name>name</name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition>
<incr><expr><name>start</name> <operator>=</operator> <name>at</name> <operator>+</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowed</name> <operator>||</operator> <operator>(</operator><name>allowed</name> <operator>&amp;</operator> <name>INTERPRET_BRANCH_HEAD</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>interpret_empty_at</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>reinterpret</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
<argument><expr><name>allowed</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>interpret_branch_mark</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
<argument><expr><name>upstream_mark</name></expr></argument>, <argument><expr><name>branch_get_upstream</name></expr></argument>,
<argument><expr><name>allowed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>interpret_branch_mark</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
<argument><expr><name>push_mark</name></expr></argument>, <argument><expr><name>branch_get_push</name></expr></argument>,
<argument><expr><name>allowed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>strbuf_branchname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>allowed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>used</name> <init>= <expr><call><name>interpret_branch_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>allowed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>used</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>used</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>used</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>strbuf_check_branch_ref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>startup_info</name><operator>-&gt;</operator><name>have_repository</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_branchname</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>INTERPRET_BRANCH_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>







<expr_stmt><expr><call><name>strbuf_splice</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"refs/heads/"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"refs/heads/HEAD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>check_refname_format</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>repo_get_oid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_context</name></name></type> <name>unused</name></decl>;</decl_stmt>
<return>return <expr><call><name>get_oid_with_context</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unused</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>get_oidf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_vaddf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_oid</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>int</name></type> <name>repo_get_oid_committish</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_context</name></name></type> <name>unused</name></decl>;</decl_stmt>
<return>return <expr><call><name>get_oid_with_context</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GET_OID_COMMITTISH</name></expr></argument>,
<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unused</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_get_oid_treeish</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_context</name></name></type> <name>unused</name></decl>;</decl_stmt>
<return>return <expr><call><name>get_oid_with_context</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GET_OID_TREEISH</name></expr></argument>,
<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unused</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_get_oid_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_context</name></name></type> <name>unused</name></decl>;</decl_stmt>
<return>return <expr><call><name>get_oid_with_context</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GET_OID_COMMIT</name></expr></argument>,
<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unused</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_get_oid_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_context</name></name></type> <name>unused</name></decl>;</decl_stmt>
<return>return <expr><call><name>get_oid_with_context</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GET_OID_TREE</name></expr></argument>,
<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unused</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_get_oid_blob</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_context</name></name></type> <name>unused</name></decl>;</decl_stmt>
<return>return <expr><call><name>get_oid_with_context</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GET_OID_BLOB</name></expr></argument>,
<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unused</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>diagnose_invalid_oid_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>tree_oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>object_name</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>object_name_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>mode</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>file_exists</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"path '%s' exists on disk, but not in '%.*s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>object_name_len</name></expr></argument>, <argument><expr><name>object_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_missing_file_error</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fullname</name> <init>= <expr><call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_tree_entry</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>tree_oid</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"path '%s' exists, but not '%s'\n"</literal>
<literal type="string">"hint: Did you mean '%.*s:%s' aka '%.*s:./%s'?"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fullname</name></expr></argument>,
<argument><expr><name>filename</name></expr></argument>,
<argument><expr><name>object_name_len</name></expr></argument>, <argument><expr><name>object_name</name></expr></argument>,
<argument><expr><name>fullname</name></expr></argument>,
<argument><expr><name>object_name_len</name></expr></argument>, <argument><expr><name>object_name</name></expr></argument>,
<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"path '%s' does not exist in '%.*s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>object_name_len</name></expr></argument>, <argument><expr><name>object_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>diagnose_invalid_index_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>fullname</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>namelen</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"path '%s' is in the index, but not at stage %d\n"</literal>
<literal type="string">"hint: Did you mean ':%d:%s'?"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>,
<argument><expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fullname</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fullname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>fullname</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>fullname</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>fullname</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>fullname</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>fullname</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"path '%s' is in the index, but not '%s'\n"</literal>
<literal type="string">"hint: Did you mean ':%d:%s' aka ':%d:./%s'?"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>fullname</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fullname</name><operator>.</operator><name>buf</name></name></expr></argument>,
<argument><expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>repo_file_exists</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"path '%s' exists on disk, but not in the index"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_missing_file_error</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"path '%s' does not exist (neither on disk nor in the index)"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>resolve_relative_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"./"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"../"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>the_repository</name> <operator>||</operator> <operator>!</operator><call><name>is_inside_work_tree</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"relative path syntax can't be used outside working tree"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<return>return <expr><call><name>prefix_path</name><argument_list>(<argument><expr><name><name>startup_info</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>startup_info</name><operator>-&gt;</operator><name>prefix</name></name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>startup_info</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>get_oid_result</name></name></type> <name>get_oid_with_context_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_context</name></name> <modifier>*</modifier></type><name>oc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>bracket_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>only_to_die</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_ONLY_TO_DIE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>only_to_die</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>GET_OID_QUIETLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>oc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>oc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>S_IFINVALID</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oc</name><operator>-&gt;</operator><name>symlink_path</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_oid_1</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>stage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>only_to_die</name> <operator>&amp;&amp;</operator> <name>namelen</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>handle_one_ref_cb</name></name></type> <name>cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>repo</name></name> <operator>=</operator> <name>repo</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>list</name></name> <operator>=</operator> <operator>&amp;</operator><name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>refs_for_each_ref</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name>handle_one_ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>refs_head_ref</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name>handle_one_ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>commit_list_sort_by_date</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>get_oid_oneline</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator>
<name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal> <operator>||</operator>
<name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'0'</literal> <operator>||</operator> <literal type="char">'3'</literal> <operator>&lt;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>name</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>stage</name> <operator>=</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>name</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>new_path</name> <operator>=</operator> <call><name>resolve_relative_path</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_path</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>namelen</name> <operator>=</operator> <name>namelen</name> <operator>-</operator> <operator>(</operator><name>cp</name> <operator>-</operator> <name>name</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>new_path</name></expr>;</expr_stmt>
<expr_stmt><expr><name>namelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_RECORD_PATH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>repo</name><operator>-&gt;</operator><name>index</name></name> <operator>||</operator> <operator>!</operator><name><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>repo_read_index</name><argument_list>(<argument><expr><name>repo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_namelen</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>namelen</name> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>stage</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>only_to_die</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>diagnose_invalid_index_path</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>name</name></expr><operator>,</operator> <expr><name>bracket_depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bracket_depth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>bracket_depth</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bracket_depth</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>bracket_depth</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>tree_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>cp</name> <operator>-</operator> <name>name</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>sub_flags</name> <init>= <expr><name>flags</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sub_flags</name> <operator>&amp;=</operator> <operator>~</operator><name>GET_OID_DISAMBIGUATORS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sub_flags</name> <operator>|=</operator> <name>GET_OID_TREEISH</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_oid_1</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree_oid</name></expr></argument>, <argument><expr><name>sub_flags</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>cp</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>new_filename</name> <operator>=</operator> <call><name>resolve_relative_path</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_filename</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>new_filename</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_FOLLOW_SYMLINKS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_tree_entry_follow_symlinks</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree_oid</name></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oc</name><operator>-&gt;</operator><name>symlink_path</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>oc</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_tree_entry</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree_oid</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>oc</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&amp;&amp;</operator> <name>only_to_die</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>diagnose_invalid_oid_path</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>,
<argument><expr><name>filename</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>tree_oid</name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_RECORD_PATH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>only_to_die</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid object name '%.*s'."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>maybe_die_on_misspelt_object_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_context</name></name></type> <name>oc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_oid_with_context_1</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>GET_OID_ONLY_TO_DIE</name></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>get_oid_result</name></name></type> <name>get_oid_with_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_context</name></name> <modifier>*</modifier></type><name>oc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GET_OID_FOLLOW_SYMLINKS</name> <operator>&amp;&amp;</operator> <name>flags</name> <operator>&amp;</operator> <name>GET_OID_ONLY_TO_DIE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"incompatible flags for get_sha1_with_context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>get_oid_with_context_1</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
